=== PHASE 1: ANALYSIS ===

Calling tool: grepTool
(?i)test_comments3
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments3
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/test_black.py:154:    def test_comments3(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/test_black.py
120:
121:    @patch("black.dump_to_file", dump_to_stderr)
122:    def test_expression(self) -> None:
123:        source, expected = read_data('expression')
124:        actual = fs(source)
125:        self.assertFormatEqual(expected, actual)
126:        black.assert_equivalent(source, actual)
127:        black.assert_stable(source, actual, line_length=ll)
128:
129:    @patch("black.dump_to_file", dump_to_stderr)
130:    def test_fstring(self) -> None:
131:        source, expected = read_data('fstring')
132:        actual = fs(source)
133:        self.assertFormatEqual(expected, actual)
134:        black.assert_equivalent(source, actual)
135:        black.assert_stable(source, actual, line_length=ll)
136:
137:    @patch("black.dump_to_file", dump_to_stderr)
138:    def test_comments(self) -> None:
139:        source, expected = read_data('comments')
140:        actual = fs(source)
141:        self.assertFormatEqual(expected, actual)
142:        black.assert_equivalent(source, actual)
143:        black.assert_stable(source, actual, line_length=ll)
144:
145:    @patch("black.dump_to_file", dump_to_stderr)
146:    def test_comments2(self) -> None:
147:        source, expected = read_data('comments2')
148:        actual = fs(source)
149:        self.assertFormatEqual(expected, actual)
150:        black.assert_equivalent(source, actual)
151:        black.assert_stable(source, actual, line_length=ll)
152:
153:    @patch("black.dump_to_file", dump_to_stderr)
154:    def test_comments3(self) -> None:
155:        source, expected = read_data('comments3')
156:        actual = fs(source)
157:        self.assertFormatEqual(expected, actual)
158:        black.assert_equivalent(source, actual)
159:        black.assert_stable(source, actual, line_length=ll)
160:
161:    @patch("black.dump_to_file", dump_to_stderr)
162:    def test_cantfit(self) -> None:
163:        source, expected = read_data('cantfit')
164:        actual = fs(source)
165:        self.assertFormatEqual(expected, actual)
166:        black.assert_equivalent(source, actual)
167:        black.assert_stable(source, actual, line_length=ll)
168:
169:    @patch("black.dump_to_file", dump_to_stderr)
170:    def test_import_spacing(self) -> None:
171:        source, expected = read_data('import_spacing')
172:        actual = fs(source)
173:        self.assertFormatEqual(expected, actual)
174:        black.assert_equivalent(source, actual)
175:        black.assert_stable(source, actual, line_length=ll)
176:
177:    @patch("black.dump_to_file", dump_to_stderr)
178:    def test_composition(self) -> None:
179:        source, expected = read_data('composition')
180:        actual = fs(source)
181:        self.assertFormatEqual(expected, actual)
182:        black.assert_equivalent(source, actual)
183:        black.assert_stable(source, actual, line_length=ll)
184:
185:    @patch("black.dump_to_file", dump_to_stderr)
186:    def test_empty_lines(self) -> None:
187:        source, expected = read_data('empty_lines')
188:        actual = fs(source)
189:        self.assertFormatEqual(expected, actual)
190:        black.assert_equivalent(source, actual)
191:        black.assert_stable(source, actual, line_length=ll)
192:
193:    @patch("black.dump_to_file", dump_to_stderr)
194:    def test_python2(self) -> None:
195:        source, expected = read_data('python2')
196:        actual = fs(source)
197:        self.assertFormatEqual(expected, actual)
198:        # black.assert_equivalent(source, actual)
199:        black.assert_stable(source, actual, line_length=ll)
200:
201:    @patch("black.dump_to_file", dump_to_stderr)
202:    def test_fmtonoff(self) -> None:
203:        source, expected = read_data('fmtonoff')
204:        actual = fs(source)
205:        self.assertFormatEqual(expected, actual)
206:        black.assert_equivalent(source, actual)
207:        black.assert_stable(source, actual, line_length=ll)
208:
209:    def test_report(self) -> None:
210:        report = black.Report()
211:        out_lines = []
212:        err_lines = []
213:
214:        def out(msg: str, **kwargs: Any) -> None:
215:            out_lines.append(msg)
216:
217:        def err(msg: str, **kwargs: Any) -> None:
218:            err_lines.append(msg)
219:
220:        with patch("black.out", out), patch("black.err", err):
221:            report.done(Path('f1'), changed=False)
222:            self.assertEqual(len(out_lines), 1)
223:            self.assertEqual(len(err_lines), 0)
224:            self.assertEqual(out_lines[-1], 'f1 already well formatted, good job.')
225:            self.assertEqual(unstyle(str(report)), '1 file left unchanged.')
226:            self.assertEqual(report.return_code, 0)
227:            report.done(Path('f2'), changed=True)
228:            self.assertEqual(len(out_lines), 2)
229:            self.assertEqual(len(err_lines), 0)
230:            self.assertEqual(out_lines[-1], 'reformatted f2')
231:            self.assertEqual(
232:                unstyle(str(report)), '1 file reformatted, 1 file left unchanged.'
233:            )
234:            self.assertEqual(report.return_code, 0)
235:            report.check = True
236:            self.assertEqual(report.return_code, 1)
237:            report.check = False
238:            report.failed(Path('e1'), 'boom')
239:            self.assertEqual(len(out_lines), 2)

Calling tool: grepTool
comments3
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments3
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/test_black.py:154:    def test_comments3(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/test_black.py:155:        source, expected = read_data('comments3')
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/bugsinpy_bug.info:4:test_file="tests/comments3.py;tests/test_black.py"

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/comments3.py
1:def func():
2:    lcomp3 = [
3:        # This one is actually too long to fit in a single line.
4:        element.split('\n', 1)[0]
5:        # yup
6:        for element in collection.select_elements()
7:        # right
8:        if element is not None
9:    ]
10:    # Capture each of the exceptions in the MultiError along with each of their causes and contexts
11:    if isinstance(exc_value, MultiError):
12:        embedded = []
13:        for exc in exc_value.exceptions:
14:            if exc not in _seen:
15:                embedded.append(
16:                    # This should be left alone (before)
17:                    traceback.TracebackException.from_exception(
18:                        exc,
19:                        limit=limit,
20:                        lookup_lines=lookup_lines,
21:                        capture_locals=capture_locals,
22:                        # copy the set of _seen exceptions so that duplicates
23:                        # shared between sub-exceptions are not omitted
24:                        _seen=set(_seen),
25:                    )
26:                    # This should be left alone (after)
27:                )
28:
29:    # everything is fine if the expression isn't nested
30:    traceback.TracebackException.from_exception(
31:        exc,
32:        limit=limit,
33:        lookup_lines=lookup_lines,
34:        capture_locals=capture_locals,
35:        # copy the set of _seen exceptions so that duplicates
36:        # shared between sub-exceptions are not omitted
37:        _seen=set(_seen),
38:    )

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/test_black.py:27:def read_data(name: str) -> Tuple[str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:from functools import partial
3:from io import StringIO
4:import os
5:from pathlib import Path
6:import sys
7:from typing import Any, List, Tuple
8:import unittest
9:from unittest.mock import patch
10:
11:from click import unstyle
12:
13:import black
14:
15:ll = 88
16:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
17:fs = partial(black.format_str, line_length=ll)
18:THIS_FILE = Path(__file__)
19:THIS_DIR = THIS_FILE.parent
20:EMPTY_LINE = '# EMPTY LINE WITH WHITESPACE' + ' (this comment will be removed)'
21:
22:
23:def dump_to_stderr(*output: str) -> str:
24:    return '\n' + '\n'.join(output) + '\n'
25:
26:
27:def read_data(name: str) -> Tuple[str, str]:
28:    """read_data('test_name') -> 'input', 'output'"""
29:    if not name.endswith(('.py', '.out')):
30:        name += '.py'
31:    _input: List[str] = []
32:    _output: List[str] = []
33:    with open(THIS_DIR / name, 'r', encoding='utf8') as test:
34:        lines = test.readlines()
35:    result = _input
36:    for line in lines:
37:        line = line.replace(EMPTY_LINE, '')
38:        if line.rstrip() == '# output':
39:            result = _output
40:            continue
41:
42:        result.append(line)
43:    if _input and not _output:
44:        # If there's no output marker, treat the entire file as already pre-formatted.
45:        _output = _input[:]
46:    return ''.join(_input).strip() + '\n', ''.join(_output).strip() + '\n'
47:
48:
49:class BlackTestCase(unittest.TestCase):
50:    maxDiff = None
51:
52:    def assertFormatEqual(self, expected: str, actual: str) -> None:
53:        if actual != expected and not os.environ.get('SKIP_AST_PRINT'):
54:            bdv: black.DebugVisitor[Any]
55:            black.out('Expected tree:', fg='green')
56:            try:
57:                exp_node = black.lib2to3_parse(expected)
58:                bdv = black.DebugVisitor()
59:                list(bdv.visit(exp_node))
60:            except Exception as ve:
61:                black.err(str(ve))
62:            black.out('Actual tree:', fg='red')
63:            try:
64:                exp_node = black.lib2to3_parse(actual)
65:                bdv = black.DebugVisitor()
66:                list(bdv.visit(exp_node))
67:            except Exception as ve:
68:                black.err(str(ve))
69:        self.assertEqual(expected, actual)
70:
71:    @patch("black.dump_to_file", dump_to_stderr)
72:    def test_self(self) -> None:
73:        source, expected = read_data('test_black')
74:        actual = fs(source)
75:        self.assertFormatEqual(expected, actual)
76:        black.assert_equivalent(source, actual)
77:        black.assert_stable(source, actual, line_length=ll)
78:        self.assertFalse(ff(THIS_FILE))
79:
80:    @patch("black.dump_to_file", dump_to_stderr)

Calling tool: grepTool
class BracketTracker|def mark\(|bracket_depth
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:455:class BracketTracker:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:463:    def mark(self, leaf: Leaf) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:466:        All leaves receive an int `bracket_depth` field that stores how deep
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:485:        leaf.bracket_depth = self.depth
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:684:        depth = closing.bracket_depth + 1
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:698:            bracket_depth = leaf.bracket_depth
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:699:            if bracket_depth == depth and leaf.type == token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1680:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1682:            leaf.bracket_depth == lowest_depth
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1707:            if leaf.bracket_depth == 0:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/blib2to3/pytree.pyi:60:    bracket_depth: int

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
440:    token.TILDE,
441:    token.LEFTSHIFT,
442:    token.RIGHTSHIFT,
443:    token.DOUBLESTAR,
444:    token.DOUBLESLASH,
445:}
446:COMPREHENSION_PRIORITY = 20
447:COMMA_PRIORITY = 10
448:LOGIC_PRIORITY = 5
449:STRING_PRIORITY = 4
450:COMPARATOR_PRIORITY = 3
451:MATH_PRIORITY = 1
452:
453:
454:@dataclass
455:class BracketTracker:
456:    """Keeps track of brackets on a line."""
457:
458:    depth: int = 0
459:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
460:    delimiters: Dict[LeafID, Priority] = Factory(dict)
461:    previous: Optional[Leaf] = None
462:
463:    def mark(self, leaf: Leaf) -> None:
464:        """Mark `leaf` with bracket-related metadata. Keep track of delimiters.
465:
466:        All leaves receive an int `bracket_depth` field that stores how deep
467:        within brackets a given leaf is. 0 means there are no enclosing brackets
468:        that started on this line.
469:
470:        If a leaf is itself a closing bracket, it receives an `opening_bracket`
471:        field that it forms a pair with. This is a one-directional link to
472:        avoid reference cycles.
473:
474:        If a leaf is a delimiter (a token on which Black can split the line if
475:        needed) and it's on depth 0, its `id()` is stored in the tracker's
476:        `delimiters` field.
477:        """
478:        if leaf.type == token.COMMENT:
479:            return
480:
481:        if leaf.type in CLOSING_BRACKETS:
482:            self.depth -= 1
483:            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))
484:            leaf.opening_bracket = opening_bracket
485:        leaf.bracket_depth = self.depth
486:        if self.depth == 0:
487:            delim = is_delimiter(leaf)
488:            if delim:
489:                self.delimiters[id(leaf)] = delim
490:            elif self.previous is not None:
491:                if leaf.type == token.STRING and self.previous.type == token.STRING:
492:                    self.delimiters[id(self.previous)] = STRING_PRIORITY
493:                elif (
494:                    leaf.type == token.NAME
495:                    and leaf.value == 'for'
496:                    and leaf.parent
497:                    and leaf.parent.type in {syms.comp_for, syms.old_comp_for}
498:                ):
499:                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY
500:                elif (
501:                    leaf.type == token.NAME
502:                    and leaf.value == 'if'
503:                    and leaf.parent
504:                    and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
505:                ):
506:                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY
507:                elif (
508:                    leaf.type == token.NAME
509:                    and leaf.value in LOGIC_OPERATORS
510:                    and leaf.parent
511:                ):
512:                    self.delimiters[id(self.previous)] = LOGIC_PRIORITY
513:        if leaf.type in OPENING_BRACKETS:
514:            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf
515:            self.depth += 1
516:        self.previous = leaf
517:
518:    def any_open_brackets(self) -> bool:
519:        """Return True if there is an yet unmatched open bracket on the line."""
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:421:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:657:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:737:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:748:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1109:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1405:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1427:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1706:        if leaf.type == STANDALONE_COMMENT:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
400:        """Pretty-print the lib2to3 AST of a given string of `code`.
401:
402:        Convenience method for debugging.
403:        """
404:        v: DebugVisitor[None] = DebugVisitor()
405:        list(v.visit(lib2to3_parse(code)))
406:
407:
408:KEYWORDS = set(keyword.kwlist)
409:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
410:FLOW_CONTROL = {'return', 'raise', 'break', 'continue'}
411:STATEMENT = {
412:    syms.if_stmt,
413:    syms.while_stmt,
414:    syms.for_stmt,
415:    syms.try_stmt,
416:    syms.except_clause,
417:    syms.with_stmt,
418:    syms.funcdef,
419:    syms.classdef,
420:}
421:STANDALONE_COMMENT = 153
422:LOGIC_OPERATORS = {'and', 'or'}
423:COMPARATORS = {
424:    token.LESS,
425:    token.GREATER,
426:    token.EQEQUAL,
427:    token.NOTEQUAL,
428:    token.LESSEQUAL,
429:    token.GREATEREQUAL,
430:}
431:MATH_OPERATORS = {
432:    token.PLUS,
433:    token.MINUS,
434:    token.STAR,
435:    token.SLASH,
436:    token.VBAR,
437:    token.AMPER,
438:    token.PERCENT,
439:    token.CIRCUMFLEX,
440:    token.TILDE,
441:    token.LEFTSHIFT,
442:    token.RIGHTSHIFT,
443:    token.DOUBLESTAR,
444:    token.DOUBLESLASH,
445:}
446:COMPREHENSION_PRIORITY = 20
447:COMMA_PRIORITY = 10
448:LOGIC_PRIORITY = 5
449:STRING_PRIORITY = 4
450:COMPARATOR_PRIORITY = 3
451:MATH_PRIORITY = 1
452:
453:
454:@dataclass
455:class BracketTracker:
456:    """Keeps track of brackets on a line."""
457:
458:    depth: int = 0
459:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
460:    delimiters: Dict[LeafID, Priority] = Factory(dict)
461:    previous: Optional[Leaf] = None
462:
463:    def mark(self, leaf: Leaf) -> None:
464:        """Mark `leaf` with bracket-related metadata. Keep track of delimiters.
465:
466:        All leaves receive an int `bracket_depth` field that stores how deep
467:        within brackets a given leaf is. 0 means there are no enclosing brackets
468:        that started on this line.
469:
470:        If a leaf is itself a closing bracket, it receives an `opening_bracket`
471:        field that it forms a pair with. This is a one-directional link to
472:        avoid reference cycles.
473:
474:        If a leaf is a delimiter (a token on which Black can split the line if
475:        needed) and it's on depth 0, its `id()` is stored in the tracker's
476:        `delimiters` field.
477:        """
478:        if leaf.type == token.COMMENT:
479:            return

Calling tool: grepTool
def normalize_prefix\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:
1768:def is_python36(node: Node) -> bool:
1769:    """Return True if the current file is using Python 3.6+ features.
1770:
1771:    Currently looking for:
1772:    - f-strings; and
1773:    - trailing commas after * or ** in function signatures.
1774:    """
1775:    for n in node.pre_order():
1776:        if n.type == token.STRING:
1777:            value_head = n.value[:2]  # type: ignore
1778:            if value_head in {'f"', 'F"', "f'", "F'", 'rf', 'fr', 'RF', 'FR'}:
1779:                return True
1780:
1781:        elif (
1782:            n.type == syms.typedargslist
1783:            and n.children
1784:            and n.children[-1].type == token.COMMA
1785:        ):
1786:            for ch in n.children:
1787:                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:
1788:                    return True
1789:
1790:    return False
1791:
1792:
1793:PYTHON_EXTENSIONS = {'.py'}
1794:BLACKLISTED_DIRECTORIES = {
1795:    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'
1796:}
1797:
1798:
1799:def gen_python_files_in_dir(path: Path) -> Iterator[Path]:
1800:    """Generate all files under `path` which aren't under BLACKLISTED_DIRECTORIES
1801:    and have one of the PYTHON_EXTENSIONS.
1802:    """
1803:    for child in path.iterdir():
1804:        if child.is_dir():
1805:            if child.name in BLACKLISTED_DIRECTORIES:
1806:                continue
1807:
1808:            yield from gen_python_files_in_dir(child)
1809:
1810:        elif child.suffix in PYTHON_EXTENSIONS:
1811:            yield child
1812:
1813:
1814:@dataclass
1815:class Report:
1816:    """Provides a reformatting counter. Can be rendered with `str(report)`."""
1817:    check: bool = False
1818:    change_count: int = 0
1819:    same_count: int = 0
1820:    failure_count: int = 0
1821:
1822:    def done(self, src: Path, changed: bool) -> None:
1823:        """Increment the counter for successful reformatting. Write out a message."""
1824:        if changed:
1825:            reformatted = 'would reformat' if self.check else 'reformatted'
1826:            out(f'{reformatted} {src}')
1827:            self.change_count += 1
1828:        else:
1829:            out(f'{src} already well formatted, good job.', bold=False)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1060:
1061:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1062:        """Visit decorators."""
1063:        for child in node.children:
1064:            yield from self.line()
1065:            yield from self.visit(child)
1066:
1067:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1068:        """Remove a semicolon and put the other statement on a separate line."""
1069:        yield from self.line()
1070:
1071:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1072:        """End of file. Process outstanding comments and end with a newline."""
1073:        yield from self.visit_default(leaf)
1074:        yield from self.line()
1075:
1076:    def visit_unformatted(self, node: LN) -> Iterator[Line]:
1077:        """Used when file contained a `# fmt: off`."""
1078:        if isinstance(node, Node):
1079:            for child in node.children:
1080:                yield from self.visit(child)
1081:
1082:        else:
1083:            try:
1084:                self.current_line.append(node)
1085:            except FormatOn as f_on:
1086:                f_on.trim_prefix(node)
1087:                yield from self.line()
1088:                yield from self.visit(node)
1089:
1090:    def __attrs_post_init__(self) -> None:
1091:        """You are in a twisty little maze of passages."""
1092:        v = self.visit_stmt
1093:        self.visit_if_stmt = partial(v, keywords={'if', 'else', 'elif'})
1094:        self.visit_while_stmt = partial(v, keywords={'while', 'else'})
1095:        self.visit_for_stmt = partial(v, keywords={'for', 'else'})
1096:        self.visit_try_stmt = partial(v, keywords={'try', 'except', 'else', 'finally'})
1097:        self.visit_except_clause = partial(v, keywords={'except'})
1098:        self.visit_funcdef = partial(v, keywords={'def'})
1099:        self.visit_with_stmt = partial(v, keywords={'with'})
1100:        self.visit_classdef = partial(v, keywords={'class'})
1101:        self.visit_async_funcdef = self.visit_async_stmt
1102:        self.visit_decorated = self.visit_decorators
1103:
1104:
1105:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1106:OPENING_BRACKETS = set(BRACKET.keys())
1107:CLOSING_BRACKETS = set(BRACKET.values())
1108:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1109:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1110:
1111:
1112:def whitespace(leaf: Leaf) -> str:  # noqa C901
1113:    """Return whitespace prefix if needed for the given `leaf`."""
1114:    NO = ''
1115:    SPACE = ' '
1116:    DOUBLESPACE = '  '
1117:    t = leaf.type
1118:    p = leaf.parent
1119:    v = leaf.value
1120:    if t in ALWAYS_NO_SPACE:
1121:        return NO
1122:
1123:    if t == token.COMMENT:
1124:        return DOUBLESPACE
1125:
1126:    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"
1127:    if t == token.COLON and p.type not in {syms.subscript, syms.subscriptlist}:
1128:        return NO
1129:
1130:    prev = leaf.prev_sibling
1131:    if not prev:
1132:        prevp = preceding_leaf(p)
1133:        if not prevp or prevp.type in OPENING_BRACKETS:
1134:            return NO
1135:
1136:        if t == token.COLON:
1137:            return SPACE if prevp.type == token.COMMA else NO
1138:
1139:        if prevp.type == token.EQUAL:
1140:            if prevp.parent:
1141:                if prevp.parent.type in {
1142:                    syms.arglist, syms.argument, syms.parameters, syms.varargslist
1143:                }:
1144:                    return NO
1145:
1146:                elif prevp.parent.type == syms.typedargslist:
1147:                    # A bit hacky: if the equal sign has whitespace, it means we
1148:                    # previously found it's a typed argument.  So, we're using
1149:                    # that, too.
1150:                    return prevp.prefix
1151:
1152:        elif prevp.type == token.DOUBLESTAR:
1153:            if prevp.parent and prevp.parent.type in {
1154:                syms.arglist,
1155:                syms.argument,
1156:                syms.dictsetmaker,
1157:                syms.parameters,
1158:                syms.typedargslist,
1159:                syms.varargslist,
1160:            }:
1161:                return NO
1162:
1163:        elif prevp.type == token.COLON:
1164:            if prevp.parent and prevp.parent.type in {syms.subscript, syms.sliceop}:
1165:                return NO
1166:
1167:        elif (
1168:            prevp.parent
1169:            and prevp.parent.type in {syms.factor, syms.star_expr}
1170:            and prevp.type in MATH_OPERATORS
1171:        ):
1172:            return NO
1173:
1174:        elif (
1175:            prevp.type == token.RIGHTSHIFT
1176:            and prevp.parent
1177:            and prevp.parent.type == syms.shift_expr
1178:            and prevp.prev_sibling
1179:            and prevp.prev_sibling.type == token.NAME

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1380:        and leaf.parent
1381:        and leaf.parent.type not in {syms.factor, syms.star_expr}
1382:    ):
1383:        return MATH_PRIORITY
1384:
1385:    return 0
1386:
1387:
1388:def generate_comments(leaf: Leaf) -> Iterator[Leaf]:
1389:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1390:
1391:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1392:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1393:    move because it does away with modifying the grammar to include all the
1394:    possible places in which comments can be placed.
1395:
1396:    The sad consequence for us though is that comments don't "belong" anywhere.
1397:    This is why this function generates simple parentless Leaf objects for
1398:    comments.  We simply don't know what the correct parent should be.
1399:
1400:    No matter though, we can live without this.  We really only need to
1401:    differentiate between inline and standalone comments.  The latter don't
1402:    share the line with any code.
1403:
1404:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1405:    are emitted with a fake STANDALONE_COMMENT token identifier.
1406:    """
1407:    p = leaf.prefix
1408:    if not p:
1409:        return
1410:
1411:    if '#' not in p:
1412:        return
1413:
1414:    consumed = 0
1415:    nlines = 0
1416:    for index, line in enumerate(p.split('\n')):
1417:        consumed += len(line) + 1  # adding the length of the split '\n'
1418:        line = line.lstrip()
1419:        if not line:
1420:            nlines += 1
1421:        if not line.startswith('#'):
1422:            continue
1423:
1424:        if index == 0 and leaf.type != token.ENDMARKER:
1425:            comment_type = token.COMMENT  # simple trailing comment
1426:        else:
1427:            comment_type = STANDALONE_COMMENT
1428:        comment = make_comment(line)
1429:        yield Leaf(comment_type, comment, prefix='\n' * nlines)
1430:
1431:        if comment in {'# fmt: on', '# yapf: enable'}:
1432:            raise FormatOn(consumed)
1433:
1434:        if comment in {'# fmt: off', '# yapf: disable'}:
1435:            raise FormatOff(consumed)
1436:
1437:        nlines = 0
1438:
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:
1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1560:    """Split line into many lines, starting with the last matching bracket pair."""
1561:    head = Line(depth=line.depth)
1562:    body = Line(depth=line.depth + 1, inside_brackets=True)
1563:    tail = Line(depth=line.depth)
1564:    tail_leaves: List[Leaf] = []
1565:    body_leaves: List[Leaf] = []
1566:    head_leaves: List[Leaf] = []
1567:    current_leaves = tail_leaves
1568:    opening_bracket = None
1569:    for leaf in reversed(line.leaves):
1570:        if current_leaves is body_leaves:
1571:            if leaf is opening_bracket:
1572:                current_leaves = head_leaves if body_leaves else tail_leaves
1573:        current_leaves.append(leaf)
1574:        if current_leaves is tail_leaves:
1575:            if leaf.type in CLOSING_BRACKETS:
1576:                opening_bracket = leaf.opening_bracket
1577:                current_leaves = body_leaves
1578:    tail_leaves.reverse()
1579:    body_leaves.reverse()
1580:    head_leaves.reverse()
1581:    # Since body is a new indent level, remove spurious leading whitespace.
1582:    if body_leaves:
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1584:    # Build the new lines.
1585:    for result, leaves in (
1586:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1587:    ):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1580:    head_leaves.reverse()
1581:    # Since body is a new indent level, remove spurious leading whitespace.
1582:    if body_leaves:
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1584:    # Build the new lines.
1585:    for result, leaves in (
1586:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1587:    ):
1588:        for leaf in leaves:
1589:            result.append(leaf, preformatted=True)
1590:            for comment_after in line.comments_after(leaf):
1591:                result.append(comment_after, preformatted=True)
1592:    bracket_split_succeeded_or_raise(head, body, tail)
1593:    for result in (head, body, tail):
1594:        if result:
1595:            yield result
1596:
1597:
1598:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
1599:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
1600:
1601:    Do nothing otherwise.
1602:
1603:    A left- or right-hand split is based on a pair of brackets. Content before
1604:    (and including) the opening bracket is left on one line, content inside the
1605:    brackets is put on a separate line, and finally content starting with and
1606:    following the closing bracket is put on a separate line.
1607:
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`
1610:    and the `tail` is just the closing bracket, then it's considered failed.
1611:    """
1612:    tail_len = len(str(tail).strip())
1613:    if not body:
1614:        if tail_len == 0:
1615:            raise CannotSplit("Splitting brackets produced the same line")
1616:
1617:        elif tail_len < 3:
1618:            raise CannotSplit(
1619:                f"Splitting brackets on an empty body to save "
1620:                f"{tail_len} characters is not worth it"
1621:            )
1622:
1623:
1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
1625:    """Normalize prefix of the first leaf in every line returned by `split_func`.
1626:
1627:    This is a decorator over relevant split functions.
1628:    """
1629:
1630:    @wraps(split_func)
1631:    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:
1632:        for l in split_func(line, py36):
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1634:            yield l
1635:
1636:    return split_wrapper
1637:
1638:
1639:@dont_increase_indentation
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:
1641:    """Split according to delimiters of the highest priority.
1642:
1643:    If `py36` is True, the split will add trailing commas also in function
1644:    signatures that contain `*` and `**`.
1645:    """
1646:    try:
1647:        last_leaf = line.leaves[-1]
1648:    except IndexError:
1649:        raise CannotSplit("Line empty")
1650:
1651:    delimiters = line.bracket_tracker.delimiters
1652:    try:
1653:        delimiter_priority = line.bracket_tracker.max_delimiter_priority(
1654:            exclude={id(last_leaf)}
1655:        )
1656:    except ValueError:
1657:        raise CannotSplit("No delimiters found")
1658:
1659:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1660:    lowest_depth = sys.maxsize
1661:    trailing_comma_safe = True
1662:
1663:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1664:        """Append `leaf` to current line or to new line if appending impossible."""
1665:        nonlocal current_line
1666:        try:
1667:            current_line.append_safe(leaf, preformatted=True)
1668:        except ValueError as ve:
1669:            yield current_line
1670:
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1672:            current_line.append(leaf)
1673:
1674:    for leaf in line.leaves:
1675:        yield from append_to_line(leaf)
1676:
1677:        for comment_after in line.comments_after(leaf):
1678:            yield from append_to_line(comment_after)
1679:
1680:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
1681:        if (
1682:            leaf.bracket_depth == lowest_depth
1683:            and leaf.type == token.STAR
1684:            or leaf.type == token.DOUBLESTAR
1685:        ):
1686:            trailing_comma_safe = trailing_comma_safe and py36
1687:        leaf_priority = delimiters.get(id(leaf))
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)

Calling tool: grepTool
\.comments\[
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:773:            comment_index, comment = self.comments[i]
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:775:                self.comments[i] = (comma_index - 1, comment)

Calling tool: grepTool
comments\.
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:532:    """Holds leaves and comments. Can be printed with `str(line)`."""
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:753:            self.comments.append((after, comment))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:794:        """Return True if the line has leaves or comments."""
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1010:        # In blib2to3 INDENT never holds comments.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1016:        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1398:    comments.  We simply don't know what the correct parent should be.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1401:    differentiate between inline and standalone comments.  The latter don't
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/comments.py:84:# Some closing comments.

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:
860:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
861:        """Return the number of extra empty lines before and after the `current_line`.
862:
863:        This is for separating `def`, `async def` and `class` with extra empty
864:        lines (two on module-level), as well as providing an extra empty line
865:        after flow control keywords to make them more prominent.
866:        """
867:        if isinstance(current_line, UnformattedLines):
868:            return 0, 0
869:
870:        before, after = self._maybe_empty_lines(current_line)
871:        before -= self.previous_after
872:        self.previous_after = after
873:        self.previous_line = current_line
874:        return before, after
875:
876:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
877:        max_allowed = 1
878:        if current_line.depth == 0:
879:            max_allowed = 2
880:        if current_line.leaves:
881:            # Consume the first leaf's extra newlines.
882:            first_leaf = current_line.leaves[0]
883:            before = first_leaf.prefix.count('\n')
884:            before = min(before, max_allowed)
885:            first_leaf.prefix = ''
886:        else:
887:            before = 0
888:        depth = current_line.depth
889:        while self.previous_defs and self.previous_defs[-1] >= depth:
890:            self.previous_defs.pop()
891:            before = 1 if depth else 2
892:        is_decorator = current_line.is_decorator
893:        if is_decorator or current_line.is_def or current_line.is_class:
894:            if not is_decorator:
895:                self.previous_defs.append(depth)
896:            if self.previous_line is None:
897:                # Don't insert empty lines before the first line in the file.
898:                return 0, 0
899:
900:            if self.previous_line and self.previous_line.is_decorator:
901:                # Don't insert empty lines between decorators.
902:                return 0, 0
903:
904:            newlines = 2
905:            if current_line.depth:
906:                newlines -= 1
907:            return newlines, 0
908:
909:        if current_line.is_flow_control:
910:            return before, 1
911:
912:        if (
913:            self.previous_line
914:            and self.previous_line.is_import
915:            and not current_line.is_import
916:            and depth == self.previous_line.depth
917:        ):
918:            return (before or 1), 0
919:
920:        if (
921:            self.previous_line
922:            and self.previous_line.is_yield
923:            and (not current_line.is_yield or depth != self.previous_line.depth)
924:        ):
925:            return (before or 1), 0
926:
927:        return before, 0
928:
929:
930:@dataclass
931:class LineGenerator(Visitor[Line]):
932:    """Generates reformatted Line objects.  Empty lines are not emitted.
933:
934:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
935:    in ways that will no longer stringify to valid Python code on the tree.
936:    """
937:    current_line: Line = Factory(Line)
938:
939:    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:
940:        """Generate a line.
941:
942:        If the line is empty, only emit if it makes sense.
943:        If the line is too long, split it first and then generate.
944:
945:        If any lines were generated, set up a new current_line.
946:        """
947:        if not self.current_line:
948:            if self.current_line.__class__ == type:
949:                self.current_line.depth += indent
950:            else:
951:                self.current_line = type(depth=self.current_line.depth + indent)
952:            return  # Line is empty, don't emit. Creating a new one unnecessary.
953:
954:        complete_line = self.current_line
955:        self.current_line = type(depth=complete_line.depth + indent)
956:        yield complete_line
957:
958:    def visit(self, node: LN) -> Iterator[Line]:
959:        """Main method to visit `node` and its children.
960:
961:        Yields :class:`Line` objects.
962:        """
963:        if isinstance(self.current_line, UnformattedLines):
964:            # File contained `# fmt: off`
965:            yield from self.visit_unformatted(node)
966:
967:        else:
968:            yield from super().visit(node)
969:
970:    def visit_default(self, node: LN) -> Iterator[Line]:
971:        """Default `visit_*()` implementation. Recurses to children of `node`."""
972:        if isinstance(node, Leaf):
973:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
974:            try:
975:                for comment in generate_comments(node):
976:                    if any_open_brackets:
977:                        # any comment within brackets is subject to splitting
978:                        self.current_line.append(comment)
979:                    elif comment.type == token.COMMENT:
980:                        # regular trailing comment
981:                        self.current_line.append(comment)
982:                        yield from self.line()
983:
984:                    else:
985:                        # regular standalone comment
986:                        yield from self.line()
987:
988:                        self.current_line.append(comment)
989:                        yield from self.line()
990:
991:            except FormatOff as f_off:
992:                f_off.trim_prefix(node)
993:                yield from self.line(type=UnformattedLines)
994:                yield from self.visit(node)
995:
996:            except FormatOn as f_on:
997:                # This only happens here if somebody says "fmt: on" multiple
998:                # times in a row.
999:                f_on.trim_prefix(node)
1000:                yield from self.visit_default(node)
1001:
1002:            else:
1003:                normalize_prefix(node, inside_brackets=any_open_brackets)
1004:                if node.type not in WHITESPACE:
1005:                    self.current_line.append(node)
1006:        yield from super().visit_default(node)
1007:
1008:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1009:        """Increase indentation level, maybe yield a line."""
1010:        # In blib2to3 INDENT never holds comments.
1011:        yield from self.line(+1)
1012:        yield from self.visit_default(node)
1013:
1014:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1015:        """Decrease indentation level, maybe yield a line."""
1016:        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.
1017:        yield from self.line(-1)
1018:
1019:    def visit_stmt(self, node: Node, keywords: Set[str]) -> Iterator[Line]:
1020:        """Visit a statement.
1021:
1022:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1023:        `def`, `with`, and `class`.
1024:
1025:        The relevant Python language `keywords` for a given statement will be NAME
1026:        leaves within it. This methods puts those on a separate line.
1027:        """
1028:        for child in node.children:
1029:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1030:                yield from self.line()
1031:
1032:            yield from self.visit(child)
1033:
1034:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1035:        """Visit a statement without nested statements."""
1036:        is_suite_like = node.parent and node.parent.type in STATEMENT
1037:        if is_suite_like:
1038:            yield from self.line(+1)
1039:            yield from self.visit_default(node)

Calling tool: createTodo
Todo List Created
Todo List (20 items):
- [ ] Verify that Line.comments changed from Dict[LeafID, Leaf] to List[Tuple[Index, Leaf]] and that all references to comments were updated accordingly (e.g., __str__, comments_after, remove_trailing_comma, left_hand_split, right_hand_split, delimiter_split, standalone_comment_split). (ID: todo-1)
- [ ] Confirm the removal of the standalone comment hack: Line.maybe_adapt_standalone_comment method is deleted and no remaining calls reference it (including in UnformattedLines and Line.append). (ID: todo-2)
- [ ] Check Line.append_comment: when encountering STANDALONE_COMMENT with any open brackets (BracketTracker.any_open_brackets is True), it returns False without converting it into an inline token.COMMENT; otherwise inline comments are recorded using the new index-based comments list. (ID: todo-3)
- [ ] Ensure the new Line.append_safe enforces constraints outside brackets: raises ValueError when appending anything after a standalone comment line, or when attempting to append a standalone comment to a non-empty line; and ensure delimiter_split and standalone_comment_split use append_safe and handle ValueError by yielding the current line and starting a new one. (ID: todo-4)
- [ ] Validate Line.is_comment now returns True only when the line has exactly one leaf and that leaf is STANDALONE_COMMENT (len(self.leaves) == 1). (ID: todo-5)
- [ ] Verify the presence and correctness of Line.contains_standalone_comments which returns True if any leaf.type == STANDALONE_COMMENT on the line, and that split_line uses it to bypass the early-return fast path. (ID: todo-6)
- [ ] In split_line, confirm that lines that are UnformattedLines or comment-only (line.is_comment) are yielded unchanged, fulfilling the intent to not reformat standalone comment lines. (ID: todo-7)
- [ ] In split_line, confirm the early-return condition additionally checks not line.contains_standalone_comments so lines with standalone comments are forced through splitting logic even if within line length and with no embedded newlines. (ID: todo-8)
- [ ] In split_line, when inside_brackets, confirm the split function order is [delimiter_split, standalone_comment_split, right_hand_split] and that split_line calls each with the updated signature (split_func(line, py36)). (ID: todo-9)
- [ ] Verify dont_increase_indentation decorator exists and is applied to delimiter_split and standalone_comment_split, and that these functions no longer call normalize_prefix on each yield explicitly (the decorator handles it). (ID: todo-10)
- [ ] Check that left_hand_split and right_hand_split now append all comments after each leaf by iterating for comment_after in line.comments_after(leaf) and appending each with preformatted=True (thus supporting multiple comments after a single leaf). (ID: todo-11)
- [ ] Verify Line.comments_after(leaf) correctly finds the index of the provided leaf in self.leaves and yields all comments with matching indices from self.comments; ensure it returns nothing if the leaf isn't found. (ID: todo-12)
- [ ] Validate Line.remove_trailing_comma updates indices of comments attached to the trailing comma (decrementing the index by 1) before popping the comma leaf, and confirm all callers of maybe_remove_trailing_comma now call remove_trailing_comma instead of popping directly. (ID: todo-13)
- [ ] Confirm ALWAYS_NO_SPACE includes STANDALONE_COMMENT and that whitespace() returns DOUBLESPACE only for token.COMMENT and no space for STANDALONE_COMMENT (via ALWAYS_NO_SPACE). (ID: todo-14)
- [ ] In LineGenerator.visit_default, verify that when any_open_brackets is True, all generated comments (both inline and standalone) are appended to the current line without immediate line emission, making them subject to splitting; while comments outside brackets are emitted as trailing or standalone appropriately. (ID: todo-15)
- [ ] Ensure standalone_comment_split exists and splits lines around standalone comments by attempting to append leaves/comments via append_safe and starting new lines when ValueError is raised; verify it yields the final current_line if non-empty. (ID: todo-16)
- [ ] Critically check standalone_comment_split's precondition: it should only raise CannotSplit when there are no STANDALONE_COMMENT leaves on the line. Verify whether the current implementation's bracket_depth check incorrectly restricts triggering to comments with bracket_depth == 0 and adjust expectations accordingly. (ID: todo-17)
- [ ] Verify delimiter_split uses append_safe in the same fashion as standalone_comment_split and handles ValueError by yielding the current line and starting a new one; confirm it still honors trailing comma insertion when splitting on COMMA_PRIORITY. (ID: todo-18)
- [ ] Check that split_line uses recursion to further split the lines returned by split functions and that it handles CannotSplit by trying the next split function, finally yielding the original line only if all split functions fail. (ID: todo-19)
- [ ] Confirm tests/test_black.py:test_comments3 reads tests/comments3.py as both input and expected (no '# output' marker) and thus asserts idempotence; ensure tests/comments3.py contains standalone comments inside a bracketed expression (list comprehension) and before/after a bracketed call to demonstrate the addressed bug scenario. (ID: todo-20)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 20
description: 'Verify that Line.comments changed from Dict[LeafID, Leaf] to List[Tuple[Index, Leaf]] and that all references to comments were updated accordingly (e.g., __str__, comments_after, remove_trailing_comma, left_hand_split, right_hand_split, delimiter_split, standalone_comment_split).'
Calling tool: grepTool
class Line\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: globTool
**/*black*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/__pycache__/black.cpython-38.pyc
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/test_black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/__pycache__/test_black.cpython-38.pyc
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/vim/plugin/black.vim

Calling tool: grepTool
class Line\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
class Line:
Matched content:
531:class Line:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:
610:    @property
611:    def is_def(self) -> bool:
612:        """Is this a function definition? (Also returns True for async defs.)"""
613:        try:
614:            first_leaf = self.leaves[0]
615:        except IndexError:
616:            return False
617:
618:        try:
619:            second_leaf: Optional[Leaf] = self.leaves[1]
620:        except IndexError:
621:            second_leaf = None
622:        return (
623:            (first_leaf.type == token.NAME and first_leaf.value == 'def')
624:            or (
625:                first_leaf.type == token.ASYNC
626:                and second_leaf is not None
627:                and second_leaf.type == token.NAME
628:                and second_leaf.value == 'def'
629:            )
630:        )
631:
632:    @property
633:    def is_flow_control(self) -> bool:
634:        """Is this line a flow control statement?
635:
636:        Those are `return`, `raise`, `break`, and `continue`.
637:        """
638:        return (
639:            bool(self)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
640:            and self.leaves[0].type == token.NAME
641:            and self.leaves[0].value in FLOW_CONTROL
642:        )
643:
644:    @property
645:    def is_yield(self) -> bool:
646:        """Is this line a yield statement?"""
647:        return (
648:            bool(self)
649:            and self.leaves[0].type == token.NAME
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True
680:
681:        # For parens let's check if it's safe to remove the comma.  If the
682:        # trailing one is the only one, we might mistakenly change a tuple
683:        # into a different type by removing the comma.
684:        depth = closing.bracket_depth + 1
685:        commas = 0
686:        opening = closing.opening_bracket
687:        for _opening_index, leaf in enumerate(self.leaves):
688:            if leaf is opening:
689:                break
690:
691:        else:
692:            return False
693:
694:        for leaf in self.leaves[_opening_index + 1:]:
695:            if leaf is closing:
696:                break
697:
698:            bracket_depth = leaf.bracket_depth
699:            if bracket_depth == depth and leaf.type == token.COMMA:
700:                commas += 1
701:                if leaf.parent and leaf.parent.type == syms.arglist:
702:                    commas += 1
703:                    break
704:
705:        if commas > 1:
706:            self.remove_trailing_comma()
707:            return True
708:
709:        return False
710:
711:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
712:        """In a for loop, or comprehension, the variables are often unpacks.
713:
714:        To avoid splitting on the comma in this situation, increase the depth of
715:        tokens between `for` and `in`.
716:        """
717:        if leaf.type == token.NAME and leaf.value == 'for':
718:            self.has_for = True
719:            self.bracket_tracker.depth += 1
720:            self._for_loop_variable = True
721:            return True
722:
723:        return False
724:
725:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
726:        """See `maybe_increment_for_loop_variable` above for explanation."""
727:        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':
728:            self.bracket_tracker.depth -= 1
729:            self._for_loop_variable = False
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:
860:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
861:        """Return the number of extra empty lines before and after the `current_line`.
862:
863:        This is for separating `def`, `async def` and `class` with extra empty
864:        lines (two on module-level), as well as providing an extra empty line
865:        after flow control keywords to make them more prominent.
866:        """
867:        if isinstance(current_line, UnformattedLines):
868:            return 0, 0
869:
870:        before, after = self._maybe_empty_lines(current_line)
871:        before -= self.previous_after
872:        self.previous_after = after
873:        self.previous_line = current_line
874:        return before, after
875:
876:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
877:        max_allowed = 1
878:        if current_line.depth == 0:
879:            max_allowed = 2

Calling tool: grepTool
def left_hand_split\(
Matched content:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:
1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1560:    """Split line into many lines, starting with the last matching bracket pair."""
1561:    head = Line(depth=line.depth)
1562:    body = Line(depth=line.depth + 1, inside_brackets=True)
1563:    tail = Line(depth=line.depth)
1564:    tail_leaves: List[Leaf] = []
1565:    body_leaves: List[Leaf] = []
1566:    head_leaves: List[Leaf] = []
1567:    current_leaves = tail_leaves
1568:    opening_bracket = None
1569:    for leaf in reversed(line.leaves):
1570:        if current_leaves is body_leaves:
1571:            if leaf is opening_bracket:
1572:                current_leaves = head_leaves if body_leaves else tail_leaves
1573:        current_leaves.append(leaf)
1574:        if current_leaves is tail_leaves:
1575:            if leaf.type in CLOSING_BRACKETS:
1576:                opening_bracket = leaf.opening_bracket
1577:                current_leaves = body_leaves
1578:    tail_leaves.reverse()
1579:    body_leaves.reverse()
1580:    head_leaves.reverse()
1581:    # Since body is a new indent level, remove spurious leading whitespace.
1582:    if body_leaves:
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1584:    # Build the new lines.
1585:    for result, leaves in (
1586:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1587:    ):
1588:        for leaf in leaves:
1589:            result.append(leaf, preformatted=True)
1590:            for comment_after in line.comments_after(leaf):
1591:                result.append(comment_after, preformatted=True)
1592:    bracket_split_succeeded_or_raise(head, body, tail)
1593:    for result in (head, body, tail):
1594:        if result:
1595:            yield result
1596:
1597:
1598:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
1599:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
1600:
1601:    Do nothing otherwise.
1602:
1603:    A left- or right-hand split is based on a pair of brackets. Content before
1604:    (and including) the opening bracket is left on one line, content inside the
1605:    brackets is put on a separate line, and finally content starting with and
1606:    following the closing bracket is put on a separate line.
1607:
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`

Calling tool: grepTool
def delimiter_split\(
Matched content:
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`
1610:    and the `tail` is just the closing bracket, then it's considered failed.
1611:    """
1612:    tail_len = len(str(tail).strip())
1613:    if not body:
1614:        if tail_len == 0:
1615:            raise CannotSplit("Splitting brackets produced the same line")
1616:
1617:        elif tail_len < 3:
1618:            raise CannotSplit(
1619:                f"Splitting brackets on an empty body to save "
1620:                f"{tail_len} characters is not worth it"
1621:            )
1622:
1623:
1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
1625:    """Normalize prefix of the first leaf in every line returned by `split_func`.
1626:
1627:    This is a decorator over relevant split functions.
1628:    """
1629:
1630:    @wraps(split_func)
1631:    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:
1632:        for l in split_func(line, py36):
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1634:            yield l
1635:
1636:    return split_wrapper
1637:
1638:
1639:@dont_increase_indentation
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:
1641:    """Split according to delimiters of the highest priority.
1642:
1643:    If `py36` is True, the split will add trailing commas also in function
1644:    signatures that contain `*` and `**`.
1645:    """
1646:    try:
1647:        last_leaf = line.leaves[-1]
1648:    except IndexError:
1649:        raise CannotSplit("Line empty")
1650:
1651:    delimiters = line.bracket_tracker.delimiters
1652:    try:
1653:        delimiter_priority = line.bracket_tracker.max_delimiter_priority(
1654:            exclude={id(last_leaf)}
1655:        )
1656:    except ValueError:
1657:        raise CannotSplit("No delimiters found")
1658:
1659:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1660:    lowest_depth = sys.maxsize
1661:    trailing_comma_safe = True
1662:
1663:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1664:        """Append `leaf` to current line or to new line if appending impossible."""
1665:        nonlocal current_line
1666:        try:
1667:            current_line.append_safe(leaf, preformatted=True)
1668:        except ValueError as ve:
1669:            yield current_line
1670:
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1672:            current_line.append(leaf)
1673:
1674:    for leaf in line.leaves:
1675:        yield from append_to_line(leaf)
1676:
1677:        for comment_after in line.comments_after(leaf):
1678:            yield from append_to_line(comment_after)
1679:
1680:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
1681:        if (
1682:            leaf.bracket_depth == lowest_depth
1683:            and leaf.type == token.STAR
1684:            or leaf.type == token.DOUBLESTAR
1685:        ):
1686:            trailing_comma_safe = trailing_comma_safe and py36
1687:        leaf_priority = delimiters.get(id(leaf))
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:

Calling tool: grepTool
def split_line\(
Matched content:
1459:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:
1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: grepTool
test_comments3
Matched content:
154:    def test_comments3(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/test_black.py
120:
121:    @patch("black.dump_to_file", dump_to_stderr)
122:    def test_expression(self) -> None:
123:        source, expected = read_data('expression')
124:        actual = fs(source)
125:        self.assertFormatEqual(expected, actual)
126:        black.assert_equivalent(source, actual)
127:        black.assert_stable(source, actual, line_length=ll)
128:
129:    @patch("black.dump_to_file", dump_to_stderr)
130:    def test_fstring(self) -> None:
131:        source, expected = read_data('fstring')
132:        actual = fs(source)
133:        self.assertFormatEqual(expected, actual)
134:        black.assert_equivalent(source, actual)
135:        black.assert_stable(source, actual, line_length=ll)
136:
137:    @patch("black.dump_to_file", dump_to_stderr)
138:    def test_comments(self) -> None:
139:        source, expected = read_data('comments')
140:        actual = fs(source)
141:        self.assertFormatEqual(expected, actual)
142:        black.assert_equivalent(source, actual)
143:        black.assert_stable(source, actual, line_length=ll)
144:
145:    @patch("black.dump_to_file", dump_to_stderr)
146:    def test_comments2(self) -> None:
147:        source, expected = read_data('comments2')
148:        actual = fs(source)
149:        self.assertFormatEqual(expected, actual)
150:        black.assert_equivalent(source, actual)
151:        black.assert_stable(source, actual, line_length=ll)
152:
153:    @patch("black.dump_to_file", dump_to_stderr)
154:    def test_comments3(self) -> None:
155:        source, expected = read_data('comments3')
156:        actual = fs(source)
157:        self.assertFormatEqual(expected, actual)
158:        black.assert_equivalent(source, actual)
159:        black.assert_stable(source, actual, line_length=ll)
160:
161:    @patch("black.dump_to_file", dump_to_stderr)
162:    def test_cantfit(self) -> None:
163:        source, expected = read_data('cantfit')
164:        actual = fs(source)
165:        self.assertFormatEqual(expected, actual)
166:        black.assert_equivalent(source, actual)
167:        black.assert_stable(source, actual, line_length=ll)
168:
169:    @patch("black.dump_to_file", dump_to_stderr)
170:    def test_import_spacing(self) -> None:
171:        source, expected = read_data('import_spacing')
172:        actual = fs(source)
173:        self.assertFormatEqual(expected, actual)
174:        black.assert_equivalent(source, actual)
175:        black.assert_stable(source, actual, line_length=ll)
176:
177:    @patch("black.dump_to_file", dump_to_stderr)
178:    def test_composition(self) -> None:
179:        source, expected = read_data('composition')
180:        actual = fs(source)
181:        self.assertFormatEqual(expected, actual)
182:        black.assert_equivalent(source, actual)
183:        black.assert_stable(source, actual, line_length=ll)
184:
185:    @patch("black.dump_to_file", dump_to_stderr)
186:    def test_empty_lines(self) -> None:
187:        source, expected = read_data('empty_lines')
188:        actual = fs(source)
189:        self.assertFormatEqual(expected, actual)
190:        black.assert_equivalent(source, actual)
191:        black.assert_stable(source, actual, line_length=ll)
192:
193:    @patch("black.dump_to_file", dump_to_stderr)
194:    def test_python2(self) -> None:
195:        source, expected = read_data('python2')
196:        actual = fs(source)
197:        self.assertFormatEqual(expected, actual)
198:        # black.assert_equivalent(source, actual)
199:        black.assert_stable(source, actual, line_length=ll)
200:
201:    @patch("black.dump_to_file", dump_to_stderr)
202:    def test_fmtonoff(self) -> None:
203:        source, expected = read_data('fmtonoff')
204:        actual = fs(source)
205:        self.assertFormatEqual(expected, actual)
206:        black.assert_equivalent(source, actual)
207:        black.assert_stable(source, actual, line_length=ll)
208:
209:    def test_report(self) -> None:
210:        report = black.Report()
211:        out_lines = []
212:        err_lines = []
213:
214:        def out(msg: str, **kwargs: Any) -> None:
215:            out_lines.append(msg)
216:
217:        def err(msg: str, **kwargs: Any) -> None:
218:            err_lines.append(msg)
219:
220:        with patch("black.out", out), patch("black.err", err):
221:            report.done(Path('f1'), changed=False)
222:            self.assertEqual(len(out_lines), 1)
223:            self.assertEqual(len(err_lines), 0)
224:            self.assertEqual(out_lines[-1], 'f1 already well formatted, good job.')
225:            self.assertEqual(unstyle(str(report)), '1 file left unchanged.')
226:            self.assertEqual(report.return_code, 0)
227:            report.done(Path('f2'), changed=True)
228:            self.assertEqual(len(out_lines), 2)
229:            self.assertEqual(len(err_lines), 0)
230:            self.assertEqual(out_lines[-1], 'reformatted f2')
231:            self.assertEqual(
232:                unstyle(str(report)), '1 file reformatted, 1 file left unchanged.'
233:            )
234:            self.assertEqual(report.return_code, 0)
235:            report.check = True
236:            self.assertEqual(report.return_code, 1)
237:            report.check = False
238:            report.failed(Path('e1'), 'boom')
239:            self.assertEqual(len(out_lines), 2)

Calling tool: grepTool
last_non_delimiter
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
Index = int
Matched content:
46:Index = int

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1:#!/usr/bin/env python3
2:
3:import asyncio
4:from asyncio.base_events import BaseEventLoop
5:from concurrent.futures import Executor, ProcessPoolExecutor
6:from functools import partial, wraps
7:import keyword
8:import os
9:from pathlib import Path
10:import tokenize
11:import sys
12:from typing import (
13:    Callable,
14:    Dict,
15:    Generic,
16:    Iterable,
17:    Iterator,
18:    List,
19:    Optional,
20:    Set,
21:    Tuple,
22:    Type,
23:    TypeVar,
24:    Union,
25:)
26:
27:from attr import dataclass, Factory
28:import click
29:
30:# lib2to3 fork
31:from blib2to3.pytree import Node, Leaf, type_repr
32:from blib2to3 import pygram, pytree
33:from blib2to3.pgen2 import driver, token
34:from blib2to3.pgen2.parse import ParseError
35:
36:__version__ = "18.3a4"
37:DEFAULT_LINE_LENGTH = 88
38:# types
39:syms = pygram.python_symbols
40:FileContent = str
41:Encoding = str
42:Depth = int
43:NodeType = int
44:LeafID = int
45:Priority = int
46:Index = int
47:LN = Union[Leaf, Node]
48:SplitFunc = Callable[['Line', bool], Iterator['Line']]
49:out = partial(click.secho, bold=True, err=True)
50:err = partial(click.secho, fg='red', err=True)
51:
52:
53:class NothingChanged(UserWarning):
54:    """Raised by :func:`format_file` when reformatted code is the same as source."""
55:
56:
57:class CannotSplit(Exception):
58:    """A readable split that fits the allotted line length is impossible.
59:
60:    Raised by :func:`left_hand_split`, :func:`right_hand_split`, and
61:    :func:`delimiter_split`.
62:    """
63:
64:
65:class FormatError(Exception):
66:    """Base exception for `# fmt: on` and `# fmt: off` handling.
67:
68:    It holds the number of bytes of the prefix consumed before the format
69:    control comment appeared.
70:    """
71:
72:    def __init__(self, consumed: int) -> None:
73:        super().__init__(consumed)
74:        self.consumed = consumed
75:
76:    def trim_prefix(self, leaf: Leaf) -> None:
77:        leaf.prefix = leaf.prefix[self.consumed:]
78:
79:    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:
80:        """Returns a new Leaf from the consumed part of the prefix."""

Calling tool: grepTool
comments\.
Matched content:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
753:            self.comments.append((after, comment))
794:        """Return True if the line has leaves or comments."""
1010:        # In blib2to3 INDENT never holds comments.
1016:        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.
1398:    comments.  We simply don't know what the correct parent should be.
1401:    differentiate between inline and standalone comments.  The latter don't

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1368:    """Return the priority of the `leaf` delimiter. Return 0 if not delimiter.
1369:
1370:    Higher numbers are higher priority.
1371:    """
1372:    if leaf.type == token.COMMA:
1373:        return COMMA_PRIORITY
1374:
1375:    if leaf.type in COMPARATORS:
1376:        return COMPARATOR_PRIORITY
1377:
1378:    if (
1379:        leaf.type in MATH_OPERATORS
1380:        and leaf.parent
1381:        and leaf.parent.type not in {syms.factor, syms.star_expr}
1382:    ):
1383:        return MATH_PRIORITY
1384:
1385:    return 0
1386:
1387:
1388:def generate_comments(leaf: Leaf) -> Iterator[Leaf]:
1389:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1390:
1391:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1392:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1393:    move because it does away with modifying the grammar to include all the
1394:    possible places in which comments can be placed.
1395:
1396:    The sad consequence for us though is that comments don't "belong" anywhere.
1397:    This is why this function generates simple parentless Leaf objects for
1398:    comments.  We simply don't know what the correct parent should be.
1399:
1400:    No matter though, we can live without this.  We really only need to
1401:    differentiate between inline and standalone comments.  The latter don't
1402:    share the line with any code.
1403:
1404:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1405:    are emitted with a fake STANDALONE_COMMENT token identifier.
1406:    """
1407:    p = leaf.prefix
1408:    if not p:
1409:        return
1410:
1411:    if '#' not in p:
1412:        return
1413:
1414:    consumed = 0
1415:    nlines = 0
1416:    for index, line in enumerate(p.split('\n')):
1417:        consumed += len(line) + 1  # adding the length of the split '\n'
1418:        line = line.lstrip()
1419:        if not line:
1420:            nlines += 1
1421:        if not line.startswith('#'):
1422:            continue
1423:
1424:        if index == 0 and leaf.type != token.ENDMARKER:
1425:            comment_type = token.COMMENT  # simple trailing comment
1426:        else:
1427:            comment_type = STANDALONE_COMMENT
1428:        comment = make_comment(line)
1429:        yield Leaf(comment_type, comment, prefix='\n' * nlines)
1430:
1431:        if comment in {'# fmt: on', '# yapf: enable'}:
1432:            raise FormatOn(consumed)
1433:
1434:        if comment in {'# fmt: off', '# yapf: disable'}:
1435:            raise FormatOff(consumed)
1436:
1437:        nlines = 0
1438:
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]

Calling tool: grepTool
comments\.values\(|comments\[|comments\.get\(
Matched content:
773:            comment_index, comment = self.comments[i]
775:                self.comments[i] = (comma_index - 1, comment)

Calling tool: grepTool
maybe_adapt_standalone_comment
No files found. Call grepTool again with a more generic pattern.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Line.comments is now List[Tuple[Index, Leaf]]. All usages were updated: __str__ iterates tuples, comments_after generates by matching indices, remove_trailing_comma shifts comment indices, and split functions (left/right/delimiter/standalone_comment_split) use comments_after instead of dict lookups. No stale dict-style accesses remain.


Todo item 1 of 20 is correct
description: 'Verify that Line.comments changed from Dict[LeafID, Leaf] to List[Tuple[Index, Leaf]] and that all references to comments were updated accordingly (e.g., __str__, comments_after, remove_trailing_comma, left_hand_split, right_hand_split, delimiter_split, standalone_comment_split).'
Validating todo item 2 of 20
description: 'Confirm the removal of the standalone comment hack: Line.maybe_adapt_standalone_comment method is deleted and no remaining calls reference it (including in UnformattedLines and Line.append).'
Calling tool: grepTool
maybe_adapt_standalone_comment\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
maybe_adapt_standalone_comment
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
def append\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:
610:    @property
611:    def is_def(self) -> bool:
612:        """Is this a function definition? (Also returns True for async defs.)"""
613:        try:
614:            first_leaf = self.leaves[0]
615:        except IndexError:
616:            return False
617:
618:        try:
619:            second_leaf: Optional[Leaf] = self.leaves[1]
620:        except IndexError:
621:            second_leaf = None
622:        return (
623:            (first_leaf.type == token.NAME and first_leaf.value == 'def')
624:            or (
625:                first_leaf.type == token.ASYNC
626:                and second_leaf is not None
627:                and second_leaf.type == token.NAME
628:                and second_leaf.value == 'def'
629:            )
630:        )
631:
632:    @property
633:    def is_flow_control(self) -> bool:
634:        """Is this line a flow control statement?
635:
636:        Those are `return`, `raise`, `break`, and `continue`.
637:        """
638:        return (
639:            bool(self)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Searched the codebase and found no occurrences of maybe_adapt_standalone_comment. In Line.append the call was removed, and UnformattedLines no longer defines the stub. Verified via reading black.py around append methods; no calls or definitions remain.


Todo item 2 of 20 is correct
description: 'Confirm the removal of the standalone comment hack: Line.maybe_adapt_standalone_comment method is deleted and no remaining calls reference it (including in UnformattedLines and Line.append).'
Validating todo item 3 of 20
description: 'Check Line.append_comment: when encountering STANDALONE_COMMENT with any open brackets (BracketTracker.any_open_brackets is True), it returns False without converting it into an inline token.COMMENT; otherwise inline comments are recorded using the new index-based comments list.'
Calling tool: grepTool
def append_comment\(
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
def append_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:734:    def append_comment(self, comment: Leaf) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:834:    def append_comment(self, comment: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
720:            self._for_loop_variable = True
721:            return True
722:
723:        return False
724:
725:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
726:        """See `maybe_increment_for_loop_variable` above for explanation."""
727:        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':
728:            self.bracket_tracker.depth -= 1
729:            self._for_loop_variable = False
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:
860:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
861:        """Return the number of extra empty lines before and after the `current_line`.
862:
863:        This is for separating `def`, `async def` and `class` with extra empty
864:        lines (two on module-level), as well as providing an extra empty line
865:        after flow control keywords to make them more prominent.
866:        """
867:        if isinstance(current_line, UnformattedLines):
868:            return 0, 0
869:
870:        before, after = self._maybe_empty_lines(current_line)
871:        before -= self.previous_after
872:        self.previous_after = after
873:        self.previous_line = current_line
874:        return before, after
875:
876:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
877:        max_allowed = 1
878:        if current_line.depth == 0:
879:            max_allowed = 2

Calling tool: grepTool
class Line:|def append\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:531:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py Line.append_comment now checks if the comment is STANDALONE_COMMENT with open brackets; it returns False after only clearing the prefix and does not convert it to token.COMMENT. For inline comments (token.COMMENT), it records them in the new index-based list via self.comments.append((after, comment)).


Todo item 3 of 20 is correct
description: 'Check Line.append_comment: when encountering STANDALONE_COMMENT with any open brackets (BracketTracker.any_open_brackets is True), it returns False without converting it into an inline token.COMMENT; otherwise inline comments are recorded using the new index-based comments list.'
Validating todo item 4 of 20
description: 'Ensure the new Line.append_safe enforces constraints outside brackets: raises ValueError when appending anything after a standalone comment line, or when attempting to append a standalone comment to a non-empty line; and ensure delimiter_split and standalone_comment_split use append_safe and handle ValueError by yielding the current line and starting a new one.'
Calling tool: grepTool
class Line\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py

Calling tool: grepTool
class Line\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
class Line
Matched content:
531:class Line:
931:class LineGenerator(Visitor[Line]):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:
610:    @property
611:    def is_def(self) -> bool:
612:        """Is this a function definition? (Also returns True for async defs.)"""
613:        try:
614:            first_leaf = self.leaves[0]
615:        except IndexError:
616:            return False
617:
618:        try:
619:            second_leaf: Optional[Leaf] = self.leaves[1]
620:        except IndexError:
621:            second_leaf = None
622:        return (
623:            (first_leaf.type == token.NAME and first_leaf.value == 'def')
624:            or (
625:                first_leaf.type == token.ASYNC
626:                and second_leaf is not None
627:                and second_leaf.type == token.NAME
628:                and second_leaf.value == 'def'
629:            )
630:        )
631:
632:    @property
633:    def is_flow_control(self) -> bool:
634:        """Is this line a flow control statement?
635:
636:        Those are `return`, `raise`, `break`, and `continue`.
637:        """
638:        return (
639:            bool(self)
640:            and self.leaves[0].type == token.NAME
641:            and self.leaves[0].value in FLOW_CONTROL
642:        )
643:
644:    @property
645:    def is_yield(self) -> bool:
646:        """Is this line a yield statement?"""
647:        return (
648:            bool(self)
649:            and self.leaves[0].type == token.NAME
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True
680:
681:        # For parens let's check if it's safe to remove the comma.  If the
682:        # trailing one is the only one, we might mistakenly change a tuple
683:        # into a different type by removing the comma.
684:        depth = closing.bracket_depth + 1
685:        commas = 0
686:        opening = closing.opening_bracket
687:        for _opening_index, leaf in enumerate(self.leaves):
688:            if leaf is opening:
689:                break
690:
691:        else:
692:            return False
693:
694:        for leaf in self.leaves[_opening_index + 1:]:
695:            if leaf is closing:
696:                break
697:
698:            bracket_depth = leaf.bracket_depth
699:            if bracket_depth == depth and leaf.type == token.COMMA:
700:                commas += 1
701:                if leaf.parent and leaf.parent.type == syms.arglist:
702:                    commas += 1
703:                    break
704:
705:        if commas > 1:
706:            self.remove_trailing_comma()
707:            return True
708:
709:        return False
710:
711:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
712:        """In a for loop, or comprehension, the variables are often unpacks.
713:
714:        To avoid splitting on the comma in this situation, increase the depth of
715:        tokens between `for` and `in`.
716:        """
717:        if leaf.type == token.NAME and leaf.value == 'for':
718:            self.has_for = True
719:            self.bracket_tracker.depth += 1

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
720:            self._for_loop_variable = True
721:            return True
722:
723:        return False
724:
725:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
726:        """See `maybe_increment_for_loop_variable` above for explanation."""
727:        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':
728:            self.bracket_tracker.depth -= 1
729:            self._for_loop_variable = False
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:
860:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
861:        """Return the number of extra empty lines before and after the `current_line`.
862:
863:        This is for separating `def`, `async def` and `class` with extra empty
864:        lines (two on module-level), as well as providing an extra empty line
865:        after flow control keywords to make them more prominent.
866:        """
867:        if isinstance(current_line, UnformattedLines):
868:            return 0, 0
869:
870:        before, after = self._maybe_empty_lines(current_line)
871:        before -= self.previous_after
872:        self.previous_after = after
873:        self.previous_line = current_line
874:        return before, after
875:
876:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
877:        max_allowed = 1
878:        if current_line.depth == 0:
879:            max_allowed = 2
880:        if current_line.leaves:
881:            # Consume the first leaf's extra newlines.
882:            first_leaf = current_line.leaves[0]
883:            before = first_leaf.prefix.count('\n')
884:            before = min(before, max_allowed)
885:            first_leaf.prefix = ''
886:        else:
887:            before = 0
888:        depth = current_line.depth
889:        while self.previous_defs and self.previous_defs[-1] >= depth:
890:            self.previous_defs.pop()
891:            before = 1 if depth else 2
892:        is_decorator = current_line.is_decorator
893:        if is_decorator or current_line.is_def or current_line.is_class:
894:            if not is_decorator:
895:                self.previous_defs.append(depth)
896:            if self.previous_line is None:
897:                # Don't insert empty lines before the first line in the file.
898:                return 0, 0
899:
900:            if self.previous_line and self.previous_line.is_decorator:
901:                # Don't insert empty lines between decorators.
902:                return 0, 0
903:
904:            newlines = 2
905:            if current_line.depth:
906:                newlines -= 1
907:            return newlines, 0
908:
909:        if current_line.is_flow_control:
910:            return before, 1
911:
912:        if (
913:            self.previous_line
914:            and self.previous_line.is_import
915:            and not current_line.is_import
916:            and depth == self.previous_line.depth
917:        ):
918:            return (before or 1), 0
919:
920:        if (
921:            self.previous_line
922:            and self.previous_line.is_yield
923:            and (not current_line.is_yield or depth != self.previous_line.depth)
924:        ):
925:            return (before or 1), 0
926:
927:        return before, 0
928:
929:
930:@dataclass
931:class LineGenerator(Visitor[Line]):
932:    """Generates reformatted Line objects.  Empty lines are not emitted.
933:
934:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
935:    in ways that will no longer stringify to valid Python code on the tree.
936:    """
937:    current_line: Line = Factory(Line)
938:
939:    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:

Calling tool: grepTool
def delimiter_split\(
Matched content:
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:
1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1560:    """Split line into many lines, starting with the last matching bracket pair."""
1561:    head = Line(depth=line.depth)
1562:    body = Line(depth=line.depth + 1, inside_brackets=True)
1563:    tail = Line(depth=line.depth)
1564:    tail_leaves: List[Leaf] = []
1565:    body_leaves: List[Leaf] = []
1566:    head_leaves: List[Leaf] = []
1567:    current_leaves = tail_leaves
1568:    opening_bracket = None
1569:    for leaf in reversed(line.leaves):
1570:        if current_leaves is body_leaves:
1571:            if leaf is opening_bracket:
1572:                current_leaves = head_leaves if body_leaves else tail_leaves
1573:        current_leaves.append(leaf)
1574:        if current_leaves is tail_leaves:
1575:            if leaf.type in CLOSING_BRACKETS:
1576:                opening_bracket = leaf.opening_bracket
1577:                current_leaves = body_leaves
1578:    tail_leaves.reverse()
1579:    body_leaves.reverse()
1580:    head_leaves.reverse()
1581:    # Since body is a new indent level, remove spurious leading whitespace.
1582:    if body_leaves:
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1584:    # Build the new lines.
1585:    for result, leaves in (
1586:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1587:    ):
1588:        for leaf in leaves:
1589:            result.append(leaf, preformatted=True)
1590:            for comment_after in line.comments_after(leaf):
1591:                result.append(comment_after, preformatted=True)
1592:    bracket_split_succeeded_or_raise(head, body, tail)
1593:    for result in (head, body, tail):
1594:        if result:
1595:            yield result
1596:
1597:
1598:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
1599:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
1600:
1601:    Do nothing otherwise.
1602:
1603:    A left- or right-hand split is based on a pair of brackets. Content before
1604:    (and including) the opening bracket is left on one line, content inside the
1605:    brackets is put on a separate line, and finally content starting with and
1606:    following the closing bracket is put on a separate line.
1607:
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`
1610:    and the `tail` is just the closing bracket, then it's considered failed.
1611:    """
1612:    tail_len = len(str(tail).strip())
1613:    if not body:
1614:        if tail_len == 0:
1615:            raise CannotSplit("Splitting brackets produced the same line")
1616:
1617:        elif tail_len < 3:
1618:            raise CannotSplit(
1619:                f"Splitting brackets on an empty body to save "
1620:                f"{tail_len} characters is not worth it"
1621:            )
1622:
1623:
1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
1625:    """Normalize prefix of the first leaf in every line returned by `split_func`.
1626:
1627:    This is a decorator over relevant split functions.
1628:    """
1629:
1630:    @wraps(split_func)
1631:    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:
1632:        for l in split_func(line, py36):
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1634:            yield l
1635:
1636:    return split_wrapper
1637:
1638:
1639:@dont_increase_indentation
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:
1641:    """Split according to delimiters of the highest priority.
1642:
1643:    If `py36` is True, the split will add trailing commas also in function
1644:    signatures that contain `*` and `**`.
1645:    """
1646:    try:
1647:        last_leaf = line.leaves[-1]
1648:    except IndexError:
1649:        raise CannotSplit("Line empty")
1650:
1651:    delimiters = line.bracket_tracker.delimiters
1652:    try:
1653:        delimiter_priority = line.bracket_tracker.max_delimiter_priority(
1654:            exclude={id(last_leaf)}
1655:        )
1656:    except ValueError:
1657:        raise CannotSplit("No delimiters found")
1658:
1659:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1660:    lowest_depth = sys.maxsize
1661:    trailing_comma_safe = True
1662:
1663:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1664:        """Append `leaf` to current line or to new line if appending impossible."""
1665:        nonlocal current_line
1666:        try:
1667:            current_line.append_safe(leaf, preformatted=True)
1668:        except ValueError as ve:
1669:            yield current_line
1670:
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1672:            current_line.append(leaf)
1673:
1674:    for leaf in line.leaves:
1675:        yield from append_to_line(leaf)
1676:
1677:        for comment_after in line.comments_after(leaf):
1678:            yield from append_to_line(comment_after)
1679:
1680:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
1681:        if (
1682:            leaf.bracket_depth == lowest_depth
1683:            and leaf.type == token.STAR
1684:            or leaf.type == token.DOUBLESTAR
1685:        ):
1686:            trailing_comma_safe = trailing_comma_safe and py36
1687:        leaf_priority = delimiters.get(id(leaf))
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:
1768:def is_python36(node: Node) -> bool:
1769:    """Return True if the current file is using Python 3.6+ features.
1770:
1771:    Currently looking for:
1772:    - f-strings; and
1773:    - trailing commas after * or ** in function signatures.
1774:    """
1775:    for n in node.pre_order():
1776:        if n.type == token.STRING:
1777:            value_head = n.value[:2]  # type: ignore
1778:            if value_head in {'f"', 'F"', "f'", "F'", 'rf', 'fr', 'RF', 'FR'}:
1779:                return True
1780:
1781:        elif (
1782:            n.type == syms.typedargslist
1783:            and n.children
1784:            and n.children[-1].type == token.COMMA
1785:        ):
1786:            for ch in n.children:
1787:                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:
1788:                    return True
1789:
1790:    return False
1791:
1792:
1793:PYTHON_EXTENSIONS = {'.py'}
1794:BLACKLISTED_DIRECTORIES = {
1795:    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'
1796:}
1797:
1798:
1799:def gen_python_files_in_dir(path: Path) -> Iterator[Path]:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified black/black.py implements Line.append_safe raising ValueError outside brackets when appending after a standalone comment line and when appending a standalone comment to a non-empty line. Also confirmed delimiter_split and standalone_comment_split use append_safe and on ValueError yield the current line, start a new one, and append the leaf. Tests align with updated split_line behavior.


Todo item 4 of 20 is correct
description: 'Ensure the new Line.append_safe enforces constraints outside brackets: raises ValueError when appending anything after a standalone comment line, or when attempting to append a standalone comment to a non-empty line; and ensure delimiter_split and standalone_comment_split use append_safe and handle ValueError by yielding the current line and starting a new one.'
Validating todo item 5 of 20
description: 'Validate Line.is_comment now returns True only when the line has exactly one leaf and that leaf is STANDALONE_COMMENT (len(self.leaves) == 1).'
Calling tool: grepTool
def is_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:587:    def is_comment(self) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:
610:    @property
611:    def is_def(self) -> bool:
612:        """Is this a function definition? (Also returns True for async defs.)"""
613:        try:
614:            first_leaf = self.leaves[0]
615:        except IndexError:
616:            return False
617:
618:        try:
619:            second_leaf: Optional[Leaf] = self.leaves[1]

Calling tool: grepTool
is_comment
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:576:            if self.is_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:587:    def is_comment(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1472:    if isinstance(line, UnformattedLines) or line.is_comment:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py Line.is_comment (line ~587) now returns `len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT`, ensuring True only when there is exactly one leaf and it is a standalone comment. Verified via grep and reading the implementation.


Todo item 5 of 20 is correct
description: 'Validate Line.is_comment now returns True only when the line has exactly one leaf and that leaf is STANDALONE_COMMENT (len(self.leaves) == 1).'
Validating todo item 6 of 20
description: 'Verify the presence and correctness of Line.contains_standalone_comments which returns True if any leaf.type == STANDALONE_COMMENT on the line, and that split_line uses it to bypass the early-return fast path.'
Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py

Calling tool: grepTool
contains_standalone_comments
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:654:    def contains_standalone_comments(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1480:        and not line.contains_standalone_comments

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
640:            and self.leaves[0].type == token.NAME
641:            and self.leaves[0].value in FLOW_CONTROL
642:        )
643:
644:    @property
645:    def is_yield(self) -> bool:
646:        """Is this line a yield statement?"""
647:        return (
648:            bool(self)
649:            and self.leaves[0].type == token.NAME
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Line.contains_standalone_comments is implemented to return True if any leaf.type == STANDALONE_COMMENT (black.py:654-660). split_lines early-return condition includes `and not line.contains_standalone_comments` (black.py:1476-1483), ensuring lines with standalone comments bypass the fast path.


Todo item 6 of 20 is correct
description: 'Verify the presence and correctness of Line.contains_standalone_comments which returns True if any leaf.type == STANDALONE_COMMENT on the line, and that split_line uses it to bypass the early-return fast path.'
Validating todo item 7 of 20
description: 'In split_line, confirm that lines that are UnformattedLines or comment-only (line.is_comment) are yielded unchanged, fulfilling the intent to not reformat standalone comment lines.'
Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1459:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:

Calling tool: grepTool
def is_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:587:    def is_comment(self) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py split_line, lines 1472-1474 explicitly yield and return when the line is an UnformattedLines or when line.is_comment is True. The is_comment property (lines 587-590) correctly identifies comment-only lines. Thus standalone comment lines are yielded unchanged as required.


Todo item 7 of 20 is correct
description: 'In split_line, confirm that lines that are UnformattedLines or comment-only (line.is_comment) are yielded unchanged, fulfilling the intent to not reformat standalone comment lines.'
Validating todo item 8 of 20
description: 'In split_line, confirm the early-return condition additionally checks not line.contains_standalone_comments so lines with standalone comments are forced through splitting logic even if within line length and with no embedded newlines.'
Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1459:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:

Calling tool: grepTool
def contains_standalone_comments\(
Matched content:
654:    def contains_standalone_comments(self) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
640:            and self.leaves[0].type == token.NAME
641:            and self.leaves[0].value in FLOW_CONTROL
642:        )
643:
644:    @property
645:    def is_yield(self) -> bool:
646:        """Is this line a yield statement?"""
647:        return (
648:            bool(self)
649:            and self.leaves[0].type == token.NAME
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified in black.py split_line that the early-return condition includes `and not line.contains_standalone_comments`. The Line class implements `contains_standalone_comments` to detect STANDALONE_COMMENT leaves, ensuring such lines are not returned early even if within line length and no embedded newlines.


Todo item 8 of 20 is correct
description: 'In split_line, confirm the early-return condition additionally checks not line.contains_standalone_comments so lines with standalone comments are forced through splitting logic even if within line length and with no embedded newlines.'
Validating todo item 9 of 20
description: 'In split_line, when inside_brackets, confirm the split function order is [delimiter_split, standalone_comment_split, right_hand_split] and that split_line calls each with the updated signature (split_func(line, py36)).'
Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1459:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py split_line, when line.inside_brackets is true, split_funcs is set to [delimiter_split, standalone_comment_split, right_hand_split] (lines ~1485-1491). The loop later calls each via for l in split_func(line, py36): (line ~1498), matching the updated signature.


Todo item 9 of 20 is correct
description: 'In split_line, when inside_brackets, confirm the split function order is [delimiter_split, standalone_comment_split, right_hand_split] and that split_line calls each with the updated signature (split_func(line, py36)).'
Validating todo item 10 of 20
description: 'Verify dont_increase_indentation decorator exists and is applied to delimiter_split and standalone_comment_split, and that these functions no longer call normalize_prefix on each yield explicitly (the decorator handles it).'
Calling tool: grepTool
dont_increase_indentation\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`
1610:    and the `tail` is just the closing bracket, then it's considered failed.
1611:    """
1612:    tail_len = len(str(tail).strip())
1613:    if not body:
1614:        if tail_len == 0:
1615:            raise CannotSplit("Splitting brackets produced the same line")
1616:
1617:        elif tail_len < 3:
1618:            raise CannotSplit(
1619:                f"Splitting brackets on an empty body to save "
1620:                f"{tail_len} characters is not worth it"
1621:            )
1622:
1623:
1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
1625:    """Normalize prefix of the first leaf in every line returned by `split_func`.
1626:
1627:    This is a decorator over relevant split functions.
1628:    """
1629:
1630:    @wraps(split_func)
1631:    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:
1632:        for l in split_func(line, py36):
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1634:            yield l
1635:
1636:    return split_wrapper
1637:
1638:
1639:@dont_increase_indentation
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:
1641:    """Split according to delimiters of the highest priority.
1642:
1643:    If `py36` is True, the split will add trailing commas also in function
1644:    signatures that contain `*` and `**`.
1645:    """
1646:    try:
1647:        last_leaf = line.leaves[-1]
1648:    except IndexError:
1649:        raise CannotSplit("Line empty")
1650:
1651:    delimiters = line.bracket_tracker.delimiters
1652:    try:
1653:        delimiter_priority = line.bracket_tracker.max_delimiter_priority(
1654:            exclude={id(last_leaf)}
1655:        )
1656:    except ValueError:
1657:        raise CannotSplit("No delimiters found")
1658:
1659:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1660:    lowest_depth = sys.maxsize
1661:    trailing_comma_safe = True
1662:
1663:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1664:        """Append `leaf` to current line or to new line if appending impossible."""
1665:        nonlocal current_line
1666:        try:
1667:            current_line.append_safe(leaf, preformatted=True)
1668:        except ValueError as ve:
1669:            yield current_line
1670:
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1672:            current_line.append(leaf)
1673:
1674:    for leaf in line.leaves:
1675:        yield from append_to_line(leaf)
1676:
1677:        for comment_after in line.comments_after(leaf):
1678:            yield from append_to_line(comment_after)
1679:
1680:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
1681:        if (
1682:            leaf.bracket_depth == lowest_depth
1683:            and leaf.type == token.STAR
1684:            or leaf.type == token.DOUBLESTAR
1685:        ):
1686:            trailing_comma_safe = trailing_comma_safe and py36
1687:        leaf_priority = delimiters.get(id(leaf))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:
1768:def is_python36(node: Node) -> bool:
1769:    """Return True if the current file is using Python 3.6+ features.
1770:
1771:    Currently looking for:
1772:    - f-strings; and
1773:    - trailing commas after * or ** in function signatures.
1774:    """
1775:    for n in node.pre_order():
1776:        if n.type == token.STRING:
1777:            value_head = n.value[:2]  # type: ignore
1778:            if value_head in {'f"', 'F"', "f'", "F'", 'rf', 'fr', 'RF', 'FR'}:
1779:                return True
1780:
1781:        elif (
1782:            n.type == syms.typedargslist
1783:            and n.children
1784:            and n.children[-1].type == token.COMMA
1785:        ):
1786:            for ch in n.children:
1787:                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:
1788:                    return True
1789:
1790:    return False
1791:
1792:
1793:PYTHON_EXTENSIONS = {'.py'}
1794:BLACKLISTED_DIRECTORIES = {
1795:    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'
1796:}
1797:
1798:
1799:def gen_python_files_in_dir(path: Path) -> Iterator[Path]:
1800:    """Generate all files under `path` which aren't under BLACKLISTED_DIRECTORIES
1801:    and have one of the PYTHON_EXTENSIONS.
1802:    """
1803:    for child in path.iterdir():
1804:        if child.is_dir():
1805:            if child.name in BLACKLISTED_DIRECTORIES:
1806:                continue
1807:

Calling tool: grepTool
normalize_prefix\(
Matched content:
1003:                normalize_prefix(node, inside_brackets=any_open_brackets)
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Found dont_increase_indentation defined and applied as a decorator to both delimiter_split and standalone_comment_split. Neither function body contains direct normalize_prefix calls; normalization is performed in the decorator.


Todo item 10 of 20 is correct
description: 'Verify dont_increase_indentation decorator exists and is applied to delimiter_split and standalone_comment_split, and that these functions no longer call normalize_prefix on each yield explicitly (the decorator handles it).'
Validating todo item 11 of 20
description: 'Check that left_hand_split and right_hand_split now append all comments after each leaf by iterating for comment_after in line.comments_after(leaf) and appending each with preformatted=True (thus supporting multiple comments after a single leaf).'
Calling tool: grepTool
def left_hand_split\(|def right_hand_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:
1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1560:    """Split line into many lines, starting with the last matching bracket pair."""
1561:    head = Line(depth=line.depth)
1562:    body = Line(depth=line.depth + 1, inside_brackets=True)
1563:    tail = Line(depth=line.depth)
1564:    tail_leaves: List[Leaf] = []
1565:    body_leaves: List[Leaf] = []
1566:    head_leaves: List[Leaf] = []
1567:    current_leaves = tail_leaves
1568:    opening_bracket = None
1569:    for leaf in reversed(line.leaves):
1570:        if current_leaves is body_leaves:
1571:            if leaf is opening_bracket:
1572:                current_leaves = head_leaves if body_leaves else tail_leaves
1573:        current_leaves.append(leaf)
1574:        if current_leaves is tail_leaves:
1575:            if leaf.type in CLOSING_BRACKETS:
1576:                opening_bracket = leaf.opening_bracket
1577:                current_leaves = body_leaves
1578:    tail_leaves.reverse()
1579:    body_leaves.reverse()
1580:    head_leaves.reverse()
1581:    # Since body is a new indent level, remove spurious leading whitespace.
1582:    if body_leaves:
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1584:    # Build the new lines.
1585:    for result, leaves in (
1586:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1587:    ):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1588:        for leaf in leaves:
1589:            result.append(leaf, preformatted=True)
1590:            for comment_after in line.comments_after(leaf):
1591:                result.append(comment_after, preformatted=True)
1592:    bracket_split_succeeded_or_raise(head, body, tail)
1593:    for result in (head, body, tail):
1594:        if result:
1595:            yield result
1596:
1597:
1598:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
1599:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
1600:
1601:    Do nothing otherwise.
1602:
1603:    A left- or right-hand split is based on a pair of brackets. Content before
1604:    (and including) the opening bracket is left on one line, content inside the
1605:    brackets is put on a separate line, and finally content starting with and
1606:    following the closing bracket is put on a separate line.
1607:
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`
1610:    and the `tail` is just the closing bracket, then it's considered failed.
1611:    """
1612:    tail_len = len(str(tail).strip())
1613:    if not body:
1614:        if tail_len == 0:
1615:            raise CannotSplit("Splitting brackets produced the same line")
1616:
1617:        elif tail_len < 3:
1618:            raise CannotSplit(
1619:                f"Splitting brackets on an empty body to save "
1620:                f"{tail_len} characters is not worth it"
1621:            )
1622:
1623:
1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
1625:    """Normalize prefix of the first leaf in every line returned by `split_func`.
1626:
1627:    This is a decorator over relevant split functions.

Calling tool: grepTool
def comments_after\(
Matched content:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In both left_hand_split and right_hand_split, the code now iterates over comments via `for comment_after in line.comments_after(leaf):` and appends each with `preformatted=True`, enabling multiple comments after a single leaf. Verified actual lines in black.py.


Todo item 11 of 20 is correct
description: 'Check that left_hand_split and right_hand_split now append all comments after each leaf by iterating for comment_after in line.comments_after(leaf) and appending each with preformatted=True (thus supporting multiple comments after a single leaf).'
Validating todo item 12 of 20
description: 'Verify Line.comments_after(leaf) correctly finds the index of the provided leaf in self.leaves and yields all comments with matching indices from self.comments; ensure it returns nothing if the leaf isn't found.'
Calling tool: grepTool
def comments_after\(
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
def comments_after\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, Line.comments_after enumerates self.leaves to find the exact index of the provided leaf by identity; if not found, it returns without yielding. It then iterates self.comments (list of (index, comment)) and yields all comments whose stored index matches, satisfying the requirement.


Todo item 12 of 20 is correct
description: 'Verify Line.comments_after(leaf) correctly finds the index of the provided leaf in self.leaves and yields all comments with matching indices from self.comments; ensure it returns nothing if the leaf isn't found.'
Validating todo item 13 of 20
description: 'Validate Line.remove_trailing_comma updates indices of comments attached to the trailing comma (decrementing the index by 1) before popping the comma leaf, and confirm all callers of maybe_remove_trailing_comma now call remove_trailing_comma instead of popping directly.'
Calling tool: grepTool
class Line\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py

Calling tool: grepTool
remove_trailing_comma
Matched content:
563:            self.maybe_remove_trailing_comma(leaf)
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
672:            self.remove_trailing_comma()
678:                self.remove_trailing_comma()
706:            self.remove_trailing_comma()
769:    def remove_trailing_comma(self) -> None:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True
680:
681:        # For parens let's check if it's safe to remove the comma.  If the
682:        # trailing one is the only one, we might mistakenly change a tuple
683:        # into a different type by removing the comma.
684:        depth = closing.bracket_depth + 1
685:        commas = 0
686:        opening = closing.opening_bracket
687:        for _opening_index, leaf in enumerate(self.leaves):
688:            if leaf is opening:
689:                break
690:
691:        else:
692:            return False
693:
694:        for leaf in self.leaves[_opening_index + 1:]:
695:            if leaf is closing:
696:                break
697:
698:            bracket_depth = leaf.bracket_depth
699:            if bracket_depth == depth and leaf.type == token.COMMA:
700:                commas += 1
701:                if leaf.parent and leaf.parent.type == syms.arglist:
702:                    commas += 1
703:                    break
704:
705:        if commas > 1:
706:            self.remove_trailing_comma()
707:            return True
708:
709:        return False
710:
711:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
712:        """In a for loop, or comprehension, the variables are often unpacks.
713:
714:        To avoid splitting on the comma in this situation, increase the depth of
715:        tokens between `for` and `in`.
716:        """
717:        if leaf.type == token.NAME and leaf.value == 'for':
718:            self.has_for = True
719:            self.bracket_tracker.depth += 1
720:            self._for_loop_variable = True
721:            return True
722:
723:        return False
724:
725:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
726:        """See `maybe_increment_for_loop_variable` above for explanation."""
727:        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':
728:            self.bracket_tracker.depth -= 1
729:            self._for_loop_variable = False
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:
860:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
861:        """Return the number of extra empty lines before and after the `current_line`.
862:
863:        This is for separating `def`, `async def` and `class` with extra empty
864:        lines (two on module-level), as well as providing an extra empty line
865:        after flow control keywords to make them more prominent.
866:        """
867:        if isinstance(current_line, UnformattedLines):
868:            return 0, 0
869:
870:        before, after = self._maybe_empty_lines(current_line)
871:        before -= self.previous_after
872:        self.previous_after = after
873:        self.previous_line = current_line
874:        return before, after
875:
876:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
877:        max_allowed = 1
878:        if current_line.depth == 0:
879:            max_allowed = 2
880:        if current_line.leaves:
881:            # Consume the first leaf's extra newlines.
882:            first_leaf = current_line.leaves[0]
883:            before = first_leaf.prefix.count('\n')
884:            before = min(before, max_allowed)
885:            first_leaf.prefix = ''
886:        else:
887:            before = 0
888:        depth = current_line.depth
889:        while self.previous_defs and self.previous_defs[-1] >= depth:

Calling tool: grepTool
leaves\.pop\(
Matched content:
776:        self.leaves.pop()

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])

Calling tool: grepTool
trailing_comma
Matched content:
563:            self.maybe_remove_trailing_comma(leaf)
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
672:            self.remove_trailing_comma()
678:                self.remove_trailing_comma()
706:            self.remove_trailing_comma()
769:    def remove_trailing_comma(self) -> None:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1661:    trailing_comma_safe = True
1686:            trailing_comma_safe = trailing_comma_safe and py36
1696:            and trailing_comma_safe

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Line.remove_trailing_comma reassigns comments with index equal to the trailing comma to (index-1) before popping the comma. In maybe_remove_trailing_comma all branches now call remove_trailing_comma; grep confirms the only leaves.pop() remaining is inside remove_trailing_comma itself.


Todo item 13 of 20 is correct
description: 'Validate Line.remove_trailing_comma updates indices of comments attached to the trailing comma (decrementing the index by 1) before popping the comma leaf, and confirm all callers of maybe_remove_trailing_comma now call remove_trailing_comma instead of popping directly.'
Validating todo item 14 of 20
description: 'Confirm ALWAYS_NO_SPACE includes STANDALONE_COMMENT and that whitespace() returns DOUBLESPACE only for token.COMMENT and no space for STANDALONE_COMMENT (via ALWAYS_NO_SPACE).'
Calling tool: grepTool
ALWAYS_NO_SPACE|whitespace\(
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
ALWAYS_NO_SPACE|whitespace\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/blib2to3/pgen2/tokenize.py:204:    def add_whitespace(self, start):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/blib2to3/pgen2/tokenize.py:217:            self.add_whitespace(start)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/empty_lines.py:10:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/empty_lines.py:61:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/empty_lines.py:101:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/empty_lines.py:152:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/blib2to3/pgen2/tokenize.pyi:23:    def add_whitespace(self, start: _Coord) -> None: ...
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:559:            leaf.prefix += whitespace(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1109:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1112:def whitespace(leaf: Leaf) -> str:  # noqa C901
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1120:    if t in ALWAYS_NO_SPACE:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1080:                yield from self.visit(child)
1081:
1082:        else:
1083:            try:
1084:                self.current_line.append(node)
1085:            except FormatOn as f_on:
1086:                f_on.trim_prefix(node)
1087:                yield from self.line()
1088:                yield from self.visit(node)
1089:
1090:    def __attrs_post_init__(self) -> None:
1091:        """You are in a twisty little maze of passages."""
1092:        v = self.visit_stmt
1093:        self.visit_if_stmt = partial(v, keywords={'if', 'else', 'elif'})
1094:        self.visit_while_stmt = partial(v, keywords={'while', 'else'})
1095:        self.visit_for_stmt = partial(v, keywords={'for', 'else'})
1096:        self.visit_try_stmt = partial(v, keywords={'try', 'except', 'else', 'finally'})
1097:        self.visit_except_clause = partial(v, keywords={'except'})
1098:        self.visit_funcdef = partial(v, keywords={'def'})
1099:        self.visit_with_stmt = partial(v, keywords={'with'})
1100:        self.visit_classdef = partial(v, keywords={'class'})
1101:        self.visit_async_funcdef = self.visit_async_stmt
1102:        self.visit_decorated = self.visit_decorators
1103:
1104:
1105:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1106:OPENING_BRACKETS = set(BRACKET.keys())
1107:CLOSING_BRACKETS = set(BRACKET.values())
1108:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1109:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1110:
1111:
1112:def whitespace(leaf: Leaf) -> str:  # noqa C901
1113:    """Return whitespace prefix if needed for the given `leaf`."""
1114:    NO = ''
1115:    SPACE = ' '
1116:    DOUBLESPACE = '  '
1117:    t = leaf.type
1118:    p = leaf.parent
1119:    v = leaf.value
1120:    if t in ALWAYS_NO_SPACE:
1121:        return NO
1122:
1123:    if t == token.COMMENT:
1124:        return DOUBLESPACE
1125:
1126:    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"
1127:    if t == token.COLON and p.type not in {syms.subscript, syms.subscriptlist}:
1128:        return NO
1129:
1130:    prev = leaf.prev_sibling
1131:    if not prev:
1132:        prevp = preceding_leaf(p)
1133:        if not prevp or prevp.type in OPENING_BRACKETS:
1134:            return NO
1135:
1136:        if t == token.COLON:
1137:            return SPACE if prevp.type == token.COMMA else NO
1138:
1139:        if prevp.type == token.EQUAL:
1140:            if prevp.parent:
1141:                if prevp.parent.type in {
1142:                    syms.arglist, syms.argument, syms.parameters, syms.varargslist
1143:                }:
1144:                    return NO
1145:
1146:                elif prevp.parent.type == syms.typedargslist:
1147:                    # A bit hacky: if the equal sign has whitespace, it means we
1148:                    # previously found it's a typed argument.  So, we're using
1149:                    # that, too.
1150:                    return prevp.prefix
1151:
1152:        elif prevp.type == token.DOUBLESTAR:
1153:            if prevp.parent and prevp.parent.type in {
1154:                syms.arglist,
1155:                syms.argument,
1156:                syms.dictsetmaker,
1157:                syms.parameters,
1158:                syms.typedargslist,
1159:                syms.varargslist,

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:421:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:657:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:737:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:748:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1109:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1405:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1427:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1706:        if leaf.type == STANDALONE_COMMENT:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
400:        """Pretty-print the lib2to3 AST of a given string of `code`.
401:
402:        Convenience method for debugging.
403:        """
404:        v: DebugVisitor[None] = DebugVisitor()
405:        list(v.visit(lib2to3_parse(code)))
406:
407:
408:KEYWORDS = set(keyword.kwlist)
409:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
410:FLOW_CONTROL = {'return', 'raise', 'break', 'continue'}
411:STATEMENT = {
412:    syms.if_stmt,
413:    syms.while_stmt,
414:    syms.for_stmt,
415:    syms.try_stmt,
416:    syms.except_clause,
417:    syms.with_stmt,
418:    syms.funcdef,
419:    syms.classdef,
420:}
421:STANDALONE_COMMENT = 153
422:LOGIC_OPERATORS = {'and', 'or'}
423:COMPARATORS = {
424:    token.LESS,
425:    token.GREATER,
426:    token.EQEQUAL,
427:    token.NOTEQUAL,
428:    token.LESSEQUAL,
429:    token.GREATEREQUAL,
430:}
431:MATH_OPERATORS = {
432:    token.PLUS,
433:    token.MINUS,
434:    token.STAR,
435:    token.SLASH,
436:    token.VBAR,
437:    token.AMPER,
438:    token.PERCENT,
439:    token.CIRCUMFLEX,
440:    token.TILDE,
441:    token.LEFTSHIFT,
442:    token.RIGHTSHIFT,
443:    token.DOUBLESTAR,
444:    token.DOUBLESLASH,
445:}
446:COMPREHENSION_PRIORITY = 20
447:COMMA_PRIORITY = 10
448:LOGIC_PRIORITY = 5
449:STRING_PRIORITY = 4
450:COMPARATOR_PRIORITY = 3
451:MATH_PRIORITY = 1
452:
453:
454:@dataclass
455:class BracketTracker:
456:    """Keeps track of brackets on a line."""
457:
458:    depth: int = 0
459:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1388:def generate_comments(leaf: Leaf) -> Iterator[Leaf]:
1389:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1390:
1391:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1392:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1393:    move because it does away with modifying the grammar to include all the
1394:    possible places in which comments can be placed.
1395:
1396:    The sad consequence for us though is that comments don't "belong" anywhere.
1397:    This is why this function generates simple parentless Leaf objects for
1398:    comments.  We simply don't know what the correct parent should be.
1399:
1400:    No matter though, we can live without this.  We really only need to
1401:    differentiate between inline and standalone comments.  The latter don't
1402:    share the line with any code.
1403:
1404:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1405:    are emitted with a fake STANDALONE_COMMENT token identifier.
1406:    """
1407:    p = leaf.prefix
1408:    if not p:
1409:        return
1410:
1411:    if '#' not in p:
1412:        return
1413:
1414:    consumed = 0
1415:    nlines = 0
1416:    for index, line in enumerate(p.split('\n')):
1417:        consumed += len(line) + 1  # adding the length of the split '\n'
1418:        line = line.lstrip()
1419:        if not line:
1420:            nlines += 1
1421:        if not line.startswith('#'):
1422:            continue
1423:
1424:        if index == 0 and leaf.type != token.ENDMARKER:
1425:            comment_type = token.COMMENT  # simple trailing comment
1426:        else:
1427:            comment_type = STANDALONE_COMMENT
1428:        comment = make_comment(line)
1429:        yield Leaf(comment_type, comment, prefix='\n' * nlines)
1430:
1431:        if comment in {'# fmt: on', '# yapf: enable'}:
1432:            raise FormatOn(consumed)
1433:
1434:        if comment in {'# fmt: off', '# yapf: disable'}:
1435:            raise FormatOff(consumed)
1436:
1437:        nlines = 0
1438:
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py line 1109, ALWAYS_NO_SPACE includes STANDALONE_COMMENT. In whitespace() (lines 11121125), it first returns no space if the token is in ALWAYS_NO_SPACE, and only returns DOUBLESPACE when t == token.COMMENT, so STANDALONE_COMMENT gets no space while inline comments get two spaces.


Todo item 14 of 20 is correct
description: 'Confirm ALWAYS_NO_SPACE includes STANDALONE_COMMENT and that whitespace() returns DOUBLESPACE only for token.COMMENT and no space for STANDALONE_COMMENT (via ALWAYS_NO_SPACE).'
Validating todo item 15 of 20
description: 'In LineGenerator.visit_default, verify that when any_open_brackets is True, all generated comments (both inline and standalone) are appended to the current line without immediate line emission, making them subject to splitting; while comments outside brackets are emitted as trailing or standalone appropriately.'
Calling tool: grepTool
class LineGenerator|def visit_default\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/debug_visitor.py:5:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:367:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:378:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:931:class LineGenerator(Visitor[Line]):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:970:    def visit_default(self, node: LN) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
900:            if self.previous_line and self.previous_line.is_decorator:
901:                # Don't insert empty lines between decorators.
902:                return 0, 0
903:
904:            newlines = 2
905:            if current_line.depth:
906:                newlines -= 1
907:            return newlines, 0
908:
909:        if current_line.is_flow_control:
910:            return before, 1
911:
912:        if (
913:            self.previous_line
914:            and self.previous_line.is_import
915:            and not current_line.is_import
916:            and depth == self.previous_line.depth
917:        ):
918:            return (before or 1), 0
919:
920:        if (
921:            self.previous_line
922:            and self.previous_line.is_yield
923:            and (not current_line.is_yield or depth != self.previous_line.depth)
924:        ):
925:            return (before or 1), 0
926:
927:        return before, 0
928:
929:
930:@dataclass
931:class LineGenerator(Visitor[Line]):
932:    """Generates reformatted Line objects.  Empty lines are not emitted.
933:
934:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
935:    in ways that will no longer stringify to valid Python code on the tree.
936:    """
937:    current_line: Line = Factory(Line)
938:
939:    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:
940:        """Generate a line.
941:
942:        If the line is empty, only emit if it makes sense.
943:        If the line is too long, split it first and then generate.
944:
945:        If any lines were generated, set up a new current_line.
946:        """
947:        if not self.current_line:
948:            if self.current_line.__class__ == type:
949:                self.current_line.depth += indent
950:            else:
951:                self.current_line = type(depth=self.current_line.depth + indent)
952:            return  # Line is empty, don't emit. Creating a new one unnecessary.
953:
954:        complete_line = self.current_line
955:        self.current_line = type(depth=complete_line.depth + indent)
956:        yield complete_line
957:
958:    def visit(self, node: LN) -> Iterator[Line]:
959:        """Main method to visit `node` and its children.
960:
961:        Yields :class:`Line` objects.
962:        """
963:        if isinstance(self.current_line, UnformattedLines):
964:            # File contained `# fmt: off`
965:            yield from self.visit_unformatted(node)
966:
967:        else:
968:            yield from super().visit(node)
969:
970:    def visit_default(self, node: LN) -> Iterator[Line]:
971:        """Default `visit_*()` implementation. Recurses to children of `node`."""
972:        if isinstance(node, Leaf):
973:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
974:            try:
975:                for comment in generate_comments(node):
976:                    if any_open_brackets:
977:                        # any comment within brackets is subject to splitting
978:                        self.current_line.append(comment)
979:                    elif comment.type == token.COMMENT:
980:                        # regular trailing comment
981:                        self.current_line.append(comment)
982:                        yield from self.line()
983:
984:                    else:
985:                        # regular standalone comment
986:                        yield from self.line()
987:
988:                        self.current_line.append(comment)
989:                        yield from self.line()
990:
991:            except FormatOff as f_off:
992:                f_off.trim_prefix(node)
993:                yield from self.line(type=UnformattedLines)
994:                yield from self.visit(node)
995:
996:            except FormatOn as f_on:
997:                # This only happens here if somebody says "fmt: on" multiple
998:                # times in a row.
999:                f_on.trim_prefix(node)
1000:                yield from self.visit_default(node)
1001:
1002:            else:
1003:                normalize_prefix(node, inside_brackets=any_open_brackets)
1004:                if node.type not in WHITESPACE:
1005:                    self.current_line.append(node)
1006:        yield from super().visit_default(node)
1007:
1008:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1009:        """Increase indentation level, maybe yield a line."""
1010:        # In blib2to3 INDENT never holds comments.
1011:        yield from self.line(+1)
1012:        yield from self.visit_default(node)
1013:
1014:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1015:        """Decrease indentation level, maybe yield a line."""
1016:        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.
1017:        yield from self.line(-1)
1018:
1019:    def visit_stmt(self, node: Node, keywords: Set[str]) -> Iterator[Line]:
1020:        """Visit a statement.
1021:
1022:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1023:        `def`, `with`, and `class`.
1024:
1025:        The relevant Python language `keywords` for a given statement will be NAME
1026:        leaves within it. This methods puts those on a separate line.
1027:        """
1028:        for child in node.children:
1029:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1030:                yield from self.line()
1031:
1032:            yield from self.visit(child)
1033:
1034:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1035:        """Visit a statement without nested statements."""
1036:        is_suite_like = node.parent and node.parent.type in STATEMENT
1037:        if is_suite_like:
1038:            yield from self.line(+1)
1039:            yield from self.visit_default(node)

Calling tool: grepTool
def generate_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1388:def generate_comments(leaf: Leaf) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1360:            except IndexError:
1361:                return None
1362:
1363:        node = node.parent
1364:    return None
1365:
1366:
1367:def is_delimiter(leaf: Leaf) -> int:
1368:    """Return the priority of the `leaf` delimiter. Return 0 if not delimiter.
1369:
1370:    Higher numbers are higher priority.
1371:    """
1372:    if leaf.type == token.COMMA:
1373:        return COMMA_PRIORITY
1374:
1375:    if leaf.type in COMPARATORS:
1376:        return COMPARATOR_PRIORITY
1377:
1378:    if (
1379:        leaf.type in MATH_OPERATORS
1380:        and leaf.parent
1381:        and leaf.parent.type not in {syms.factor, syms.star_expr}
1382:    ):
1383:        return MATH_PRIORITY
1384:
1385:    return 0
1386:
1387:
1388:def generate_comments(leaf: Leaf) -> Iterator[Leaf]:
1389:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1390:
1391:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1392:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1393:    move because it does away with modifying the grammar to include all the
1394:    possible places in which comments can be placed.
1395:
1396:    The sad consequence for us though is that comments don't "belong" anywhere.
1397:    This is why this function generates simple parentless Leaf objects for
1398:    comments.  We simply don't know what the correct parent should be.
1399:
1400:    No matter though, we can live without this.  We really only need to
1401:    differentiate between inline and standalone comments.  The latter don't
1402:    share the line with any code.
1403:
1404:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1405:    are emitted with a fake STANDALONE_COMMENT token identifier.
1406:    """
1407:    p = leaf.prefix
1408:    if not p:
1409:        return
1410:
1411:    if '#' not in p:
1412:        return
1413:
1414:    consumed = 0
1415:    nlines = 0
1416:    for index, line in enumerate(p.split('\n')):
1417:        consumed += len(line) + 1  # adding the length of the split '\n'
1418:        line = line.lstrip()
1419:        if not line:
1420:            nlines += 1
1421:        if not line.startswith('#'):
1422:            continue
1423:
1424:        if index == 0 and leaf.type != token.ENDMARKER:
1425:            comment_type = token.COMMENT  # simple trailing comment
1426:        else:
1427:            comment_type = STANDALONE_COMMENT
1428:        comment = make_comment(line)
1429:        yield Leaf(comment_type, comment, prefix='\n' * nlines)
1430:
1431:        if comment in {'# fmt: on', '# yapf: enable'}:
1432:            raise FormatOn(consumed)
1433:
1434:        if comment in {'# fmt: off', '# yapf: disable'}:
1435:            raise FormatOff(consumed)
1436:
1437:        nlines = 0
1438:
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
340:    """Given a lib2to3 node, return its string representation."""
341:    code = str(node)
342:    return code
343:
344:
345:T = TypeVar('T')
346:
347:
348:class Visitor(Generic[T]):
349:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
350:
351:    def visit(self, node: LN) -> Iterator[T]:
352:        """Main method to visit `node` and its children.
353:
354:        It tries to find a `visit_*()` method for the given `node.type`, like
355:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
356:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
357:        instead.
358:
359:        Then yields objects of type `T` from the selected visitor.
360:        """
361:        if node.type < 256:
362:            name = token.tok_name[node.type]
363:        else:
364:            name = type_repr(node.type)
365:        yield from getattr(self, f'visit_{name}', self.visit_default)(node)
366:
367:    def visit_default(self, node: LN) -> Iterator[T]:
368:        """Default `visit_*()` implementation. Recurses to children of `node`."""
369:        if isinstance(node, Node):
370:            for child in node.children:
371:                yield from self.visit(child)
372:
373:
374:@dataclass
375:class DebugVisitor(Visitor[T]):
376:    tree_depth: int = 0
377:
378:    def visit_default(self, node: LN) -> Iterator[T]:
379:        indent = ' ' * (2 * self.tree_depth)
380:        if isinstance(node, Node):
381:            _type = type_repr(node.type)
382:            out(f'{indent}{_type}', fg='yellow')
383:            self.tree_depth += 1
384:            for child in node.children:
385:                yield from self.visit(child)
386:
387:            self.tree_depth -= 1
388:            out(f'{indent}/{_type}', fg='yellow', bold=False)
389:        else:
390:            _type = token.tok_name.get(node.type, str(node.type))
391:            out(f'{indent}{_type}', fg='blue', nl=False)
392:            if node.prefix:
393:                # We don't have to handle prefixes for `Node` objects since
394:                # that delegates to the first child anyway.
395:                out(f' {node.prefix!r}', fg='green', bold=False, nl=False)
396:            out(f' {node.value!r}', fg='blue', bold=False)
397:
398:    @classmethod
399:    def show(cls, code: str) -> None:

Calling tool: grepTool
class BracketTracker|def mark\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:455:class BracketTracker:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:463:    def mark(self, leaf: Leaf) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
440:    token.TILDE,
441:    token.LEFTSHIFT,
442:    token.RIGHTSHIFT,
443:    token.DOUBLESTAR,
444:    token.DOUBLESLASH,
445:}
446:COMPREHENSION_PRIORITY = 20
447:COMMA_PRIORITY = 10
448:LOGIC_PRIORITY = 5
449:STRING_PRIORITY = 4
450:COMPARATOR_PRIORITY = 3
451:MATH_PRIORITY = 1
452:
453:
454:@dataclass
455:class BracketTracker:
456:    """Keeps track of brackets on a line."""
457:
458:    depth: int = 0
459:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
460:    delimiters: Dict[LeafID, Priority] = Factory(dict)
461:    previous: Optional[Leaf] = None
462:
463:    def mark(self, leaf: Leaf) -> None:
464:        """Mark `leaf` with bracket-related metadata. Keep track of delimiters.
465:
466:        All leaves receive an int `bracket_depth` field that stores how deep
467:        within brackets a given leaf is. 0 means there are no enclosing brackets
468:        that started on this line.
469:
470:        If a leaf is itself a closing bracket, it receives an `opening_bracket`
471:        field that it forms a pair with. This is a one-directional link to
472:        avoid reference cycles.
473:
474:        If a leaf is a delimiter (a token on which Black can split the line if
475:        needed) and it's on depth 0, its `id()` is stored in the tracker's
476:        `delimiters` field.
477:        """
478:        if leaf.type == token.COMMENT:
479:            return
480:
481:        if leaf.type in CLOSING_BRACKETS:
482:            self.depth -= 1
483:            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))
484:            leaf.opening_bracket = opening_bracket
485:        leaf.bracket_depth = self.depth
486:        if self.depth == 0:
487:            delim = is_delimiter(leaf)
488:            if delim:
489:                self.delimiters[id(leaf)] = delim
490:            elif self.previous is not None:
491:                if leaf.type == token.STRING and self.previous.type == token.STRING:
492:                    self.delimiters[id(self.previous)] = STRING_PRIORITY
493:                elif (
494:                    leaf.type == token.NAME
495:                    and leaf.value == 'for'
496:                    and leaf.parent
497:                    and leaf.parent.type in {syms.comp_for, syms.old_comp_for}
498:                ):
499:                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY
500:                elif (
501:                    leaf.type == token.NAME
502:                    and leaf.value == 'if'
503:                    and leaf.parent
504:                    and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
505:                ):
506:                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY
507:                elif (
508:                    leaf.type == token.NAME
509:                    and leaf.value in LOGIC_OPERATORS
510:                    and leaf.parent
511:                ):
512:                    self.delimiters[id(self.previous)] = LOGIC_PRIORITY
513:        if leaf.type in OPENING_BRACKETS:
514:            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf
515:            self.depth += 1
516:        self.previous = leaf
517:
518:    def any_open_brackets(self) -> bool:
519:        """Return True if there is an yet unmatched open bracket on the line."""
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:
610:    @property
611:    def is_def(self) -> bool:
612:        """Is this a function definition? (Also returns True for async defs.)"""
613:        try:
614:            first_leaf = self.leaves[0]
615:        except IndexError:
616:            return False
617:
618:        try:
619:            second_leaf: Optional[Leaf] = self.leaves[1]
620:        except IndexError:
621:            second_leaf = None
622:        return (
623:            (first_leaf.type == token.NAME and first_leaf.value == 'def')
624:            or (
625:                first_leaf.type == token.ASYNC
626:                and second_leaf is not None
627:                and second_leaf.type == token.NAME
628:                and second_leaf.value == 'def'
629:            )
630:        )
631:
632:    @property
633:    def is_flow_control(self) -> bool:
634:        """Is this line a flow control statement?
635:
636:        Those are `return`, `raise`, `break`, and `continue`.
637:        """
638:        return (
639:            bool(self)
640:            and self.leaves[0].type == token.NAME
641:            and self.leaves[0].value in FLOW_CONTROL
642:        )
643:
644:    @property
645:    def is_yield(self) -> bool:
646:        """Is this line a yield statement?"""
647:        return (
648:            bool(self)
649:            and self.leaves[0].type == token.NAME
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True
680:
681:        # For parens let's check if it's safe to remove the comma.  If the
682:        # trailing one is the only one, we might mistakenly change a tuple
683:        # into a different type by removing the comma.
684:        depth = closing.bracket_depth + 1
685:        commas = 0
686:        opening = closing.opening_bracket
687:        for _opening_index, leaf in enumerate(self.leaves):
688:            if leaf is opening:
689:                break
690:
691:        else:
692:            return False
693:
694:        for leaf in self.leaves[_opening_index + 1:]:
695:            if leaf is closing:
696:                break
697:
698:            bracket_depth = leaf.bracket_depth
699:            if bracket_depth == depth and leaf.type == token.COMMA:
700:                commas += 1
701:                if leaf.parent and leaf.parent.type == syms.arglist:
702:                    commas += 1
703:                    break
704:
705:        if commas > 1:
706:            self.remove_trailing_comma()
707:            return True
708:
709:        return False
710:
711:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
712:        """In a for loop, or comprehension, the variables are often unpacks.
713:
714:        To avoid splitting on the comma in this situation, increase the depth of
715:        tokens between `for` and `in`.

Calling tool: grepTool
inside_brackets
Matched content:
538:    inside_brackets: bool = False
560:        if self.inside_brackets or not preformatted:
1003:                normalize_prefix(node, inside_brackets=any_open_brackets)
1488:    elif line.inside_brackets:
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1562:    body = Line(depth=line.depth + 1, inside_brackets=True)
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1659:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1756:    if not inside_brackets:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:
1768:def is_python36(node: Node) -> bool:
1769:    """Return True if the current file is using Python 3.6+ features.
1770:
1771:    Currently looking for:
1772:    - f-strings; and
1773:    - trailing commas after * or ** in function signatures.
1774:    """
1775:    for n in node.pre_order():
1776:        if n.type == token.STRING:
1777:            value_head = n.value[:2]  # type: ignore
1778:            if value_head in {'f"', 'F"', "f'", "F'", 'rf', 'fr', 'RF', 'FR'}:
1779:                return True
1780:
1781:        elif (
1782:            n.type == syms.typedargslist
1783:            and n.children
1784:            and n.children[-1].type == token.COMMA
1785:        ):
1786:            for ch in n.children:
1787:                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:
1788:                    return True
1789:
1790:    return False
1791:
1792:
1793:PYTHON_EXTENSIONS = {'.py'}
1794:BLACKLISTED_DIRECTORIES = {
1795:    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'
1796:}
1797:
1798:
1799:def gen_python_files_in_dir(path: Path) -> Iterator[Path]:
1800:    """Generate all files under `path` which aren't under BLACKLISTED_DIRECTORIES
1801:    and have one of the PYTHON_EXTENSIONS.
1802:    """
1803:    for child in path.iterdir():
1804:        if child.is_dir():
1805:            if child.name in BLACKLISTED_DIRECTORIES:
1806:                continue
1807:
1808:            yield from gen_python_files_in_dir(child)
1809:
1810:        elif child.suffix in PYTHON_EXTENSIONS:
1811:            yield child
1812:
1813:
1814:@dataclass
1815:class Report:
1816:    """Provides a reformatting counter. Can be rendered with `str(report)`."""
1817:    check: bool = False
1818:    change_count: int = 0
1819:    same_count: int = 0
1820:    failure_count: int = 0
1821:
1822:    def done(self, src: Path, changed: bool) -> None:
1823:        """Increment the counter for successful reformatting. Write out a message."""
1824:        if changed:
1825:            reformatted = 'would reformat' if self.check else 'reformatted'
1826:            out(f'{reformatted} {src}')
1827:            self.change_count += 1

Calling tool: grepTool
split_line\(
Matched content:
298:        for line in split_line(current_line, line_length=line_length, py36=py36):
1459:def split_line(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
260:) -> FileContent:
261:    """Reformat contents a file and return new contents.
262:
263:    If `fast` is False, additionally confirm that the reformatted code is
264:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
265:    `line_length` is passed to :func:`format_str`.
266:    """
267:    if src_contents.strip() == '':
268:        raise NothingChanged
269:
270:    dst_contents = format_str(src_contents, line_length=line_length)
271:    if src_contents == dst_contents:
272:        raise NothingChanged
273:
274:    if not fast:
275:        assert_equivalent(src_contents, dst_contents)
276:        assert_stable(src_contents, dst_contents, line_length=line_length)
277:    return dst_contents
278:
279:
280:def format_str(src_contents: str, line_length: int) -> FileContent:
281:    """Reformat a string and return new contents.
282:
283:    `line_length` determines how many characters per line are allowed.
284:    """
285:    src_node = lib2to3_parse(src_contents)
286:    dst_contents = ""
287:    lines = LineGenerator()
288:    elt = EmptyLineTracker()
289:    py36 = is_python36(src_node)
290:    empty_line = Line()
291:    after = 0
292:    for current_line in lines.visit(src_node):
293:        for _ in range(after):
294:            dst_contents += str(empty_line)
295:        before, after = elt.maybe_empty_lines(current_line)
296:        for _ in range(before):
297:            dst_contents += str(empty_line)
298:        for line in split_line(current_line, line_length=line_length, py36=py36):
299:            dst_contents += str(line)
300:    return dst_contents
301:
302:
303:GRAMMARS = [
304:    pygram.python_grammar_no_print_statement_no_exec_statement,
305:    pygram.python_grammar_no_print_statement,
306:    pygram.python_grammar_no_exec_statement,
307:    pygram.python_grammar,
308:]
309:
310:
311:def lib2to3_parse(src_txt: str) -> Node:
312:    """Given a string with source, return the lib2to3 Node."""
313:    grammar = pygram.python_grammar_no_print_statement
314:    if src_txt[-1] != '\n':
315:        nl = '\r\n' if '\r\n' in src_txt[:1024] else '\n'
316:        src_txt += nl
317:    for grammar in GRAMMARS:
318:        drv = driver.Driver(grammar, pytree.convert)
319:        try:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In LineGenerator.visit_default (black.py:970-1006), when any_open_brackets is True, all comments from generate_comments are appended to current_line without emitting lines (lines 975-979). Outside brackets, inline (token.COMMENT) comments are appended then emitted (lines 979-983), while standalone comments flush the current line, are appended, and then emitted (lines 984-989). This matches the requirement that in-bracket comments are subject to splitting and outside-bracket comments are emitted appropriately.


Todo item 15 of 20 is correct
description: 'In LineGenerator.visit_default, verify that when any_open_brackets is True, all generated comments (both inline and standalone) are appended to the current line without immediate line emission, making them subject to splitting; while comments outside brackets are emitted as trailing or standalone appropriately.'
Validating todo item 16 of 20
description: 'Ensure standalone_comment_split exists and splits lines around standalone comments by attempting to append leaves/comments via append_safe and starting new lines when ValueError is raised; verify it yields the final current_line if non-empty.'
Calling tool: grepTool
def standalone_comment_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: standalone_comment_split exists and implements the described behavior: it attempts to append both leaves and comments via append_safe (lines 17191730), on ValueError it yields the current line and starts a new one (lines 17211724), and it yields the final current_line if present (lines 17321733).


Todo item 16 of 20 is correct
description: 'Ensure standalone_comment_split exists and splits lines around standalone comments by attempting to append leaves/comments via append_safe and starting new lines when ValueError is raised; verify it yields the final current_line if non-empty.'
Validating todo item 17 of 20
description: 'Critically check standalone_comment_split's precondition: it should only raise CannotSplit when there are no STANDALONE_COMMENT leaves on the line. Verify whether the current implementation's bracket_depth check incorrectly restricts triggering to comments with bracket_depth == 0 and adjust expectations accordingly.'
Calling tool: grepTool
def standalone_comment_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1670:
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1672:            current_line.append(leaf)
1673:
1674:    for leaf in line.leaves:
1675:        yield from append_to_line(leaf)
1676:
1677:        for comment_after in line.comments_after(leaf):
1678:            yield from append_to_line(comment_after)
1679:
1680:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
1681:        if (
1682:            leaf.bracket_depth == lowest_depth
1683:            and leaf.type == token.STAR
1684:            or leaf.type == token.DOUBLESTAR
1685:        ):
1686:            trailing_comma_safe = trailing_comma_safe and py36
1687:        leaf_priority = delimiters.get(id(leaf))
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:
1768:def is_python36(node: Node) -> bool:
1769:    """Return True if the current file is using Python 3.6+ features.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: standalone_comment_split checks for a STANDALONE_COMMENT with bracket_depth == 0 before allowing splitting (black.py:1705-1711). This causes CannotSplit to be raised even when STANDALONE_COMMENT leaves exist inside brackets, violating the requirement that it should only raise when there are no STANDALONE_COMMENT leaves at all.


Validating todo item 1 of 20
description: 'Verify that Line.comments changed from Dict[LeafID, Leaf] to List[Tuple[Index, Leaf]] and that all references to comments were updated accordingly (e.g., __str__, comments_after, remove_trailing_comma, left_hand_split, right_hand_split, delimiter_split, standalone_comment_split).'

Calling tool: grepTool
class Line\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: globTool
**/*black*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/__pycache__/black.cpython-38.pyc
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/test_black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/__pycache__/test_black.cpython-38.pyc
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/vim/plugin/black.vim

Calling tool: grepTool
class Line\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
class Line:
Matched content:
531:class Line:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:
610:    @property
611:    def is_def(self) -> bool:
612:        """Is this a function definition? (Also returns True for async defs.)"""
613:        try:
614:            first_leaf = self.leaves[0]
615:        except IndexError:
616:            return False
617:
618:        try:
619:            second_leaf: Optional[Leaf] = self.leaves[1]
620:        except IndexError:
621:            second_leaf = None
622:        return (
623:            (first_leaf.type == token.NAME and first_leaf.value == 'def')
624:            or (
625:                first_leaf.type == token.ASYNC
626:                and second_leaf is not None
627:                and second_leaf.type == token.NAME
628:                and second_leaf.value == 'def'
629:            )
630:        )
631:
632:    @property
633:    def is_flow_control(self) -> bool:
634:        """Is this line a flow control statement?
635:
636:        Those are `return`, `raise`, `break`, and `continue`.
637:        """
638:        return (
639:            bool(self)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
640:            and self.leaves[0].type == token.NAME
641:            and self.leaves[0].value in FLOW_CONTROL
642:        )
643:
644:    @property
645:    def is_yield(self) -> bool:
646:        """Is this line a yield statement?"""
647:        return (
648:            bool(self)
649:            and self.leaves[0].type == token.NAME
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True
680:
681:        # For parens let's check if it's safe to remove the comma.  If the
682:        # trailing one is the only one, we might mistakenly change a tuple
683:        # into a different type by removing the comma.
684:        depth = closing.bracket_depth + 1
685:        commas = 0
686:        opening = closing.opening_bracket
687:        for _opening_index, leaf in enumerate(self.leaves):
688:            if leaf is opening:
689:                break
690:
691:        else:
692:            return False
693:
694:        for leaf in self.leaves[_opening_index + 1:]:
695:            if leaf is closing:
696:                break
697:
698:            bracket_depth = leaf.bracket_depth
699:            if bracket_depth == depth and leaf.type == token.COMMA:
700:                commas += 1
701:                if leaf.parent and leaf.parent.type == syms.arglist:
702:                    commas += 1
703:                    break
704:
705:        if commas > 1:
706:            self.remove_trailing_comma()
707:            return True
708:
709:        return False
710:
711:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
712:        """In a for loop, or comprehension, the variables are often unpacks.
713:
714:        To avoid splitting on the comma in this situation, increase the depth of
715:        tokens between `for` and `in`.
716:        """
717:        if leaf.type == token.NAME and leaf.value == 'for':
718:            self.has_for = True
719:            self.bracket_tracker.depth += 1
720:            self._for_loop_variable = True
721:            return True
722:
723:        return False
724:
725:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
726:        """See `maybe_increment_for_loop_variable` above for explanation."""
727:        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':
728:            self.bracket_tracker.depth -= 1
729:            self._for_loop_variable = False
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:
860:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
861:        """Return the number of extra empty lines before and after the `current_line`.
862:
863:        This is for separating `def`, `async def` and `class` with extra empty
864:        lines (two on module-level), as well as providing an extra empty line
865:        after flow control keywords to make them more prominent.
866:        """
867:        if isinstance(current_line, UnformattedLines):
868:            return 0, 0
869:
870:        before, after = self._maybe_empty_lines(current_line)
871:        before -= self.previous_after
872:        self.previous_after = after
873:        self.previous_line = current_line
874:        return before, after
875:
876:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
877:        max_allowed = 1
878:        if current_line.depth == 0:
879:            max_allowed = 2

Calling tool: grepTool
def left_hand_split\(
Matched content:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:
1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1560:    """Split line into many lines, starting with the last matching bracket pair."""
1561:    head = Line(depth=line.depth)
1562:    body = Line(depth=line.depth + 1, inside_brackets=True)
1563:    tail = Line(depth=line.depth)
1564:    tail_leaves: List[Leaf] = []
1565:    body_leaves: List[Leaf] = []
1566:    head_leaves: List[Leaf] = []
1567:    current_leaves = tail_leaves
1568:    opening_bracket = None
1569:    for leaf in reversed(line.leaves):
1570:        if current_leaves is body_leaves:
1571:            if leaf is opening_bracket:
1572:                current_leaves = head_leaves if body_leaves else tail_leaves
1573:        current_leaves.append(leaf)
1574:        if current_leaves is tail_leaves:
1575:            if leaf.type in CLOSING_BRACKETS:
1576:                opening_bracket = leaf.opening_bracket
1577:                current_leaves = body_leaves
1578:    tail_leaves.reverse()
1579:    body_leaves.reverse()
1580:    head_leaves.reverse()
1581:    # Since body is a new indent level, remove spurious leading whitespace.
1582:    if body_leaves:
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1584:    # Build the new lines.
1585:    for result, leaves in (
1586:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1587:    ):
1588:        for leaf in leaves:
1589:            result.append(leaf, preformatted=True)
1590:            for comment_after in line.comments_after(leaf):
1591:                result.append(comment_after, preformatted=True)
1592:    bracket_split_succeeded_or_raise(head, body, tail)
1593:    for result in (head, body, tail):
1594:        if result:
1595:            yield result
1596:
1597:
1598:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
1599:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
1600:
1601:    Do nothing otherwise.
1602:
1603:    A left- or right-hand split is based on a pair of brackets. Content before
1604:    (and including) the opening bracket is left on one line, content inside the
1605:    brackets is put on a separate line, and finally content starting with and
1606:    following the closing bracket is put on a separate line.
1607:
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`

Calling tool: grepTool
def delimiter_split\(
Matched content:
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`
1610:    and the `tail` is just the closing bracket, then it's considered failed.
1611:    """
1612:    tail_len = len(str(tail).strip())
1613:    if not body:
1614:        if tail_len == 0:
1615:            raise CannotSplit("Splitting brackets produced the same line")
1616:
1617:        elif tail_len < 3:
1618:            raise CannotSplit(
1619:                f"Splitting brackets on an empty body to save "
1620:                f"{tail_len} characters is not worth it"
1621:            )
1622:
1623:
1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
1625:    """Normalize prefix of the first leaf in every line returned by `split_func`.
1626:
1627:    This is a decorator over relevant split functions.
1628:    """
1629:
1630:    @wraps(split_func)
1631:    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:
1632:        for l in split_func(line, py36):
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1634:            yield l
1635:
1636:    return split_wrapper
1637:
1638:
1639:@dont_increase_indentation
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:
1641:    """Split according to delimiters of the highest priority.
1642:
1643:    If `py36` is True, the split will add trailing commas also in function
1644:    signatures that contain `*` and `**`.
1645:    """
1646:    try:
1647:        last_leaf = line.leaves[-1]
1648:    except IndexError:
1649:        raise CannotSplit("Line empty")
1650:
1651:    delimiters = line.bracket_tracker.delimiters
1652:    try:
1653:        delimiter_priority = line.bracket_tracker.max_delimiter_priority(
1654:            exclude={id(last_leaf)}
1655:        )
1656:    except ValueError:
1657:        raise CannotSplit("No delimiters found")
1658:
1659:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1660:    lowest_depth = sys.maxsize
1661:    trailing_comma_safe = True
1662:
1663:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1664:        """Append `leaf` to current line or to new line if appending impossible."""
1665:        nonlocal current_line
1666:        try:
1667:            current_line.append_safe(leaf, preformatted=True)
1668:        except ValueError as ve:
1669:            yield current_line
1670:
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1672:            current_line.append(leaf)
1673:
1674:    for leaf in line.leaves:
1675:        yield from append_to_line(leaf)
1676:
1677:        for comment_after in line.comments_after(leaf):
1678:            yield from append_to_line(comment_after)
1679:
1680:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
1681:        if (
1682:            leaf.bracket_depth == lowest_depth
1683:            and leaf.type == token.STAR
1684:            or leaf.type == token.DOUBLESTAR
1685:        ):
1686:            trailing_comma_safe = trailing_comma_safe and py36
1687:        leaf_priority = delimiters.get(id(leaf))
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:

Calling tool: grepTool
def split_line\(
Matched content:
1459:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:
1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: grepTool
test_comments3
Matched content:
154:    def test_comments3(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/test_black.py
120:
121:    @patch("black.dump_to_file", dump_to_stderr)
122:    def test_expression(self) -> None:
123:        source, expected = read_data('expression')
124:        actual = fs(source)
125:        self.assertFormatEqual(expected, actual)
126:        black.assert_equivalent(source, actual)
127:        black.assert_stable(source, actual, line_length=ll)
128:
129:    @patch("black.dump_to_file", dump_to_stderr)
130:    def test_fstring(self) -> None:
131:        source, expected = read_data('fstring')
132:        actual = fs(source)
133:        self.assertFormatEqual(expected, actual)
134:        black.assert_equivalent(source, actual)
135:        black.assert_stable(source, actual, line_length=ll)
136:
137:    @patch("black.dump_to_file", dump_to_stderr)
138:    def test_comments(self) -> None:
139:        source, expected = read_data('comments')
140:        actual = fs(source)
141:        self.assertFormatEqual(expected, actual)
142:        black.assert_equivalent(source, actual)
143:        black.assert_stable(source, actual, line_length=ll)
144:
145:    @patch("black.dump_to_file", dump_to_stderr)
146:    def test_comments2(self) -> None:
147:        source, expected = read_data('comments2')
148:        actual = fs(source)
149:        self.assertFormatEqual(expected, actual)
150:        black.assert_equivalent(source, actual)
151:        black.assert_stable(source, actual, line_length=ll)
152:
153:    @patch("black.dump_to_file", dump_to_stderr)
154:    def test_comments3(self) -> None:
155:        source, expected = read_data('comments3')
156:        actual = fs(source)
157:        self.assertFormatEqual(expected, actual)
158:        black.assert_equivalent(source, actual)
159:        black.assert_stable(source, actual, line_length=ll)
160:
161:    @patch("black.dump_to_file", dump_to_stderr)
162:    def test_cantfit(self) -> None:
163:        source, expected = read_data('cantfit')
164:        actual = fs(source)
165:        self.assertFormatEqual(expected, actual)
166:        black.assert_equivalent(source, actual)
167:        black.assert_stable(source, actual, line_length=ll)
168:
169:    @patch("black.dump_to_file", dump_to_stderr)
170:    def test_import_spacing(self) -> None:
171:        source, expected = read_data('import_spacing')
172:        actual = fs(source)
173:        self.assertFormatEqual(expected, actual)
174:        black.assert_equivalent(source, actual)
175:        black.assert_stable(source, actual, line_length=ll)
176:
177:    @patch("black.dump_to_file", dump_to_stderr)
178:    def test_composition(self) -> None:
179:        source, expected = read_data('composition')
180:        actual = fs(source)
181:        self.assertFormatEqual(expected, actual)
182:        black.assert_equivalent(source, actual)
183:        black.assert_stable(source, actual, line_length=ll)
184:
185:    @patch("black.dump_to_file", dump_to_stderr)
186:    def test_empty_lines(self) -> None:
187:        source, expected = read_data('empty_lines')
188:        actual = fs(source)
189:        self.assertFormatEqual(expected, actual)
190:        black.assert_equivalent(source, actual)
191:        black.assert_stable(source, actual, line_length=ll)
192:
193:    @patch("black.dump_to_file", dump_to_stderr)
194:    def test_python2(self) -> None:
195:        source, expected = read_data('python2')
196:        actual = fs(source)
197:        self.assertFormatEqual(expected, actual)
198:        # black.assert_equivalent(source, actual)
199:        black.assert_stable(source, actual, line_length=ll)
200:
201:    @patch("black.dump_to_file", dump_to_stderr)
202:    def test_fmtonoff(self) -> None:
203:        source, expected = read_data('fmtonoff')
204:        actual = fs(source)
205:        self.assertFormatEqual(expected, actual)
206:        black.assert_equivalent(source, actual)
207:        black.assert_stable(source, actual, line_length=ll)
208:
209:    def test_report(self) -> None:
210:        report = black.Report()
211:        out_lines = []
212:        err_lines = []
213:
214:        def out(msg: str, **kwargs: Any) -> None:
215:            out_lines.append(msg)
216:
217:        def err(msg: str, **kwargs: Any) -> None:
218:            err_lines.append(msg)
219:
220:        with patch("black.out", out), patch("black.err", err):
221:            report.done(Path('f1'), changed=False)
222:            self.assertEqual(len(out_lines), 1)
223:            self.assertEqual(len(err_lines), 0)
224:            self.assertEqual(out_lines[-1], 'f1 already well formatted, good job.')
225:            self.assertEqual(unstyle(str(report)), '1 file left unchanged.')
226:            self.assertEqual(report.return_code, 0)
227:            report.done(Path('f2'), changed=True)
228:            self.assertEqual(len(out_lines), 2)
229:            self.assertEqual(len(err_lines), 0)
230:            self.assertEqual(out_lines[-1], 'reformatted f2')
231:            self.assertEqual(
232:                unstyle(str(report)), '1 file reformatted, 1 file left unchanged.'
233:            )
234:            self.assertEqual(report.return_code, 0)
235:            report.check = True
236:            self.assertEqual(report.return_code, 1)
237:            report.check = False
238:            report.failed(Path('e1'), 'boom')
239:            self.assertEqual(len(out_lines), 2)

Calling tool: grepTool
last_non_delimiter
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
Index = int
Matched content:
46:Index = int

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1:#!/usr/bin/env python3
2:
3:import asyncio
4:from asyncio.base_events import BaseEventLoop
5:from concurrent.futures import Executor, ProcessPoolExecutor
6:from functools import partial, wraps
7:import keyword
8:import os
9:from pathlib import Path
10:import tokenize
11:import sys
12:from typing import (
13:    Callable,
14:    Dict,
15:    Generic,
16:    Iterable,
17:    Iterator,
18:    List,
19:    Optional,
20:    Set,
21:    Tuple,
22:    Type,
23:    TypeVar,
24:    Union,
25:)
26:
27:from attr import dataclass, Factory
28:import click
29:
30:# lib2to3 fork
31:from blib2to3.pytree import Node, Leaf, type_repr
32:from blib2to3 import pygram, pytree
33:from blib2to3.pgen2 import driver, token
34:from blib2to3.pgen2.parse import ParseError
35:
36:__version__ = "18.3a4"
37:DEFAULT_LINE_LENGTH = 88
38:# types
39:syms = pygram.python_symbols
40:FileContent = str
41:Encoding = str
42:Depth = int
43:NodeType = int
44:LeafID = int
45:Priority = int
46:Index = int
47:LN = Union[Leaf, Node]
48:SplitFunc = Callable[['Line', bool], Iterator['Line']]
49:out = partial(click.secho, bold=True, err=True)
50:err = partial(click.secho, fg='red', err=True)
51:
52:
53:class NothingChanged(UserWarning):
54:    """Raised by :func:`format_file` when reformatted code is the same as source."""
55:
56:
57:class CannotSplit(Exception):
58:    """A readable split that fits the allotted line length is impossible.
59:
60:    Raised by :func:`left_hand_split`, :func:`right_hand_split`, and
61:    :func:`delimiter_split`.
62:    """
63:
64:
65:class FormatError(Exception):
66:    """Base exception for `# fmt: on` and `# fmt: off` handling.
67:
68:    It holds the number of bytes of the prefix consumed before the format
69:    control comment appeared.
70:    """
71:
72:    def __init__(self, consumed: int) -> None:
73:        super().__init__(consumed)
74:        self.consumed = consumed
75:
76:    def trim_prefix(self, leaf: Leaf) -> None:
77:        leaf.prefix = leaf.prefix[self.consumed:]
78:
79:    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:
80:        """Returns a new Leaf from the consumed part of the prefix."""

Calling tool: grepTool
comments\.
Matched content:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
753:            self.comments.append((after, comment))
794:        """Return True if the line has leaves or comments."""
1010:        # In blib2to3 INDENT never holds comments.
1016:        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.
1398:    comments.  We simply don't know what the correct parent should be.
1401:    differentiate between inline and standalone comments.  The latter don't

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1368:    """Return the priority of the `leaf` delimiter. Return 0 if not delimiter.
1369:
1370:    Higher numbers are higher priority.
1371:    """
1372:    if leaf.type == token.COMMA:
1373:        return COMMA_PRIORITY
1374:
1375:    if leaf.type in COMPARATORS:
1376:        return COMPARATOR_PRIORITY
1377:
1378:    if (
1379:        leaf.type in MATH_OPERATORS
1380:        and leaf.parent
1381:        and leaf.parent.type not in {syms.factor, syms.star_expr}
1382:    ):
1383:        return MATH_PRIORITY
1384:
1385:    return 0
1386:
1387:
1388:def generate_comments(leaf: Leaf) -> Iterator[Leaf]:
1389:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1390:
1391:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1392:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1393:    move because it does away with modifying the grammar to include all the
1394:    possible places in which comments can be placed.
1395:
1396:    The sad consequence for us though is that comments don't "belong" anywhere.
1397:    This is why this function generates simple parentless Leaf objects for
1398:    comments.  We simply don't know what the correct parent should be.
1399:
1400:    No matter though, we can live without this.  We really only need to
1401:    differentiate between inline and standalone comments.  The latter don't
1402:    share the line with any code.
1403:
1404:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1405:    are emitted with a fake STANDALONE_COMMENT token identifier.
1406:    """
1407:    p = leaf.prefix
1408:    if not p:
1409:        return
1410:
1411:    if '#' not in p:
1412:        return
1413:
1414:    consumed = 0
1415:    nlines = 0
1416:    for index, line in enumerate(p.split('\n')):
1417:        consumed += len(line) + 1  # adding the length of the split '\n'
1418:        line = line.lstrip()
1419:        if not line:
1420:            nlines += 1
1421:        if not line.startswith('#'):
1422:            continue
1423:
1424:        if index == 0 and leaf.type != token.ENDMARKER:
1425:            comment_type = token.COMMENT  # simple trailing comment
1426:        else:
1427:            comment_type = STANDALONE_COMMENT
1428:        comment = make_comment(line)
1429:        yield Leaf(comment_type, comment, prefix='\n' * nlines)
1430:
1431:        if comment in {'# fmt: on', '# yapf: enable'}:
1432:            raise FormatOn(consumed)
1433:
1434:        if comment in {'# fmt: off', '# yapf: disable'}:
1435:            raise FormatOff(consumed)
1436:
1437:        nlines = 0
1438:
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]

Calling tool: grepTool
comments\.values\(|comments\[|comments\.get\(
Matched content:
773:            comment_index, comment = self.comments[i]
775:                self.comments[i] = (comma_index - 1, comment)

Calling tool: grepTool
maybe_adapt_standalone_comment
No files found. Call grepTool again with a more generic pattern.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Line.comments is now List[Tuple[Index, Leaf]]. All usages were updated: __str__ iterates tuples, comments_after generates by matching indices, remove_trailing_comma shifts comment indices, and split functions (left/right/delimiter/standalone_comment_split) use comments_after instead of dict lookups. No stale dict-style accesses remain.

Todo item 1 of 20 is correct
description: 'Verify that Line.comments changed from Dict[LeafID, Leaf] to List[Tuple[Index, Leaf]] and that all references to comments were updated accordingly (e.g., __str__, comments_after, remove_trailing_comma, left_hand_split, right_hand_split, delimiter_split, standalone_comment_split).'

Validating todo item 2 of 20
description: 'Confirm the removal of the standalone comment hack: Line.maybe_adapt_standalone_comment method is deleted and no remaining calls reference it (including in UnformattedLines and Line.append).'

Calling tool: grepTool
maybe_adapt_standalone_comment\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
maybe_adapt_standalone_comment
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
def append\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:
610:    @property
611:    def is_def(self) -> bool:
612:        """Is this a function definition? (Also returns True for async defs.)"""
613:        try:
614:            first_leaf = self.leaves[0]
615:        except IndexError:
616:            return False
617:
618:        try:
619:            second_leaf: Optional[Leaf] = self.leaves[1]
620:        except IndexError:
621:            second_leaf = None
622:        return (
623:            (first_leaf.type == token.NAME and first_leaf.value == 'def')
624:            or (
625:                first_leaf.type == token.ASYNC
626:                and second_leaf is not None
627:                and second_leaf.type == token.NAME
628:                and second_leaf.value == 'def'
629:            )
630:        )
631:
632:    @property
633:    def is_flow_control(self) -> bool:
634:        """Is this line a flow control statement?
635:
636:        Those are `return`, `raise`, `break`, and `continue`.
637:        """
638:        return (
639:            bool(self)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Searched the codebase and found no occurrences of maybe_adapt_standalone_comment. In Line.append the call was removed, and UnformattedLines no longer defines the stub. Verified via reading black.py around append methods; no calls or definitions remain.

Todo item 2 of 20 is correct
description: 'Confirm the removal of the standalone comment hack: Line.maybe_adapt_standalone_comment method is deleted and no remaining calls reference it (including in UnformattedLines and Line.append).'

Validating todo item 3 of 20
description: 'Check Line.append_comment: when encountering STANDALONE_COMMENT with any open brackets (BracketTracker.any_open_brackets is True), it returns False without converting it into an inline token.COMMENT; otherwise inline comments are recorded using the new index-based comments list.'

Calling tool: grepTool
def append_comment\(
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
def append_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:734:    def append_comment(self, comment: Leaf) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:834:    def append_comment(self, comment: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
720:            self._for_loop_variable = True
721:            return True
722:
723:        return False
724:
725:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
726:        """See `maybe_increment_for_loop_variable` above for explanation."""
727:        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':
728:            self.bracket_tracker.depth -= 1
729:            self._for_loop_variable = False
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:
860:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
861:        """Return the number of extra empty lines before and after the `current_line`.
862:
863:        This is for separating `def`, `async def` and `class` with extra empty
864:        lines (two on module-level), as well as providing an extra empty line
865:        after flow control keywords to make them more prominent.
866:        """
867:        if isinstance(current_line, UnformattedLines):
868:            return 0, 0
869:
870:        before, after = self._maybe_empty_lines(current_line)
871:        before -= self.previous_after
872:        self.previous_after = after
873:        self.previous_line = current_line
874:        return before, after
875:
876:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
877:        max_allowed = 1
878:        if current_line.depth == 0:
879:            max_allowed = 2

Calling tool: grepTool
class Line:|def append\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:531:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py Line.append_comment now checks if the comment is STANDALONE_COMMENT with open brackets; it returns False after only clearing the prefix and does not convert it to token.COMMENT. For inline comments (token.COMMENT), it records them in the new index-based list via self.comments.append((after, comment)).

Todo item 3 of 20 is correct
description: 'Check Line.append_comment: when encountering STANDALONE_COMMENT with any open brackets (BracketTracker.any_open_brackets is True), it returns False without converting it into an inline token.COMMENT; otherwise inline comments are recorded using the new index-based comments list.'

Validating todo item 4 of 20
description: 'Ensure the new Line.append_safe enforces constraints outside brackets: raises ValueError when appending anything after a standalone comment line, or when attempting to append a standalone comment to a non-empty line; and ensure delimiter_split and standalone_comment_split use append_safe and handle ValueError by yielding the current line and starting a new one.'

Calling tool: grepTool
class Line\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py

Calling tool: grepTool
class Line\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
class Line
Matched content:
531:class Line:
931:class LineGenerator(Visitor[Line]):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:
610:    @property
611:    def is_def(self) -> bool:
612:        """Is this a function definition? (Also returns True for async defs.)"""
613:        try:
614:            first_leaf = self.leaves[0]
615:        except IndexError:
616:            return False
617:
618:        try:
619:            second_leaf: Optional[Leaf] = self.leaves[1]
620:        except IndexError:
621:            second_leaf = None
622:        return (
623:            (first_leaf.type == token.NAME and first_leaf.value == 'def')
624:            or (
625:                first_leaf.type == token.ASYNC
626:                and second_leaf is not None
627:                and second_leaf.type == token.NAME
628:                and second_leaf.value == 'def'
629:            )
630:        )
631:
632:    @property
633:    def is_flow_control(self) -> bool:
634:        """Is this line a flow control statement?
635:
636:        Those are `return`, `raise`, `break`, and `continue`.
637:        """
638:        return (
639:            bool(self)
640:            and self.leaves[0].type == token.NAME
641:            and self.leaves[0].value in FLOW_CONTROL
642:        )
643:
644:    @property
645:    def is_yield(self) -> bool:
646:        """Is this line a yield statement?"""
647:        return (
648:            bool(self)
649:            and self.leaves[0].type == token.NAME
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True
680:
681:        # For parens let's check if it's safe to remove the comma.  If the
682:        # trailing one is the only one, we might mistakenly change a tuple
683:        # into a different type by removing the comma.
684:        depth = closing.bracket_depth + 1
685:        commas = 0
686:        opening = closing.opening_bracket
687:        for _opening_index, leaf in enumerate(self.leaves):
688:            if leaf is opening:
689:                break
690:
691:        else:
692:            return False
693:
694:        for leaf in self.leaves[_opening_index + 1:]:
695:            if leaf is closing:
696:                break
697:
698:            bracket_depth = leaf.bracket_depth
699:            if bracket_depth == depth and leaf.type == token.COMMA:
700:                commas += 1
701:                if leaf.parent and leaf.parent.type == syms.arglist:
702:                    commas += 1
703:                    break
704:
705:        if commas > 1:
706:            self.remove_trailing_comma()
707:            return True
708:
709:        return False
710:
711:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
712:        """In a for loop, or comprehension, the variables are often unpacks.
713:
714:        To avoid splitting on the comma in this situation, increase the depth of
715:        tokens between `for` and `in`.
716:        """
717:        if leaf.type == token.NAME and leaf.value == 'for':
718:            self.has_for = True
719:            self.bracket_tracker.depth += 1

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
720:            self._for_loop_variable = True
721:            return True
722:
723:        return False
724:
725:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
726:        """See `maybe_increment_for_loop_variable` above for explanation."""
727:        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':
728:            self.bracket_tracker.depth -= 1
729:            self._for_loop_variable = False
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:
860:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
861:        """Return the number of extra empty lines before and after the `current_line`.
862:
863:        This is for separating `def`, `async def` and `class` with extra empty
864:        lines (two on module-level), as well as providing an extra empty line
865:        after flow control keywords to make them more prominent.
866:        """
867:        if isinstance(current_line, UnformattedLines):
868:            return 0, 0
869:
870:        before, after = self._maybe_empty_lines(current_line)
871:        before -= self.previous_after
872:        self.previous_after = after
873:        self.previous_line = current_line
874:        return before, after
875:
876:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
877:        max_allowed = 1
878:        if current_line.depth == 0:
879:            max_allowed = 2
880:        if current_line.leaves:
881:            # Consume the first leaf's extra newlines.
882:            first_leaf = current_line.leaves[0]
883:            before = first_leaf.prefix.count('\n')
884:            before = min(before, max_allowed)
885:            first_leaf.prefix = ''
886:        else:
887:            before = 0
888:        depth = current_line.depth
889:        while self.previous_defs and self.previous_defs[-1] >= depth:
890:            self.previous_defs.pop()
891:            before = 1 if depth else 2
892:        is_decorator = current_line.is_decorator
893:        if is_decorator or current_line.is_def or current_line.is_class:
894:            if not is_decorator:
895:                self.previous_defs.append(depth)
896:            if self.previous_line is None:
897:                # Don't insert empty lines before the first line in the file.
898:                return 0, 0
899:
900:            if self.previous_line and self.previous_line.is_decorator:
901:                # Don't insert empty lines between decorators.
902:                return 0, 0
903:
904:            newlines = 2
905:            if current_line.depth:
906:                newlines -= 1
907:            return newlines, 0
908:
909:        if current_line.is_flow_control:
910:            return before, 1
911:
912:        if (
913:            self.previous_line
914:            and self.previous_line.is_import
915:            and not current_line.is_import
916:            and depth == self.previous_line.depth
917:        ):
918:            return (before or 1), 0
919:
920:        if (
921:            self.previous_line
922:            and self.previous_line.is_yield
923:            and (not current_line.is_yield or depth != self.previous_line.depth)
924:        ):
925:            return (before or 1), 0
926:
927:        return before, 0
928:
929:
930:@dataclass
931:class LineGenerator(Visitor[Line]):
932:    """Generates reformatted Line objects.  Empty lines are not emitted.
933:
934:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
935:    in ways that will no longer stringify to valid Python code on the tree.
936:    """
937:    current_line: Line = Factory(Line)
938:
939:    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:

Calling tool: grepTool
def delimiter_split\(
Matched content:
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:
1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1560:    """Split line into many lines, starting with the last matching bracket pair."""
1561:    head = Line(depth=line.depth)
1562:    body = Line(depth=line.depth + 1, inside_brackets=True)
1563:    tail = Line(depth=line.depth)
1564:    tail_leaves: List[Leaf] = []
1565:    body_leaves: List[Leaf] = []
1566:    head_leaves: List[Leaf] = []
1567:    current_leaves = tail_leaves
1568:    opening_bracket = None
1569:    for leaf in reversed(line.leaves):
1570:        if current_leaves is body_leaves:
1571:            if leaf is opening_bracket:
1572:                current_leaves = head_leaves if body_leaves else tail_leaves
1573:        current_leaves.append(leaf)
1574:        if current_leaves is tail_leaves:
1575:            if leaf.type in CLOSING_BRACKETS:
1576:                opening_bracket = leaf.opening_bracket
1577:                current_leaves = body_leaves
1578:    tail_leaves.reverse()
1579:    body_leaves.reverse()
1580:    head_leaves.reverse()
1581:    # Since body is a new indent level, remove spurious leading whitespace.
1582:    if body_leaves:
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1584:    # Build the new lines.
1585:    for result, leaves in (
1586:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1587:    ):
1588:        for leaf in leaves:
1589:            result.append(leaf, preformatted=True)
1590:            for comment_after in line.comments_after(leaf):
1591:                result.append(comment_after, preformatted=True)
1592:    bracket_split_succeeded_or_raise(head, body, tail)
1593:    for result in (head, body, tail):
1594:        if result:
1595:            yield result
1596:
1597:
1598:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
1599:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
1600:
1601:    Do nothing otherwise.
1602:
1603:    A left- or right-hand split is based on a pair of brackets. Content before
1604:    (and including) the opening bracket is left on one line, content inside the
1605:    brackets is put on a separate line, and finally content starting with and
1606:    following the closing bracket is put on a separate line.
1607:
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`
1610:    and the `tail` is just the closing bracket, then it's considered failed.
1611:    """
1612:    tail_len = len(str(tail).strip())
1613:    if not body:
1614:        if tail_len == 0:
1615:            raise CannotSplit("Splitting brackets produced the same line")
1616:
1617:        elif tail_len < 3:
1618:            raise CannotSplit(
1619:                f"Splitting brackets on an empty body to save "
1620:                f"{tail_len} characters is not worth it"
1621:            )
1622:
1623:
1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
1625:    """Normalize prefix of the first leaf in every line returned by `split_func`.
1626:
1627:    This is a decorator over relevant split functions.
1628:    """
1629:
1630:    @wraps(split_func)
1631:    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:
1632:        for l in split_func(line, py36):
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1634:            yield l
1635:
1636:    return split_wrapper
1637:
1638:
1639:@dont_increase_indentation
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:
1641:    """Split according to delimiters of the highest priority.
1642:
1643:    If `py36` is True, the split will add trailing commas also in function
1644:    signatures that contain `*` and `**`.
1645:    """
1646:    try:
1647:        last_leaf = line.leaves[-1]
1648:    except IndexError:
1649:        raise CannotSplit("Line empty")
1650:
1651:    delimiters = line.bracket_tracker.delimiters
1652:    try:
1653:        delimiter_priority = line.bracket_tracker.max_delimiter_priority(
1654:            exclude={id(last_leaf)}
1655:        )
1656:    except ValueError:
1657:        raise CannotSplit("No delimiters found")
1658:
1659:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1660:    lowest_depth = sys.maxsize
1661:    trailing_comma_safe = True
1662:
1663:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1664:        """Append `leaf` to current line or to new line if appending impossible."""
1665:        nonlocal current_line
1666:        try:
1667:            current_line.append_safe(leaf, preformatted=True)
1668:        except ValueError as ve:
1669:            yield current_line
1670:
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1672:            current_line.append(leaf)
1673:
1674:    for leaf in line.leaves:
1675:        yield from append_to_line(leaf)
1676:
1677:        for comment_after in line.comments_after(leaf):
1678:            yield from append_to_line(comment_after)
1679:
1680:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
1681:        if (
1682:            leaf.bracket_depth == lowest_depth
1683:            and leaf.type == token.STAR
1684:            or leaf.type == token.DOUBLESTAR
1685:        ):
1686:            trailing_comma_safe = trailing_comma_safe and py36
1687:        leaf_priority = delimiters.get(id(leaf))
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:
1768:def is_python36(node: Node) -> bool:
1769:    """Return True if the current file is using Python 3.6+ features.
1770:
1771:    Currently looking for:
1772:    - f-strings; and
1773:    - trailing commas after * or ** in function signatures.
1774:    """
1775:    for n in node.pre_order():
1776:        if n.type == token.STRING:
1777:            value_head = n.value[:2]  # type: ignore
1778:            if value_head in {'f"', 'F"', "f'", "F'", 'rf', 'fr', 'RF', 'FR'}:
1779:                return True
1780:
1781:        elif (
1782:            n.type == syms.typedargslist
1783:            and n.children
1784:            and n.children[-1].type == token.COMMA
1785:        ):
1786:            for ch in n.children:
1787:                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:
1788:                    return True
1789:
1790:    return False
1791:
1792:
1793:PYTHON_EXTENSIONS = {'.py'}
1794:BLACKLISTED_DIRECTORIES = {
1795:    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'
1796:}
1797:
1798:
1799:def gen_python_files_in_dir(path: Path) -> Iterator[Path]:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified black/black.py implements Line.append_safe raising ValueError outside brackets when appending after a standalone comment line and when appending a standalone comment to a non-empty line. Also confirmed delimiter_split and standalone_comment_split use append_safe and on ValueError yield the current line, start a new one, and append the leaf. Tests align with updated split_line behavior.

Todo item 4 of 20 is correct
description: 'Ensure the new Line.append_safe enforces constraints outside brackets: raises ValueError when appending anything after a standalone comment line, or when attempting to append a standalone comment to a non-empty line; and ensure delimiter_split and standalone_comment_split use append_safe and handle ValueError by yielding the current line and starting a new one.'

Validating todo item 5 of 20
description: 'Validate Line.is_comment now returns True only when the line has exactly one leaf and that leaf is STANDALONE_COMMENT (len(self.leaves) == 1).'

Calling tool: grepTool
def is_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:587:    def is_comment(self) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:
610:    @property
611:    def is_def(self) -> bool:
612:        """Is this a function definition? (Also returns True for async defs.)"""
613:        try:
614:            first_leaf = self.leaves[0]
615:        except IndexError:
616:            return False
617:
618:        try:
619:            second_leaf: Optional[Leaf] = self.leaves[1]

Calling tool: grepTool
is_comment
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:576:            if self.is_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:587:    def is_comment(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1472:    if isinstance(line, UnformattedLines) or line.is_comment:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py Line.is_comment (line ~587) now returns `len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT`, ensuring True only when there is exactly one leaf and it is a standalone comment. Verified via grep and reading the implementation.

Todo item 5 of 20 is correct
description: 'Validate Line.is_comment now returns True only when the line has exactly one leaf and that leaf is STANDALONE_COMMENT (len(self.leaves) == 1).'

Validating todo item 6 of 20
description: 'Verify the presence and correctness of Line.contains_standalone_comments which returns True if any leaf.type == STANDALONE_COMMENT on the line, and that split_line uses it to bypass the early-return fast path.'

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py

Calling tool: grepTool
contains_standalone_comments
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:654:    def contains_standalone_comments(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1480:        and not line.contains_standalone_comments

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
640:            and self.leaves[0].type == token.NAME
641:            and self.leaves[0].value in FLOW_CONTROL
642:        )
643:
644:    @property
645:    def is_yield(self) -> bool:
646:        """Is this line a yield statement?"""
647:        return (
648:            bool(self)
649:            and self.leaves[0].type == token.NAME
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Line.contains_standalone_comments is implemented to return True if any leaf.type == STANDALONE_COMMENT (black.py:654-660). split_lines early-return condition includes `and not line.contains_standalone_comments` (black.py:1476-1483), ensuring lines with standalone comments bypass the fast path.

Todo item 6 of 20 is correct
description: 'Verify the presence and correctness of Line.contains_standalone_comments which returns True if any leaf.type == STANDALONE_COMMENT on the line, and that split_line uses it to bypass the early-return fast path.'

Validating todo item 7 of 20
description: 'In split_line, confirm that lines that are UnformattedLines or comment-only (line.is_comment) are yielded unchanged, fulfilling the intent to not reformat standalone comment lines.'

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1459:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:

Calling tool: grepTool
def is_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:587:    def is_comment(self) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py split_line, lines 1472-1474 explicitly yield and return when the line is an UnformattedLines or when line.is_comment is True. The is_comment property (lines 587-590) correctly identifies comment-only lines. Thus standalone comment lines are yielded unchanged as required.

Todo item 7 of 20 is correct
description: 'In split_line, confirm that lines that are UnformattedLines or comment-only (line.is_comment) are yielded unchanged, fulfilling the intent to not reformat standalone comment lines.'

Validating todo item 8 of 20
description: 'In split_line, confirm the early-return condition additionally checks not line.contains_standalone_comments so lines with standalone comments are forced through splitting logic even if within line length and with no embedded newlines.'

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1459:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:

Calling tool: grepTool
def contains_standalone_comments\(
Matched content:
654:    def contains_standalone_comments(self) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
640:            and self.leaves[0].type == token.NAME
641:            and self.leaves[0].value in FLOW_CONTROL
642:        )
643:
644:    @property
645:    def is_yield(self) -> bool:
646:        """Is this line a yield statement?"""
647:        return (
648:            bool(self)
649:            and self.leaves[0].type == token.NAME
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified in black.py split_line that the early-return condition includes `and not line.contains_standalone_comments`. The Line class implements `contains_standalone_comments` to detect STANDALONE_COMMENT leaves, ensuring such lines are not returned early even if within line length and no embedded newlines.

Todo item 8 of 20 is correct
description: 'In split_line, confirm the early-return condition additionally checks not line.contains_standalone_comments so lines with standalone comments are forced through splitting logic even if within line length and with no embedded newlines.'

Validating todo item 9 of 20
description: 'In split_line, when inside_brackets, confirm the split function order is [delimiter_split, standalone_comment_split, right_hand_split] and that split_line calls each with the updated signature (split_func(line, py36)).'

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1459:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings
1480:        and not line.contains_standalone_comments
1481:    ):
1482:        yield line
1483:        return
1484:
1485:    split_funcs: List[SplitFunc]
1486:    if line.is_def:
1487:        split_funcs = [left_hand_split]
1488:    elif line.inside_brackets:
1489:        split_funcs = [delimiter_split, standalone_comment_split, right_hand_split]
1490:    else:
1491:        split_funcs = [right_hand_split]
1492:    for split_func in split_funcs:
1493:        # We are accumulating lines in `result` because we might want to abort
1494:        # mission and return the original line in the end, or attempt a different
1495:        # split altogether.
1496:        result: List[Line] = []
1497:        try:
1498:            for l in split_func(line, py36):
1499:                if str(l).strip('\n') == line_str:
1500:                    raise CannotSplit("Split function returned an unchanged result")
1501:
1502:                result.extend(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)
1504:                )
1505:        except CannotSplit as cs:
1506:            continue
1507:
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py split_line, when line.inside_brackets is true, split_funcs is set to [delimiter_split, standalone_comment_split, right_hand_split] (lines ~1485-1491). The loop later calls each via for l in split_func(line, py36): (line ~1498), matching the updated signature.

Todo item 9 of 20 is correct
description: 'In split_line, when inside_brackets, confirm the split function order is [delimiter_split, standalone_comment_split, right_hand_split] and that split_line calls each with the updated signature (split_func(line, py36)).'

Validating todo item 10 of 20
description: 'Verify dont_increase_indentation decorator exists and is applied to delimiter_split and standalone_comment_split, and that these functions no longer call normalize_prefix on each yield explicitly (the decorator handles it).'

Calling tool: grepTool
dont_increase_indentation\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`
1610:    and the `tail` is just the closing bracket, then it's considered failed.
1611:    """
1612:    tail_len = len(str(tail).strip())
1613:    if not body:
1614:        if tail_len == 0:
1615:            raise CannotSplit("Splitting brackets produced the same line")
1616:
1617:        elif tail_len < 3:
1618:            raise CannotSplit(
1619:                f"Splitting brackets on an empty body to save "
1620:                f"{tail_len} characters is not worth it"
1621:            )
1622:
1623:
1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
1625:    """Normalize prefix of the first leaf in every line returned by `split_func`.
1626:
1627:    This is a decorator over relevant split functions.
1628:    """
1629:
1630:    @wraps(split_func)
1631:    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:
1632:        for l in split_func(line, py36):
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1634:            yield l
1635:
1636:    return split_wrapper
1637:
1638:
1639:@dont_increase_indentation
1640:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:
1641:    """Split according to delimiters of the highest priority.
1642:
1643:    If `py36` is True, the split will add trailing commas also in function
1644:    signatures that contain `*` and `**`.
1645:    """
1646:    try:
1647:        last_leaf = line.leaves[-1]
1648:    except IndexError:
1649:        raise CannotSplit("Line empty")
1650:
1651:    delimiters = line.bracket_tracker.delimiters
1652:    try:
1653:        delimiter_priority = line.bracket_tracker.max_delimiter_priority(
1654:            exclude={id(last_leaf)}
1655:        )
1656:    except ValueError:
1657:        raise CannotSplit("No delimiters found")
1658:
1659:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1660:    lowest_depth = sys.maxsize
1661:    trailing_comma_safe = True
1662:
1663:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1664:        """Append `leaf` to current line or to new line if appending impossible."""
1665:        nonlocal current_line
1666:        try:
1667:            current_line.append_safe(leaf, preformatted=True)
1668:        except ValueError as ve:
1669:            yield current_line
1670:
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1672:            current_line.append(leaf)
1673:
1674:    for leaf in line.leaves:
1675:        yield from append_to_line(leaf)
1676:
1677:        for comment_after in line.comments_after(leaf):
1678:            yield from append_to_line(comment_after)
1679:
1680:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
1681:        if (
1682:            leaf.bracket_depth == lowest_depth
1683:            and leaf.type == token.STAR
1684:            or leaf.type == token.DOUBLESTAR
1685:        ):
1686:            trailing_comma_safe = trailing_comma_safe and py36
1687:        leaf_priority = delimiters.get(id(leaf))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:
1768:def is_python36(node: Node) -> bool:
1769:    """Return True if the current file is using Python 3.6+ features.
1770:
1771:    Currently looking for:
1772:    - f-strings; and
1773:    - trailing commas after * or ** in function signatures.
1774:    """
1775:    for n in node.pre_order():
1776:        if n.type == token.STRING:
1777:            value_head = n.value[:2]  # type: ignore
1778:            if value_head in {'f"', 'F"', "f'", "F'", 'rf', 'fr', 'RF', 'FR'}:
1779:                return True
1780:
1781:        elif (
1782:            n.type == syms.typedargslist
1783:            and n.children
1784:            and n.children[-1].type == token.COMMA
1785:        ):
1786:            for ch in n.children:
1787:                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:
1788:                    return True
1789:
1790:    return False
1791:
1792:
1793:PYTHON_EXTENSIONS = {'.py'}
1794:BLACKLISTED_DIRECTORIES = {
1795:    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'
1796:}
1797:
1798:
1799:def gen_python_files_in_dir(path: Path) -> Iterator[Path]:
1800:    """Generate all files under `path` which aren't under BLACKLISTED_DIRECTORIES
1801:    and have one of the PYTHON_EXTENSIONS.
1802:    """
1803:    for child in path.iterdir():
1804:        if child.is_dir():
1805:            if child.name in BLACKLISTED_DIRECTORIES:
1806:                continue
1807:

Calling tool: grepTool
normalize_prefix\(
Matched content:
1003:                normalize_prefix(node, inside_brackets=any_open_brackets)
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Found dont_increase_indentation defined and applied as a decorator to both delimiter_split and standalone_comment_split. Neither function body contains direct normalize_prefix calls; normalization is performed in the decorator.

Todo item 10 of 20 is correct
description: 'Verify dont_increase_indentation decorator exists and is applied to delimiter_split and standalone_comment_split, and that these functions no longer call normalize_prefix on each yield explicitly (the decorator handles it).'

Validating todo item 11 of 20
description: 'Check that left_hand_split and right_hand_split now append all comments after each leaf by iterating for comment_after in line.comments_after(leaf) and appending each with preformatted=True (thus supporting multiple comments after a single leaf).'

Calling tool: grepTool
def left_hand_split\(|def right_hand_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1508:        else:
1509:            yield from result
1510:            break
1511:
1512:    else:
1513:        yield line
1514:
1515:
1516:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1517:    """Split line into many lines, starting with the first matching bracket pair.
1518:
1519:    Note: this usually looks weird, only use this for function definitions.
1520:    Prefer RHS otherwise.
1521:    """
1522:    head = Line(depth=line.depth)
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1524:    tail = Line(depth=line.depth)
1525:    tail_leaves: List[Leaf] = []
1526:    body_leaves: List[Leaf] = []
1527:    head_leaves: List[Leaf] = []
1528:    current_leaves = head_leaves
1529:    matching_bracket = None
1530:    for leaf in line.leaves:
1531:        if (
1532:            current_leaves is body_leaves
1533:            and leaf.type in CLOSING_BRACKETS
1534:            and leaf.opening_bracket is matching_bracket
1535:        ):
1536:            current_leaves = tail_leaves if body_leaves else head_leaves
1537:        current_leaves.append(leaf)
1538:        if current_leaves is head_leaves:
1539:            if leaf.type in OPENING_BRACKETS:
1540:                matching_bracket = leaf
1541:                current_leaves = body_leaves
1542:    # Since body is a new indent level, remove spurious leading whitespace.
1543:    if body_leaves:
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1545:    # Build the new lines.
1546:    for result, leaves in (
1547:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1548:    ):
1549:        for leaf in leaves:
1550:            result.append(leaf, preformatted=True)
1551:            for comment_after in line.comments_after(leaf):
1552:                result.append(comment_after, preformatted=True)
1553:    bracket_split_succeeded_or_raise(head, body, tail)
1554:    for result in (head, body, tail):
1555:        if result:
1556:            yield result
1557:
1558:
1559:def right_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
1560:    """Split line into many lines, starting with the last matching bracket pair."""
1561:    head = Line(depth=line.depth)
1562:    body = Line(depth=line.depth + 1, inside_brackets=True)
1563:    tail = Line(depth=line.depth)
1564:    tail_leaves: List[Leaf] = []
1565:    body_leaves: List[Leaf] = []
1566:    head_leaves: List[Leaf] = []
1567:    current_leaves = tail_leaves
1568:    opening_bracket = None
1569:    for leaf in reversed(line.leaves):
1570:        if current_leaves is body_leaves:
1571:            if leaf is opening_bracket:
1572:                current_leaves = head_leaves if body_leaves else tail_leaves
1573:        current_leaves.append(leaf)
1574:        if current_leaves is tail_leaves:
1575:            if leaf.type in CLOSING_BRACKETS:
1576:                opening_bracket = leaf.opening_bracket
1577:                current_leaves = body_leaves
1578:    tail_leaves.reverse()
1579:    body_leaves.reverse()
1580:    head_leaves.reverse()
1581:    # Since body is a new indent level, remove spurious leading whitespace.
1582:    if body_leaves:
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1584:    # Build the new lines.
1585:    for result, leaves in (
1586:        (head, head_leaves), (body, body_leaves), (tail, tail_leaves)
1587:    ):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1588:        for leaf in leaves:
1589:            result.append(leaf, preformatted=True)
1590:            for comment_after in line.comments_after(leaf):
1591:                result.append(comment_after, preformatted=True)
1592:    bracket_split_succeeded_or_raise(head, body, tail)
1593:    for result in (head, body, tail):
1594:        if result:
1595:            yield result
1596:
1597:
1598:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
1599:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
1600:
1601:    Do nothing otherwise.
1602:
1603:    A left- or right-hand split is based on a pair of brackets. Content before
1604:    (and including) the opening bracket is left on one line, content inside the
1605:    brackets is put on a separate line, and finally content starting with and
1606:    following the closing bracket is put on a separate line.
1607:
1608:    Those are called `head`, `body`, and `tail`, respectively. If the split
1609:    produced the same line (all content in `head`) or ended up with an empty `body`
1610:    and the `tail` is just the closing bracket, then it's considered failed.
1611:    """
1612:    tail_len = len(str(tail).strip())
1613:    if not body:
1614:        if tail_len == 0:
1615:            raise CannotSplit("Splitting brackets produced the same line")
1616:
1617:        elif tail_len < 3:
1618:            raise CannotSplit(
1619:                f"Splitting brackets on an empty body to save "
1620:                f"{tail_len} characters is not worth it"
1621:            )
1622:
1623:
1624:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
1625:    """Normalize prefix of the first leaf in every line returned by `split_func`.
1626:
1627:    This is a decorator over relevant split functions.

Calling tool: grepTool
def comments_after\(
Matched content:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In both left_hand_split and right_hand_split, the code now iterates over comments via `for comment_after in line.comments_after(leaf):` and appends each with `preformatted=True`, enabling multiple comments after a single leaf. Verified actual lines in black.py.

Todo item 11 of 20 is correct
description: 'Check that left_hand_split and right_hand_split now append all comments after each leaf by iterating for comment_after in line.comments_after(leaf) and appending each with preformatted=True (thus supporting multiple comments after a single leaf).'

Validating todo item 12 of 20
description: 'Verify Line.comments_after(leaf) correctly finds the index of the provided leaf in self.leaves and yields all comments with matching indices from self.comments; ensure it returns nothing if the leaf isn't found.'

Calling tool: grepTool
def comments_after\(
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
def comments_after\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, Line.comments_after enumerates self.leaves to find the exact index of the provided leaf by identity; if not found, it returns without yielding. It then iterates self.comments (list of (index, comment)) and yields all comments whose stored index matches, satisfying the requirement.

Todo item 12 of 20 is correct
description: 'Verify Line.comments_after(leaf) correctly finds the index of the provided leaf in self.leaves and yields all comments with matching indices from self.comments; ensure it returns nothing if the leaf isn't found.'

Validating todo item 13 of 20
description: 'Validate Line.remove_trailing_comma updates indices of comments attached to the trailing comma (decrementing the index by 1) before popping the comma leaf, and confirm all callers of maybe_remove_trailing_comma now call remove_trailing_comma instead of popping directly.'

Calling tool: grepTool
class Line\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py

Calling tool: grepTool
remove_trailing_comma
Matched content:
563:            self.maybe_remove_trailing_comma(leaf)
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
672:            self.remove_trailing_comma()
678:                self.remove_trailing_comma()
706:            self.remove_trailing_comma()
769:    def remove_trailing_comma(self) -> None:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''
750:            return False
751:
752:        else:
753:            self.comments.append((after, comment))
754:            return True
755:
756:    def comments_after(self, leaf: Leaf) -> Iterator[Leaf]:
757:        """Generate comments that should appear directly after `leaf`."""
758:        for _leaf_index, _leaf in enumerate(self.leaves):
759:            if leaf is _leaf:
760:                break
761:
762:        else:
763:            return
764:
765:        for index, comment_after in self.comments:
766:            if _leaf_index == index:
767:                yield comment_after
768:
769:    def remove_trailing_comma(self) -> None:
770:        """Remove the trailing comma and moves the comments attached to it."""
771:        comma_index = len(self.leaves) - 1
772:        for i in range(len(self.comments)):
773:            comment_index, comment = self.comments[i]
774:            if comment_index == comma_index:
775:                self.comments[i] = (comma_index - 1, comment)
776:        self.leaves.pop()
777:
778:    def __str__(self) -> str:
779:        """Render the line."""
780:        if not self:
781:            return '\n'
782:
783:        indent = '    ' * self.depth
784:        leaves = iter(self.leaves)
785:        first = next(leaves)
786:        res = f'{first.prefix}{indent}{first.value}'
787:        for leaf in leaves:
788:            res += str(leaf)
789:        for _, comment in self.comments:
790:            res += str(comment)
791:        return res + '\n'
792:
793:    def __bool__(self) -> bool:
794:        """Return True if the line has leaves or comments."""
795:        return bool(self.leaves or self.comments)
796:
797:
798:class UnformattedLines(Line):
799:    """Just like :class:`Line` but stores lines which aren't reformatted."""
800:
801:    def append(self, leaf: Leaf, preformatted: bool = True) -> None:
802:        """Just add a new `leaf` to the end of the lines.
803:
804:        The `preformatted` argument is ignored.
805:
806:        Keeps track of indentation `depth`, which is useful when the user
807:        says `# fmt: on`. Otherwise, doesn't do anything with the `leaf`.
808:        """
809:        try:
810:            list(generate_comments(leaf))
811:        except FormatOn as f_on:
812:            self.leaves.append(f_on.leaf_from_consumed(leaf))
813:            raise
814:
815:        self.leaves.append(leaf)
816:        if leaf.type == token.INDENT:
817:            self.depth += 1
818:        elif leaf.type == token.DEDENT:
819:            self.depth -= 1
820:
821:    def __str__(self) -> str:
822:        """Render unformatted lines from leaves which were added with `append()`.
823:
824:        `depth` is not used for indentation in this case.
825:        """
826:        if not self:
827:            return '\n'
828:
829:        res = ''

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True
680:
681:        # For parens let's check if it's safe to remove the comma.  If the
682:        # trailing one is the only one, we might mistakenly change a tuple
683:        # into a different type by removing the comma.
684:        depth = closing.bracket_depth + 1
685:        commas = 0
686:        opening = closing.opening_bracket
687:        for _opening_index, leaf in enumerate(self.leaves):
688:            if leaf is opening:
689:                break
690:
691:        else:
692:            return False
693:
694:        for leaf in self.leaves[_opening_index + 1:]:
695:            if leaf is closing:
696:                break
697:
698:            bracket_depth = leaf.bracket_depth
699:            if bracket_depth == depth and leaf.type == token.COMMA:
700:                commas += 1
701:                if leaf.parent and leaf.parent.type == syms.arglist:
702:                    commas += 1
703:                    break
704:
705:        if commas > 1:
706:            self.remove_trailing_comma()
707:            return True
708:
709:        return False
710:
711:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
712:        """In a for loop, or comprehension, the variables are often unpacks.
713:
714:        To avoid splitting on the comma in this situation, increase the depth of
715:        tokens between `for` and `in`.
716:        """
717:        if leaf.type == token.NAME and leaf.value == 'for':
718:            self.has_for = True
719:            self.bracket_tracker.depth += 1
720:            self._for_loop_variable = True
721:            return True
722:
723:        return False
724:
725:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
726:        """See `maybe_increment_for_loop_variable` above for explanation."""
727:        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == 'in':
728:            self.bracket_tracker.depth -= 1
729:            self._for_loop_variable = False
730:            return True
731:
732:        return False
733:
734:    def append_comment(self, comment: Leaf) -> bool:
735:        """Add an inline or standalone comment to the line."""
736:        if (
737:            comment.type == STANDALONE_COMMENT
738:            and self.bracket_tracker.any_open_brackets()
739:        ):
740:            comment.prefix = ''
741:            return False
742:
743:        if comment.type != token.COMMENT:
744:            return False
745:
746:        after = len(self.leaves) - 1
747:        if after == -1:
748:            comment.type = STANDALONE_COMMENT
749:            comment.prefix = ''

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
830:        for leaf in self.leaves:
831:            res += str(leaf)
832:        return res
833:
834:    def append_comment(self, comment: Leaf) -> bool:
835:        """Not implemented in this class. Raises `NotImplementedError`."""
836:        raise NotImplementedError("Unformatted lines don't store comments separately.")
837:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
839:        """Does nothing and returns False."""
840:        return False
841:
842:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
843:        """Does nothing and returns False."""
844:        return False
845:
846:
847:@dataclass
848:class EmptyLineTracker:
849:    """Provides a stateful method that returns the number of potential extra
850:    empty lines needed before and after the currently processed line.
851:
852:    Note: this tracker works on lines that haven't been split yet.  It assumes
853:    the prefix of the first leaf consists of optional newlines.  Those newlines
854:    are consumed by `maybe_empty_lines()` and included in the computation.
855:    """
856:    previous_line: Optional[Line] = None
857:    previous_after: int = 0
858:    previous_defs: List[int] = Factory(list)
859:
860:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
861:        """Return the number of extra empty lines before and after the `current_line`.
862:
863:        This is for separating `def`, `async def` and `class` with extra empty
864:        lines (two on module-level), as well as providing an extra empty line
865:        after flow control keywords to make them more prominent.
866:        """
867:        if isinstance(current_line, UnformattedLines):
868:            return 0, 0
869:
870:        before, after = self._maybe_empty_lines(current_line)
871:        before -= self.previous_after
872:        self.previous_after = after
873:        self.previous_line = current_line
874:        return before, after
875:
876:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
877:        max_allowed = 1
878:        if current_line.depth == 0:
879:            max_allowed = 2
880:        if current_line.leaves:
881:            # Consume the first leaf's extra newlines.
882:            first_leaf = current_line.leaves[0]
883:            before = first_leaf.prefix.count('\n')
884:            before = min(before, max_allowed)
885:            first_leaf.prefix = ''
886:        else:
887:            before = 0
888:        depth = current_line.depth
889:        while self.previous_defs and self.previous_defs[-1] >= depth:

Calling tool: grepTool
leaves\.pop\(
Matched content:
776:        self.leaves.pop()

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])

Calling tool: grepTool
trailing_comma
Matched content:
563:            self.maybe_remove_trailing_comma(leaf)
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
672:            self.remove_trailing_comma()
678:                self.remove_trailing_comma()
706:            self.remove_trailing_comma()
769:    def remove_trailing_comma(self) -> None:
838:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1661:    trailing_comma_safe = True
1686:            trailing_comma_safe = trailing_comma_safe and py36
1696:            and trailing_comma_safe

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Line.remove_trailing_comma reassigns comments with index equal to the trailing comma to (index-1) before popping the comma. In maybe_remove_trailing_comma all branches now call remove_trailing_comma; grep confirms the only leaves.pop() remaining is inside remove_trailing_comma itself.

Todo item 13 of 20 is correct
description: 'Validate Line.remove_trailing_comma updates indices of comments attached to the trailing comma (decrementing the index by 1) before popping the comma leaf, and confirm all callers of maybe_remove_trailing_comma now call remove_trailing_comma instead of popping directly.'

Validating todo item 14 of 20
description: 'Confirm ALWAYS_NO_SPACE includes STANDALONE_COMMENT and that whitespace() returns DOUBLESPACE only for token.COMMENT and no space for STANDALONE_COMMENT (via ALWAYS_NO_SPACE).'

Calling tool: grepTool
ALWAYS_NO_SPACE|whitespace\(
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
ALWAYS_NO_SPACE|whitespace\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/blib2to3/pgen2/tokenize.py:204:    def add_whitespace(self, start):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/blib2to3/pgen2/tokenize.py:217:            self.add_whitespace(start)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/empty_lines.py:10:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/empty_lines.py:61:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/empty_lines.py:101:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/empty_lines.py:152:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/blib2to3/pgen2/tokenize.pyi:23:    def add_whitespace(self, start: _Coord) -> None: ...
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:559:            leaf.prefix += whitespace(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1109:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1112:def whitespace(leaf: Leaf) -> str:  # noqa C901
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1120:    if t in ALWAYS_NO_SPACE:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1080:                yield from self.visit(child)
1081:
1082:        else:
1083:            try:
1084:                self.current_line.append(node)
1085:            except FormatOn as f_on:
1086:                f_on.trim_prefix(node)
1087:                yield from self.line()
1088:                yield from self.visit(node)
1089:
1090:    def __attrs_post_init__(self) -> None:
1091:        """You are in a twisty little maze of passages."""
1092:        v = self.visit_stmt
1093:        self.visit_if_stmt = partial(v, keywords={'if', 'else', 'elif'})
1094:        self.visit_while_stmt = partial(v, keywords={'while', 'else'})
1095:        self.visit_for_stmt = partial(v, keywords={'for', 'else'})
1096:        self.visit_try_stmt = partial(v, keywords={'try', 'except', 'else', 'finally'})
1097:        self.visit_except_clause = partial(v, keywords={'except'})
1098:        self.visit_funcdef = partial(v, keywords={'def'})
1099:        self.visit_with_stmt = partial(v, keywords={'with'})
1100:        self.visit_classdef = partial(v, keywords={'class'})
1101:        self.visit_async_funcdef = self.visit_async_stmt
1102:        self.visit_decorated = self.visit_decorators
1103:
1104:
1105:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1106:OPENING_BRACKETS = set(BRACKET.keys())
1107:CLOSING_BRACKETS = set(BRACKET.values())
1108:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1109:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1110:
1111:
1112:def whitespace(leaf: Leaf) -> str:  # noqa C901
1113:    """Return whitespace prefix if needed for the given `leaf`."""
1114:    NO = ''
1115:    SPACE = ' '
1116:    DOUBLESPACE = '  '
1117:    t = leaf.type
1118:    p = leaf.parent
1119:    v = leaf.value
1120:    if t in ALWAYS_NO_SPACE:
1121:        return NO
1122:
1123:    if t == token.COMMENT:
1124:        return DOUBLESPACE
1125:
1126:    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"
1127:    if t == token.COLON and p.type not in {syms.subscript, syms.subscriptlist}:
1128:        return NO
1129:
1130:    prev = leaf.prev_sibling
1131:    if not prev:
1132:        prevp = preceding_leaf(p)
1133:        if not prevp or prevp.type in OPENING_BRACKETS:
1134:            return NO
1135:
1136:        if t == token.COLON:
1137:            return SPACE if prevp.type == token.COMMA else NO
1138:
1139:        if prevp.type == token.EQUAL:
1140:            if prevp.parent:
1141:                if prevp.parent.type in {
1142:                    syms.arglist, syms.argument, syms.parameters, syms.varargslist
1143:                }:
1144:                    return NO
1145:
1146:                elif prevp.parent.type == syms.typedargslist:
1147:                    # A bit hacky: if the equal sign has whitespace, it means we
1148:                    # previously found it's a typed argument.  So, we're using
1149:                    # that, too.
1150:                    return prevp.prefix
1151:
1152:        elif prevp.type == token.DOUBLESTAR:
1153:            if prevp.parent and prevp.parent.type in {
1154:                syms.arglist,
1155:                syms.argument,
1156:                syms.dictsetmaker,
1157:                syms.parameters,
1158:                syms.typedargslist,
1159:                syms.varargslist,

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:421:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:657:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:737:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:748:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1109:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1405:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1427:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1706:        if leaf.type == STANDALONE_COMMENT:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
400:        """Pretty-print the lib2to3 AST of a given string of `code`.
401:
402:        Convenience method for debugging.
403:        """
404:        v: DebugVisitor[None] = DebugVisitor()
405:        list(v.visit(lib2to3_parse(code)))
406:
407:
408:KEYWORDS = set(keyword.kwlist)
409:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
410:FLOW_CONTROL = {'return', 'raise', 'break', 'continue'}
411:STATEMENT = {
412:    syms.if_stmt,
413:    syms.while_stmt,
414:    syms.for_stmt,
415:    syms.try_stmt,
416:    syms.except_clause,
417:    syms.with_stmt,
418:    syms.funcdef,
419:    syms.classdef,
420:}
421:STANDALONE_COMMENT = 153
422:LOGIC_OPERATORS = {'and', 'or'}
423:COMPARATORS = {
424:    token.LESS,
425:    token.GREATER,
426:    token.EQEQUAL,
427:    token.NOTEQUAL,
428:    token.LESSEQUAL,
429:    token.GREATEREQUAL,
430:}
431:MATH_OPERATORS = {
432:    token.PLUS,
433:    token.MINUS,
434:    token.STAR,
435:    token.SLASH,
436:    token.VBAR,
437:    token.AMPER,
438:    token.PERCENT,
439:    token.CIRCUMFLEX,
440:    token.TILDE,
441:    token.LEFTSHIFT,
442:    token.RIGHTSHIFT,
443:    token.DOUBLESTAR,
444:    token.DOUBLESLASH,
445:}
446:COMPREHENSION_PRIORITY = 20
447:COMMA_PRIORITY = 10
448:LOGIC_PRIORITY = 5
449:STRING_PRIORITY = 4
450:COMPARATOR_PRIORITY = 3
451:MATH_PRIORITY = 1
452:
453:
454:@dataclass
455:class BracketTracker:
456:    """Keeps track of brackets on a line."""
457:
458:    depth: int = 0
459:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1388:def generate_comments(leaf: Leaf) -> Iterator[Leaf]:
1389:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1390:
1391:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1392:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1393:    move because it does away with modifying the grammar to include all the
1394:    possible places in which comments can be placed.
1395:
1396:    The sad consequence for us though is that comments don't "belong" anywhere.
1397:    This is why this function generates simple parentless Leaf objects for
1398:    comments.  We simply don't know what the correct parent should be.
1399:
1400:    No matter though, we can live without this.  We really only need to
1401:    differentiate between inline and standalone comments.  The latter don't
1402:    share the line with any code.
1403:
1404:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1405:    are emitted with a fake STANDALONE_COMMENT token identifier.
1406:    """
1407:    p = leaf.prefix
1408:    if not p:
1409:        return
1410:
1411:    if '#' not in p:
1412:        return
1413:
1414:    consumed = 0
1415:    nlines = 0
1416:    for index, line in enumerate(p.split('\n')):
1417:        consumed += len(line) + 1  # adding the length of the split '\n'
1418:        line = line.lstrip()
1419:        if not line:
1420:            nlines += 1
1421:        if not line.startswith('#'):
1422:            continue
1423:
1424:        if index == 0 and leaf.type != token.ENDMARKER:
1425:            comment_type = token.COMMENT  # simple trailing comment
1426:        else:
1427:            comment_type = STANDALONE_COMMENT
1428:        comment = make_comment(line)
1429:        yield Leaf(comment_type, comment, prefix='\n' * nlines)
1430:
1431:        if comment in {'# fmt: on', '# yapf: enable'}:
1432:            raise FormatOn(consumed)
1433:
1434:        if comment in {'# fmt: off', '# yapf: disable'}:
1435:            raise FormatOff(consumed)
1436:
1437:        nlines = 0
1438:
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py line 1109, ALWAYS_NO_SPACE includes STANDALONE_COMMENT. In whitespace() (lines 11121125), it first returns no space if the token is in ALWAYS_NO_SPACE, and only returns DOUBLESPACE when t == token.COMMENT, so STANDALONE_COMMENT gets no space while inline comments get two spaces.

Todo item 14 of 20 is correct
description: 'Confirm ALWAYS_NO_SPACE includes STANDALONE_COMMENT and that whitespace() returns DOUBLESPACE only for token.COMMENT and no space for STANDALONE_COMMENT (via ALWAYS_NO_SPACE).'

Validating todo item 15 of 20
description: 'In LineGenerator.visit_default, verify that when any_open_brackets is True, all generated comments (both inline and standalone) are appended to the current line without immediate line emission, making them subject to splitting; while comments outside brackets are emitted as trailing or standalone appropriately.'

Calling tool: grepTool
class LineGenerator|def visit_default\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/tests/debug_visitor.py:5:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:367:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:378:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:931:class LineGenerator(Visitor[Line]):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:970:    def visit_default(self, node: LN) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
900:            if self.previous_line and self.previous_line.is_decorator:
901:                # Don't insert empty lines between decorators.
902:                return 0, 0
903:
904:            newlines = 2
905:            if current_line.depth:
906:                newlines -= 1
907:            return newlines, 0
908:
909:        if current_line.is_flow_control:
910:            return before, 1
911:
912:        if (
913:            self.previous_line
914:            and self.previous_line.is_import
915:            and not current_line.is_import
916:            and depth == self.previous_line.depth
917:        ):
918:            return (before or 1), 0
919:
920:        if (
921:            self.previous_line
922:            and self.previous_line.is_yield
923:            and (not current_line.is_yield or depth != self.previous_line.depth)
924:        ):
925:            return (before or 1), 0
926:
927:        return before, 0
928:
929:
930:@dataclass
931:class LineGenerator(Visitor[Line]):
932:    """Generates reformatted Line objects.  Empty lines are not emitted.
933:
934:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
935:    in ways that will no longer stringify to valid Python code on the tree.
936:    """
937:    current_line: Line = Factory(Line)
938:
939:    def line(self, indent: int = 0, type: Type[Line] = Line) -> Iterator[Line]:
940:        """Generate a line.
941:
942:        If the line is empty, only emit if it makes sense.
943:        If the line is too long, split it first and then generate.
944:
945:        If any lines were generated, set up a new current_line.
946:        """
947:        if not self.current_line:
948:            if self.current_line.__class__ == type:
949:                self.current_line.depth += indent
950:            else:
951:                self.current_line = type(depth=self.current_line.depth + indent)
952:            return  # Line is empty, don't emit. Creating a new one unnecessary.
953:
954:        complete_line = self.current_line
955:        self.current_line = type(depth=complete_line.depth + indent)
956:        yield complete_line
957:
958:    def visit(self, node: LN) -> Iterator[Line]:
959:        """Main method to visit `node` and its children.
960:
961:        Yields :class:`Line` objects.
962:        """
963:        if isinstance(self.current_line, UnformattedLines):
964:            # File contained `# fmt: off`
965:            yield from self.visit_unformatted(node)
966:
967:        else:
968:            yield from super().visit(node)
969:
970:    def visit_default(self, node: LN) -> Iterator[Line]:
971:        """Default `visit_*()` implementation. Recurses to children of `node`."""
972:        if isinstance(node, Leaf):
973:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
974:            try:
975:                for comment in generate_comments(node):
976:                    if any_open_brackets:
977:                        # any comment within brackets is subject to splitting
978:                        self.current_line.append(comment)
979:                    elif comment.type == token.COMMENT:
980:                        # regular trailing comment
981:                        self.current_line.append(comment)
982:                        yield from self.line()
983:
984:                    else:
985:                        # regular standalone comment
986:                        yield from self.line()
987:
988:                        self.current_line.append(comment)
989:                        yield from self.line()
990:
991:            except FormatOff as f_off:
992:                f_off.trim_prefix(node)
993:                yield from self.line(type=UnformattedLines)
994:                yield from self.visit(node)
995:
996:            except FormatOn as f_on:
997:                # This only happens here if somebody says "fmt: on" multiple
998:                # times in a row.
999:                f_on.trim_prefix(node)
1000:                yield from self.visit_default(node)
1001:
1002:            else:
1003:                normalize_prefix(node, inside_brackets=any_open_brackets)
1004:                if node.type not in WHITESPACE:
1005:                    self.current_line.append(node)
1006:        yield from super().visit_default(node)
1007:
1008:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1009:        """Increase indentation level, maybe yield a line."""
1010:        # In blib2to3 INDENT never holds comments.
1011:        yield from self.line(+1)
1012:        yield from self.visit_default(node)
1013:
1014:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1015:        """Decrease indentation level, maybe yield a line."""
1016:        # DEDENT has no value. Additionally, in blib2to3 it never holds comments.
1017:        yield from self.line(-1)
1018:
1019:    def visit_stmt(self, node: Node, keywords: Set[str]) -> Iterator[Line]:
1020:        """Visit a statement.
1021:
1022:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1023:        `def`, `with`, and `class`.
1024:
1025:        The relevant Python language `keywords` for a given statement will be NAME
1026:        leaves within it. This methods puts those on a separate line.
1027:        """
1028:        for child in node.children:
1029:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1030:                yield from self.line()
1031:
1032:            yield from self.visit(child)
1033:
1034:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1035:        """Visit a statement without nested statements."""
1036:        is_suite_like = node.parent and node.parent.type in STATEMENT
1037:        if is_suite_like:
1038:            yield from self.line(+1)
1039:            yield from self.visit_default(node)

Calling tool: grepTool
def generate_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1388:def generate_comments(leaf: Leaf) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1360:            except IndexError:
1361:                return None
1362:
1363:        node = node.parent
1364:    return None
1365:
1366:
1367:def is_delimiter(leaf: Leaf) -> int:
1368:    """Return the priority of the `leaf` delimiter. Return 0 if not delimiter.
1369:
1370:    Higher numbers are higher priority.
1371:    """
1372:    if leaf.type == token.COMMA:
1373:        return COMMA_PRIORITY
1374:
1375:    if leaf.type in COMPARATORS:
1376:        return COMPARATOR_PRIORITY
1377:
1378:    if (
1379:        leaf.type in MATH_OPERATORS
1380:        and leaf.parent
1381:        and leaf.parent.type not in {syms.factor, syms.star_expr}
1382:    ):
1383:        return MATH_PRIORITY
1384:
1385:    return 0
1386:
1387:
1388:def generate_comments(leaf: Leaf) -> Iterator[Leaf]:
1389:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1390:
1391:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1392:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1393:    move because it does away with modifying the grammar to include all the
1394:    possible places in which comments can be placed.
1395:
1396:    The sad consequence for us though is that comments don't "belong" anywhere.
1397:    This is why this function generates simple parentless Leaf objects for
1398:    comments.  We simply don't know what the correct parent should be.
1399:
1400:    No matter though, we can live without this.  We really only need to
1401:    differentiate between inline and standalone comments.  The latter don't
1402:    share the line with any code.
1403:
1404:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1405:    are emitted with a fake STANDALONE_COMMENT token identifier.
1406:    """
1407:    p = leaf.prefix
1408:    if not p:
1409:        return
1410:
1411:    if '#' not in p:
1412:        return
1413:
1414:    consumed = 0
1415:    nlines = 0
1416:    for index, line in enumerate(p.split('\n')):
1417:        consumed += len(line) + 1  # adding the length of the split '\n'
1418:        line = line.lstrip()
1419:        if not line:
1420:            nlines += 1
1421:        if not line.startswith('#'):
1422:            continue
1423:
1424:        if index == 0 and leaf.type != token.ENDMARKER:
1425:            comment_type = token.COMMENT  # simple trailing comment
1426:        else:
1427:            comment_type = STANDALONE_COMMENT
1428:        comment = make_comment(line)
1429:        yield Leaf(comment_type, comment, prefix='\n' * nlines)
1430:
1431:        if comment in {'# fmt: on', '# yapf: enable'}:
1432:            raise FormatOn(consumed)
1433:
1434:        if comment in {'# fmt: off', '# yapf: disable'}:
1435:            raise FormatOff(consumed)
1436:
1437:        nlines = 0
1438:
1439:
1440:def make_comment(content: str) -> str:
1441:    """Return a consistently formatted comment from the given `content` string.
1442:
1443:    All comments (except for "##", "#!", "#:") should have a single space between
1444:    the hash sign and the content.
1445:
1446:    If `content` didn't start with a hash sign, one is provided.
1447:    """
1448:    content = content.rstrip()
1449:    if not content:
1450:        return '#'
1451:
1452:    if content[0] == '#':
1453:        content = content[1:]
1454:    if content and content[0] not in ' !:#':
1455:        content = ' ' + content
1456:    return '#' + content
1457:
1458:
1459:def split_line(
1460:    line: Line, line_length: int, inner: bool = False, py36: bool = False
1461:) -> Iterator[Line]:
1462:    """Split a `line` into potentially many lines.
1463:
1464:    They should fit in the allotted `line_length` but might not be able to.
1465:    `inner` signifies that there were a pair of brackets somewhere around the
1466:    current `line`, possibly transitively. This means we can fallback to splitting
1467:    by delimiters if the LHS/RHS don't yield any results.
1468:
1469:    If `py36` is True, splitting may generate syntax that is only compatible
1470:    with Python 3.6 and later.
1471:    """
1472:    if isinstance(line, UnformattedLines) or line.is_comment:
1473:        yield line
1474:        return
1475:
1476:    line_str = str(line).strip('\n')
1477:    if (
1478:        len(line_str) <= line_length
1479:        and '\n' not in line_str  # multiline strings

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
340:    """Given a lib2to3 node, return its string representation."""
341:    code = str(node)
342:    return code
343:
344:
345:T = TypeVar('T')
346:
347:
348:class Visitor(Generic[T]):
349:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
350:
351:    def visit(self, node: LN) -> Iterator[T]:
352:        """Main method to visit `node` and its children.
353:
354:        It tries to find a `visit_*()` method for the given `node.type`, like
355:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
356:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
357:        instead.
358:
359:        Then yields objects of type `T` from the selected visitor.
360:        """
361:        if node.type < 256:
362:            name = token.tok_name[node.type]
363:        else:
364:            name = type_repr(node.type)
365:        yield from getattr(self, f'visit_{name}', self.visit_default)(node)
366:
367:    def visit_default(self, node: LN) -> Iterator[T]:
368:        """Default `visit_*()` implementation. Recurses to children of `node`."""
369:        if isinstance(node, Node):
370:            for child in node.children:
371:                yield from self.visit(child)
372:
373:
374:@dataclass
375:class DebugVisitor(Visitor[T]):
376:    tree_depth: int = 0
377:
378:    def visit_default(self, node: LN) -> Iterator[T]:
379:        indent = ' ' * (2 * self.tree_depth)
380:        if isinstance(node, Node):
381:            _type = type_repr(node.type)
382:            out(f'{indent}{_type}', fg='yellow')
383:            self.tree_depth += 1
384:            for child in node.children:
385:                yield from self.visit(child)
386:
387:            self.tree_depth -= 1
388:            out(f'{indent}/{_type}', fg='yellow', bold=False)
389:        else:
390:            _type = token.tok_name.get(node.type, str(node.type))
391:            out(f'{indent}{_type}', fg='blue', nl=False)
392:            if node.prefix:
393:                # We don't have to handle prefixes for `Node` objects since
394:                # that delegates to the first child anyway.
395:                out(f' {node.prefix!r}', fg='green', bold=False, nl=False)
396:            out(f' {node.value!r}', fg='blue', bold=False)
397:
398:    @classmethod
399:    def show(cls, code: str) -> None:

Calling tool: grepTool
class BracketTracker|def mark\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:455:class BracketTracker:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:463:    def mark(self, leaf: Leaf) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
440:    token.TILDE,
441:    token.LEFTSHIFT,
442:    token.RIGHTSHIFT,
443:    token.DOUBLESTAR,
444:    token.DOUBLESLASH,
445:}
446:COMPREHENSION_PRIORITY = 20
447:COMMA_PRIORITY = 10
448:LOGIC_PRIORITY = 5
449:STRING_PRIORITY = 4
450:COMPARATOR_PRIORITY = 3
451:MATH_PRIORITY = 1
452:
453:
454:@dataclass
455:class BracketTracker:
456:    """Keeps track of brackets on a line."""
457:
458:    depth: int = 0
459:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
460:    delimiters: Dict[LeafID, Priority] = Factory(dict)
461:    previous: Optional[Leaf] = None
462:
463:    def mark(self, leaf: Leaf) -> None:
464:        """Mark `leaf` with bracket-related metadata. Keep track of delimiters.
465:
466:        All leaves receive an int `bracket_depth` field that stores how deep
467:        within brackets a given leaf is. 0 means there are no enclosing brackets
468:        that started on this line.
469:
470:        If a leaf is itself a closing bracket, it receives an `opening_bracket`
471:        field that it forms a pair with. This is a one-directional link to
472:        avoid reference cycles.
473:
474:        If a leaf is a delimiter (a token on which Black can split the line if
475:        needed) and it's on depth 0, its `id()` is stored in the tracker's
476:        `delimiters` field.
477:        """
478:        if leaf.type == token.COMMENT:
479:            return
480:
481:        if leaf.type in CLOSING_BRACKETS:
482:            self.depth -= 1
483:            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))
484:            leaf.opening_bracket = opening_bracket
485:        leaf.bracket_depth = self.depth
486:        if self.depth == 0:
487:            delim = is_delimiter(leaf)
488:            if delim:
489:                self.delimiters[id(leaf)] = delim
490:            elif self.previous is not None:
491:                if leaf.type == token.STRING and self.previous.type == token.STRING:
492:                    self.delimiters[id(self.previous)] = STRING_PRIORITY
493:                elif (
494:                    leaf.type == token.NAME
495:                    and leaf.value == 'for'
496:                    and leaf.parent
497:                    and leaf.parent.type in {syms.comp_for, syms.old_comp_for}
498:                ):
499:                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY
500:                elif (
501:                    leaf.type == token.NAME
502:                    and leaf.value == 'if'
503:                    and leaf.parent
504:                    and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
505:                ):
506:                    self.delimiters[id(self.previous)] = COMPREHENSION_PRIORITY
507:                elif (
508:                    leaf.type == token.NAME
509:                    and leaf.value in LOGIC_OPERATORS
510:                    and leaf.parent
511:                ):
512:                    self.delimiters[id(self.previous)] = LOGIC_PRIORITY
513:        if leaf.type in OPENING_BRACKETS:
514:            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf
515:            self.depth += 1
516:        self.previous = leaf
517:
518:    def any_open_brackets(self) -> bool:
519:        """Return True if there is an yet unmatched open bracket on the line."""
520:        return bool(self.bracket_match)
521:
522:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
523:        """Return the highest priority of a delimiter found on the line.
524:
525:        Values are consistent with what `is_delimiter()` returns.
526:        """
527:        return max(v for k, v in self.delimiters.items() if k not in exclude)
528:
529:
530:@dataclass
531:class Line:
532:    """Holds leaves and comments. Can be printed with `str(line)`."""
533:
534:    depth: int = 0
535:    leaves: List[Leaf] = Factory(list)
536:    comments: List[Tuple[Index, Leaf]] = Factory(list)
537:    bracket_tracker: BracketTracker = Factory(BracketTracker)
538:    inside_brackets: bool = False
539:    has_for: bool = False
540:    _for_loop_variable: bool = False
541:
542:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
543:        """Add a new `leaf` to the end of the line.
544:
545:        Unless `preformatted` is True, the `leaf` will receive a new consistent
546:        whitespace prefix and metadata applied by :class:`BracketTracker`.
547:        Trailing commas are maybe removed, unpacked for loop variables are
548:        demoted from being delimiters.
549:
550:        Inline comments are put aside.
551:        """
552:        has_value = leaf.value.strip()
553:        if not has_value:
554:            return
555:
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
556:        if self.leaves and not preformatted:
557:            # Note: at this point leaf.prefix should be empty except for
558:            # imports, for which we only preserve newlines.
559:            leaf.prefix += whitespace(leaf)
560:        if self.inside_brackets or not preformatted:
561:            self.maybe_decrement_after_for_loop_variable(leaf)
562:            self.bracket_tracker.mark(leaf)
563:            self.maybe_remove_trailing_comma(leaf)
564:            self.maybe_increment_for_loop_variable(leaf)
565:
566:        if not self.append_comment(leaf):
567:            self.leaves.append(leaf)
568:
569:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
570:        """Like :func:`append()` but disallow invalid standalone comment structure.
571:
572:        Raises ValueError when any `leaf` is appended after a standalone comment
573:        or when a standalone comment is not the first leaf on the line.
574:        """
575:        if self.bracket_tracker.depth == 0:
576:            if self.is_comment:
577:                raise ValueError("cannot append to standalone comments")
578:
579:            if self.leaves and leaf.type == STANDALONE_COMMENT:
580:                raise ValueError(
581:                    "cannot append standalone comments to a populated line"
582:                )
583:
584:        self.append(leaf, preformatted=preformatted)
585:
586:    @property
587:    def is_comment(self) -> bool:
588:        """Is this line a standalone comment?"""
589:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
590:
591:    @property
592:    def is_decorator(self) -> bool:
593:        """Is this line a decorator?"""
594:        return bool(self) and self.leaves[0].type == token.AT
595:
596:    @property
597:    def is_import(self) -> bool:
598:        """Is this an import line?"""
599:        return bool(self) and is_import(self.leaves[0])
600:
601:    @property
602:    def is_class(self) -> bool:
603:        """Is this line a class definition?"""
604:        return (
605:            bool(self)
606:            and self.leaves[0].type == token.NAME
607:            and self.leaves[0].value == 'class'
608:        )
609:
610:    @property
611:    def is_def(self) -> bool:
612:        """Is this a function definition? (Also returns True for async defs.)"""
613:        try:
614:            first_leaf = self.leaves[0]
615:        except IndexError:
616:            return False
617:
618:        try:
619:            second_leaf: Optional[Leaf] = self.leaves[1]
620:        except IndexError:
621:            second_leaf = None
622:        return (
623:            (first_leaf.type == token.NAME and first_leaf.value == 'def')
624:            or (
625:                first_leaf.type == token.ASYNC
626:                and second_leaf is not None
627:                and second_leaf.type == token.NAME
628:                and second_leaf.value == 'def'
629:            )
630:        )
631:
632:    @property
633:    def is_flow_control(self) -> bool:
634:        """Is this line a flow control statement?
635:
636:        Those are `return`, `raise`, `break`, and `continue`.
637:        """
638:        return (
639:            bool(self)
640:            and self.leaves[0].type == token.NAME
641:            and self.leaves[0].value in FLOW_CONTROL
642:        )
643:
644:    @property
645:    def is_yield(self) -> bool:
646:        """Is this line a yield statement?"""
647:        return (
648:            bool(self)
649:            and self.leaves[0].type == token.NAME
650:            and self.leaves[0].value == 'yield'
651:        )
652:
653:    @property
654:    def contains_standalone_comments(self) -> bool:
655:        """If so, needs to be split before emitting."""
656:        for leaf in self.leaves:
657:            if leaf.type == STANDALONE_COMMENT:
658:                return True
659:
660:        return False
661:
662:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
663:        """Remove trailing comma if there is one and it's safe."""
664:        if not (
665:            self.leaves
666:            and self.leaves[-1].type == token.COMMA
667:            and closing.type in CLOSING_BRACKETS
668:        ):
669:            return False
670:
671:        if closing.type == token.RBRACE:
672:            self.remove_trailing_comma()
673:            return True
674:
675:        if closing.type == token.RSQB:
676:            comma = self.leaves[-1]
677:            if comma.parent and comma.parent.type == syms.listmaker:
678:                self.remove_trailing_comma()
679:                return True
680:
681:        # For parens let's check if it's safe to remove the comma.  If the
682:        # trailing one is the only one, we might mistakenly change a tuple
683:        # into a different type by removing the comma.
684:        depth = closing.bracket_depth + 1
685:        commas = 0
686:        opening = closing.opening_bracket
687:        for _opening_index, leaf in enumerate(self.leaves):
688:            if leaf is opening:
689:                break
690:
691:        else:
692:            return False
693:
694:        for leaf in self.leaves[_opening_index + 1:]:
695:            if leaf is closing:
696:                break
697:
698:            bracket_depth = leaf.bracket_depth
699:            if bracket_depth == depth and leaf.type == token.COMMA:
700:                commas += 1
701:                if leaf.parent and leaf.parent.type == syms.arglist:
702:                    commas += 1
703:                    break
704:
705:        if commas > 1:
706:            self.remove_trailing_comma()
707:            return True
708:
709:        return False
710:
711:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
712:        """In a for loop, or comprehension, the variables are often unpacks.
713:
714:        To avoid splitting on the comma in this situation, increase the depth of
715:        tokens between `for` and `in`.

Calling tool: grepTool
inside_brackets
Matched content:
538:    inside_brackets: bool = False
560:        if self.inside_brackets or not preformatted:
1003:                normalize_prefix(node, inside_brackets=any_open_brackets)
1488:    elif line.inside_brackets:
1523:    body = Line(depth=line.depth + 1, inside_brackets=True)
1544:        normalize_prefix(body_leaves[0], inside_brackets=True)
1562:    body = Line(depth=line.depth + 1, inside_brackets=True)
1583:        normalize_prefix(body_leaves[0], inside_brackets=True)
1633:            normalize_prefix(l.leaves[0], inside_brackets=True)
1659:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1756:    if not inside_brackets:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:
1768:def is_python36(node: Node) -> bool:
1769:    """Return True if the current file is using Python 3.6+ features.
1770:
1771:    Currently looking for:
1772:    - f-strings; and
1773:    - trailing commas after * or ** in function signatures.
1774:    """
1775:    for n in node.pre_order():
1776:        if n.type == token.STRING:
1777:            value_head = n.value[:2]  # type: ignore
1778:            if value_head in {'f"', 'F"', "f'", "F'", 'rf', 'fr', 'RF', 'FR'}:
1779:                return True
1780:
1781:        elif (
1782:            n.type == syms.typedargslist
1783:            and n.children
1784:            and n.children[-1].type == token.COMMA
1785:        ):
1786:            for ch in n.children:
1787:                if ch.type == token.STAR or ch.type == token.DOUBLESTAR:
1788:                    return True
1789:
1790:    return False
1791:
1792:
1793:PYTHON_EXTENSIONS = {'.py'}
1794:BLACKLISTED_DIRECTORIES = {
1795:    'build', 'buck-out', 'dist', '_build', '.git', '.hg', '.mypy_cache', '.tox', '.venv'
1796:}
1797:
1798:
1799:def gen_python_files_in_dir(path: Path) -> Iterator[Path]:
1800:    """Generate all files under `path` which aren't under BLACKLISTED_DIRECTORIES
1801:    and have one of the PYTHON_EXTENSIONS.
1802:    """
1803:    for child in path.iterdir():
1804:        if child.is_dir():
1805:            if child.name in BLACKLISTED_DIRECTORIES:
1806:                continue
1807:
1808:            yield from gen_python_files_in_dir(child)
1809:
1810:        elif child.suffix in PYTHON_EXTENSIONS:
1811:            yield child
1812:
1813:
1814:@dataclass
1815:class Report:
1816:    """Provides a reformatting counter. Can be rendered with `str(report)`."""
1817:    check: bool = False
1818:    change_count: int = 0
1819:    same_count: int = 0
1820:    failure_count: int = 0
1821:
1822:    def done(self, src: Path, changed: bool) -> None:
1823:        """Increment the counter for successful reformatting. Write out a message."""
1824:        if changed:
1825:            reformatted = 'would reformat' if self.check else 'reformatted'
1826:            out(f'{reformatted} {src}')
1827:            self.change_count += 1

Calling tool: grepTool
split_line\(
Matched content:
298:        for line in split_line(current_line, line_length=line_length, py36=py36):
1459:def split_line(
1503:                    split_line(l, line_length=line_length, inner=True, py36=py36)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
260:) -> FileContent:
261:    """Reformat contents a file and return new contents.
262:
263:    If `fast` is False, additionally confirm that the reformatted code is
264:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
265:    `line_length` is passed to :func:`format_str`.
266:    """
267:    if src_contents.strip() == '':
268:        raise NothingChanged
269:
270:    dst_contents = format_str(src_contents, line_length=line_length)
271:    if src_contents == dst_contents:
272:        raise NothingChanged
273:
274:    if not fast:
275:        assert_equivalent(src_contents, dst_contents)
276:        assert_stable(src_contents, dst_contents, line_length=line_length)
277:    return dst_contents
278:
279:
280:def format_str(src_contents: str, line_length: int) -> FileContent:
281:    """Reformat a string and return new contents.
282:
283:    `line_length` determines how many characters per line are allowed.
284:    """
285:    src_node = lib2to3_parse(src_contents)
286:    dst_contents = ""
287:    lines = LineGenerator()
288:    elt = EmptyLineTracker()
289:    py36 = is_python36(src_node)
290:    empty_line = Line()
291:    after = 0
292:    for current_line in lines.visit(src_node):
293:        for _ in range(after):
294:            dst_contents += str(empty_line)
295:        before, after = elt.maybe_empty_lines(current_line)
296:        for _ in range(before):
297:            dst_contents += str(empty_line)
298:        for line in split_line(current_line, line_length=line_length, py36=py36):
299:            dst_contents += str(line)
300:    return dst_contents
301:
302:
303:GRAMMARS = [
304:    pygram.python_grammar_no_print_statement_no_exec_statement,
305:    pygram.python_grammar_no_print_statement,
306:    pygram.python_grammar_no_exec_statement,
307:    pygram.python_grammar,
308:]
309:
310:
311:def lib2to3_parse(src_txt: str) -> Node:
312:    """Given a string with source, return the lib2to3 Node."""
313:    grammar = pygram.python_grammar_no_print_statement
314:    if src_txt[-1] != '\n':
315:        nl = '\r\n' if '\r\n' in src_txt[:1024] else '\n'
316:        src_txt += nl
317:    for grammar in GRAMMARS:
318:        drv = driver.Driver(grammar, pytree.convert)
319:        try:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In LineGenerator.visit_default (black.py:970-1006), when any_open_brackets is True, all comments from generate_comments are appended to current_line without emitting lines (lines 975-979). Outside brackets, inline (token.COMMENT) comments are appended then emitted (lines 979-983), while standalone comments flush the current line, are appended, and then emitted (lines 984-989). This matches the requirement that in-bracket comments are subject to splitting and outside-bracket comments are emitted appropriately.

Todo item 15 of 20 is correct
description: 'In LineGenerator.visit_default, verify that when any_open_brackets is True, all generated comments (both inline and standalone) are appended to the current line without immediate line emission, making them subject to splitting; while comments outside brackets are emitted as trailing or standalone appropriately.'

Validating todo item 16 of 20
description: 'Ensure standalone_comment_split exists and splits lines around standalone comments by attempting to append leaves/comments via append_safe and starting new lines when ValueError is raised; verify it yields the final current_line if non-empty.'

Calling tool: grepTool
def standalone_comment_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: standalone_comment_split exists and implements the described behavior: it attempts to append both leaves and comments via append_safe (lines 17191730), on ValueError it yields the current line and starts a new one (lines 17211724), and it yields the final current_line if present (lines 17321733).

Todo item 16 of 20 is correct
description: 'Ensure standalone_comment_split exists and splits lines around standalone comments by attempting to append leaves/comments via append_safe and starting new lines when ValueError is raised; verify it yields the final current_line if non-empty.'

Validating todo item 17 of 20
description: 'Critically check standalone_comment_split's precondition: it should only raise CannotSplit when there are no STANDALONE_COMMENT leaves on the line. Verify whether the current implementation's bracket_depth check incorrectly restricts triggering to comments with bracket_depth == 0 and adjust expectations accordingly.'

Calling tool: grepTool
def standalone_comment_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py:1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-22/good/black/black.py
1670:
1671:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1672:            current_line.append(leaf)
1673:
1674:    for leaf in line.leaves:
1675:        yield from append_to_line(leaf)
1676:
1677:        for comment_after in line.comments_after(leaf):
1678:            yield from append_to_line(comment_after)
1679:
1680:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
1681:        if (
1682:            leaf.bracket_depth == lowest_depth
1683:            and leaf.type == token.STAR
1684:            or leaf.type == token.DOUBLESTAR
1685:        ):
1686:            trailing_comma_safe = trailing_comma_safe and py36
1687:        leaf_priority = delimiters.get(id(leaf))
1688:        if leaf_priority == delimiter_priority:
1689:            yield current_line
1690:
1691:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1692:    if current_line:
1693:        if (
1694:            delimiter_priority == COMMA_PRIORITY
1695:            and current_line.leaves[-1].type != token.COMMA
1696:            and trailing_comma_safe
1697:        ):
1698:            current_line.append(Leaf(token.COMMA, ','))
1699:        yield current_line
1700:
1701:
1702:@dont_increase_indentation
1703:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
1704:    """Split standalone comments from the rest of the line."""
1705:    for leaf in line.leaves:
1706:        if leaf.type == STANDALONE_COMMENT:
1707:            if leaf.bracket_depth == 0:
1708:                break
1709:
1710:    else:
1711:        raise CannotSplit("Line does not have any standalone comments")
1712:
1713:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1714:
1715:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
1716:        """Append `leaf` to current line or to new line if appending impossible."""
1717:        nonlocal current_line
1718:        try:
1719:            current_line.append_safe(leaf, preformatted=True)
1720:        except ValueError as ve:
1721:            yield current_line
1722:
1723:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
1724:            current_line.append(leaf)
1725:
1726:    for leaf in line.leaves:
1727:        yield from append_to_line(leaf)
1728:
1729:        for comment_after in line.comments_after(leaf):
1730:            yield from append_to_line(comment_after)
1731:
1732:    if current_line:
1733:        yield current_line
1734:
1735:
1736:def is_import(leaf: Leaf) -> bool:
1737:    """Return True if the given leaf starts an import statement."""
1738:    p = leaf.parent
1739:    t = leaf.type
1740:    v = leaf.value
1741:    return bool(
1742:        t == token.NAME
1743:        and (
1744:            (v == 'import' and p and p.type == syms.import_name)
1745:            or (v == 'from' and p and p.type == syms.import_from)
1746:        )
1747:    )
1748:
1749:
1750:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
1751:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
1752:    else.
1753:
1754:    Note: don't use backslashes for formatting or you'll lose your voting rights.
1755:    """
1756:    if not inside_brackets:
1757:        spl = leaf.prefix.split('#')
1758:        if '\\' not in spl[0]:
1759:            nl_count = spl[-1].count('\n')
1760:            if len(spl) > 1:
1761:                nl_count -= 1
1762:            leaf.prefix = '\n' * nl_count
1763:            return
1764:
1765:    leaf.prefix = ''
1766:
1767:
1768:def is_python36(node: Node) -> bool:
1769:    """Return True if the current file is using Python 3.6+ features.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: standalone_comment_split checks for a STANDALONE_COMMENT with bracket_depth == 0 before allowing splitting (black.py:1705-1711). This causes CannotSplit to be raised even when STANDALONE_COMMENT leaves exist inside brackets, violating the requirement that it should only raise when there are no STANDALONE_COMMENT leaves at all.


=== PHASE 2 COMPLETE ===

