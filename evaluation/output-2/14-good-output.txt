=== PHASE 1: ANALYSIS ===

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2895:
2896:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2897:                # Empty brackets would fail a split so treat them as "inner"
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py
1:#!/usr/bin/env python2
2:from __future__ import unicode_literals as _unicode_literals
3:from __future__ import absolute_import
4:from __future__ import print_function as lol, with_function
5:
6:u'hello'
7:U"hello"
8:Ur"hello"
9:
10:# output
11:
12:
13:#!/usr/bin/env python2
14:from __future__ import unicode_literals as _unicode_literals
15:from __future__ import absolute_import
16:from __future__ import print_function as lol, with_function
17:
18:"hello"
19:"hello"
20:r"hello"

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generator,
24:    Generic,
25:    Iterable,
26:    Iterator,
27:    List,
28:    Optional,
29:    Pattern,
30:    Sequence,
31:    Set,
32:    Tuple,
33:    TypeVar,
34:    Union,
35:    cast,
36:)
37:
38:from appdirs import user_cache_dir
39:from attr import dataclass, Factory
40:import click
41:import toml
42:
43:# lib2to3 fork
44:from blib2to3.pytree import Node, Leaf, type_repr
45:from blib2to3 import pygram, pytree
46:from blib2to3.pgen2 import driver, token
47:from blib2to3.pgen2.parse import ParseError
48:
49:
50:__version__ = "18.6b4"

Calling tool: grepTool
type LN\b
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
\bLN\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/debug_visitor.py:5:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/debug_visitor.out:85: 'LN'
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:68:LN = Union[Leaf, Node]
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:686:    def visit(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:702:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:713:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1423:    def visit_default(self, node: LN) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1812:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1830:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1832:    node: Optional[LN] = descendant
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1838:def container_of(leaf: Leaf) -> LN:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1844:    container: LN = leaf
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1972:def generate_comments(leaf: LN) -> Iterator[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2617:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2622:    container: Optional[LN] = container_of(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2633:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2657:def is_empty_tuple(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2667:def is_one_tuple(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2690:def is_yield(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2753:def is_stub_body(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2769:def max_delimiter_priority_in_atom(node: LN) -> int:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
60:FileContent = str
61:Encoding = str
62:NewLine = str
63:Depth = int
64:NodeType = int
65:LeafID = int
66:Priority = int
67:Index = int
68:LN = Union[Leaf, Node]
69:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
70:Timestamp = float
71:FileSize = int
72:CacheInfo = Tuple[Timestamp, FileSize]
73:Cache = Dict[Path, CacheInfo]
74:out = partial(click.secho, bold=True, err=True)
75:err = partial(click.secho, fg="red", err=True)
76:
77:pygram.initialize(CACHE_DIR)
78:syms = pygram.python_symbols
79:

Calling tool: grepTool
get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:599:    future_imports = get_future_imports(src_node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:719:        self.assertEqual(set(), black.get_future_imports(node))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:721:        self.assertEqual({"black"}, black.get_future_imports(node))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:731:        self.assertEqual({"black"}, black.get_future_imports(node))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:733:        self.assertEqual({"black"}, black.get_future_imports(node))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:735:        self.assertEqual(set(), black.get_future_imports(node))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:737:        self.assertEqual(set(), black.get_future_imports(node))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
580:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
581:    if src_contents == dst_contents:
582:        raise NothingChanged
583:
584:    if not fast:
585:        assert_equivalent(src_contents, dst_contents)
586:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
587:    return dst_contents
588:
589:
590:def format_str(
591:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
592:) -> FileContent:
593:    """Reformat a string and return new contents.
594:
595:    `line_length` determines how many characters per line are allowed.
596:    """
597:    src_node = lib2to3_parse(src_contents)
598:    dst_contents = ""
599:    future_imports = get_future_imports(src_node)
600:    is_pyi = bool(mode & FileMode.PYI)
601:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
602:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
603:    normalize_fmt_off(src_node)
604:    lines = LineGenerator(
605:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
606:        is_pyi=is_pyi,
607:        normalize_strings=normalize_strings,
608:    )
609:    elt = EmptyLineTracker(is_pyi=is_pyi)
610:    empty_line = Line()
611:    after = 0
612:    for current_line in lines.visit(src_node):
613:        for _ in range(after):
614:            dst_contents += str(empty_line)
615:        before, after = elt.maybe_empty_lines(current_line)
616:        for _ in range(before):
617:            dst_contents += str(empty_line)
618:        for line in split_line(current_line, line_length=line_length, py36=py36):
619:            dst_contents += str(line)

Calling tool: createTodo
Todo List Created
Todo List (16 items):
- [ ] Verify typing imports in black.py include Generator, as used by get_imports_from_children annotation. (ID: todo-1)
- [ ] In black.py, confirm get_future_imports returns Set[str] and initializes imports with a typed Set[str]. (ID: todo-2)
- [ ] Validate get_future_imports defines helper get_imports_from_children(children: List[LN]) -> Generator[str, None, None]. (ID: todo-3)
- [ ] Check that get_imports_from_children yields only original import names: for Leaf children, it yields when child.type == token.NAME; commas/parentheses are ignored since they are non-NAME Leaves. (ID: todo-4)
- [ ] Check that in get_imports_from_children, when encountering syms.import_as_name, it yields the first child (original name) and does not yield the alias (ensuring alias names like 'lol' are not included). (ID: todo-5)
- [ ] Check that in get_imports_from_children, when encountering syms.import_as_names, it recurses into its children to collect names (covering multiple and mixed alias/non-alias imports). (ID: todo-6)
- [ ] Ensure get_imports_from_children contains only the allowed Node type branches (import_as_name, import_as_names) and asserts False for any other Node types. (ID: todo-7)
- [ ] In get_future_imports, verify it iterates over node.children while child.type == syms.simple_stmt and stops otherwise (breaks on first non-simple_stmt). (ID: todo-8)
- [ ] In get_future_imports, verify that a leading docstring (STRING followed by NEWLINE) is allowed and skipped; otherwise encountering a Leaf first_child causes a break (ensuring only top-of-file future imports are considered). (ID: todo-9)
- [ ] In get_future_imports, validate it only processes 'from __future__ import ...' statements by checking first_child.type == syms.import_from and module_name Leaf value == '__future__'; otherwise it breaks. (ID: todo-10)
- [ ] In get_future_imports, validate it collects imported names by calling get_imports_from_children on first_child.children[3:] (after the 'import' token), and unions the resulting set into imports. (ID: todo-11)
- [ ] Confirm format_str reads future_imports = get_future_imports(src_node) and sets remove_u_prefix to py36 or 'unicode_literals' in future_imports (tie-in to PR behavior). (ID: todo-12)
- [ ] Review tests/test_black.py::test_get_future_imports to ensure added cases cover aliasing: 'from __future__ import unicode_literals as _unicode_literals' should yield {'unicode_literals'}, and 'from __future__ import unicode_literals as _lol, print' should yield {'unicode_literals', 'print'}. (ID: todo-13)
- [ ] Check tests/test_black.py::test_get_future_imports also retains existing cases: empty input, single name, multiple names, parenthesized list, multiple lines, comment/docstring before imports, non-top-of-file code before import, and non-__future__ module import. (ID: todo-14)
- [ ] Validate tests/data/python2_unicode_literals.py input segment includes: from __future__ import unicode_literals as _unicode_literals; from __future__ import absolute_import; from __future__ import print_function as lol, with_function; and contains u-prefixed literals. (ID: todo-15)
- [ ] Validate tests/data/python2_unicode_literals.py expected segment mirrors the same future imports and has the 'u' prefixes removed from string literals (indirectly asserting remove_u_prefix behavior works with aliased unicode_literals). (ID: todo-16)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 16
description: 'Verify typing imports in black.py include Generator, as used by get_imports_from_children annotation.'
Calling tool: grepTool
from typing import \(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:18:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generator,
24:    Generic,
25:    Iterable,
26:    Iterator,
27:    List,
28:    Optional,
29:    Pattern,
30:    Sequence,
31:    Set,
32:    Tuple,
33:    TypeVar,
34:    Union,
35:    cast,
36:)
37:
38:from appdirs import user_cache_dir
39:from attr import dataclass, Factory
40:import click
41:import toml
42:
43:# lib2to3 fork
44:from blib2to3.pytree import Node, Leaf, type_repr
45:from blib2to3 import pygram, pytree
46:from blib2to3.pgen2 import driver, token
47:from blib2to3.pgen2.parse import ParseError
48:
49:
50:__version__ = "18.6b4"
51:DEFAULT_LINE_LENGTH = 88
52:DEFAULT_EXCLUDES = (
53:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
54:)
55:DEFAULT_INCLUDES = r"\.pyi?$"
56:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
57:
58:
59:# types
60:FileContent = str

Calling tool: grepTool
get_imports_from_children
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2927:                yield from get_imports_from_children(child.children)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2949:            imports |= set(get_imports_from_children(first_child.children[3:]))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, the typing import list includes Generator (line 23), and get_imports_from_children is annotated to return Generator[str, None, None] (line 2916). Thus, the necessary typing import is present.


Todo item 1 of 16 is correct
description: 'Verify typing imports in black.py include Generator, as used by get_imports_from_children annotation.'
Validating todo item 2 of 16
description: 'In black.py, confirm get_future_imports returns Set[str] and initializes imports with a typed Set[str].'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, get_future_imports is annotated to return Set[str] (line 2912) and the variable is initialized with a typed Set[str] via `imports: Set[str] = set()` (line 2914), as verified by reading the implementation.


Todo item 2 of 16 is correct
description: 'In black.py, confirm get_future_imports returns Set[str] and initializes imports with a typed Set[str].'
Validating todo item 3 of 16
description: 'Validate get_future_imports defines helper get_imports_from_children(children: List[LN]) -> Generator[str, None, None].'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)

Calling tool: grepTool
from typing import \(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:18:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generator,
24:    Generic,
25:    Iterable,
26:    Iterator,
27:    List,
28:    Optional,
29:    Pattern,
30:    Sequence,
31:    Set,
32:    Tuple,
33:    TypeVar,
34:    Union,
35:    cast,
36:)
37:
38:from appdirs import user_cache_dir
39:from attr import dataclass, Factory
40:import click
41:import toml
42:
43:# lib2to3 fork
44:from blib2to3.pytree import Node, Leaf, type_repr
45:from blib2to3 import pygram, pytree
46:from blib2to3.pgen2 import driver, token
47:from blib2to3.pgen2.parse import ParseError
48:
49:
50:__version__ = "18.6b4"

Calling tool: grepTool
\bLN\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:68:LN = Union[Leaf, Node]
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:686:    def visit(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:702:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:713:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1423:    def visit_default(self, node: LN) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1812:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1830:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1832:    node: Optional[LN] = descendant
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1838:def container_of(leaf: Leaf) -> LN:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1844:    container: LN = leaf
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1972:def generate_comments(leaf: LN) -> Iterator[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2617:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2622:    container: Optional[LN] = container_of(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2633:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2657:def is_empty_tuple(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2667:def is_one_tuple(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2690:def is_yield(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2753:def is_stub_body(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2769:def max_delimiter_priority_in_atom(node: LN) -> int:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/debug_visitor.py:5:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/debug_visitor.out:85: 'LN'

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
60:FileContent = str
61:Encoding = str
62:NewLine = str
63:Depth = int
64:NodeType = int
65:LeafID = int
66:Priority = int
67:Index = int
68:LN = Union[Leaf, Node]
69:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
70:Timestamp = float
71:FileSize = int
72:CacheInfo = Tuple[Timestamp, FileSize]
73:Cache = Dict[Path, CacheInfo]
74:out = partial(click.secho, bold=True, err=True)
75:err = partial(click.secho, fg="red", err=True)
76:
77:pygram.initialize(CACHE_DIR)
78:syms = pygram.python_symbols
79:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, get_future_imports defines a nested helper at line 2916: `def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:` which matches the required signature. The typing import includes Generator, and LN is defined, so the signature is valid.


Todo item 3 of 16 is correct
description: 'Validate get_future_imports defines helper get_imports_from_children(children: List[LN]) -> Generator[str, None, None].'
Validating todo item 4 of 16
description: 'Check that get_imports_from_children yields only original import names: for Leaf children, it yields when child.type == token.NAME; commas/parentheses are ignored since they are non-NAME Leaves.'
Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pyâ€™s get_future_imports, the helper get_imports_from_children yields only when encountering Leaf nodes of type token.NAME, ignoring commas/parentheses. For aliases (import_as_name), it yields the original name (child.children[0]). Tests confirm expected behavior.


Todo item 4 of 16 is correct
description: 'Check that get_imports_from_children yields only original import names: for Leaf children, it yields when child.type == token.NAME; commas/parentheses are ignored since they are non-NAME Leaves.'
Validating todo item 5 of 16
description: 'Check that in get_imports_from_children, when encountering syms.import_as_name, it yields the first child (original name) and does not yield the alias (ensuring alias names like 'lol' are not included).'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pyâ€™s get_future_imports, the helper get_imports_from_children handles syms.import_as_name by selecting child.children[0] (the original name) and yielding only that value. It does not descend into the alias; import_as_names causes recursion over its children (import_as_name nodes), ensuring aliases like â€˜lolâ€™ arenâ€™t included. Tests confirm this behavior.


Todo item 5 of 16 is correct
description: 'Check that in get_imports_from_children, when encountering syms.import_as_name, it yields the first child (original name) and does not yield the alias (ensuring alias names like 'lol' are not included).'
Validating todo item 6 of 16
description: 'Check that in get_imports_from_children, when encountering syms.import_as_names, it recurses into its children to collect names (covering multiple and mixed alias/non-alias imports).'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2895:
2896:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2897:                # Empty brackets would fail a split so treat them as "inner"
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:
3005:    If no directory in the tree contains a marker that would specify it's the
3006:    project root, the root of the file system is returned.
3007:    """
3008:    if not srcs:
3009:        return Path("/").resolve()
3010:
3011:    common_base = min(Path(src).resolve() for src in srcs)
3012:    if common_base.is_dir():
3013:        # Append a fake file so `parents` below returns `common_base_dir`, too.
3014:        common_base /= "fake-file"

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, get_imports_from_children explicitly handles syms.import_as_names by recursing into its children (yield from get_imports_from_children(child.children)), ensuring multiple and mixed alias/non-alias imports are collected. Tests include such cases and this implementation covers them.


Todo item 6 of 16 is correct
description: 'Check that in get_imports_from_children, when encountering syms.import_as_names, it recurses into its children to collect names (covering multiple and mixed alias/non-alias imports).'
Validating todo item 7 of 16
description: 'Ensure get_imports_from_children contains only the allowed Node type branches (import_as_name, import_as_names) and asserts False for any other Node types.'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Inside get_imports_from_children, the only Node type branches are for syms.import_as_name and syms.import_as_names; any other non-Leaf node hits an assert False. Leaf NAMEs are yielded, which doesnâ€™t add additional Node type branches.


Todo item 7 of 16 is correct
description: 'Ensure get_imports_from_children contains only the allowed Node type branches (import_as_name, import_as_names) and asserts False for any other Node types.'
Validating todo item 8 of 16
description: 'In get_future_imports, verify it iterates over node.children while child.type == syms.simple_stmt and stops otherwise (breaks on first non-simple_stmt).'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pyâ€™s get_future_imports, the loop over node.children immediately breaks on the first child whose type != syms.simple_stmt (lines 2931-2934), ensuring it iterates only while children are simple_stmt. This matches the todo requirement.


Todo item 8 of 16 is correct
description: 'In get_future_imports, verify it iterates over node.children while child.type == syms.simple_stmt and stops otherwise (breaks on first non-simple_stmt).'
Validating todo item 9 of 16
description: 'In get_future_imports, verify that a leading docstring (STRING followed by NEWLINE) is allowed and skipped; otherwise encountering a Leaf first_child causes a break (ensuring only top-of-file future imports are considered).'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py lines 2935-2944, get_future_imports explicitly skips a leading docstring by continuing when it sees a simple_stmt composed of STRING followed by NEWLINE; otherwise, encountering a Leaf first_child triggers a break, ensuring only top-of-file future imports are considered.


Todo item 9 of 16 is correct
description: 'In get_future_imports, verify that a leading docstring (STRING followed by NEWLINE) is allowed and skipped; otherwise encountering a Leaf first_child causes a break (ensuring only top-of-file future imports are considered).'
Validating todo item 10 of 16
description: 'In get_future_imports, validate it only processes 'from __future__ import ...' statements by checking first_child.type == syms.import_from and module_name Leaf value == '__future__'; otherwise it breaks.'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In get_future_imports, the code explicitly checks that first_child.type == syms.import_from and then validates the module_name is a Leaf with value "__future__"; if not, it breaks. This ensures only 'from __future__ import ...' is processed.


Todo item 10 of 16 is correct
description: 'In get_future_imports, validate it only processes 'from __future__ import ...' statements by checking first_child.type == syms.import_from and module_name Leaf value == '__future__'; otherwise it breaks.'
Validating todo item 11 of 16
description: 'In get_future_imports, validate it collects imported names by calling get_imports_from_children on first_child.children[3:] (after the 'import' token), and unions the resulting set into imports.'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py get_future_imports, the code now calls get_imports_from_children on first_child.children[3:] and unions the result into imports (line 2949), exactly matching the requirement to collect imported names after the 'import' token.


Todo item 11 of 16 is correct
description: 'In get_future_imports, validate it collects imported names by calling get_imports_from_children on first_child.children[3:] (after the 'import' token), and unions the resulting set into imports.'
Validating todo item 12 of 16
description: 'Confirm format_str reads future_imports = get_future_imports(src_node) and sets remove_u_prefix to py36 or 'unicode_literals' in future_imports (tie-in to PR behavior).'
Calling tool: grepTool
def format_str\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:590:def format_str(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
560:            f.write(diff(src, dst, src_name, dst_name))
561:        f.detach()
562:
563:
564:def format_file_contents(
565:    src_contents: str,
566:    *,
567:    line_length: int,
568:    fast: bool,
569:    mode: FileMode = FileMode.AUTO_DETECT,
570:) -> FileContent:
571:    """Reformat contents a file and return new contents.
572:
573:    If `fast` is False, additionally confirm that the reformatted code is
574:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
575:    `line_length` is passed to :func:`format_str`.
576:    """
577:    if src_contents.strip() == "":
578:        raise NothingChanged
579:
580:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
581:    if src_contents == dst_contents:
582:        raise NothingChanged
583:
584:    if not fast:
585:        assert_equivalent(src_contents, dst_contents)
586:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
587:    return dst_contents
588:
589:
590:def format_str(
591:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
592:) -> FileContent:
593:    """Reformat a string and return new contents.
594:
595:    `line_length` determines how many characters per line are allowed.
596:    """
597:    src_node = lib2to3_parse(src_contents)
598:    dst_contents = ""
599:    future_imports = get_future_imports(src_node)
600:    is_pyi = bool(mode & FileMode.PYI)
601:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
602:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
603:    normalize_fmt_off(src_node)
604:    lines = LineGenerator(
605:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
606:        is_pyi=is_pyi,
607:        normalize_strings=normalize_strings,
608:    )
609:    elt = EmptyLineTracker(is_pyi=is_pyi)
610:    empty_line = Line()
611:    after = 0
612:    for current_line in lines.visit(src_node):
613:        for _ in range(after):
614:            dst_contents += str(empty_line)
615:        before, after = elt.maybe_empty_lines(current_line)
616:        for _ in range(before):
617:            dst_contents += str(empty_line)
618:        for line in split_line(current_line, line_length=line_length, py36=py36):
619:            dst_contents += str(line)
620:    return dst_contents
621:
622:
623:def decode_bytes(src: bytes) -> Tuple[FileContent, Encoding, NewLine]:
624:    """Return a tuple of (decoded_contents, encoding, newline).
625:
626:    `newline` is either CRLF or LF but `decoded_contents` is decoded with
627:    universal newlines (i.e. only contains LF).
628:    """
629:    srcbuf = io.BytesIO(src)
630:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
631:    if not lines:
632:        return "", encoding, "\n"
633:
634:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
635:    srcbuf.seek(0)
636:    with io.TextIOWrapper(srcbuf, encoding) as tiow:
637:        return tiow.read(), encoding, newline
638:
639:
640:GRAMMARS = [
641:    pygram.python_grammar_no_print_statement_no_exec_statement,
642:    pygram.python_grammar_no_print_statement,
643:    pygram.python_grammar,
644:]
645:
646:
647:def lib2to3_parse(src_txt: str) -> Node:
648:    """Given a string with source, return the lib2to3 Node."""
649:    grammar = pygram.python_grammar_no_print_statement
650:    if src_txt[-1:] != "\n":
651:        src_txt += "\n"
652:    for grammar in GRAMMARS:
653:        drv = driver.Driver(grammar, pytree.convert)
654:        try:
655:            result = drv.parse_string(src_txt, True)
656:            break
657:
658:        except ParseError as pe:
659:            lineno, column = pe.context[1]

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py format_str() (lines ~597-609) assigns future_imports = get_future_imports(src_node) and initializes LineGenerator with remove_u_prefix=py36 or 'unicode_literals' in future_imports, satisfying the specified behavior.


Todo item 12 of 16 is correct
description: 'Confirm format_str reads future_imports = get_future_imports(src_node) and sets remove_u_prefix to py36 or 'unicode_literals' in future_imports (tie-in to PR behavior).'
Validating todo item 13 of 16
description: 'Review tests/test_black.py::test_get_future_imports to ensure added cases cover aliasing: 'from __future__ import unicode_literals as _unicode_literals' should yield {'unicode_literals'}, and 'from __future__ import unicode_literals as _lol, print' should yield {'unicode_literals', 'print'}.'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The test `tests/test_black.py::test_get_future_imports` includes the two aliasing cases and asserts the expected sets. The updated `get_future_imports` implementation collects original names from `import_as_name` and `import_as_names`, correctly yielding {'unicode_literals'} and {'unicode_literals', 'print'} for the scenarios.


Todo item 13 of 16 is correct
description: 'Review tests/test_black.py::test_get_future_imports to ensure added cases cover aliasing: 'from __future__ import unicode_literals as _unicode_literals' should yield {'unicode_literals'}, and 'from __future__ import unicode_literals as _lol, print' should yield {'unicode_literals', 'print'}.'
Validating todo item 14 of 16
description: 'Check tests/test_black.py::test_get_future_imports also retains existing cases: empty input, single name, multiple names, parenthesized list, multiple lines, comment/docstring before imports, non-top-of-file code before import, and non-__future__ module import.'
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2890:                inner_brackets.add(id(leaf))
2891:        elif leaf.type in CLOSING_BRACKETS:
2892:            if not leaf.value:
2893:                optional_brackets.add(id(opening_bracket))
2894:                continue
2895:
2896:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2897:                # Empty brackets would fail a split so treat them as "inner"
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:
3005:    If no directory in the tree contains a marker that would specify it's the
3006:    project root, the root of the file system is returned.
3007:    """
3008:    if not srcs:
3009:        return Path("/").resolve()

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):
780:            black.format_file_contents(same, line_length=ll, fast=False)
781:        different = "l = [1,2,3]"
782:        expected = same
783:        actual = black.format_file_contents(different, line_length=ll, fast=False)
784:        self.assertEqual(expected, actual)
785:        invalid = "return if you can"
786:        with self.assertRaises(ValueError) as e:
787:            black.format_file_contents(invalid, line_length=ll, fast=False)
788:        self.assertEqual(str(e.exception), "Cannot parse: 1:7: return if you can")
789:
790:    def test_endmarker(self) -> None:
791:        n = black.lib2to3_parse("\n")
792:        self.assertEqual(n.type, black.syms.file_input)
793:        self.assertEqual(len(n.children), 1)
794:        self.assertEqual(n.children[0].type, black.token.ENDMARKER)
795:
796:    @unittest.skipIf(os.environ.get("SKIP_AST_PRINT"), "user set SKIP_AST_PRINT")
797:    def test_assertFormatEqual(self) -> None:
798:        out_lines = []
799:        err_lines = []
800:
801:        def out(msg: str, **kwargs: Any) -> None:
802:            out_lines.append(msg)
803:
804:        def err(msg: str, **kwargs: Any) -> None:
805:            err_lines.append(msg)
806:
807:        with patch("black.out", out), patch("black.err", err):
808:            with self.assertRaises(AssertionError):
809:                self.assertFormatEqual("l = [1, 2, 3]", "l = [1, 2, 3,]")

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified get_future_imports implementation. It still handles: empty input (breaks immediately), single/multiple names and parenthesized lists (collects token.NAME via helper), multiple lines (loops over consecutive import_from), comment/docstring before imports (docstring is skipped, comments ignored by parser), non-top-of-file code (breaks on first non-docstring Leaf), and non-__future__ module import (breaks when module name not __future__). Tests in tests/test_black.py cover these and align with the logic.


Todo item 14 of 16 is correct
description: 'Check tests/test_black.py::test_get_future_imports also retains existing cases: empty input, single name, multiple names, parenthesized list, multiple lines, comment/docstring before imports, non-top-of-file code before import, and non-__future__ module import.'
Validating todo item 15 of 16
description: 'Validate tests/data/python2_unicode_literals.py input segment includes: from __future__ import unicode_literals as _unicode_literals; from __future__ import absolute_import; from __future__ import print_function as lol, with_function; and contains u-prefixed literals.'
Calling tool: grepTool
from __future__ import unicode_literals as _unicode_literals
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:2:from __future__ import unicode_literals as _unicode_literals
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:14:from __future__ import unicode_literals as _unicode_literals
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:739:            "from __future__ import unicode_literals as _unicode_literals"

Calling tool: grepTool
from __future__ import absolute_import
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:3:from __future__ import absolute_import
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:15:from __future__ import absolute_import

Calling tool: grepTool
from __future__ import print_function as lol, with_function
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:4:from __future__ import print_function as lol, with_function
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:16:from __future__ import print_function as lol, with_function

Calling tool: grepTool
u'hello'
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:6:u'hello'

Calling tool: grepTool
U"hello"
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:7:U"hello"

Calling tool: grepTool
Ur"hello"
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:8:Ur"hello"

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py
1:#!/usr/bin/env python2
2:from __future__ import unicode_literals as _unicode_literals
3:from __future__ import absolute_import
4:from __future__ import print_function as lol, with_function
5:
6:u'hello'
7:U"hello"
8:Ur"hello"
9:
10:# output
11:
12:
13:#!/usr/bin/env python2
14:from __future__ import unicode_literals as _unicode_literals
15:from __future__ import absolute_import
16:from __future__ import print_function as lol, with_function
17:
18:"hello"
19:"hello"
20:r"hello"

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified tests/data/python2_unicode_literals.py contains the specified future imports with aliasing and includes u-prefixed literals in the input segment (lines 1â€“8). The content matches the diff and test expectations.


Todo item 15 of 16 is correct
description: 'Validate tests/data/python2_unicode_literals.py input segment includes: from __future__ import unicode_literals as _unicode_literals; from __future__ import absolute_import; from __future__ import print_function as lol, with_function; and contains u-prefixed literals.'
Validating todo item 16 of 16
description: 'Validate tests/data/python2_unicode_literals.py expected segment mirrors the same future imports and has the 'u' prefixes removed from string literals (indirectly asserting remove_u_prefix behavior works with aliased unicode_literals).'
Calling tool: grepTool
python2_unicode_literals\.py
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_patchfile.info:1:black.py;tests/data/python2_unicode_literals.py;

Calling tool: globTool
**/tests/data/python2_unicode_literals.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py
1:#!/usr/bin/env python2
2:from __future__ import unicode_literals as _unicode_literals
3:from __future__ import absolute_import
4:from __future__ import print_function as lol, with_function
5:
6:u'hello'
7:U"hello"
8:Ur"hello"
9:
10:# output
11:
12:
13:#!/usr/bin/env python2
14:from __future__ import unicode_literals as _unicode_literals
15:from __future__ import absolute_import
16:from __future__ import print_function as lol, with_function
17:
18:"hello"
19:"hello"
20:r"hello"

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Inspected tests/data/python2_unicode_literals.py. The expected segment mirrors the same __future__ imports (including the aliasing) and the output strings have the â€˜uâ€™ prefix removed (u/Ur -> plain/r), thus asserting remove_u_prefix behavior works with aliased unicode_literals.


Todo item 16 of 16 is correct
description: 'Validate tests/data/python2_unicode_literals.py expected segment mirrors the same future imports and has the 'u' prefixes removed from string literals (indirectly asserting remove_u_prefix behavior works with aliased unicode_literals).'
Validating todo item 1 of 16
description: 'Verify typing imports in black.py include Generator, as used by get_imports_from_children annotation.'

Calling tool: grepTool
from typing import \(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:18:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generator,
24:    Generic,
25:    Iterable,
26:    Iterator,
27:    List,
28:    Optional,
29:    Pattern,
30:    Sequence,
31:    Set,
32:    Tuple,
33:    TypeVar,
34:    Union,
35:    cast,
36:)
37:
38:from appdirs import user_cache_dir
39:from attr import dataclass, Factory
40:import click
41:import toml
42:
43:# lib2to3 fork
44:from blib2to3.pytree import Node, Leaf, type_repr
45:from blib2to3 import pygram, pytree
46:from blib2to3.pgen2 import driver, token
47:from blib2to3.pgen2.parse import ParseError
48:
49:
50:__version__ = "18.6b4"
51:DEFAULT_LINE_LENGTH = 88
52:DEFAULT_EXCLUDES = (
53:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
54:)
55:DEFAULT_INCLUDES = r"\.pyi?$"
56:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
57:
58:
59:# types
60:FileContent = str

Calling tool: grepTool
get_imports_from_children
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2927:                yield from get_imports_from_children(child.children)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2949:            imports |= set(get_imports_from_children(first_child.children[3:]))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, the typing import list includes Generator (line 23), and get_imports_from_children is annotated to return Generator[str, None, None] (line 2916). Thus, the necessary typing import is present.

Todo item 1 of 16 is correct
description: 'Verify typing imports in black.py include Generator, as used by get_imports_from_children annotation.'

Validating todo item 2 of 16
description: 'In black.py, confirm get_future_imports returns Set[str] and initializes imports with a typed Set[str].'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, get_future_imports is annotated to return Set[str] (line 2912) and the variable is initialized with a typed Set[str] via `imports: Set[str] = set()` (line 2914), as verified by reading the implementation.

Todo item 2 of 16 is correct
description: 'In black.py, confirm get_future_imports returns Set[str] and initializes imports with a typed Set[str].'

Validating todo item 3 of 16
description: 'Validate get_future_imports defines helper get_imports_from_children(children: List[LN]) -> Generator[str, None, None].'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)

Calling tool: grepTool
from typing import \(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:18:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generator,
24:    Generic,
25:    Iterable,
26:    Iterator,
27:    List,
28:    Optional,
29:    Pattern,
30:    Sequence,
31:    Set,
32:    Tuple,
33:    TypeVar,
34:    Union,
35:    cast,
36:)
37:
38:from appdirs import user_cache_dir
39:from attr import dataclass, Factory
40:import click
41:import toml
42:
43:# lib2to3 fork
44:from blib2to3.pytree import Node, Leaf, type_repr
45:from blib2to3 import pygram, pytree
46:from blib2to3.pgen2 import driver, token
47:from blib2to3.pgen2.parse import ParseError
48:
49:
50:__version__ = "18.6b4"

Calling tool: grepTool
\bLN\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:68:LN = Union[Leaf, Node]
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:686:    def visit(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:702:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:713:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1423:    def visit_default(self, node: LN) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1812:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1830:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1832:    node: Optional[LN] = descendant
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1838:def container_of(leaf: Leaf) -> LN:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1844:    container: LN = leaf
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1972:def generate_comments(leaf: LN) -> Iterator[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2617:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2622:    container: Optional[LN] = container_of(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2633:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2657:def is_empty_tuple(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2667:def is_one_tuple(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2690:def is_yield(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2753:def is_stub_body(node: LN) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2769:def max_delimiter_priority_in_atom(node: LN) -> int:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/debug_visitor.py:5:    def visit_default(self, node: LN) -> Iterator[T]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/debug_visitor.out:85: 'LN'

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
60:FileContent = str
61:Encoding = str
62:NewLine = str
63:Depth = int
64:NodeType = int
65:LeafID = int
66:Priority = int
67:Index = int
68:LN = Union[Leaf, Node]
69:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
70:Timestamp = float
71:FileSize = int
72:CacheInfo = Tuple[Timestamp, FileSize]
73:Cache = Dict[Path, CacheInfo]
74:out = partial(click.secho, bold=True, err=True)
75:err = partial(click.secho, fg="red", err=True)
76:
77:pygram.initialize(CACHE_DIR)
78:syms = pygram.python_symbols
79:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, get_future_imports defines a nested helper at line 2916: `def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:` which matches the required signature. The typing import includes Generator, and LN is defined, so the signature is valid.

Todo item 3 of 16 is correct
description: 'Validate get_future_imports defines helper get_imports_from_children(children: List[LN]) -> Generator[str, None, None].'

Validating todo item 4 of 16
description: 'Check that get_imports_from_children yields only original import names: for Leaf children, it yields when child.type == token.NAME; commas/parentheses are ignored since they are non-NAME Leaves.'

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pyâ€™s get_future_imports, the helper get_imports_from_children yields only when encountering Leaf nodes of type token.NAME, ignoring commas/parentheses. For aliases (import_as_name), it yields the original name (child.children[0]). Tests confirm expected behavior.

Todo item 4 of 16 is correct
description: 'Check that get_imports_from_children yields only original import names: for Leaf children, it yields when child.type == token.NAME; commas/parentheses are ignored since they are non-NAME Leaves.'

Validating todo item 5 of 16
description: 'Check that in get_imports_from_children, when encountering syms.import_as_name, it yields the first child (original name) and does not yield the alias (ensuring alias names like 'lol' are not included).'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pyâ€™s get_future_imports, the helper get_imports_from_children handles syms.import_as_name by selecting child.children[0] (the original name) and yielding only that value. It does not descend into the alias; import_as_names causes recursion over its children (import_as_name nodes), ensuring aliases like â€˜lolâ€™ arenâ€™t included. Tests confirm this behavior.

Todo item 5 of 16 is correct
description: 'Check that in get_imports_from_children, when encountering syms.import_as_name, it yields the first child (original name) and does not yield the alias (ensuring alias names like 'lol' are not included).'

Validating todo item 6 of 16
description: 'Check that in get_imports_from_children, when encountering syms.import_as_names, it recurses into its children to collect names (covering multiple and mixed alias/non-alias imports).'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2895:
2896:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2897:                # Empty brackets would fail a split so treat them as "inner"
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:
3005:    If no directory in the tree contains a marker that would specify it's the
3006:    project root, the root of the file system is returned.
3007:    """
3008:    if not srcs:
3009:        return Path("/").resolve()
3010:
3011:    common_base = min(Path(src).resolve() for src in srcs)
3012:    if common_base.is_dir():
3013:        # Append a fake file so `parents` below returns `common_base_dir`, too.
3014:        common_base /= "fake-file"

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, get_imports_from_children explicitly handles syms.import_as_names by recursing into its children (yield from get_imports_from_children(child.children)), ensuring multiple and mixed alias/non-alias imports are collected. Tests include such cases and this implementation covers them.

Todo item 6 of 16 is correct
description: 'Check that in get_imports_from_children, when encountering syms.import_as_names, it recurses into its children to collect names (covering multiple and mixed alias/non-alias imports).'

Validating todo item 7 of 16
description: 'Ensure get_imports_from_children contains only the allowed Node type branches (import_as_name, import_as_names) and asserts False for any other Node types.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Inside get_imports_from_children, the only Node type branches are for syms.import_as_name and syms.import_as_names; any other non-Leaf node hits an assert False. Leaf NAMEs are yielded, which doesnâ€™t add additional Node type branches.

Todo item 7 of 16 is correct
description: 'Ensure get_imports_from_children contains only the allowed Node type branches (import_as_name, import_as_names) and asserts False for any other Node types.'

Validating todo item 8 of 16
description: 'In get_future_imports, verify it iterates over node.children while child.type == syms.simple_stmt and stops otherwise (breaks on first non-simple_stmt).'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pyâ€™s get_future_imports, the loop over node.children immediately breaks on the first child whose type != syms.simple_stmt (lines 2931-2934), ensuring it iterates only while children are simple_stmt. This matches the todo requirement.

Todo item 8 of 16 is correct
description: 'In get_future_imports, verify it iterates over node.children while child.type == syms.simple_stmt and stops otherwise (breaks on first non-simple_stmt).'

Validating todo item 9 of 16
description: 'In get_future_imports, verify that a leading docstring (STRING followed by NEWLINE) is allowed and skipped; otherwise encountering a Leaf first_child causes a break (ensuring only top-of-file future imports are considered).'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py lines 2935-2944, get_future_imports explicitly skips a leading docstring by continuing when it sees a simple_stmt composed of STRING followed by NEWLINE; otherwise, encountering a Leaf first_child triggers a break, ensuring only top-of-file future imports are considered.

Todo item 9 of 16 is correct
description: 'In get_future_imports, verify that a leading docstring (STRING followed by NEWLINE) is allowed and skipped; otherwise encountering a Leaf first_child causes a break (ensuring only top-of-file future imports are considered).'

Validating todo item 10 of 16
description: 'In get_future_imports, validate it only processes 'from __future__ import ...' statements by checking first_child.type == syms.import_from and module_name Leaf value == '__future__'; otherwise it breaks.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In get_future_imports, the code explicitly checks that first_child.type == syms.import_from and then validates the module_name is a Leaf with value "__future__"; if not, it breaks. This ensures only 'from __future__ import ...' is processed.

Todo item 10 of 16 is correct
description: 'In get_future_imports, validate it only processes 'from __future__ import ...' statements by checking first_child.type == syms.import_from and module_name Leaf value == '__future__'; otherwise it breaks.'

Validating todo item 11 of 16
description: 'In get_future_imports, validate it collects imported names by calling get_imports_from_children on first_child.children[3:] (after the 'import' token), and unions the resulting set into imports.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py get_future_imports, the code now calls get_imports_from_children on first_child.children[3:] and unions the result into imports (line 2949), exactly matching the requirement to collect imported names after the 'import' token.

Todo item 11 of 16 is correct
description: 'In get_future_imports, validate it collects imported names by calling get_imports_from_children on first_child.children[3:] (after the 'import' token), and unions the resulting set into imports.'

Validating todo item 12 of 16
description: 'Confirm format_str reads future_imports = get_future_imports(src_node) and sets remove_u_prefix to py36 or 'unicode_literals' in future_imports (tie-in to PR behavior).'

Calling tool: grepTool
def format_str\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:590:def format_str(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
560:            f.write(diff(src, dst, src_name, dst_name))
561:        f.detach()
562:
563:
564:def format_file_contents(
565:    src_contents: str,
566:    *,
567:    line_length: int,
568:    fast: bool,
569:    mode: FileMode = FileMode.AUTO_DETECT,
570:) -> FileContent:
571:    """Reformat contents a file and return new contents.
572:
573:    If `fast` is False, additionally confirm that the reformatted code is
574:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
575:    `line_length` is passed to :func:`format_str`.
576:    """
577:    if src_contents.strip() == "":
578:        raise NothingChanged
579:
580:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
581:    if src_contents == dst_contents:
582:        raise NothingChanged
583:
584:    if not fast:
585:        assert_equivalent(src_contents, dst_contents)
586:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
587:    return dst_contents
588:
589:
590:def format_str(
591:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
592:) -> FileContent:
593:    """Reformat a string and return new contents.
594:
595:    `line_length` determines how many characters per line are allowed.
596:    """
597:    src_node = lib2to3_parse(src_contents)
598:    dst_contents = ""
599:    future_imports = get_future_imports(src_node)
600:    is_pyi = bool(mode & FileMode.PYI)
601:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
602:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
603:    normalize_fmt_off(src_node)
604:    lines = LineGenerator(
605:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
606:        is_pyi=is_pyi,
607:        normalize_strings=normalize_strings,
608:    )
609:    elt = EmptyLineTracker(is_pyi=is_pyi)
610:    empty_line = Line()
611:    after = 0
612:    for current_line in lines.visit(src_node):
613:        for _ in range(after):
614:            dst_contents += str(empty_line)
615:        before, after = elt.maybe_empty_lines(current_line)
616:        for _ in range(before):
617:            dst_contents += str(empty_line)
618:        for line in split_line(current_line, line_length=line_length, py36=py36):
619:            dst_contents += str(line)
620:    return dst_contents
621:
622:
623:def decode_bytes(src: bytes) -> Tuple[FileContent, Encoding, NewLine]:
624:    """Return a tuple of (decoded_contents, encoding, newline).
625:
626:    `newline` is either CRLF or LF but `decoded_contents` is decoded with
627:    universal newlines (i.e. only contains LF).
628:    """
629:    srcbuf = io.BytesIO(src)
630:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
631:    if not lines:
632:        return "", encoding, "\n"
633:
634:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
635:    srcbuf.seek(0)
636:    with io.TextIOWrapper(srcbuf, encoding) as tiow:
637:        return tiow.read(), encoding, newline
638:
639:
640:GRAMMARS = [
641:    pygram.python_grammar_no_print_statement_no_exec_statement,
642:    pygram.python_grammar_no_print_statement,
643:    pygram.python_grammar,
644:]
645:
646:
647:def lib2to3_parse(src_txt: str) -> Node:
648:    """Given a string with source, return the lib2to3 Node."""
649:    grammar = pygram.python_grammar_no_print_statement
650:    if src_txt[-1:] != "\n":
651:        src_txt += "\n"
652:    for grammar in GRAMMARS:
653:        drv = driver.Driver(grammar, pytree.convert)
654:        try:
655:            result = drv.parse_string(src_txt, True)
656:            break
657:
658:        except ParseError as pe:
659:            lineno, column = pe.context[1]

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py format_str() (lines ~597-609) assigns future_imports = get_future_imports(src_node) and initializes LineGenerator with remove_u_prefix=py36 or 'unicode_literals' in future_imports, satisfying the specified behavior.

Todo item 12 of 16 is correct
description: 'Confirm format_str reads future_imports = get_future_imports(src_node) and sets remove_u_prefix to py36 or 'unicode_literals' in future_imports (tie-in to PR behavior).'

Validating todo item 13 of 16
description: 'Review tests/test_black.py::test_get_future_imports to ensure added cases cover aliasing: 'from __future__ import unicode_literals as _unicode_literals' should yield {'unicode_literals'}, and 'from __future__ import unicode_literals as _lol, print' should yield {'unicode_literals', 'print'}.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The test `tests/test_black.py::test_get_future_imports` includes the two aliasing cases and asserts the expected sets. The updated `get_future_imports` implementation collects original names from `import_as_name` and `import_as_names`, correctly yielding {'unicode_literals'} and {'unicode_literals', 'print'} for the scenarios.

Todo item 13 of 16 is correct
description: 'Review tests/test_black.py::test_get_future_imports to ensure added cases cover aliasing: 'from __future__ import unicode_literals as _unicode_literals' should yield {'unicode_literals'}, and 'from __future__ import unicode_literals as _lol, print' should yield {'unicode_literals', 'print'}.'

Validating todo item 14 of 16
description: 'Check tests/test_black.py::test_get_future_imports also retains existing cases: empty input, single name, multiple names, parenthesized list, multiple lines, comment/docstring before imports, non-top-of-file code before import, and non-__future__ module import.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2890:                inner_brackets.add(id(leaf))
2891:        elif leaf.type in CLOSING_BRACKETS:
2892:            if not leaf.value:
2893:                optional_brackets.add(id(opening_bracket))
2894:                continue
2895:
2896:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2897:                # Empty brackets would fail a split so treat them as "inner"
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:
3005:    If no directory in the tree contains a marker that would specify it's the
3006:    project root, the root of the file system is returned.
3007:    """
3008:    if not srcs:
3009:        return Path("/").resolve()

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):
780:            black.format_file_contents(same, line_length=ll, fast=False)
781:        different = "l = [1,2,3]"
782:        expected = same
783:        actual = black.format_file_contents(different, line_length=ll, fast=False)
784:        self.assertEqual(expected, actual)
785:        invalid = "return if you can"
786:        with self.assertRaises(ValueError) as e:
787:            black.format_file_contents(invalid, line_length=ll, fast=False)
788:        self.assertEqual(str(e.exception), "Cannot parse: 1:7: return if you can")
789:
790:    def test_endmarker(self) -> None:
791:        n = black.lib2to3_parse("\n")
792:        self.assertEqual(n.type, black.syms.file_input)
793:        self.assertEqual(len(n.children), 1)
794:        self.assertEqual(n.children[0].type, black.token.ENDMARKER)
795:
796:    @unittest.skipIf(os.environ.get("SKIP_AST_PRINT"), "user set SKIP_AST_PRINT")
797:    def test_assertFormatEqual(self) -> None:
798:        out_lines = []
799:        err_lines = []
800:
801:        def out(msg: str, **kwargs: Any) -> None:
802:            out_lines.append(msg)
803:
804:        def err(msg: str, **kwargs: Any) -> None:
805:            err_lines.append(msg)
806:
807:        with patch("black.out", out), patch("black.err", err):
808:            with self.assertRaises(AssertionError):
809:                self.assertFormatEqual("l = [1, 2, 3]", "l = [1, 2, 3,]")

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified get_future_imports implementation. It still handles: empty input (breaks immediately), single/multiple names and parenthesized lists (collects token.NAME via helper), multiple lines (loops over consecutive import_from), comment/docstring before imports (docstring is skipped, comments ignored by parser), non-top-of-file code (breaks on first non-docstring Leaf), and non-__future__ module import (breaks when module name not __future__). Tests in tests/test_black.py cover these and align with the logic.

Todo item 14 of 16 is correct
description: 'Check tests/test_black.py::test_get_future_imports also retains existing cases: empty input, single name, multiple names, parenthesized list, multiple lines, comment/docstring before imports, non-top-of-file code before import, and non-__future__ module import.'

Validating todo item 15 of 16
description: 'Validate tests/data/python2_unicode_literals.py input segment includes: from __future__ import unicode_literals as _unicode_literals; from __future__ import absolute_import; from __future__ import print_function as lol, with_function; and contains u-prefixed literals.'

Calling tool: grepTool
from __future__ import unicode_literals as _unicode_literals
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:2:from __future__ import unicode_literals as _unicode_literals
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:14:from __future__ import unicode_literals as _unicode_literals
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:739:            "from __future__ import unicode_literals as _unicode_literals"

Calling tool: grepTool
from __future__ import absolute_import
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:3:from __future__ import absolute_import
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:15:from __future__ import absolute_import

Calling tool: grepTool
from __future__ import print_function as lol, with_function
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:4:from __future__ import print_function as lol, with_function
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:16:from __future__ import print_function as lol, with_function

Calling tool: grepTool
u'hello'
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:6:u'hello'

Calling tool: grepTool
U"hello"
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:7:U"hello"

Calling tool: grepTool
Ur"hello"
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py:8:Ur"hello"

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py
1:#!/usr/bin/env python2
2:from __future__ import unicode_literals as _unicode_literals
3:from __future__ import absolute_import
4:from __future__ import print_function as lol, with_function
5:
6:u'hello'
7:U"hello"
8:Ur"hello"
9:
10:# output
11:
12:
13:#!/usr/bin/env python2
14:from __future__ import unicode_literals as _unicode_literals
15:from __future__ import absolute_import
16:from __future__ import print_function as lol, with_function
17:
18:"hello"
19:"hello"
20:r"hello"

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified tests/data/python2_unicode_literals.py contains the specified future imports with aliasing and includes u-prefixed literals in the input segment (lines 1â€“8). The content matches the diff and test expectations.

Todo item 15 of 16 is correct
description: 'Validate tests/data/python2_unicode_literals.py input segment includes: from __future__ import unicode_literals as _unicode_literals; from __future__ import absolute_import; from __future__ import print_function as lol, with_function; and contains u-prefixed literals.'

Validating todo item 16 of 16
description: 'Validate tests/data/python2_unicode_literals.py expected segment mirrors the same future imports and has the 'u' prefixes removed from string literals (indirectly asserting remove_u_prefix behavior works with aliased unicode_literals).'

Calling tool: grepTool
python2_unicode_literals\.py
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_patchfile.info:1:black.py;tests/data/python2_unicode_literals.py;

Calling tool: globTool
**/tests/data/python2_unicode_literals.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py
1:#!/usr/bin/env python2
2:from __future__ import unicode_literals as _unicode_literals
3:from __future__ import absolute_import
4:from __future__ import print_function as lol, with_function
5:
6:u'hello'
7:U"hello"
8:Ur"hello"
9:
10:# output
11:
12:
13:#!/usr/bin/env python2
14:from __future__ import unicode_literals as _unicode_literals
15:from __future__ import absolute_import
16:from __future__ import print_function as lol, with_function
17:
18:"hello"
19:"hello"
20:r"hello"

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Inspected tests/data/python2_unicode_literals.py. The expected segment mirrors the same __future__ imports (including the aliasing) and the output strings have the â€˜uâ€™ prefix removed (u/Ur -> plain/r), thus asserting remove_u_prefix behavior works with aliased unicode_literals.

Todo item 16 of 16 is correct
description: 'Validate tests/data/python2_unicode_literals.py expected segment mirrors the same future imports and has the 'u' prefixes removed from string literals (indirectly asserting remove_u_prefix behavior works with aliased unicode_literals).'


=== PHASE 2 COMPLETE ===

