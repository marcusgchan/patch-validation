=== PHASE 1: ANALYSIS ===

Calling tool: grepTool
test_preserves_line_endings
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1113:    def test_preserves_line_endings(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
1080:        sources.extend(
1081:            black.gen_python_files_in_dir(
1082:                path, this_abs, empty, re.compile(black.DEFAULT_EXCLUDES), report
1083:            )
1084:        )
1085:        self.assertEqual(sorted(expected), sorted(sources))
1086:
1087:    def test_empty_exclude(self) -> None:
1088:        path = THIS_DIR / "include_exclude_tests"
1089:        report = black.Report()
1090:        empty = re.compile(r"")
1091:        sources: List[Path] = []
1092:        expected = [
1093:            Path(path / "b/dont_exclude/a.py"),
1094:            Path(path / "b/dont_exclude/a.pyi"),
1095:            Path(path / "b/exclude/a.py"),
1096:            Path(path / "b/exclude/a.pyi"),
1097:            Path(path / "b/.definitely_exclude/a.py"),
1098:            Path(path / "b/.definitely_exclude/a.pyi"),
1099:        ]
1100:        this_abs = THIS_DIR.resolve()
1101:        sources.extend(
1102:            black.gen_python_files_in_dir(
1103:                path, this_abs, re.compile(black.DEFAULT_INCLUDES), empty, report
1104:            )
1105:        )
1106:        self.assertEqual(sorted(expected), sorted(sources))
1107:
1108:    def test_invalid_include_exclude(self) -> None:
1109:        for option in ["--include", "--exclude"]:
1110:            result = CliRunner().invoke(black.main, ["-", option, "**()(!!*)"])
1111:            self.assertEqual(result.exit_code, 2)
1112:
1113:    def test_preserves_line_endings(self) -> None:
1114:        with TemporaryDirectory() as workspace:
1115:            test_file = Path(workspace) / "test.py"
1116:            for nl in ["\n", "\r\n"]:
1117:                contents = nl.join(["def f(  ):", "    pass"])
1118:                test_file.write_bytes(contents.encode())
1119:                ff(test_file, write_back=black.WriteBack.YES)
1120:                updated_contents: bytes = test_file.read_bytes()
1121:                self.assertIn(nl.encode(), updated_contents)  # type: ignore
1122:                if nl == "\n":
1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore
1124:
1125:
1126:if __name__ == "__main__":
1127:    unittest.main()

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
430:        pending: Iterable[asyncio.Task] = tasks.keys()
431:        try:
432:            loop.add_signal_handler(signal.SIGINT, cancel, pending)
433:            loop.add_signal_handler(signal.SIGTERM, cancel, pending)
434:        except NotImplementedError:
435:            # There are no good alternatives for these on Windows
436:            pass
437:        while pending:
438:            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
439:            for task in done:
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """
580:    src_node = lib2to3_parse(src_contents)
581:    dst_contents = ""
582:    future_imports = get_future_imports(src_node)
583:    is_pyi = bool(mode & FileMode.PYI)
584:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
585:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
586:    lines = LineGenerator(
587:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
588:        is_pyi=is_pyi,
589:        normalize_strings=normalize_strings,
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.

Calling tool: grepTool
from typing import .*Tuple
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
from typing import
Matched content:
17:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
1:import asyncio
2:import pickle
3:from asyncio.base_events import BaseEventLoop
4:from concurrent.futures import Executor, ProcessPoolExecutor
5:from enum import Enum, Flag
6:from functools import partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import re
14:import tokenize
15:import signal
16:import sys
17:from typing import (
18:    Any,
19:    Callable,
20:    Collection,
21:    Dict,
22:    Generic,
23:    Iterable,
24:    Iterator,
25:    List,
26:    Optional,
27:    Pattern,
28:    Sequence,
29:    Set,
30:    Tuple,
31:    Type,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:

Calling tool: grepTool
def ff\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
\bff\(
Matched content:
109:        self.assertFalse(ff(THIS_FILE))
118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
163:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
193:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
210:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.DIFF))
1119:                ff(test_file, write_back=black.WriteBack.YES)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
80:class BlackTestCase(unittest.TestCase):
81:    maxDiff = None
82:
83:    def assertFormatEqual(self, expected: str, actual: str) -> None:
84:        if actual != expected and not os.environ.get("SKIP_AST_PRINT"):
85:            bdv: black.DebugVisitor[Any]
86:            black.out("Expected tree:", fg="green")
87:            try:
88:                exp_node = black.lib2to3_parse(expected)
89:                bdv = black.DebugVisitor()
90:                list(bdv.visit(exp_node))
91:            except Exception as ve:
92:                black.err(str(ve))
93:            black.out("Actual tree:", fg="red")
94:            try:
95:                exp_node = black.lib2to3_parse(actual)
96:                bdv = black.DebugVisitor()
97:                list(bdv.visit(exp_node))
98:            except Exception as ve:
99:                black.err(str(ve))
100:        self.assertEqual(expected, actual)
101:
102:    @patch("black.dump_to_file", dump_to_stderr)
103:    def test_self(self) -> None:
104:        source, expected = read_data("test_black")
105:        actual = fs(source)
106:        self.assertFormatEqual(expected, actual)
107:        black.assert_equivalent(source, actual)
108:        black.assert_stable(source, actual, line_length=ll)
109:        self.assertFalse(ff(THIS_FILE))
110:
111:    @patch("black.dump_to_file", dump_to_stderr)
112:    def test_black(self) -> None:
113:        source, expected = read_data("../black")
114:        actual = fs(source)
115:        self.assertFormatEqual(expected, actual)
116:        black.assert_equivalent(source, actual)
117:        black.assert_stable(source, actual, line_length=ll)
118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
119:
120:    def test_piping(self) -> None:
121:        source, expected = read_data("../black")
122:        hold_stdin, hold_stdout = sys.stdin, sys.stdout
123:        try:
124:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
125:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
126:            sys.stdin.buffer.name = "<stdin>"  # type: ignore
127:            black.format_stdin_to_stdout(
128:                line_length=ll, fast=True, write_back=black.WriteBack.YES
129:            )
130:            sys.stdout.seek(0)
131:            actual = sys.stdout.read()
132:        finally:
133:            sys.stdin, sys.stdout = hold_stdin, hold_stdout
134:        self.assertFormatEqual(expected, actual)
135:        black.assert_equivalent(source, actual)
136:        black.assert_stable(source, actual, line_length=ll)
137:
138:    def test_piping_diff(self) -> None:
139:        source, _ = read_data("expression.py")
140:        expected, _ = read_data("expression.diff")
141:        hold_stdin, hold_stdout = sys.stdin, sys.stdout
142:        try:
143:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
144:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
145:            sys.stdin.buffer.name = "<stdin>"  # type: ignore
146:            black.format_stdin_to_stdout(
147:                line_length=ll, fast=True, write_back=black.WriteBack.DIFF
148:            )
149:            sys.stdout.seek(0)
150:            actual = sys.stdout.read()
151:        finally:
152:            sys.stdin, sys.stdout = hold_stdin, hold_stdout
153:        actual = actual.rstrip() + "\n"  # the diff output has a trailing space
154:        self.assertEqual(expected, actual)
155:
156:    @patch("black.dump_to_file", dump_to_stderr)
157:    def test_setup(self) -> None:
158:        source, expected = read_data("../setup")
159:        actual = fs(source)
160:        self.assertFormatEqual(expected, actual)
161:        black.assert_equivalent(source, actual)
162:        black.assert_stable(source, actual, line_length=ll)
163:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
164:
165:    @patch("black.dump_to_file", dump_to_stderr)
166:    def test_function(self) -> None:
167:        source, expected = read_data("function")
168:        actual = fs(source)
169:        self.assertFormatEqual(expected, actual)
170:        black.assert_equivalent(source, actual)
171:        black.assert_stable(source, actual, line_length=ll)
172:
173:    @patch("black.dump_to_file", dump_to_stderr)
174:    def test_function2(self) -> None:
175:        source, expected = read_data("function2")
176:        actual = fs(source)
177:        self.assertFormatEqual(expected, actual)
178:        black.assert_equivalent(source, actual)
179:        black.assert_stable(source, actual, line_length=ll)
180:
181:    @patch("black.dump_to_file", dump_to_stderr)
182:    def test_expression(self) -> None:
183:        source, expected = read_data("expression")
184:        actual = fs(source)
185:        self.assertFormatEqual(expected, actual)
186:        black.assert_equivalent(source, actual)
187:        black.assert_stable(source, actual, line_length=ll)
188:
189:    def test_expression_ff(self) -> None:
190:        source, expected = read_data("expression")
191:        tmp_file = Path(black.dump_to_file(source))
192:        try:
193:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
194:            with open(tmp_file, encoding="utf8") as f:
195:                actual = f.read()
196:        finally:
197:            os.unlink(tmp_file)
198:        self.assertFormatEqual(expected, actual)
199:        with patch("black.dump_to_file", dump_to_stderr):
200:            black.assert_equivalent(source, actual)
201:            black.assert_stable(source, actual, line_length=ll)
202:
203:    def test_expression_diff(self) -> None:
204:        source, _ = read_data("expression.py")
205:        expected, _ = read_data("expression.diff")
206:        tmp_file = Path(black.dump_to_file(source))
207:        hold_stdout = sys.stdout
208:        try:
209:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
210:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.DIFF))
211:            sys.stdout.seek(0)
212:            actual = sys.stdout.read()
213:            actual = actual.replace(str(tmp_file), "<stdin>")
214:        finally:
215:            sys.stdout = hold_stdout
216:            os.unlink(tmp_file)
217:        actual = actual.rstrip() + "\n"  # the diff output has a trailing space
218:        if expected != actual:
219:            dump = black.dump_to_file(actual)
220:            msg = (
221:                f"Expected diff isn't equal to the actual. If you made changes "
222:                f"to expression.py and this is an anticipated difference, "
223:                f"overwrite tests/expression.diff with {dump}"
224:            )
225:            self.assertEqual(expected, actual, msg)
226:
227:    @patch("black.dump_to_file", dump_to_stderr)
228:    def test_fstring(self) -> None:
229:        source, expected = read_data("fstring")
230:        actual = fs(source)
231:        self.assertFormatEqual(expected, actual)
232:        black.assert_equivalent(source, actual)
233:        black.assert_stable(source, actual, line_length=ll)
234:
235:    @patch("black.dump_to_file", dump_to_stderr)
236:    def test_string_quotes(self) -> None:
237:        source, expected = read_data("string_quotes")
238:        actual = fs(source)
239:        self.assertFormatEqual(expected, actual)

Calling tool: grepTool
\bff =
Matched content:
22:ff = partial(black.format_file_in_place, line_length=ll, fast=True)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import sys
10:from tempfile import TemporaryDirectory
11:from typing import Any, List, Tuple, Iterator
12:import unittest
13:from unittest.mock import patch
14:import re
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:ll = 88
22:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
23:fs = partial(black.format_str, line_length=ll)
24:THIS_FILE = Path(__file__)
25:THIS_DIR = THIS_FILE.parent
26:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
27:
28:
29:def dump_to_stderr(*output: str) -> str:
30:    return "\n" + "\n".join(output) + "\n"
31:
32:
33:def read_data(name: str) -> Tuple[str, str]:
34:    """read_data('test_name') -> 'input', 'output'"""
35:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
36:        name += ".py"
37:    _input: List[str] = []
38:    _output: List[str] = []
39:    with open(THIS_DIR / name, "r", encoding="utf8") as test:
40:        lines = test.readlines()
41:    result = _input
42:    for line in lines:
43:        line = line.replace(EMPTY_LINE, "")
44:        if line.rstrip() == "# output":
45:            result = _output
46:            continue
47:
48:        result.append(line)
49:    if _input and not _output:
50:        # If there's no output marker, treat the entire file as already pre-formatted.
51:        _output = _input[:]
52:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
53:
54:
55:@contextmanager
56:def cache_dir(exists: bool = True) -> Iterator[Path]:
57:    with TemporaryDirectory() as workspace:
58:        cache_dir = Path(workspace)
59:        if not exists:
60:            cache_dir = cache_dir / "new"

Calling tool: grepTool
class WriteBack
Matched content:
118:class WriteBack(Enum):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
112:
113:
114:class FormatOff(FormatError):
115:    """Found a comment like `# fmt: off` in the file."""
116:
117:
118:class WriteBack(Enum):
119:    NO = 0
120:    YES = 1
121:    DIFF = 2
122:
123:    @classmethod
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
125:        if check and not diff:
126:            return cls.NO
127:
128:        return cls.DIFF if diff else cls.YES
129:
130:
131:class Changed(Enum):
132:    NO = 0
133:    CACHED = 1
134:    YES = 2
135:
136:
137:class FileMode(Flag):
138:    AUTO_DETECT = 0
139:    PYTHON36 = 1
140:    PYI = 2
141:    NO_STRING_NORMALIZATION = 4
142:
143:    @classmethod
144:    def from_configuration(
145:        cls, *, py36: bool, pyi: bool, skip_string_normalization: bool
146:    ) -> "FileMode":
147:        mode = cls.AUTO_DETECT
148:        if py36:
149:            mode |= cls.PYTHON36
150:        if pyi:
151:            mode |= cls.PYI
152:        if skip_string_normalization:
153:            mode |= cls.NO_STRING_NORMALIZATION
154:        return mode
155:
156:
157:@click.command()
158:@click.option(
159:    "-l",
160:    "--line-length",
161:    type=int,
162:    default=DEFAULT_LINE_LENGTH,
163:    help="How many character per line to allow.",
164:    show_default=True,
165:)
166:@click.option(
167:    "--py36",
168:    is_flag=True,
169:    help=(
170:        "Allow using Python 3.6-only syntax on all input files.  This will put "
171:        "trailing commas in function signatures and calls also after *args and "

Calling tool: grepTool
== write_back\.YES
Matched content:
479:    if write_back == write_back.YES:

Calling tool: grepTool
\bwrite_back\b
Matched content:
276:    write_back = WriteBack.from_configuration(check=check, diff=diff)
314:            write_back=write_back,
327:                    write_back=write_back,
346:    write_back: WriteBack,
353:    `write_back`, `fast` and `pyi` options are passed to
360:                line_length=line_length, fast=fast, write_back=write_back, mode=mode
365:            if write_back != WriteBack.DIFF:
374:                write_back=write_back,
378:            if write_back == WriteBack.YES and changed is not Changed.NO:
389:    write_back: WriteBack,
399:    `line_length`, `write_back`, `fast`, and `pyi` options are passed to
403:    if write_back != WriteBack.DIFF:
412:        if write_back == WriteBack.DIFF:
424:                write_back,
450:    if write_back == WriteBack.YES and formatted:
458:    write_back: WriteBack = WriteBack.NO,
464:    If `write_back` is True, write reformatted code back to stdout.
479:    if write_back == write_back.YES:
482:    elif write_back == write_back.DIFF:
506:    write_back: WriteBack = WriteBack.NO,
511:    If `write_back` is True, write reformatted code back to stdout.
525:        if write_back == WriteBack.YES:
534:        elif write_back == WriteBack.DIFF:

Calling tool: createTodo
Todo List Created
Todo List (12 items):
- [ ] Verify `black.black.py::format_file_in_place` reads the source in binary mode and uses `prepare_input` to obtain `(newline, encoding, src_contents)`, replacing prior `tokenize.open` usage. (ID: todo-1)
- [ ] Confirm that when `write_back == WriteBack.YES` in `format_file_in_place`, the file is reopened with `open(src, "w", encoding=encoding, newline=newline)` and `dst_contents` is written, ensuring newline preservation based on input. (ID: todo-2)
- [ ] Confirm that when `write_back == WriteBack.DIFF` in `format_file_in_place`, the diff is written to stdout via an `io.TextIOWrapper` wrapping `sys.stdout.buffer` with the same `encoding` and `newline`, and that `.detach()` is called after writing. (ID: todo-3)
- [ ] Verify `black.black.py::format_stdin_to_stdout` reads stdin from `sys.stdin.buffer.read()`, passes it to `prepare_input`, and uses the returned `encoding` and `newline` for writing to stdout for both `WriteBack.YES` and `WriteBack.DIFF` paths via `io.TextIOWrapper`. (ID: todo-4)
- [ ] Check that `prepare_input` is implemented to: (1) wrap the bytes in `io.BytesIO`, (2) call `tokenize.detect_encoding(srcbuf.readline)` to determine `encoding` and `lines`, (3) set `newline` to "\r\n" iff the first line in `lines` ends with CRLF, and (4) return decoded contents using `io.TextIOWrapper(srcbuf, encoding).read()` so internal text uses universal newlines (LF only). (ID: todo-5)
- [ ] Ensure `black.black.py::lib2to3_parse` unconditionally appends a single "\n" when the input text doesn’t end with a newline, removing any CRLF-detection logic, to keep internal representation normalized to LF. (ID: todo-6)
- [ ] Verify that `GRAMMARS` and downstream parsing/formatting functions continue to operate on LF-only internal text (consistent with `prepare_input` universal newline behavior). (ID: todo-7)
- [ ] Check that the new import `import io` is present at the top of `black.black.py` and is the module used by the added code paths (i.e., `io.BytesIO` and `io.TextIOWrapper`). (ID: todo-8)
- [ ] Validate that all writes to stdout introduced in the diff pass `str` objects to `TextIOWrapper.write()` and not bytes, matching the text mode wrapper usage. (ID: todo-9)
- [ ] Confirm that the test `tests/test_black.py::BlackTestCase.test_preserves_line_endings` creates a temporary file, writes bytes with both "\n" and "\r\n" styles, calls `black.format_file_in_place(..., write_back=black.WriteBack.YES)`, and then reads raw bytes to assert the original newline style is preserved (and that CRLF is absent when the original was LF). (ID: todo-10)
- [ ] Ensure that all code paths changed by the PR avoid relying on platform default newline translation by explicitly setting the `newline` parameter for file/stdout writes only when writing back or emitting diffs, aligning with the PR intent to preserve line endings. (ID: todo-11)
- [ ] Cross-check that the encoding used for writing back (file and stdout) is exactly the encoding detected by `tokenize.detect_encoding` for the input, not a hardcoded default. (ID: todo-12)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 12
description: 'Verify `black.black.py::format_file_in_place` reads the source in binary mode and uses `prepare_input` to obtain `(newline, encoding, src_contents)`, replacing prior `tokenize.open` usage.'
Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:

Calling tool: grepTool
^import io$
Matched content:
7:import io

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py, format_file_in_place now opens the source in binary mode (open(src, "rb")) and calls prepare_input(buf.read()) to obtain (newline, encoding, src_contents), replacing the previous tokenize.open usage. Verified by reading the function implementation around line 454.


Todo item 1 of 12 is correct
description: 'Verify `black.black.py::format_file_in_place` reads the source in binary mode and uses `prepare_input` to obtain `(newline, encoding, src_contents)`, replacing prior `tokenize.open` usage.'
Validating todo item 2 of 12
description: 'Confirm that when `write_back == WriteBack.YES` in `format_file_in_place`, the file is reopened with `open(src, "w", encoding=encoding, newline=newline)` and `dst_contents` is written, ensuring newline preservation based on input.'
Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py:format_file_in_place, the YES branch opens the file with open(src, "w", encoding=encoding, newline=newline) and writes dst_contents, ensuring newline preservation based on the input-derived newline/encoding.


Todo item 2 of 12 is correct
description: 'Confirm that when `write_back == WriteBack.YES` in `format_file_in_place`, the file is reopened with `open(src, "w", encoding=encoding, newline=newline)` and `dst_contents` is written, ensuring newline preservation based on input.'
Validating todo item 3 of 12
description: 'Confirm that when `write_back == WriteBack.DIFF` in `format_file_in_place`, the diff is written to stdout via an `io.TextIOWrapper` wrapping `sys.stdout.buffer` with the same `encoding` and `newline`, and that `.detach()` is called after writing.'
Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """

Calling tool: grepTool
class WriteBack
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:118:class WriteBack(Enum):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
100:
101:    def trim_prefix(self, leaf: Leaf) -> None:
102:        leaf.prefix = leaf.prefix[self.consumed :]
103:
104:    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:
105:        """Returns a new Leaf from the consumed part of the prefix."""
106:        unformatted_prefix = leaf.prefix[: self.consumed]
107:        return Leaf(token.NEWLINE, unformatted_prefix)
108:
109:
110:class FormatOn(FormatError):
111:    """Found a comment like `# fmt: on` in the file."""
112:
113:
114:class FormatOff(FormatError):
115:    """Found a comment like `# fmt: off` in the file."""
116:
117:
118:class WriteBack(Enum):
119:    NO = 0
120:    YES = 1
121:    DIFF = 2
122:
123:    @classmethod
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
125:        if check and not diff:
126:            return cls.NO
127:
128:        return cls.DIFF if diff else cls.YES
129:
130:
131:class Changed(Enum):
132:    NO = 0
133:    CACHED = 1
134:    YES = 2
135:
136:
137:class FileMode(Flag):
138:    AUTO_DETECT = 0
139:    PYTHON36 = 1

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py’s format_file_in_place, the WriteBack.DIFF branch wraps sys.stdout.buffer in io.TextIOWrapper using the detected encoding and newline, writes diff_contents, and calls f.detach() afterward (lines 489–496). This matches the todo requirement.


Todo item 3 of 12 is correct
description: 'Confirm that when `write_back == WriteBack.DIFF` in `format_file_in_place`, the diff is written to stdout via an `io.TextIOWrapper` wrapping `sys.stdout.buffer` with the same `encoding` and `newline`, and that `.detach()` is called after writing.'
Validating todo item 4 of 12
description: 'Verify `black.black.py::format_stdin_to_stdout` reads stdin from `sys.stdin.buffer.read()`, passes it to `prepare_input`, and uses the returned `encoding` and `newline` for writing to stdout for both `WriteBack.YES` and `WriteBack.DIFF` paths via `io.TextIOWrapper`.'
Calling tool: grepTool
def format_stdin_to_stdout\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:503:def format_stdin_to_stdout(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:

Calling tool: grepTool
^import io$
Matched content:
7:import io

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, format_stdin_to_stdout reads from sys.stdin.buffer.read() and passes the bytes to prepare_input. The returned encoding and newline are used to construct io.TextIOWrapper over sys.stdout.buffer for both WriteBack.YES and WriteBack.DIFF paths, and writing is done via that wrapper.


Todo item 4 of 12 is correct
description: 'Verify `black.black.py::format_stdin_to_stdout` reads stdin from `sys.stdin.buffer.read()`, passes it to `prepare_input`, and uses the returned `encoding` and `newline` for writing to stdout for both `WriteBack.YES` and `WriteBack.DIFF` paths via `io.TextIOWrapper`.'
Validating todo item 5 of 12
description: 'Check that `prepare_input` is implemented to: (1) wrap the bytes in `io.BytesIO`, (2) call `tokenize.detect_encoding(srcbuf.readline)` to determine `encoding` and `lines`, (3) set `newline` to "\r\n" iff the first line in `lines` ends with CRLF, and (4) return decoded contents using `io.TextIOWrapper(srcbuf, encoding).read()` so internal text uses universal newlines (LF only).'
Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py

Calling tool: grepTool
def prepare_input\(
Matched content:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
670:        instead.
671:
672:        Then yields objects of type `T` from the selected visitor.
673:        """
674:        if node.type < 256:
675:            name = token.tok_name[node.type]

Calling tool: grepTool
import tokenize
Matched content:
14:import tokenize

Calling tool: grepTool
import io
Matched content:
7:import io

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The implemented prepare_input wraps bytes in io.BytesIO, uses tokenize.detect_encoding(srcbuf.readline) to get encoding and lines, sets newline to CRLF only if the first line ends with CRLF (lines[0][-2:] == b"\r\n"), seeks back, and returns decoded text via io.TextIOWrapper(srcbuf, encoding).read(), which applies universal newline translation.


Todo item 5 of 12 is correct
description: 'Check that `prepare_input` is implemented to: (1) wrap the bytes in `io.BytesIO`, (2) call `tokenize.detect_encoding(srcbuf.readline)` to determine `encoding` and `lines`, (3) set `newline` to "\r\n" iff the first line in `lines` ends with CRLF, and (4) return decoded contents using `io.TextIOWrapper(srcbuf, encoding).read()` so internal text uses universal newlines (LF only).'
Validating todo item 6 of 12
description: 'Ensure `black.black.py::lib2to3_parse` unconditionally appends a single "\n" when the input text doesn’t end with a newline, removing any CRLF-detection logic, to keep internal representation normalized to LF.'
Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py

Calling tool: grepTool
def lib2to3_parse\(
Matched content:
625:def lib2to3_parse(src_txt: str) -> Node:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
670:        instead.
671:
672:        Then yields objects of type `T` from the selected visitor.
673:        """
674:        if node.type < 256:
675:            name = token.tok_name[node.type]
676:        else:
677:            name = type_repr(node.type)
678:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
679:
680:    def visit_default(self, node: LN) -> Iterator[T]:
681:        """Default `visit_*()` implementation. Recurses to children of `node`."""
682:        if isinstance(node, Node):
683:            for child in node.children:
684:                yield from self.visit(child)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py lines 625-631, lib2to3_parse now unconditionally appends a single "\n" when input doesn’t end with one and the previous CRLF detection logic has been removed. Verified by reading the exact function implementation.


Todo item 6 of 12 is correct
description: 'Ensure `black.black.py::lib2to3_parse` unconditionally appends a single "\n" when the input text doesn’t end with a newline, removing any CRLF-detection logic, to keep internal representation normalized to LF.'
Validating todo item 7 of 12
description: 'Verify that `GRAMMARS` and downstream parsing/formatting functions continue to operate on LF-only internal text (consistent with `prepare_input` universal newline behavior).'
Calling tool: grepTool
GRAMMARS\s*=\s*\[
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:618:GRAMMARS = [

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
670:        instead.
671:
672:        Then yields objects of type `T` from the selected visitor.
673:        """
674:        if node.type < 256:
675:            name = token.tok_name[node.type]
676:        else:
677:            name = type_repr(node.type)
678:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
679:

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """
580:    src_node = lib2to3_parse(src_contents)
581:    dst_contents = ""
582:    future_imports = get_future_imports(src_node)
583:    is_pyi = bool(mode & FileMode.PYI)
584:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
585:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
586:    lines = LineGenerator(
587:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
588:        is_pyi=is_pyi,
589:        normalize_strings=normalize_strings,
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,

Calling tool: grepTool
\r\n
Grep command failed with exit code 2: rg: the literal "\n" is not allowed in a regex

Consider enabling multiline mode with the --multiline flag (or -U for short).
When multiline mode is enabled, new line characters can be matched.


Calling tool: grepTool
"\\r\\n"
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1116:            for nl in ["\n", "\r\n"]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore

Calling tool: grepTool
tokenize\.open\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
1100:        this_abs = THIS_DIR.resolve()
1101:        sources.extend(
1102:            black.gen_python_files_in_dir(
1103:                path, this_abs, re.compile(black.DEFAULT_INCLUDES), empty, report
1104:            )
1105:        )
1106:        self.assertEqual(sorted(expected), sorted(sources))
1107:
1108:    def test_invalid_include_exclude(self) -> None:
1109:        for option in ["--include", "--exclude"]:
1110:            result = CliRunner().invoke(black.main, ["-", option, "**()(!!*)"])
1111:            self.assertEqual(result.exit_code, 2)
1112:
1113:    def test_preserves_line_endings(self) -> None:
1114:        with TemporaryDirectory() as workspace:
1115:            test_file = Path(workspace) / "test.py"
1116:            for nl in ["\n", "\r\n"]:
1117:                contents = nl.join(["def f(  ):", "    pass"])
1118:                test_file.write_bytes(contents.encode())
1119:                ff(test_file, write_back=black.WriteBack.YES)
1120:                updated_contents: bytes = test_file.read_bytes()
1121:                self.assertIn(nl.encode(), updated_contents)  # type: ignore
1122:                if nl == "\n":
1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore
1124:
1125:
1126:if __name__ == "__main__":
1127:    unittest.main()

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: prepare_input normalizes all input to LF-only via TextIOWrapper universal newlines, and lib2to3_parse now unconditionally appends “\n” (replacing prior CRLF detection). GRAMMARS is used on this LF-only text, so downstream parsing/formatting operates on LF-only internal strings.


Todo item 7 of 12 is correct
description: 'Verify that `GRAMMARS` and downstream parsing/formatting functions continue to operate on LF-only internal text (consistent with `prepare_input` universal newline behavior).'
Validating todo item 8 of 12
description: 'Check that the new import `import io` is present at the top of `black.black.py` and is the module used by the added code paths (i.e., `io.BytesIO` and `io.TextIOWrapper`).'
Calling tool: grepTool
(?i)def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: grepTool
^import io
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black/black.py: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black/black.py: No such file or directory (os error 2)


Calling tool: grepTool
^import io
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/blib2to3/pgen2/driver.py:20:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:7:import io

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
1:import asyncio
2:import pickle
3:from asyncio.base_events import BaseEventLoop
4:from concurrent.futures import Executor, ProcessPoolExecutor
5:from enum import Enum, Flag
6:from functools import partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import re
14:import tokenize
15:import signal
16:import sys
17:from typing import (
18:    Any,
19:    Callable,
20:    Collection,
21:    Dict,
22:    Generic,
23:    Iterable,
24:    Iterator,
25:    List,
26:    Optional,
27:    Pattern,
28:    Sequence,
29:    Set,
30:    Tuple,
31:    Type,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:

Calling tool: grepTool
io\.TextIOWrapper\(|io\.BytesIO\(
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black: No such file or directory (os error 2)


Calling tool: grepTool
io\.TextIOWrapper\(|io\.BytesIO\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:489:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:526:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:537:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:611:    srcbuf = io.BytesIO(src)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"

Calling tool: grepTool
from io import|import io
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/blib2to3/pytree.py:16:from io import StringIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:7:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/blib2to3/pgen2/driver.py:20:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:6:from io import BytesIO, TextIOWrapper

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Confirmed `import io` exists at top of `black/black.py` (line 7). Verified added code uses `io.TextIOWrapper` and `io.BytesIO` in this file (lines ~489, 526, 537, 611, 615).


Todo item 8 of 12 is correct
description: 'Check that the new import `import io` is present at the top of `black.black.py` and is the module used by the added code paths (i.e., `io.BytesIO` and `io.TextIOWrapper`).'
Validating todo item 9 of 12
description: 'Validate that all writes to stdout introduced in the diff pass `str` objects to `TextIOWrapper.write()` and not bytes, matching the text mode wrapper usage.'
Calling tool: grepTool
TextIOWrapper\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:489:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:526:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:537:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:124:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:125:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:143:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:144:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:209:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:

Calling tool: grepTool
def diff\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:3090:def diff(a: str, b: str, a_name: str, b_name: str) -> str:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
3085:            if lines and lines[-1] != "\n":
3086:                f.write("\n")
3087:    return f.name
3088:
3089:
3090:def diff(a: str, b: str, a_name: str, b_name: str) -> str:
3091:    """Return a unified diff string between strings `a` and `b`."""
3092:    import difflib
3093:
3094:    a_lines = [line + "\n" for line in a.split("\n")]
3095:    b_lines = [line + "\n" for line in b.split("\n")]
3096:    return "".join(
3097:        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)
3098:    )
3099:
3100:
3101:def cancel(tasks: Iterable[asyncio.Task]) -> None:
3102:    """asyncio signal handler that cancels all `tasks` and reports to stderr."""
3103:    err("Aborted!")
3104:    for task in tasks:
3105:        task.cancel()
3106:
3107:
3108:def shutdown(loop: BaseEventLoop) -> None:
3109:    """Cancel all pending tasks on `loop`, wait for them, and close the loop."""
3110:    try:
3111:        # This part is borrowed from asyncio/runners.py in Python 3.7b2.
3112:        to_cancel = [task for task in asyncio.Task.all_tasks(loop) if not task.done()]
3113:        if not to_cancel:
3114:            return
3115:
3116:        for task in to_cancel:
3117:            task.cancel()
3118:        loop.run_until_complete(
3119:            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)
3120:        )
3121:    finally:
3122:        # `concurrent.futures.Future` objects cannot be cancelled once they
3123:        # are already running. There might be some when the `shutdown()` happened.
3124:        # Silence their logger's spew about the event loop being closed.

Calling tool: grepTool
class WriteBack|WriteBack|FileContent|format_file_in_place\(|format_stdin_to_stdout\(
Matched content:
58:FileContent = str
118:class WriteBack(Enum):
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
276:    write_back = WriteBack.from_configuration(check=check, diff=diff)
346:    write_back: WriteBack,
359:            if format_stdin_to_stdout(
365:            if write_back != WriteBack.DIFF:
370:            if changed is not Changed.CACHED and format_file_in_place(
378:            if write_back == WriteBack.YES and changed is not Changed.NO:
389:    write_back: WriteBack,
403:    if write_back != WriteBack.DIFF:
412:        if write_back == WriteBack.DIFF:
450:    if write_back == WriteBack.YES and formatted:
454:def format_file_in_place(
458:    write_back: WriteBack = WriteBack.NO,
503:def format_stdin_to_stdout(
506:    write_back: WriteBack = WriteBack.NO,
525:        if write_back == WriteBack.YES:
534:        elif write_back == WriteBack.DIFF:
553:) -> FileContent:
575:) -> FileContent:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
1:import asyncio
2:import pickle
3:from asyncio.base_events import BaseEventLoop
4:from concurrent.futures import Executor, ProcessPoolExecutor
5:from enum import Enum, Flag
6:from functools import partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import re
14:import tokenize
15:import signal
16:import sys
17:from typing import (
18:    Any,
19:    Callable,
20:    Collection,
21:    Dict,
22:    Generic,
23:    Iterable,
24:    Iterator,
25:    List,
26:    Optional,
27:    Pattern,
28:    Sequence,
29:    Set,
30:    Tuple,
31:    Type,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:
41:# lib2to3 fork
42:from blib2to3.pytree import Node, Leaf, type_repr
43:from blib2to3 import pygram, pytree
44:from blib2to3.pgen2 import driver, token
45:from blib2to3.pgen2.parse import ParseError
46:
47:
48:__version__ = "18.5b1"
49:DEFAULT_LINE_LENGTH = 88
50:DEFAULT_EXCLUDES = (
51:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
52:)
53:DEFAULT_INCLUDES = r"\.pyi?$"
54:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
55:
56:
57:# types
58:FileContent = str
59:Encoding = str
60:Depth = int
61:NodeType = int
62:LeafID = int
63:Priority = int
64:Index = int
65:LN = Union[Leaf, Node]
66:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
67:Timestamp = float
68:FileSize = int
69:CacheInfo = Tuple[Timestamp, FileSize]
70:Cache = Dict[Path, CacheInfo]
71:out = partial(click.secho, bold=True, err=True)
72:err = partial(click.secho, fg="red", err=True)
73:
74:pygram.initialize(CACHE_DIR)
75:syms = pygram.python_symbols
76:
77:
78:class NothingChanged(UserWarning):
79:    """Raised by :func:`format_file` when reformatted code is the same as source."""
80:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: All new stdout writes wrap sys.stdout.buffer with io.TextIOWrapper and pass strings: format_file_in_place writes diff_contents (str from diff()) at line 495; format_stdin_to_stdout writes dst (str) at line 532 and diff(src, dst, ...) (str) at line 543. No bytes are passed to TextIOWrapper.write().


Todo item 9 of 12 is correct
description: 'Validate that all writes to stdout introduced in the diff pass `str` objects to `TextIOWrapper.write()` and not bytes, matching the text mode wrapper usage.'
Validating todo item 10 of 12
description: 'Confirm that the test `tests/test_black.py::BlackTestCase.test_preserves_line_endings` creates a temporary file, writes bytes with both "\n" and "\r\n" styles, calls `black.format_file_in_place(..., write_back=black.WriteBack.YES)`, and then reads raw bytes to assert the original newline style is preserved (and that CRLF is absent when the original was LF).'
Calling tool: grepTool
test_preserves_line_endings
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1113:    def test_preserves_line_endings(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
1088:        path = THIS_DIR / "include_exclude_tests"
1089:        report = black.Report()
1090:        empty = re.compile(r"")
1091:        sources: List[Path] = []
1092:        expected = [
1093:            Path(path / "b/dont_exclude/a.py"),
1094:            Path(path / "b/dont_exclude/a.pyi"),
1095:            Path(path / "b/exclude/a.py"),
1096:            Path(path / "b/exclude/a.pyi"),
1097:            Path(path / "b/.definitely_exclude/a.py"),
1098:            Path(path / "b/.definitely_exclude/a.pyi"),
1099:        ]
1100:        this_abs = THIS_DIR.resolve()
1101:        sources.extend(
1102:            black.gen_python_files_in_dir(
1103:                path, this_abs, re.compile(black.DEFAULT_INCLUDES), empty, report
1104:            )
1105:        )
1106:        self.assertEqual(sorted(expected), sorted(sources))
1107:
1108:    def test_invalid_include_exclude(self) -> None:
1109:        for option in ["--include", "--exclude"]:
1110:            result = CliRunner().invoke(black.main, ["-", option, "**()(!!*)"])
1111:            self.assertEqual(result.exit_code, 2)
1112:
1113:    def test_preserves_line_endings(self) -> None:
1114:        with TemporaryDirectory() as workspace:
1115:            test_file = Path(workspace) / "test.py"
1116:            for nl in ["\n", "\r\n"]:
1117:                contents = nl.join(["def f(  ):", "    pass"])
1118:                test_file.write_bytes(contents.encode())
1119:                ff(test_file, write_back=black.WriteBack.YES)
1120:                updated_contents: bytes = test_file.read_bytes()
1121:                self.assertIn(nl.encode(), updated_contents)  # type: ignore
1122:                if nl == "\n":
1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore
1124:
1125:
1126:if __name__ == "__main__":
1127:    unittest.main()

Calling tool: grepTool
def ff\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
\bff\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:109:        self.assertFalse(ff(THIS_FILE))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:163:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:193:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:210:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.DIFF))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1119:                ff(test_file, write_back=black.WriteBack.YES)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import sys
10:from tempfile import TemporaryDirectory
11:from typing import Any, List, Tuple, Iterator
12:import unittest
13:from unittest.mock import patch
14:import re
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:ll = 88
22:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
23:fs = partial(black.format_str, line_length=ll)
24:THIS_FILE = Path(__file__)
25:THIS_DIR = THIS_FILE.parent
26:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
27:
28:
29:def dump_to_stderr(*output: str) -> str:
30:    return "\n" + "\n".join(output) + "\n"
31:
32:
33:def read_data(name: str) -> Tuple[str, str]:
34:    """read_data('test_name') -> 'input', 'output'"""
35:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
36:        name += ".py"
37:    _input: List[str] = []
38:    _output: List[str] = []
39:    with open(THIS_DIR / name, "r", encoding="utf8") as test:
40:        lines = test.readlines()
41:    result = _input
42:    for line in lines:
43:        line = line.replace(EMPTY_LINE, "")
44:        if line.rstrip() == "# output":
45:            result = _output
46:            continue
47:
48:        result.append(line)
49:    if _input and not _output:
50:        # If there's no output marker, treat the entire file as already pre-formatted.
51:        _output = _input[:]
52:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
53:
54:
55:@contextmanager
56:def cache_dir(exists: bool = True) -> Iterator[Path]:
57:    with TemporaryDirectory() as workspace:
58:        cache_dir = Path(workspace)
59:        if not exists:
60:            cache_dir = cache_dir / "new"
61:        with patch("black.CACHE_DIR", cache_dir):
62:            yield cache_dir
63:
64:
65:@contextmanager
66:def event_loop(close: bool) -> Iterator[None]:
67:    policy = asyncio.get_event_loop_policy()
68:    old_loop = policy.get_event_loop()
69:    loop = policy.new_event_loop()
70:    asyncio.set_event_loop(loop)
71:    try:
72:        yield
73:
74:    finally:
75:        policy.set_event_loop(old_loop)
76:        if close:
77:            loop.close()
78:
79:
80:class BlackTestCase(unittest.TestCase):
81:    maxDiff = None
82:
83:    def assertFormatEqual(self, expected: str, actual: str) -> None:
84:        if actual != expected and not os.environ.get("SKIP_AST_PRINT"):
85:            bdv: black.DebugVisitor[Any]
86:            black.out("Expected tree:", fg="green")
87:            try:
88:                exp_node = black.lib2to3_parse(expected)
89:                bdv = black.DebugVisitor()
90:                list(bdv.visit(exp_node))
91:            except Exception as ve:
92:                black.err(str(ve))
93:            black.out("Actual tree:", fg="red")
94:            try:
95:                exp_node = black.lib2to3_parse(actual)
96:                bdv = black.DebugVisitor()
97:                list(bdv.visit(exp_node))
98:            except Exception as ve:
99:                black.err(str(ve))
100:        self.assertEqual(expected, actual)
101:
102:    @patch("black.dump_to_file", dump_to_stderr)
103:    def test_self(self) -> None:
104:        source, expected = read_data("test_black")
105:        actual = fs(source)
106:        self.assertFormatEqual(expected, actual)
107:        black.assert_equivalent(source, actual)
108:        black.assert_stable(source, actual, line_length=ll)
109:        self.assertFalse(ff(THIS_FILE))
110:
111:    @patch("black.dump_to_file", dump_to_stderr)
112:    def test_black(self) -> None:
113:        source, expected = read_data("../black")
114:        actual = fs(source)
115:        self.assertFormatEqual(expected, actual)
116:        black.assert_equivalent(source, actual)
117:        black.assert_stable(source, actual, line_length=ll)
118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
119:
120:    def test_piping(self) -> None:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The test `tests/test_black.py::BlackTestCase.test_preserves_line_endings` creates a temp file, writes bytes with both "\n" and "\r\n", invokes `black.format_file_in_place` via `ff(..., write_back=black.WriteBack.YES)`, then reads raw bytes and asserts the original newline is present and that CRLF is absent when the original was LF.


Todo item 10 of 12 is correct
description: 'Confirm that the test `tests/test_black.py::BlackTestCase.test_preserves_line_endings` creates a temporary file, writes bytes with both "\n" and "\r\n" styles, calls `black.format_file_in_place(..., write_back=black.WriteBack.YES)`, and then reads raw bytes to assert the original newline style is preserved (and that CRLF is absent when the original was LF).'
Validating todo item 11 of 12
description: 'Ensure that all code paths changed by the PR avoid relying on platform default newline translation by explicitly setting the `newline` parameter for file/stdout writes only when writing back or emitting diffs, aligning with the PR intent to preserve line endings.'
Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`

Calling tool: grepTool
class WriteBack\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:118:class WriteBack(Enum):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
100:
101:    def trim_prefix(self, leaf: Leaf) -> None:
102:        leaf.prefix = leaf.prefix[self.consumed :]
103:
104:    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:
105:        """Returns a new Leaf from the consumed part of the prefix."""
106:        unformatted_prefix = leaf.prefix[: self.consumed]
107:        return Leaf(token.NEWLINE, unformatted_prefix)
108:
109:
110:class FormatOn(FormatError):
111:    """Found a comment like `# fmt: on` in the file."""
112:
113:
114:class FormatOff(FormatError):
115:    """Found a comment like `# fmt: off` in the file."""
116:
117:
118:class WriteBack(Enum):
119:    NO = 0
120:    YES = 1
121:    DIFF = 2
122:
123:    @classmethod
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
125:        if check and not diff:
126:            return cls.NO
127:
128:        return cls.DIFF if diff else cls.YES
129:
130:
131:class Changed(Enum):
132:    NO = 0
133:    CACHED = 1
134:    YES = 2
135:
136:
137:class FileMode(Flag):
138:    AUTO_DETECT = 0
139:    PYTHON36 = 1

Calling tool: globTool
**/*test*preserves*line*endings*
No files found. Call Project Search tool again with a more generic glob.

Calling tool: grepTool
test_preserves_line_endings
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1113:    def test_preserves_line_endings(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
1090:        empty = re.compile(r"")
1091:        sources: List[Path] = []
1092:        expected = [
1093:            Path(path / "b/dont_exclude/a.py"),
1094:            Path(path / "b/dont_exclude/a.pyi"),
1095:            Path(path / "b/exclude/a.py"),
1096:            Path(path / "b/exclude/a.pyi"),
1097:            Path(path / "b/.definitely_exclude/a.py"),
1098:            Path(path / "b/.definitely_exclude/a.pyi"),
1099:        ]
1100:        this_abs = THIS_DIR.resolve()
1101:        sources.extend(
1102:            black.gen_python_files_in_dir(
1103:                path, this_abs, re.compile(black.DEFAULT_INCLUDES), empty, report
1104:            )
1105:        )
1106:        self.assertEqual(sorted(expected), sorted(sources))
1107:
1108:    def test_invalid_include_exclude(self) -> None:
1109:        for option in ["--include", "--exclude"]:
1110:            result = CliRunner().invoke(black.main, ["-", option, "**()(!!*)"])
1111:            self.assertEqual(result.exit_code, 2)
1112:
1113:    def test_preserves_line_endings(self) -> None:
1114:        with TemporaryDirectory() as workspace:
1115:            test_file = Path(workspace) / "test.py"
1116:            for nl in ["\n", "\r\n"]:
1117:                contents = nl.join(["def f(  ):", "    pass"])
1118:                test_file.write_bytes(contents.encode())
1119:                ff(test_file, write_back=black.WriteBack.YES)
1120:                updated_contents: bytes = test_file.read_bytes()
1121:                self.assertIn(nl.encode(), updated_contents)  # type: ignore
1122:                if nl == "\n":
1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore
1124:
1125:
1126:if __name__ == "__main__":
1127:    unittest.main()

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Inspected changed paths in black.py. In format_file_in_place, file writes use open(..., encoding=encoding, newline=newline). For DIFF, stdout is wrapped via io.TextIOWrapper(sys.stdout.buffer, encoding=encoding, newline=newline). In format_stdin_to_stdout, both YES and DIFF stdout writes use the same wrapper with explicit newline. Thus all modified write paths avoid platform default newline translation and explicitly set newline only for writing back or diffs, aligning with the PR intent.


Todo item 11 of 12 is correct
description: 'Ensure that all code paths changed by the PR avoid relying on platform default newline translation by explicitly setting the `newline` parameter for file/stdout writes only when writing back or emitting diffs, aligning with the PR intent to preserve line endings.'
Validating todo item 12 of 12
description: 'Cross-check that the encoding used for writing back (file and stdout) is exactly the encoding detected by `tokenize.detect_encoding` for the input, not a hardcoded default.'
Calling tool: grepTool
prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:471:        newline, encoding, src_contents = prepare_input(buf.read())
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """
580:    src_node = lib2to3_parse(src_contents)
581:    dst_contents = ""
582:    future_imports = get_future_imports(src_node)
583:    is_pyi = bool(mode & FileMode.PYI)
584:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
585:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
586:    lines = LineGenerator(
587:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
588:        is_pyi=is_pyi,
589:        normalize_strings=normalize_strings,
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The code now uses prepare_input, which calls tokenize.detect_encoding to obtain the encoding, and then writes back using open(..., encoding=encoding) for files and wraps sys.stdout.buffer with TextIOWrapper(encoding=encoding) for both YES and DIFF modes. No hardcoded default encoding is used in these paths.


Todo item 12 of 12 is correct
description: 'Cross-check that the encoding used for writing back (file and stdout) is exactly the encoding detected by `tokenize.detect_encoding` for the input, not a hardcoded default.'
Validating todo item 1 of 12
description: 'Verify `black.black.py::format_file_in_place` reads the source in binary mode and uses `prepare_input` to obtain `(newline, encoding, src_contents)`, replacing prior `tokenize.open` usage.'

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:

Calling tool: grepTool
^import io$
Matched content:
7:import io

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py, format_file_in_place now opens the source in binary mode (open(src, "rb")) and calls prepare_input(buf.read()) to obtain (newline, encoding, src_contents), replacing the previous tokenize.open usage. Verified by reading the function implementation around line 454.

Todo item 1 of 12 is correct
description: 'Verify `black.black.py::format_file_in_place` reads the source in binary mode and uses `prepare_input` to obtain `(newline, encoding, src_contents)`, replacing prior `tokenize.open` usage.'

Validating todo item 2 of 12
description: 'Confirm that when `write_back == WriteBack.YES` in `format_file_in_place`, the file is reopened with `open(src, "w", encoding=encoding, newline=newline)` and `dst_contents` is written, ensuring newline preservation based on input.'

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py:format_file_in_place, the YES branch opens the file with open(src, "w", encoding=encoding, newline=newline) and writes dst_contents, ensuring newline preservation based on the input-derived newline/encoding.

Todo item 2 of 12 is correct
description: 'Confirm that when `write_back == WriteBack.YES` in `format_file_in_place`, the file is reopened with `open(src, "w", encoding=encoding, newline=newline)` and `dst_contents` is written, ensuring newline preservation based on input.'

Validating todo item 3 of 12
description: 'Confirm that when `write_back == WriteBack.DIFF` in `format_file_in_place`, the diff is written to stdout via an `io.TextIOWrapper` wrapping `sys.stdout.buffer` with the same `encoding` and `newline`, and that `.detach()` is called after writing.'

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """

Calling tool: grepTool
class WriteBack
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:118:class WriteBack(Enum):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
100:
101:    def trim_prefix(self, leaf: Leaf) -> None:
102:        leaf.prefix = leaf.prefix[self.consumed :]
103:
104:    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:
105:        """Returns a new Leaf from the consumed part of the prefix."""
106:        unformatted_prefix = leaf.prefix[: self.consumed]
107:        return Leaf(token.NEWLINE, unformatted_prefix)
108:
109:
110:class FormatOn(FormatError):
111:    """Found a comment like `# fmt: on` in the file."""
112:
113:
114:class FormatOff(FormatError):
115:    """Found a comment like `# fmt: off` in the file."""
116:
117:
118:class WriteBack(Enum):
119:    NO = 0
120:    YES = 1
121:    DIFF = 2
122:
123:    @classmethod
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
125:        if check and not diff:
126:            return cls.NO
127:
128:        return cls.DIFF if diff else cls.YES
129:
130:
131:class Changed(Enum):
132:    NO = 0
133:    CACHED = 1
134:    YES = 2
135:
136:
137:class FileMode(Flag):
138:    AUTO_DETECT = 0
139:    PYTHON36 = 1

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py’s format_file_in_place, the WriteBack.DIFF branch wraps sys.stdout.buffer in io.TextIOWrapper using the detected encoding and newline, writes diff_contents, and calls f.detach() afterward (lines 489–496). This matches the todo requirement.

Todo item 3 of 12 is correct
description: 'Confirm that when `write_back == WriteBack.DIFF` in `format_file_in_place`, the diff is written to stdout via an `io.TextIOWrapper` wrapping `sys.stdout.buffer` with the same `encoding` and `newline`, and that `.detach()` is called after writing.'

Validating todo item 4 of 12
description: 'Verify `black.black.py::format_stdin_to_stdout` reads stdin from `sys.stdin.buffer.read()`, passes it to `prepare_input`, and uses the returned `encoding` and `newline` for writing to stdout for both `WriteBack.YES` and `WriteBack.DIFF` paths via `io.TextIOWrapper`.'

Calling tool: grepTool
def format_stdin_to_stdout\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:503:def format_stdin_to_stdout(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:

Calling tool: grepTool
^import io$
Matched content:
7:import io

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, format_stdin_to_stdout reads from sys.stdin.buffer.read() and passes the bytes to prepare_input. The returned encoding and newline are used to construct io.TextIOWrapper over sys.stdout.buffer for both WriteBack.YES and WriteBack.DIFF paths, and writing is done via that wrapper.

Todo item 4 of 12 is correct
description: 'Verify `black.black.py::format_stdin_to_stdout` reads stdin from `sys.stdin.buffer.read()`, passes it to `prepare_input`, and uses the returned `encoding` and `newline` for writing to stdout for both `WriteBack.YES` and `WriteBack.DIFF` paths via `io.TextIOWrapper`.'

Validating todo item 5 of 12
description: 'Check that `prepare_input` is implemented to: (1) wrap the bytes in `io.BytesIO`, (2) call `tokenize.detect_encoding(srcbuf.readline)` to determine `encoding` and `lines`, (3) set `newline` to "\r\n" iff the first line in `lines` ends with CRLF, and (4) return decoded contents using `io.TextIOWrapper(srcbuf, encoding).read()` so internal text uses universal newlines (LF only).'

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py

Calling tool: grepTool
def prepare_input\(
Matched content:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
670:        instead.
671:
672:        Then yields objects of type `T` from the selected visitor.
673:        """
674:        if node.type < 256:
675:            name = token.tok_name[node.type]

Calling tool: grepTool
import tokenize
Matched content:
14:import tokenize

Calling tool: grepTool
import io
Matched content:
7:import io

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The implemented prepare_input wraps bytes in io.BytesIO, uses tokenize.detect_encoding(srcbuf.readline) to get encoding and lines, sets newline to CRLF only if the first line ends with CRLF (lines[0][-2:] == b"\r\n"), seeks back, and returns decoded text via io.TextIOWrapper(srcbuf, encoding).read(), which applies universal newline translation.

Todo item 5 of 12 is correct
description: 'Check that `prepare_input` is implemented to: (1) wrap the bytes in `io.BytesIO`, (2) call `tokenize.detect_encoding(srcbuf.readline)` to determine `encoding` and `lines`, (3) set `newline` to "\r\n" iff the first line in `lines` ends with CRLF, and (4) return decoded contents using `io.TextIOWrapper(srcbuf, encoding).read()` so internal text uses universal newlines (LF only).'

Validating todo item 6 of 12
description: 'Ensure `black.black.py::lib2to3_parse` unconditionally appends a single "\n" when the input text doesn’t end with a newline, removing any CRLF-detection logic, to keep internal representation normalized to LF.'

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py

Calling tool: grepTool
def lib2to3_parse\(
Matched content:
625:def lib2to3_parse(src_txt: str) -> Node:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
670:        instead.
671:
672:        Then yields objects of type `T` from the selected visitor.
673:        """
674:        if node.type < 256:
675:            name = token.tok_name[node.type]
676:        else:
677:            name = type_repr(node.type)
678:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
679:
680:    def visit_default(self, node: LN) -> Iterator[T]:
681:        """Default `visit_*()` implementation. Recurses to children of `node`."""
682:        if isinstance(node, Node):
683:            for child in node.children:
684:                yield from self.visit(child)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py lines 625-631, lib2to3_parse now unconditionally appends a single "\n" when input doesn’t end with one and the previous CRLF detection logic has been removed. Verified by reading the exact function implementation.

Todo item 6 of 12 is correct
description: 'Ensure `black.black.py::lib2to3_parse` unconditionally appends a single "\n" when the input text doesn’t end with a newline, removing any CRLF-detection logic, to keep internal representation normalized to LF.'

Validating todo item 7 of 12
description: 'Verify that `GRAMMARS` and downstream parsing/formatting functions continue to operate on LF-only internal text (consistent with `prepare_input` universal newline behavior).'

Calling tool: grepTool
GRAMMARS\s*=\s*\[
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:618:GRAMMARS = [

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
670:        instead.
671:
672:        Then yields objects of type `T` from the selected visitor.
673:        """
674:        if node.type < 256:
675:            name = token.tok_name[node.type]
676:        else:
677:            name = type_repr(node.type)
678:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
679:

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """
580:    src_node = lib2to3_parse(src_contents)
581:    dst_contents = ""
582:    future_imports = get_future_imports(src_node)
583:    is_pyi = bool(mode & FileMode.PYI)
584:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
585:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
586:    lines = LineGenerator(
587:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
588:        is_pyi=is_pyi,
589:        normalize_strings=normalize_strings,
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,

Calling tool: grepTool
\r\n
Grep command failed with exit code 2: rg: the literal "\n" is not allowed in a regex

Consider enabling multiline mode with the --multiline flag (or -U for short).
When multiline mode is enabled, new line characters can be matched.


Calling tool: grepTool
"\\r\\n"
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1116:            for nl in ["\n", "\r\n"]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore

Calling tool: grepTool
tokenize\.open\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
1100:        this_abs = THIS_DIR.resolve()
1101:        sources.extend(
1102:            black.gen_python_files_in_dir(
1103:                path, this_abs, re.compile(black.DEFAULT_INCLUDES), empty, report
1104:            )
1105:        )
1106:        self.assertEqual(sorted(expected), sorted(sources))
1107:
1108:    def test_invalid_include_exclude(self) -> None:
1109:        for option in ["--include", "--exclude"]:
1110:            result = CliRunner().invoke(black.main, ["-", option, "**()(!!*)"])
1111:            self.assertEqual(result.exit_code, 2)
1112:
1113:    def test_preserves_line_endings(self) -> None:
1114:        with TemporaryDirectory() as workspace:
1115:            test_file = Path(workspace) / "test.py"
1116:            for nl in ["\n", "\r\n"]:
1117:                contents = nl.join(["def f(  ):", "    pass"])
1118:                test_file.write_bytes(contents.encode())
1119:                ff(test_file, write_back=black.WriteBack.YES)
1120:                updated_contents: bytes = test_file.read_bytes()
1121:                self.assertIn(nl.encode(), updated_contents)  # type: ignore
1122:                if nl == "\n":
1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore
1124:
1125:
1126:if __name__ == "__main__":
1127:    unittest.main()

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: prepare_input normalizes all input to LF-only via TextIOWrapper universal newlines, and lib2to3_parse now unconditionally appends “\n” (replacing prior CRLF detection). GRAMMARS is used on this LF-only text, so downstream parsing/formatting operates on LF-only internal strings.

Todo item 7 of 12 is correct
description: 'Verify that `GRAMMARS` and downstream parsing/formatting functions continue to operate on LF-only internal text (consistent with `prepare_input` universal newline behavior).'

Validating todo item 8 of 12
description: 'Check that the new import `import io` is present at the top of `black.black.py` and is the module used by the added code paths (i.e., `io.BytesIO` and `io.TextIOWrapper`).'

Calling tool: grepTool
(?i)def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: grepTool
^import io
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black/black.py: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black/black.py: No such file or directory (os error 2)


Calling tool: grepTool
^import io
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/blib2to3/pgen2/driver.py:20:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:7:import io

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
1:import asyncio
2:import pickle
3:from asyncio.base_events import BaseEventLoop
4:from concurrent.futures import Executor, ProcessPoolExecutor
5:from enum import Enum, Flag
6:from functools import partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import re
14:import tokenize
15:import signal
16:import sys
17:from typing import (
18:    Any,
19:    Callable,
20:    Collection,
21:    Dict,
22:    Generic,
23:    Iterable,
24:    Iterator,
25:    List,
26:    Optional,
27:    Pattern,
28:    Sequence,
29:    Set,
30:    Tuple,
31:    Type,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:

Calling tool: grepTool
io\.TextIOWrapper\(|io\.BytesIO\(
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black: No such file or directory (os error 2)


Calling tool: grepTool
io\.TextIOWrapper\(|io\.BytesIO\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:489:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:526:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:537:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:611:    srcbuf = io.BytesIO(src)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"

Calling tool: grepTool
from io import|import io
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/blib2to3/pytree.py:16:from io import StringIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:7:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/blib2to3/pgen2/driver.py:20:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:6:from io import BytesIO, TextIOWrapper

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Confirmed `import io` exists at top of `black/black.py` (line 7). Verified added code uses `io.TextIOWrapper` and `io.BytesIO` in this file (lines ~489, 526, 537, 611, 615).

Todo item 8 of 12 is correct
description: 'Check that the new import `import io` is present at the top of `black.black.py` and is the module used by the added code paths (i.e., `io.BytesIO` and `io.TextIOWrapper`).'

Validating todo item 9 of 12
description: 'Validate that all writes to stdout introduced in the diff pass `str` objects to `TextIOWrapper.write()` and not bytes, matching the text mode wrapper usage.'

Calling tool: grepTool
TextIOWrapper\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:489:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:526:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:537:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:124:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:125:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:143:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:144:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:209:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:

Calling tool: grepTool
def diff\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:3090:def diff(a: str, b: str, a_name: str, b_name: str) -> str:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
3085:            if lines and lines[-1] != "\n":
3086:                f.write("\n")
3087:    return f.name
3088:
3089:
3090:def diff(a: str, b: str, a_name: str, b_name: str) -> str:
3091:    """Return a unified diff string between strings `a` and `b`."""
3092:    import difflib
3093:
3094:    a_lines = [line + "\n" for line in a.split("\n")]
3095:    b_lines = [line + "\n" for line in b.split("\n")]
3096:    return "".join(
3097:        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)
3098:    )
3099:
3100:
3101:def cancel(tasks: Iterable[asyncio.Task]) -> None:
3102:    """asyncio signal handler that cancels all `tasks` and reports to stderr."""
3103:    err("Aborted!")
3104:    for task in tasks:
3105:        task.cancel()
3106:
3107:
3108:def shutdown(loop: BaseEventLoop) -> None:
3109:    """Cancel all pending tasks on `loop`, wait for them, and close the loop."""
3110:    try:
3111:        # This part is borrowed from asyncio/runners.py in Python 3.7b2.
3112:        to_cancel = [task for task in asyncio.Task.all_tasks(loop) if not task.done()]
3113:        if not to_cancel:
3114:            return
3115:
3116:        for task in to_cancel:
3117:            task.cancel()
3118:        loop.run_until_complete(
3119:            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)
3120:        )
3121:    finally:
3122:        # `concurrent.futures.Future` objects cannot be cancelled once they
3123:        # are already running. There might be some when the `shutdown()` happened.
3124:        # Silence their logger's spew about the event loop being closed.

Calling tool: grepTool
class WriteBack|WriteBack|FileContent|format_file_in_place\(|format_stdin_to_stdout\(
Matched content:
58:FileContent = str
118:class WriteBack(Enum):
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
276:    write_back = WriteBack.from_configuration(check=check, diff=diff)
346:    write_back: WriteBack,
359:            if format_stdin_to_stdout(
365:            if write_back != WriteBack.DIFF:
370:            if changed is not Changed.CACHED and format_file_in_place(
378:            if write_back == WriteBack.YES and changed is not Changed.NO:
389:    write_back: WriteBack,
403:    if write_back != WriteBack.DIFF:
412:        if write_back == WriteBack.DIFF:
450:    if write_back == WriteBack.YES and formatted:
454:def format_file_in_place(
458:    write_back: WriteBack = WriteBack.NO,
503:def format_stdin_to_stdout(
506:    write_back: WriteBack = WriteBack.NO,
525:        if write_back == WriteBack.YES:
534:        elif write_back == WriteBack.DIFF:
553:) -> FileContent:
575:) -> FileContent:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
1:import asyncio
2:import pickle
3:from asyncio.base_events import BaseEventLoop
4:from concurrent.futures import Executor, ProcessPoolExecutor
5:from enum import Enum, Flag
6:from functools import partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import re
14:import tokenize
15:import signal
16:import sys
17:from typing import (
18:    Any,
19:    Callable,
20:    Collection,
21:    Dict,
22:    Generic,
23:    Iterable,
24:    Iterator,
25:    List,
26:    Optional,
27:    Pattern,
28:    Sequence,
29:    Set,
30:    Tuple,
31:    Type,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:
41:# lib2to3 fork
42:from blib2to3.pytree import Node, Leaf, type_repr
43:from blib2to3 import pygram, pytree
44:from blib2to3.pgen2 import driver, token
45:from blib2to3.pgen2.parse import ParseError
46:
47:
48:__version__ = "18.5b1"
49:DEFAULT_LINE_LENGTH = 88
50:DEFAULT_EXCLUDES = (
51:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
52:)
53:DEFAULT_INCLUDES = r"\.pyi?$"
54:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
55:
56:
57:# types
58:FileContent = str
59:Encoding = str
60:Depth = int
61:NodeType = int
62:LeafID = int
63:Priority = int
64:Index = int
65:LN = Union[Leaf, Node]
66:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
67:Timestamp = float
68:FileSize = int
69:CacheInfo = Tuple[Timestamp, FileSize]
70:Cache = Dict[Path, CacheInfo]
71:out = partial(click.secho, bold=True, err=True)
72:err = partial(click.secho, fg="red", err=True)
73:
74:pygram.initialize(CACHE_DIR)
75:syms = pygram.python_symbols
76:
77:
78:class NothingChanged(UserWarning):
79:    """Raised by :func:`format_file` when reformatted code is the same as source."""
80:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: All new stdout writes wrap sys.stdout.buffer with io.TextIOWrapper and pass strings: format_file_in_place writes diff_contents (str from diff()) at line 495; format_stdin_to_stdout writes dst (str) at line 532 and diff(src, dst, ...) (str) at line 543. No bytes are passed to TextIOWrapper.write().

Todo item 9 of 12 is correct
description: 'Validate that all writes to stdout introduced in the diff pass `str` objects to `TextIOWrapper.write()` and not bytes, matching the text mode wrapper usage.'

Validating todo item 10 of 12
description: 'Confirm that the test `tests/test_black.py::BlackTestCase.test_preserves_line_endings` creates a temporary file, writes bytes with both "\n" and "\r\n" styles, calls `black.format_file_in_place(..., write_back=black.WriteBack.YES)`, and then reads raw bytes to assert the original newline style is preserved (and that CRLF is absent when the original was LF).'

Calling tool: grepTool
test_preserves_line_endings
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1113:    def test_preserves_line_endings(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
1088:        path = THIS_DIR / "include_exclude_tests"
1089:        report = black.Report()
1090:        empty = re.compile(r"")
1091:        sources: List[Path] = []
1092:        expected = [
1093:            Path(path / "b/dont_exclude/a.py"),
1094:            Path(path / "b/dont_exclude/a.pyi"),
1095:            Path(path / "b/exclude/a.py"),
1096:            Path(path / "b/exclude/a.pyi"),
1097:            Path(path / "b/.definitely_exclude/a.py"),
1098:            Path(path / "b/.definitely_exclude/a.pyi"),
1099:        ]
1100:        this_abs = THIS_DIR.resolve()
1101:        sources.extend(
1102:            black.gen_python_files_in_dir(
1103:                path, this_abs, re.compile(black.DEFAULT_INCLUDES), empty, report
1104:            )
1105:        )
1106:        self.assertEqual(sorted(expected), sorted(sources))
1107:
1108:    def test_invalid_include_exclude(self) -> None:
1109:        for option in ["--include", "--exclude"]:
1110:            result = CliRunner().invoke(black.main, ["-", option, "**()(!!*)"])
1111:            self.assertEqual(result.exit_code, 2)
1112:
1113:    def test_preserves_line_endings(self) -> None:
1114:        with TemporaryDirectory() as workspace:
1115:            test_file = Path(workspace) / "test.py"
1116:            for nl in ["\n", "\r\n"]:
1117:                contents = nl.join(["def f(  ):", "    pass"])
1118:                test_file.write_bytes(contents.encode())
1119:                ff(test_file, write_back=black.WriteBack.YES)
1120:                updated_contents: bytes = test_file.read_bytes()
1121:                self.assertIn(nl.encode(), updated_contents)  # type: ignore
1122:                if nl == "\n":
1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore
1124:
1125:
1126:if __name__ == "__main__":
1127:    unittest.main()

Calling tool: grepTool
def ff\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
\bff\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:109:        self.assertFalse(ff(THIS_FILE))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:163:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:193:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:210:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.DIFF))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1119:                ff(test_file, write_back=black.WriteBack.YES)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import sys
10:from tempfile import TemporaryDirectory
11:from typing import Any, List, Tuple, Iterator
12:import unittest
13:from unittest.mock import patch
14:import re
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:ll = 88
22:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
23:fs = partial(black.format_str, line_length=ll)
24:THIS_FILE = Path(__file__)
25:THIS_DIR = THIS_FILE.parent
26:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
27:
28:
29:def dump_to_stderr(*output: str) -> str:
30:    return "\n" + "\n".join(output) + "\n"
31:
32:
33:def read_data(name: str) -> Tuple[str, str]:
34:    """read_data('test_name') -> 'input', 'output'"""
35:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
36:        name += ".py"
37:    _input: List[str] = []
38:    _output: List[str] = []
39:    with open(THIS_DIR / name, "r", encoding="utf8") as test:
40:        lines = test.readlines()
41:    result = _input
42:    for line in lines:
43:        line = line.replace(EMPTY_LINE, "")
44:        if line.rstrip() == "# output":
45:            result = _output
46:            continue
47:
48:        result.append(line)
49:    if _input and not _output:
50:        # If there's no output marker, treat the entire file as already pre-formatted.
51:        _output = _input[:]
52:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
53:
54:
55:@contextmanager
56:def cache_dir(exists: bool = True) -> Iterator[Path]:
57:    with TemporaryDirectory() as workspace:
58:        cache_dir = Path(workspace)
59:        if not exists:
60:            cache_dir = cache_dir / "new"
61:        with patch("black.CACHE_DIR", cache_dir):
62:            yield cache_dir
63:
64:
65:@contextmanager
66:def event_loop(close: bool) -> Iterator[None]:
67:    policy = asyncio.get_event_loop_policy()
68:    old_loop = policy.get_event_loop()
69:    loop = policy.new_event_loop()
70:    asyncio.set_event_loop(loop)
71:    try:
72:        yield
73:
74:    finally:
75:        policy.set_event_loop(old_loop)
76:        if close:
77:            loop.close()
78:
79:
80:class BlackTestCase(unittest.TestCase):
81:    maxDiff = None
82:
83:    def assertFormatEqual(self, expected: str, actual: str) -> None:
84:        if actual != expected and not os.environ.get("SKIP_AST_PRINT"):
85:            bdv: black.DebugVisitor[Any]
86:            black.out("Expected tree:", fg="green")
87:            try:
88:                exp_node = black.lib2to3_parse(expected)
89:                bdv = black.DebugVisitor()
90:                list(bdv.visit(exp_node))
91:            except Exception as ve:
92:                black.err(str(ve))
93:            black.out("Actual tree:", fg="red")
94:            try:
95:                exp_node = black.lib2to3_parse(actual)
96:                bdv = black.DebugVisitor()
97:                list(bdv.visit(exp_node))
98:            except Exception as ve:
99:                black.err(str(ve))
100:        self.assertEqual(expected, actual)
101:
102:    @patch("black.dump_to_file", dump_to_stderr)
103:    def test_self(self) -> None:
104:        source, expected = read_data("test_black")
105:        actual = fs(source)
106:        self.assertFormatEqual(expected, actual)
107:        black.assert_equivalent(source, actual)
108:        black.assert_stable(source, actual, line_length=ll)
109:        self.assertFalse(ff(THIS_FILE))
110:
111:    @patch("black.dump_to_file", dump_to_stderr)
112:    def test_black(self) -> None:
113:        source, expected = read_data("../black")
114:        actual = fs(source)
115:        self.assertFormatEqual(expected, actual)
116:        black.assert_equivalent(source, actual)
117:        black.assert_stable(source, actual, line_length=ll)
118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
119:
120:    def test_piping(self) -> None:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The test `tests/test_black.py::BlackTestCase.test_preserves_line_endings` creates a temp file, writes bytes with both "\n" and "\r\n", invokes `black.format_file_in_place` via `ff(..., write_back=black.WriteBack.YES)`, then reads raw bytes and asserts the original newline is present and that CRLF is absent when the original was LF.

Todo item 10 of 12 is correct
description: 'Confirm that the test `tests/test_black.py::BlackTestCase.test_preserves_line_endings` creates a temporary file, writes bytes with both "\n" and "\r\n" styles, calls `black.format_file_in_place(..., write_back=black.WriteBack.YES)`, and then reads raw bytes to assert the original newline style is preserved (and that CRLF is absent when the original was LF).'

Validating todo item 11 of 12
description: 'Ensure that all code paths changed by the PR avoid relying on platform default newline translation by explicitly setting the `newline` parameter for file/stdout writes only when writing back or emitting diffs, aligning with the PR intent to preserve line endings.'

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:454:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`

Calling tool: grepTool
class WriteBack\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:118:class WriteBack(Enum):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
100:
101:    def trim_prefix(self, leaf: Leaf) -> None:
102:        leaf.prefix = leaf.prefix[self.consumed :]
103:
104:    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:
105:        """Returns a new Leaf from the consumed part of the prefix."""
106:        unformatted_prefix = leaf.prefix[: self.consumed]
107:        return Leaf(token.NEWLINE, unformatted_prefix)
108:
109:
110:class FormatOn(FormatError):
111:    """Found a comment like `# fmt: on` in the file."""
112:
113:
114:class FormatOff(FormatError):
115:    """Found a comment like `# fmt: off` in the file."""
116:
117:
118:class WriteBack(Enum):
119:    NO = 0
120:    YES = 1
121:    DIFF = 2
122:
123:    @classmethod
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
125:        if check and not diff:
126:            return cls.NO
127:
128:        return cls.DIFF if diff else cls.YES
129:
130:
131:class Changed(Enum):
132:    NO = 0
133:    CACHED = 1
134:    YES = 2
135:
136:
137:class FileMode(Flag):
138:    AUTO_DETECT = 0
139:    PYTHON36 = 1

Calling tool: globTool
**/*test*preserves*line*endings*
No files found. Call Project Search tool again with a more generic glob.

Calling tool: grepTool
test_preserves_line_endings
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py:1113:    def test_preserves_line_endings(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/tests/test_black.py
1090:        empty = re.compile(r"")
1091:        sources: List[Path] = []
1092:        expected = [
1093:            Path(path / "b/dont_exclude/a.py"),
1094:            Path(path / "b/dont_exclude/a.pyi"),
1095:            Path(path / "b/exclude/a.py"),
1096:            Path(path / "b/exclude/a.pyi"),
1097:            Path(path / "b/.definitely_exclude/a.py"),
1098:            Path(path / "b/.definitely_exclude/a.pyi"),
1099:        ]
1100:        this_abs = THIS_DIR.resolve()
1101:        sources.extend(
1102:            black.gen_python_files_in_dir(
1103:                path, this_abs, re.compile(black.DEFAULT_INCLUDES), empty, report
1104:            )
1105:        )
1106:        self.assertEqual(sorted(expected), sorted(sources))
1107:
1108:    def test_invalid_include_exclude(self) -> None:
1109:        for option in ["--include", "--exclude"]:
1110:            result = CliRunner().invoke(black.main, ["-", option, "**()(!!*)"])
1111:            self.assertEqual(result.exit_code, 2)
1112:
1113:    def test_preserves_line_endings(self) -> None:
1114:        with TemporaryDirectory() as workspace:
1115:            test_file = Path(workspace) / "test.py"
1116:            for nl in ["\n", "\r\n"]:
1117:                contents = nl.join(["def f(  ):", "    pass"])
1118:                test_file.write_bytes(contents.encode())
1119:                ff(test_file, write_back=black.WriteBack.YES)
1120:                updated_contents: bytes = test_file.read_bytes()
1121:                self.assertIn(nl.encode(), updated_contents)  # type: ignore
1122:                if nl == "\n":
1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore
1124:
1125:
1126:if __name__ == "__main__":
1127:    unittest.main()

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Inspected changed paths in black.py. In format_file_in_place, file writes use open(..., encoding=encoding, newline=newline). For DIFF, stdout is wrapped via io.TextIOWrapper(sys.stdout.buffer, encoding=encoding, newline=newline). In format_stdin_to_stdout, both YES and DIFF stdout writes use the same wrapper with explicit newline. Thus all modified write paths avoid platform default newline translation and explicitly set newline only for writing back or diffs, aligning with the PR intent.

Todo item 11 of 12 is correct
description: 'Ensure that all code paths changed by the PR avoid relying on platform default newline translation by explicitly setting the `newline` parameter for file/stdout writes only when writing back or emitting diffs, aligning with the PR intent to preserve line endings.'

Validating todo item 12 of 12
description: 'Cross-check that the encoding used for writing back (file and stdout) is exactly the encoding detected by `tokenize.detect_encoding` for the input, not a hardcoded default.'

Calling tool: grepTool
prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:471:        newline, encoding, src_contents = prepare_input(buf.read())
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/good/black/black.py
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """
580:    src_node = lib2to3_parse(src_contents)
581:    dst_contents = ""
582:    future_imports = get_future_imports(src_node)
583:    is_pyi = bool(mode & FileMode.PYI)
584:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
585:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
586:    lines = LineGenerator(
587:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
588:        is_pyi=is_pyi,
589:        normalize_strings=normalize_strings,
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The code now uses prepare_input, which calls tokenize.detect_encoding to obtain the encoding, and then writes back using open(..., encoding=encoding) for files and wraps sys.stdout.buffer with TextIOWrapper(encoding=encoding) for both YES and DIFF modes. No hardcoded default encoding is used in these paths.

Todo item 12 of 12 is correct
description: 'Cross-check that the encoding used for writing back (file and stdout) is exactly the encoding detected by `tokenize.detect_encoding` for the input, not a hardcoded default.'


=== PHASE 2 COMPLETE ===

