=== PHASE 1: ANALYSIS ===

Calling tool: grepTool
test_fmtonoff4
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_fmtonoff4
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/test_black.py:636:    def test_fmtonoff4(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/test_black.py
620:    def test_fmtonoff2(self) -> None:
621:        source, expected = read_data("fmtonoff2")
622:        actual = fs(source)
623:        self.assertFormatEqual(expected, actual)
624:        black.assert_equivalent(source, actual)
625:        black.assert_stable(source, actual, black.FileMode())
626:
627:    @patch("black.dump_to_file", dump_to_stderr)
628:    def test_fmtonoff3(self) -> None:
629:        source, expected = read_data("fmtonoff3")
630:        actual = fs(source)
631:        self.assertFormatEqual(expected, actual)
632:        black.assert_equivalent(source, actual)
633:        black.assert_stable(source, actual, black.FileMode())
634:
635:    @patch("black.dump_to_file", dump_to_stderr)
636:    def test_fmtonoff4(self) -> None:
637:        source, expected = read_data("fmtonoff4")
638:        actual = fs(source)
639:        self.assertFormatEqual(expected, actual)
640:        black.assert_equivalent(source, actual)
641:        black.assert_stable(source, actual, black.FileMode())
642:
643:    @patch("black.dump_to_file", dump_to_stderr)
644:    def test_remove_empty_parentheses_after_class(self) -> None:
645:        source, expected = read_data("class_blank_parentheses")
646:        actual = fs(source)
647:        self.assertFormatEqual(expected, actual)
648:        black.assert_equivalent(source, actual)
649:        black.assert_stable(source, actual, black.FileMode())
650:
651:    @patch("black.dump_to_file", dump_to_stderr)
652:    def test_new_line_between_class_and_code(self) -> None:
653:        source, expected = read_data("class_methods_new_line")
654:        actual = fs(source)
655:        self.assertFormatEqual(expected, actual)
656:        black.assert_equivalent(source, actual)
657:        black.assert_stable(source, actual, black.FileMode())
658:
659:    @patch("black.dump_to_file", dump_to_stderr)
660:    def test_bracket_match(self) -> None:
661:        source, expected = read_data("bracketmatch")
662:        actual = fs(source)
663:        self.assertFormatEqual(expected, actual)
664:        black.assert_equivalent(source, actual)
665:        black.assert_stable(source, actual, black.FileMode())
666:
667:    @patch("black.dump_to_file", dump_to_stderr)
668:    def test_tuple_assign(self) -> None:
669:        source, expected = read_data("tupleassign")
670:        actual = fs(source)
671:        self.assertFormatEqual(expected, actual)
672:        black.assert_equivalent(source, actual)
673:        black.assert_stable(source, actual, black.FileMode())
674:
675:    @patch("black.dump_to_file", dump_to_stderr)
676:    def test_beginning_backslash(self) -> None:
677:        source, expected = read_data("beginning_backslash")
678:        actual = fs(source)
679:        self.assertFormatEqual(expected, actual)
680:        black.assert_equivalent(source, actual)
681:        black.assert_stable(source, actual, black.FileMode())
682:
683:    def test_tab_comment_indentation(self) -> None:
684:        contents_tab = "if 1:\n\tif 2:\n\t\tpass\n\t# comment\n\tpass\n"
685:        contents_spc = "if 1:\n    if 2:\n        pass\n    # comment\n    pass\n"
686:        self.assertFormatEqual(contents_spc, fs(contents_spc))
687:        self.assertFormatEqual(contents_spc, fs(contents_tab))
688:
689:        contents_tab = "if 1:\n\tif 2:\n\t\tpass\n\t\t# comment\n\tpass\n"
690:        contents_spc = "if 1:\n    if 2:\n        pass\n        # comment\n    pass\n"
691:        self.assertFormatEqual(contents_spc, fs(contents_spc))
692:        self.assertFormatEqual(contents_spc, fs(contents_tab))
693:
694:        # mixed tabs and spaces (valid Python 2 code)
695:        contents_tab = "if 1:\n        if 2:\n\t\tpass\n\t# comment\n        pass\n"
696:        contents_spc = "if 1:\n    if 2:\n        pass\n    # comment\n    pass\n"
697:        self.assertFormatEqual(contents_spc, fs(contents_spc))
698:        self.assertFormatEqual(contents_spc, fs(contents_tab))
699:
700:        contents_tab = "if 1:\n        if 2:\n\t\tpass\n\t\t# comment\n        pass\n"
701:        contents_spc = "if 1:\n    if 2:\n        pass\n        # comment\n    pass\n"
702:        self.assertFormatEqual(contents_spc, fs(contents_spc))
703:        self.assertFormatEqual(contents_spc, fs(contents_tab))
704:
705:    def test_report_verbose(self) -> None:
706:        report = black.Report(verbose=True)
707:        out_lines = []
708:        err_lines = []
709:
710:        def out(msg: str, **kwargs: Any) -> None:
711:            out_lines.append(msg)
712:
713:        def err(msg: str, **kwargs: Any) -> None:
714:            err_lines.append(msg)
715:
716:        with patch("black.out", out), patch("black.err", err):
717:            report.done(Path("f1"), black.Changed.NO)
718:            self.assertEqual(len(out_lines), 1)
719:            self.assertEqual(len(err_lines), 0)
720:            self.assertEqual(out_lines[-1], "f1 already well formatted, good job.")
721:            self.assertEqual(unstyle(str(report)), "1 file left unchanged.")
722:            self.assertEqual(report.return_code, 0)
723:            report.done(Path("f2"), black.Changed.YES)
724:            self.assertEqual(len(out_lines), 2)
725:            self.assertEqual(len(err_lines), 0)
726:            self.assertEqual(out_lines[-1], "reformatted f2")
727:            self.assertEqual(
728:                unstyle(str(report)), "1 file reformatted, 1 file left unchanged."
729:            )
730:            report.done(Path("f3"), black.Changed.CACHED)
731:            self.assertEqual(len(out_lines), 3)
732:            self.assertEqual(len(err_lines), 0)
733:            self.assertEqual(
734:                out_lines[-1], "f3 wasn't modified on disk since last run."
735:            )
736:            self.assertEqual(
737:                unstyle(str(report)), "1 file reformatted, 2 files left unchanged."
738:            )
739:            self.assertEqual(report.return_code, 0)

Calling tool: grepTool
fmtonoff4
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_fmtonoff4
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/test_black.py:636:    def test_fmtonoff4(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/test_black.py:637:        source, expected = read_data("fmtonoff4")

Calling tool: globTool
**/data/*fmtonoff4*
No files found. Call Project Search tool again with a more generic glob.

Calling tool: globTool
**/*fmtonoff4*
No files found. Call Project Search tool again with a more generic glob.

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/test_black.py:51:def read_data(name: str, data: bool = True) -> Tuple[str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:import logging
4:from concurrent.futures import ThreadPoolExecutor
5:from contextlib import contextmanager
6:from functools import partial
7:from io import BytesIO, TextIOWrapper
8:import os
9:from pathlib import Path
10:import regex as re
11:import sys
12:from tempfile import TemporaryDirectory
13:from typing import Any, BinaryIO, Generator, List, Tuple, Iterator, TypeVar
14:import unittest
15:from unittest.mock import patch, MagicMock
16:
17:from click import unstyle
18:from click.testing import CliRunner
19:
20:import black
21:from black import Feature, TargetVersion
22:
23:try:
24:    import blackd
25:    from aiohttp.test_utils import AioHTTPTestCase, unittest_run_loop
26:    from aiohttp import web
27:except ImportError:
28:    has_blackd_deps = False
29:else:
30:    has_blackd_deps = True
31:
32:from pathspec import PathSpec
33:
34:ff = partial(black.format_file_in_place, mode=black.FileMode(), fast=True)
35:fs = partial(black.format_str, mode=black.FileMode())
36:THIS_FILE = Path(__file__)
37:THIS_DIR = THIS_FILE.parent
38:DETERMINISTIC_HEADER = "[Deterministic header]"
39:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
40:PY36_ARGS = [
41:    f"--target-version={version.name.lower()}" for version in black.PY36_VERSIONS
42:]
43:T = TypeVar("T")
44:R = TypeVar("R")
45:
46:
47:def dump_to_stderr(*output: str) -> str:
48:    return "\n" + "\n".join(output) + "\n"
49:
50:
51:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
52:    """read_data('test_name') -> 'input', 'output'"""
53:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
54:        name += ".py"
55:    _input: List[str] = []
56:    _output: List[str] = []
57:    base_dir = THIS_DIR / "data" if data else THIS_DIR
58:    with open(base_dir / name, "r", encoding="utf8") as test:
59:        lines = test.readlines()
60:    result = _input
61:    for line in lines:
62:        line = line.replace(EMPTY_LINE, "")
63:        if line.rstrip() == "# output":
64:            result = _output
65:            continue
66:
67:        result.append(line)
68:    if _input and not _output:
69:        # If there's no output marker, treat the entire file as already pre-formatted.
70:        _output = _input[:]
71:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
72:
73:
74:@contextmanager
75:def cache_dir(exists: bool = True) -> Iterator[Path]:
76:    with TemporaryDirectory() as workspace:
77:        cache_dir = Path(workspace)
78:        if not exists:
79:            cache_dir = cache_dir / "new"
80:        with patch("black.CACHE_DIR", cache_dir):
81:            yield cache_dir
82:
83:
84:@contextmanager
85:def event_loop(close: bool) -> Iterator[None]:
86:    policy = asyncio.get_event_loop_policy()
87:    loop = policy.new_event_loop()
88:    asyncio.set_event_loop(loop)
89:    try:
90:        yield
91:
92:    finally:
93:        if close:
94:            loop.close()
95:
96:
97:@contextmanager
98:def skip_if_exception(e: str) -> Iterator[None]:
99:    try:
100:        yield
101:    except Exception as exc:
102:        if exc.__class__.__name__ == e:
103:            unittest.skip(f"Encountered expected exception {exc}, skipping")
104:        else:
105:            raise
106:
107:
108:class BlackRunner(CliRunner):
109:    """Modify CliRunner so that stderr is not merged with stdout.
110:
111:    This is a hack that can be removed once we depend on Click 7.x"""
112:
113:    def __init__(self) -> None:
114:        self.stderrbuf = BytesIO()
115:        self.stdoutbuf = BytesIO()
116:        self.stdout_bytes = b""
117:        self.stderr_bytes = b""
118:        super().__init__()
119:
120:    @contextmanager

Calling tool: globTool
**/tests/data/*
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/debug_visitor.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/comments.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/function_trailing_comma.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/function.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/python2_unicode_literals.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/import_spacing.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/expression.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/python37.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/slices.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/class_methods_new_line.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/force_pyi.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/composition.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/cantfit.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/python38.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/comments5.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/pep_570.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/numeric_literals_py2.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/empty_lines.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/collections.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/empty_pyproject.toml
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/numeric_literals_skip_underscores.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/comments4.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/string_prefixes.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/expression.diff
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/blackd_diff.diff
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/class_blank_parentheses.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/stub.pyi
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/comments3.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/beginning_backslash.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/tricky_unicode_symbols.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/comments7.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/pep_572.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/async_as_identifier.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/comments6.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/function2.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/bracketmatch.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/string_quotes.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/debug_visitor.out
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/comments2.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/force_py36.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/numeric_literals.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/remove_parens.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff2.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/blackd_diff.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/tupleassign.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/python2.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fstring.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff3.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/python2_print_function.py

Calling tool: grepTool
def generate_ignored_nodes\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3112:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py
3080:                parent = first.parent
3081:                prefix = first.prefix
3082:                first.prefix = prefix[comment.consumed :]
3083:                hidden_value = (
3084:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
3085:                )
3086:                if hidden_value.endswith("\n"):
3087:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
3088:                    # leaf (possibly followed by a DEDENT).
3089:                    hidden_value = hidden_value[:-1]
3090:                first_idx: Optional[int] = None
3091:                for ignored in ignored_nodes:
3092:                    index = ignored.remove()
3093:                    if first_idx is None:
3094:                        first_idx = index
3095:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
3096:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
3097:                parent.insert_child(
3098:                    first_idx,
3099:                    Leaf(
3100:                        STANDALONE_COMMENT,
3101:                        hidden_value,
3102:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
3103:                    ),
3104:                )
3105:                return True
3106:
3107:            previous_consumed = comment.consumed
3108:
3109:    return False
3110:
3111:
3112:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
3113:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
3114:
3115:    Stops at the end of the block.
3116:    """
3117:    container: Optional[LN] = container_of(leaf)
3118:    while container is not None and container.type != token.ENDMARKER:
3119:        if fmt_off(container):
3120:            return
3121:
3122:        # fix for fmt: on in children
3123:        if contains_fmt_off_at_column(container, leaf.column):
3124:            for child in container.children:
3125:                if contains_fmt_off_at_column(child, leaf.column):
3126:                    return
3127:                yield child
3128:        else:
3129:            yield container
3130:            container = container.next_sibling
3131:
3132:
3133:def fmt_off(container: LN) -> bool:
3134:    is_fmt_off = False
3135:    for comment in list_comments(container.prefix, is_endmarker=False):
3136:        if comment.value in FMT_OFF:
3137:            is_fmt_off = True
3138:        elif comment.value in FMT_ON:
3139:            is_fmt_off = False
3140:    return is_fmt_off
3141:
3142:
3143:def contains_fmt_off_at_column(container: LN, column: int) -> bool:
3144:    for child in container.children:
3145:        if (
3146:            isinstance(child, Node)
3147:            and first_leaf_column(child) == column
3148:            or isinstance(child, Leaf)
3149:            and child.column == column
3150:        ):
3151:            if fmt_off(child):
3152:                return True
3153:
3154:    return False
3155:
3156:
3157:def first_leaf_column(node: Node) -> Optional[int]:
3158:    for child in node.children:
3159:        if isinstance(child, Leaf):
3160:            return child.column
3161:    return None
3162:
3163:
3164:def maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool:
3165:    """If it's safe, make the parens in the atom `node` invisible, recursively.
3166:    Additionally, remove repeated, adjacent invisible parens from the atom `node`
3167:    as they are redundant.
3168:
3169:    Returns whether the node should itself be wrapped in invisible parentheses.
3170:
3171:    """
3172:    if (
3173:        node.type != syms.atom
3174:        or is_empty_tuple(node)
3175:        or is_one_tuple(node)
3176:        or (is_yield(node) and parent.type != syms.expr_stmt)
3177:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
3178:    ):
3179:        return False
3180:
3181:    first = node.children[0]
3182:    last = node.children[-1]
3183:    if first.type == token.LPAR and last.type == token.RPAR:
3184:        middle = node.children[1]
3185:        # make parentheses invisible
3186:        first.value = ""  # type: ignore
3187:        last.value = ""  # type: ignore
3188:        maybe_make_parens_invisible_in_atom(middle, parent=parent)
3189:
3190:        if is_atom_with_invisible_parens(middle):
3191:            # Strip the invisible parens from `middle` by replacing
3192:            # it with the child in-between the invisible parens
3193:            middle.replace(middle.children[1])
3194:
3195:        return False
3196:
3197:    return True
3198:
3199:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff3.py
1:# fmt: off
2:x = [
3:    1, 2,
4:    3, 4,
5:]
6:# fmt: on
7:
8:# fmt: off
9:x = [
10:    1, 2,
11:    3, 4,
12:]
13:# fmt: on
14:
15:x = [
16:    1, 2, 3, 4
17:]
18:
19:# output
20:
21:# fmt: off
22:x = [
23:    1, 2,
24:    3, 4,
25:]
26:# fmt: on
27:
28:# fmt: off
29:x = [
30:    1, 2,
31:    3, 4,
32:]
33:# fmt: on
34:
35:x = [1, 2, 3, 4]

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff2.py
1:import pytest
2:
3:TmSt = 1
4:TmEx = 2
5:
6:# fmt: off
7:
8:# Test data:
9:#   Position, Volume, State, TmSt/TmEx/None, [call, [arg1...]]
10:
11:@pytest.mark.parametrize('test', [
12:
13:    # Test don't manage the volume
14:    [
15:        ('stuff', 'in')
16:    ],
17:])
18:def test_fader(test):
19:    pass
20:
21:def check_fader(test):
22:
23:    pass
24:
25:def verify_fader(test):
26:  # misaligned comment
27:    pass
28:
29:def verify_fader(test):
30:    """Hey, ho."""
31:    assert test.passed()
32:
33:def test_calculate_fades():
34:    calcs = [
35:        # one is zero/none
36:        (0, 4, 0, 0, 10,        0, 0, 6, 10),
37:        (None, 4, 0, 0, 10,     0, 0, 6, 10),
38:    ]
39:
40:# fmt: on

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py
1:#!/usr/bin/env python3
2:import asyncio
3:import sys
4:
5:from third_party import X, Y, Z
6:
7:from library import some_connection, \
8:                    some_decorator
9:# fmt: off
10:from third_party import (X,
11:                         Y, Z)
12:# fmt: on
13:f'trigger 3.6 mode'
14:# Comment 1
15:
16:# Comment 2
17:
18:# fmt: off
19:def func_no_args():
20:  a; b; c
21:  if True: raise RuntimeError
22:  if False: ...
23:  for i in range(10):
24:    print(i)
25:    continue
26:  exec('new-style exec', {}, {})
27:  return None
28:async def coroutine(arg, exec=False):
29: 'Single-line docstring. Multiline is harder to reformat.'
30: async with some_connection() as conn:
31:     await conn.do_what_i_mean('SELECT bobby, tables FROM xkcd', timeout=2)
32: await asyncio.sleep(1)
33:@asyncio.coroutine
34:@some_decorator(
35:with_args=True,
36:many_args=[1,2,3]
37:)
38:def function_signature_stress_test(number:int,no_annotation=None,text:str='default',* ,debug:bool=False,**kwargs) -> str:
39: return text[number:-1]
40:# fmt: on
41:def spaces(a=1, b=(), c=[], d={}, e=True, f=-1, g=1 if False else 2, h="", i=r''):
42: offset = attr.ib(default=attr.Factory( lambda: _r.uniform(1, 2)))
43: assert task._cancel_stack[:len(old_stack)] == old_stack
44:def spaces_types(a: int = 1, b: tuple = (), c: list = [], d: dict = {}, e: bool = True, f: int = -1, g: int = 1 if False else 2, h: str = "", i: str = r''): ...
45:def spaces2(result= _core.Value(None)):
46: ...
47:something = {
48:    # fmt: off
49:    key: 'value',
50:}
51:
52:def subscriptlist():
53:    atom[
54:        # fmt: off
55:        'some big and',
56:        'complex subscript',
57:        # fmt: on
58:        goes + here, andhere,
59:       ]
60:
61:def import_as_names():
62:    # fmt: off
63:    from hello import a,        b
64:    'unformatted'
65:    # fmt: on
66:
67:def testlist_star_expr():
68:    # fmt: off
69:    a , b = *hello
70:    'unformatted'
71:    # fmt: on
72:
73:def yield_expr():
74:    # fmt: off
75:    yield hello
76:    'unformatted'
77:    # fmt: on
78:    'formatted'
79:    # fmt: off
80:    ( yield hello )
81:    'unformatted'
82:    # fmt: on
83:
84:def example(session):
85:    # fmt: off
86:    result = session\
87:        .query(models.Customer.id)\
88:        .filter(models.Customer.account_id == account_id,
89:                models.Customer.email == email_address)\
90:        .order_by(models.Customer.id.asc())\
91:        .all()
92:    # fmt: on
93:def off_and_on_without_data():
94:    """All comments here are technically on the same prefix.
95:
96:    The comments between will be formatted. This is a known limitation.
97:    """
98:    # fmt: off
99:
100:
101:        #hey, that won't work
102:
103:
104:    # fmt: on
105:    pass
106:def on_and_off_broken():
107:    """Another known limitation."""
108:    # fmt: on
109:    # fmt: off
110:    this=should.not_be.formatted()
111:    and_=indeed . it  is  not  formatted
112:    because . the . handling . inside . generate_ignored_nodes()
113:    now . considers . multiple . fmt . directives . within . one . prefix
114:    # fmt: on
115:    # fmt: off
116:        # ...but comments still get reformatted even though they should not be
117:    # fmt: on
118:def long_lines():
119:    if True:
120:        typedargslist.extend(
121:            gen_annotated_params(ast_args.kwonlyargs, ast_args.kw_defaults, parameters, implicit_default=True)
122:        )
123:        # fmt: off
124:        a = (
125:            unnecessary_bracket()
126:        )
127:        # fmt: on
128:    _type_comment_re = re.compile(
129:        r"""
130:        ^
131:        [\t ]*
132:        \#[ ]type:[ ]*
133:        (?P<type>
134:            [^#\t\n]+?
135:        )
136:        (?<!ignore)     # note: this will force the non-greedy + in <type> to match
137:                        # a trailing space which is why we need the silliness below
138:        (?<!ignore[ ]{1})(?<!ignore[ ]{2})(?<!ignore[ ]{3})(?<!ignore[ ]{4})
139:        (?<!ignore[ ]{5})(?<!ignore[ ]{6})(?<!ignore[ ]{7})(?<!ignore[ ]{8})
140:        (?<!ignore[ ]{9})(?<!ignore[ ]{10})
141:        [\t ]*
142:        (?P<nl>
143:            (?:\#[^\n]*)?
144:            \n?
145:        )
146:        $
147:        """,
148:        # fmt: off
149:        re.MULTILINE|re.VERBOSE
150:        # fmt: on
151:    )
152:def single_literal_yapf_disable():
153:    """Black does not support this."""
154:    BAZ = {
155:        (1, 2, 3, 4),
156:        (5, 6, 7, 8),
157:        (9, 10, 11, 12)
158:    }  # yapf: disable
159:cfg.rule(
160:    "Default", "address",
161:    xxxx_xxxx=["xxx-xxxxxx-xxxxxxxxxx"],
162:    xxxxxx="xx_xxxxx", xxxxxxx="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
163:    xxxxxxxxx_xxxx=True, xxxxxxxx_xxxxxxxxxx=False,
164:    xxxxxx_xxxxxx=2, xxxxxx_xxxxx_xxxxxxxx=70, xxxxxx_xxxxxx_xxxxx=True,
165:    # fmt: off
166:    xxxxxxx_xxxxxxxxxxxx={
167:        "xxxxxxxx": {
168:            "xxxxxx": False,
169:            "xxxxxxx": False,
170:            "xxxx_xxxxxx": "xxxxx",
171:        },
172:        "xxxxxxxx-xxxxx": {
173:            "xxxxxx": False,
174:            "xxxxxxx": True,
175:            "xxxx_xxxxxx": "xxxxxx",
176:        },
177:    },
178:    # fmt: on
179:    xxxxxxxxxx_xxxxxxxxxxx_xxxxxxx_xxxxxxxxx=5
180:)
181:# fmt: off
182:yield  'hello'
183:# No formatting to the end of the file
184:l=[1,2,3]
185:d={'a':1,
186:   'b':2}
187:
188:# output
189:
190:
191:#!/usr/bin/env python3
192:import asyncio
193:import sys
194:
195:from third_party import X, Y, Z
196:
197:from library import some_connection, some_decorator
198:
199:# fmt: off
200:from third_party import (X,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py
200:from third_party import (X,
201:                         Y, Z)
202:# fmt: on
203:f"trigger 3.6 mode"
204:# Comment 1
205:
206:# Comment 2
207:
208:# fmt: off
209:def func_no_args():
210:  a; b; c
211:  if True: raise RuntimeError
212:  if False: ...
213:  for i in range(10):
214:    print(i)
215:    continue
216:  exec('new-style exec', {}, {})
217:  return None
218:async def coroutine(arg, exec=False):
219: 'Single-line docstring. Multiline is harder to reformat.'
220: async with some_connection() as conn:
221:     await conn.do_what_i_mean('SELECT bobby, tables FROM xkcd', timeout=2)
222: await asyncio.sleep(1)
223:@asyncio.coroutine
224:@some_decorator(
225:with_args=True,
226:many_args=[1,2,3]
227:)
228:def function_signature_stress_test(number:int,no_annotation=None,text:str='default',* ,debug:bool=False,**kwargs) -> str:
229: return text[number:-1]
230:# fmt: on
231:def spaces(a=1, b=(), c=[], d={}, e=True, f=-1, g=1 if False else 2, h="", i=r""):
232:    offset = attr.ib(default=attr.Factory(lambda: _r.uniform(1, 2)))
233:    assert task._cancel_stack[: len(old_stack)] == old_stack
234:
235:
236:def spaces_types(
237:    a: int = 1,
238:    b: tuple = (),
239:    c: list = [],
240:    d: dict = {},
241:    e: bool = True,
242:    f: int = -1,
243:    g: int = 1 if False else 2,
244:    h: str = "",
245:    i: str = r"",
246:):
247:    ...
248:
249:
250:def spaces2(result=_core.Value(None)):
251:    ...
252:
253:
254:something = {
255:    # fmt: off
256:    key: 'value',
257:}
258:
259:
260:def subscriptlist():
261:    atom[
262:        # fmt: off
263:        'some big and',
264:        'complex subscript',
265:        # fmt: on
266:        goes + here,
267:        andhere,
268:    ]
269:
270:
271:def import_as_names():
272:    # fmt: off
273:    from hello import a,        b
274:    'unformatted'
275:    # fmt: on
276:
277:
278:def testlist_star_expr():
279:    # fmt: off
280:    a , b = *hello
281:    'unformatted'
282:    # fmt: on
283:
284:
285:def yield_expr():
286:    # fmt: off
287:    yield hello
288:    'unformatted'
289:    # fmt: on
290:    "formatted"
291:    # fmt: off
292:    ( yield hello )
293:    'unformatted'
294:    # fmt: on
295:
296:
297:def example(session):
298:    # fmt: off
299:    result = session\
300:        .query(models.Customer.id)\
301:        .filter(models.Customer.account_id == account_id,
302:                models.Customer.email == email_address)\
303:        .order_by(models.Customer.id.asc())\
304:        .all()
305:    # fmt: on
306:
307:
308:def off_and_on_without_data():
309:    """All comments here are technically on the same prefix.
310:
311:    The comments between will be formatted. This is a known limitation.
312:    """
313:    # fmt: off
314:
315:    # hey, that won't work
316:
317:    # fmt: on
318:    pass
319:
320:
321:def on_and_off_broken():
322:    """Another known limitation."""
323:    # fmt: on
324:    # fmt: off
325:    this=should.not_be.formatted()
326:    and_=indeed . it  is  not  formatted
327:    because . the . handling . inside . generate_ignored_nodes()
328:    now . considers . multiple . fmt . directives . within . one . prefix
329:    # fmt: on
330:    # fmt: off
331:    # ...but comments still get reformatted even though they should not be
332:    # fmt: on
333:
334:
335:def long_lines():
336:    if True:
337:        typedargslist.extend(
338:            gen_annotated_params(
339:                ast_args.kwonlyargs,
340:                ast_args.kw_defaults,
341:                parameters,
342:                implicit_default=True,
343:            )
344:        )
345:        # fmt: off
346:        a = (
347:            unnecessary_bracket()
348:        )
349:        # fmt: on
350:    _type_comment_re = re.compile(
351:        r"""
352:        ^
353:        [\t ]*
354:        \#[ ]type:[ ]*
355:        (?P<type>
356:            [^#\t\n]+?
357:        )
358:        (?<!ignore)     # note: this will force the non-greedy + in <type> to match
359:                        # a trailing space which is why we need the silliness below
360:        (?<!ignore[ ]{1})(?<!ignore[ ]{2})(?<!ignore[ ]{3})(?<!ignore[ ]{4})
361:        (?<!ignore[ ]{5})(?<!ignore[ ]{6})(?<!ignore[ ]{7})(?<!ignore[ ]{8})
362:        (?<!ignore[ ]{9})(?<!ignore[ ]{10})
363:        [\t ]*
364:        (?P<nl>
365:            (?:\#[^\n]*)?
366:            \n?
367:        )
368:        $
369:        """,
370:        # fmt: off
371:        re.MULTILINE|re.VERBOSE
372:        # fmt: on
373:    )
374:
375:
376:def single_literal_yapf_disable():
377:    """Black does not support this."""
378:    BAZ = {(1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12)}  # yapf: disable
379:
380:
381:cfg.rule(
382:    "Default",
383:    "address",
384:    xxxx_xxxx=["xxx-xxxxxx-xxxxxxxxxx"],
385:    xxxxxx="xx_xxxxx",
386:    xxxxxxx="xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
387:    xxxxxxxxx_xxxx=True,
388:    xxxxxxxx_xxxxxxxxxx=False,
389:    xxxxxx_xxxxxx=2,
390:    xxxxxx_xxxxx_xxxxxxxx=70,
391:    xxxxxx_xxxxxx_xxxxx=True,
392:    # fmt: off
393:    xxxxxxx_xxxxxxxxxxxx={
394:        "xxxxxxxx": {
395:            "xxxxxx": False,
396:            "xxxxxxx": False,
397:            "xxxx_xxxxxx": "xxxxx",
398:        },
399:        "xxxxxxxx-xxxxx": {

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py
400:            "xxxxxx": False,
401:            "xxxxxxx": True,
402:            "xxxx_xxxxxx": "xxxxxx",
403:        },
404:    },
405:    # fmt: on
406:    xxxxxxxxxx_xxxxxxxxxxx_xxxxxxx_xxxxxxxxx=5,
407:)
408:# fmt: off
409:yield  'hello'
410:# No formatting to the end of the file
411:l=[1,2,3]
412:d={'a':1,
413:   'b':2}

Calling tool: grepTool
generate_ignored_nodes\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3075:                ignored_nodes = list(generate_ignored_nodes(leaf))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3112:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py:112:    because . the . handling . inside . generate_ignored_nodes()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py:327:    because . the . handling . inside . generate_ignored_nodes()

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py
3040:                    # insert invisible parentheses
3041:                    node.insert_child(index, Leaf(token.LPAR, ""))
3042:                    node.append_child(Leaf(token.RPAR, ""))
3043:                break
3044:
3045:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
3046:                wrap_in_parentheses(node, child, visible=False)
3047:
3048:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
3049:
3050:
3051:def normalize_fmt_off(node: Node) -> None:
3052:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
3053:    try_again = True
3054:    while try_again:
3055:        try_again = convert_one_fmt_off_pair(node)
3056:
3057:
3058:def convert_one_fmt_off_pair(node: Node) -> bool:
3059:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
3060:
3061:    Returns True if a pair was converted.
3062:    """
3063:    for leaf in node.leaves():
3064:        previous_consumed = 0
3065:        for comment in list_comments(leaf.prefix, is_endmarker=False):
3066:            if comment.value in FMT_OFF:
3067:                # We only want standalone comments. If there's no previous leaf or
3068:                # the previous leaf is indentation, it's a standalone comment in
3069:                # disguise.
3070:                if comment.type != STANDALONE_COMMENT:
3071:                    prev = preceding_leaf(leaf)
3072:                    if prev and prev.type not in WHITESPACE:
3073:                        continue
3074:
3075:                ignored_nodes = list(generate_ignored_nodes(leaf))
3076:                if not ignored_nodes:
3077:                    continue
3078:
3079:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
3080:                parent = first.parent
3081:                prefix = first.prefix
3082:                first.prefix = prefix[comment.consumed :]
3083:                hidden_value = (
3084:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
3085:                )
3086:                if hidden_value.endswith("\n"):
3087:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
3088:                    # leaf (possibly followed by a DEDENT).
3089:                    hidden_value = hidden_value[:-1]
3090:                first_idx: Optional[int] = None
3091:                for ignored in ignored_nodes:
3092:                    index = ignored.remove()
3093:                    if first_idx is None:
3094:                        first_idx = index
3095:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
3096:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
3097:                parent.insert_child(
3098:                    first_idx,
3099:                    Leaf(

Calling tool: grepTool
from typing import .*Optional
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black.py: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black.py: No such file or directory (os error 2)


Calling tool: grepTool
Optional\[
Matched content:
220:def find_pyproject_toml(path_search_start: str) -> Optional[str]:
238:    ctx: click.Context, param: click.Parameter, value: Optional[str]
239:) -> Optional[str]:
413:    code: Optional[str],
427:    config: Optional[str],
1093:    previous: Optional[Leaf] = None
1213:    def get_open_lsqb(self) -> Optional[Leaf]:
1378:            second_leaf: Optional[Leaf] = self.leaves[1]
1626:    previous_line: Optional[Line] = None
2170:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
2188:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
2190:    node: Optional[LN] = descendant
2221:def is_split_after_delimiter(leaf: Leaf, previous: Optional[Leaf] = None) -> Priority:
2235:def is_split_before_delimiter(leaf: Leaf, previous: Optional[Leaf] = None) -> Priority:
2525:    matching_bracket: Optional[Leaf] = None
2568:    opening_bracket: Optional[Leaf] = None
2569:    closing_bracket: Optional[Leaf] = None
3090:                first_idx: Optional[int] = None
3117:    container: Optional[LN] = container_of(leaf)
3157:def first_leaf_column(node: Node) -> Optional[int]:
3228:def unwrap_singleton_parenthesis(node: LN) -> Optional[LN]:
3492:    opening_bracket: Optional[Leaf] = None
3493:    closing_bracket: Optional[Leaf] = None

Calling tool: grepTool
FMT_ON|FMT_OFF
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:2331:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:2332:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3010:        if pc.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3066:            if comment.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3136:        if comment.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3138:        elif comment.value in FMT_ON:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py
2290:        and leaf.parent
2291:        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
2292:    ):
2293:        return COMPREHENSION_PRIORITY
2294:
2295:    if leaf.value in {"if", "else"} and leaf.parent and leaf.parent.type == syms.test:
2296:        return TERNARY_PRIORITY
2297:
2298:    if leaf.value == "is":
2299:        return COMPARATOR_PRIORITY
2300:
2301:    if (
2302:        leaf.value == "in"
2303:        and leaf.parent
2304:        and leaf.parent.type in {syms.comp_op, syms.comparison}
2305:        and not (
2306:            previous is not None
2307:            and previous.type == token.NAME
2308:            and previous.value == "not"
2309:        )
2310:    ):
2311:        return COMPARATOR_PRIORITY
2312:
2313:    if (
2314:        leaf.value == "not"
2315:        and leaf.parent
2316:        and leaf.parent.type == syms.comp_op
2317:        and not (
2318:            previous is not None
2319:            and previous.type == token.NAME
2320:            and previous.value == "is"
2321:        )
2322:    ):
2323:        return COMPARATOR_PRIORITY
2324:
2325:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
2326:        return LOGIC_PRIORITY
2327:
2328:    return 0
2329:
2330:
2331:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2332:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2333:
2334:
2335:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2336:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2337:
2338:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2339:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2340:    move because it does away with modifying the grammar to include all the
2341:    possible places in which comments can be placed.
2342:
2343:    The sad consequence for us though is that comments don't "belong" anywhere.
2344:    This is why this function generates simple parentless Leaf objects for
2345:    comments.  We simply don't know what the correct parent should be.
2346:
2347:    No matter though, we can live without this.  We really only need to
2348:    differentiate between inline and standalone comments.  The latter don't
2349:    share the line with any code.
2350:
2351:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2352:    are emitted with a fake STANDALONE_COMMENT token identifier.
2353:    """
2354:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2355:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2356:
2357:
2358:@dataclass
2359:class ProtoComment:
2360:    """Describes a piece of syntax that is a comment.
2361:
2362:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2363:
2364:    * it can be cached (`Leaf` objects should not be reused more than once as
2365:      they store their lineno, column, prefix, and parent information);
2366:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2367:      simplifies handling of special marker comments like ``# fmt: off/on``.
2368:    """
2369:

Calling tool: grepTool
from .* import .*Node, .*Leaf
Matched content:
51:from blib2to3.pytree import Node, Leaf, type_repr

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py
1:import ast
2:import asyncio
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from contextlib import contextmanager
5:from datetime import datetime
6:from enum import Enum
7:from functools import lru_cache, partial, wraps
8:import io
9:import itertools
10:import logging
11:from multiprocessing import Manager, freeze_support
12:import os
13:from pathlib import Path
14:import pickle
15:import regex as re
16:import signal
17:import sys
18:import tempfile
19:import tokenize
20:import traceback
21:from typing import (
22:    Any,
23:    Callable,
24:    Collection,
25:    Dict,
26:    Generator,
27:    Generic,
28:    Iterable,
29:    Iterator,
30:    List,
31:    Optional,
32:    Pattern,
33:    Sequence,
34:    Set,
35:    Tuple,
36:    TypeVar,
37:    Union,
38:    cast,
39:)
40:from typing_extensions import Final
41:from mypy_extensions import mypyc_attr
42:
43:from appdirs import user_cache_dir
44:from dataclasses import dataclass, field, replace
45:import click
46:import toml
47:from typed_ast import ast3, ast27
48:from pathspec import PathSpec
49:
50:# lib2to3 fork
51:from blib2to3.pytree import Node, Leaf, type_repr
52:from blib2to3 import pygram, pytree
53:from blib2to3.pgen2 import driver, token
54:from blib2to3.pgen2.grammar import Grammar
55:from blib2to3.pgen2.parse import ParseError
56:
57:from _black_version import version as __version__
58:
59:DEFAULT_LINE_LENGTH = 88
60:DEFAULT_EXCLUDES = r"/(\.eggs|\.git|\.hg|\.mypy_cache|\.nox|\.tox|\.venv|\.svn|_build|buck-out|build|dist)/"  # noqa: B950
61:DEFAULT_INCLUDES = r"\.pyi?$"
62:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
63:
64:
65:# types
66:FileContent = str
67:Encoding = str
68:NewLine = str
69:Depth = int
70:NodeType = int
71:LeafID = int
72:Priority = int
73:Index = int
74:LN = Union[Leaf, Node]
75:SplitFunc = Callable[["Line", Collection["Feature"]], Iterator["Line"]]
76:Timestamp = float
77:FileSize = int
78:CacheInfo = Tuple[Timestamp, FileSize]
79:Cache = Dict[Path, CacheInfo]
80:out = partial(click.secho, bold=True, err=True)
81:err = partial(click.secho, fg="red", err=True)
82:
83:pygram.initialize(CACHE_DIR)
84:syms = pygram.python_symbols
85:
86:
87:class NothingChanged(UserWarning):
88:    """Raised when reformatted code is the same as source."""
89:
90:
91:class CannotSplit(Exception):
92:    """A readable split that fits the allotted line length is impossible."""
93:
94:
95:class InvalidInput(ValueError):
96:    """Raised when input source code fails all parse attempts."""
97:
98:
99:class WriteBack(Enum):
100:    NO = 0

Calling tool: createTodo
Todo List Created
Todo List (13 items):
- [ ] In black.py, verify that generate_ignored_nodes (around lines 3112-3131) still fulfills its documented contract: it should generate nodes until a "# fmt: on" marker is found. Check that the new early-return condition `if fmt_off(container): return` is consistent with this (it appears inverted vs the previous `FMT_ON`-based stop condition). (ID: todo-1)
- [ ] Confirm that the new child-processing branch in generate_ignored_nodes correctly advances the iteration: after yielding children, ensure the generator either updates `container` or returns; otherwise, identify a potential infinite loop if no child triggers the stop condition. (ID: todo-2)
- [ ] Validate that the child stop condition in generate_ignored_nodes is checking for the correct directive. The PR intent is to stop ignoring when a "# fmt: on" appears at the same column. The current code checks `contains_fmt_off_at_column(child, leaf.column)`; verify whether this should instead detect "fmt: on" and whether the naming/logic matches the PR intent. (ID: todo-3)
- [ ] Check that contains_fmt_off_at_column(container: LN, column: int) safely handles being called with a Leaf. It currently iterates `for child in container.children` unconditionally; verify that generate_ignored_nodes never passes a Leaf, or that the function guards against non-Node inputs. (ID: todo-4)
- [ ] Validate that contains_fmt_off_at_column examines the target LN itself (its prefix/column) as needed. In generate_ignored_nodes it is called with each immediate child LN; confirm that the function will detect a marker on that child itself, not only within its descendants. (ID: todo-5)
- [ ] Verify the boolean expression in contains_fmt_off_at_column (lines 3144-3150) has the intended grouping. Due to `and`/`or` precedence, confirm it is equivalent to `(isinstance(child, Node) and first_leaf_column(child) == column) or (isinstance(child, Leaf) and child.column == column)`, or recommend adding parentheses if ambiguous. (ID: todo-6)
- [ ] Ensure first_leaf_column(node: Node) returns a column compatible with Leaf.column used elsewhere. Confirm that returning None when the first immediate child is not a Leaf is correctly handled by callers (comparisons against an int should evaluate False). (ID: todo-7)
- [ ] Verify fmt_off(container: LN) replicates the previous toggle semantics over `list_comments(container.prefix, is_endmarker=False)`: the last encountered directive among FMT_OFF/FMT_ON within the same prefix wins, and the function returns True only when the final state is "off". (ID: todo-8)
- [ ] Confirm that convert_one_fmt_off_pair continues to work when generate_ignored_nodes yields children instead of whole containers: `ignored.remove()` must be valid for both `Node` and `Leaf`, and the constructed `hidden_value` must correctly concatenate the string representations of the ignored children. (ID: todo-9)
- [ ] Check that generate_ignored_nodes yields the correct granularity when "fmt: on" appears in children at the same column: it should yield only the children before the on-marker and stop right before the child containing the on-marker, matching the PR description about processing each child separately. (ID: todo-10)
- [ ] Validate that imports and types used by the new helpers exist: `Optional`, `LN`, `Node`, `Leaf`, `list_comments`, `FMT_OFF`, and `FMT_ON` are defined/imported earlier in black.py. (ID: todo-11)
- [ ] Confirm that the test `tests/test_black.py::BlackTestCase.test_fmtonoff4` has a corresponding input/expected data file (`tests/data/fmtonoff4.py`) that exercises decorators with `# fmt: off` followed by `# fmt: on` crossing a block boundary at the same indentation. If the data file is missing, note incomplete test coverage for this PR. (ID: todo-12)
- [ ] Ensure the change does not regress existing fmt on/off behavior by statically comparing the new control flow with previous behavior for plain cases (e.g., `tests/data/fmtonoff.py`, `fmtonoff2.py`, `fmtonoff3.py`): when no child-level on-marker case applies, the loop should yield siblings and stop at the first `FMT_ON` marker as before. (ID: todo-13)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 13
description: 'In black.py, verify that generate_ignored_nodes (around lines 3112-3131) still fulfills its documented contract: it should generate nodes until a "# fmt: on" marker is found. Check that the new early-return condition `if fmt_off(container): return` is consistent with this (it appears inverted vs the previous `FMT_ON`-based stop condition).'
Calling tool: grepTool
def generate_ignored_nodes\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3112:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py
3098:                    first_idx,
3099:                    Leaf(
3100:                        STANDALONE_COMMENT,
3101:                        hidden_value,
3102:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
3103:                    ),
3104:                )
3105:                return True
3106:
3107:            previous_consumed = comment.consumed
3108:
3109:    return False
3110:
3111:
3112:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
3113:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
3114:
3115:    Stops at the end of the block.
3116:    """
3117:    container: Optional[LN] = container_of(leaf)
3118:    while container is not None and container.type != token.ENDMARKER:
3119:        if fmt_off(container):
3120:            return
3121:
3122:        # fix for fmt: on in children
3123:        if contains_fmt_off_at_column(container, leaf.column):
3124:            for child in container.children:
3125:                if contains_fmt_off_at_column(child, leaf.column):
3126:                    return
3127:                yield child
3128:        else:
3129:            yield container
3130:            container = container.next_sibling
3131:
3132:
3133:def fmt_off(container: LN) -> bool:
3134:    is_fmt_off = False
3135:    for comment in list_comments(container.prefix, is_endmarker=False):
3136:        if comment.value in FMT_OFF:
3137:            is_fmt_off = True
3138:        elif comment.value in FMT_ON:
3139:            is_fmt_off = False
3140:    return is_fmt_off
3141:
3142:
3143:def contains_fmt_off_at_column(container: LN, column: int) -> bool:
3144:    for child in container.children:
3145:        if (
3146:            isinstance(child, Node)
3147:            and first_leaf_column(child) == column
3148:            or isinstance(child, Leaf)
3149:            and child.column == column
3150:        ):
3151:            if fmt_off(child):
3152:                return True
3153:
3154:    return False
3155:
3156:
3157:def first_leaf_column(node: Node) -> Optional[int]:
3158:    for child in node.children:
3159:        if isinstance(child, Leaf):
3160:            return child.column
3161:    return None
3162:
3163:
3164:def maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool:
3165:    """If it's safe, make the parens in the atom `node` invisible, recursively.
3166:    Additionally, remove repeated, adjacent invisible parens from the atom `node`
3167:    as they are redundant.
3168:
3169:    Returns whether the node should itself be wrapped in invisible parentheses.
3170:
3171:    """
3172:    if (
3173:        node.type != syms.atom
3174:        or is_empty_tuple(node)
3175:        or is_one_tuple(node)
3176:        or (is_yield(node) and parent.type != syms.expr_stmt)
3177:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
3178:    ):
3179:        return False
3180:
3181:    first = node.children[0]
3182:    last = node.children[-1]
3183:    if first.type == token.LPAR and last.type == token.RPAR:
3184:        middle = node.children[1]
3185:        # make parentheses invisible
3186:        first.value = ""  # type: ignore
3187:        last.value = ""  # type: ignore
3188:        maybe_make_parens_invisible_in_atom(middle, parent=parent)
3189:
3190:        if is_atom_with_invisible_parens(middle):
3191:            # Strip the invisible parens from `middle` by replacing
3192:            # it with the child in-between the invisible parens
3193:            middle.replace(middle.children[1])
3194:
3195:        return False
3196:
3197:    return True
3198:
3199:
3200:def is_atom_with_invisible_parens(node: LN) -> bool:
3201:    """Given a `LN`, determines whether it's an atom `node` with invisible
3202:    parens. Useful in dedupe-ing and normalizing parens.
3203:    """
3204:    if isinstance(node, Leaf) or node.type != syms.atom:
3205:        return False
3206:
3207:    first, last = node.children[0], node.children[-1]
3208:    return (
3209:        isinstance(first, Leaf)
3210:        and first.type == token.LPAR
3211:        and first.value == ""
3212:        and isinstance(last, Leaf)
3213:        and last.type == token.RPAR
3214:        and last.value == ""
3215:    )
3216:
3217:

Calling tool: grepTool
generate_ignored_nodes\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3075:                ignored_nodes = list(generate_ignored_nodes(leaf))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3112:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py:112:    because . the . handling . inside . generate_ignored_nodes()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py:327:    because . the . handling . inside . generate_ignored_nodes()

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py
3058:def convert_one_fmt_off_pair(node: Node) -> bool:
3059:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
3060:
3061:    Returns True if a pair was converted.
3062:    """
3063:    for leaf in node.leaves():
3064:        previous_consumed = 0
3065:        for comment in list_comments(leaf.prefix, is_endmarker=False):
3066:            if comment.value in FMT_OFF:
3067:                # We only want standalone comments. If there's no previous leaf or
3068:                # the previous leaf is indentation, it's a standalone comment in
3069:                # disguise.
3070:                if comment.type != STANDALONE_COMMENT:
3071:                    prev = preceding_leaf(leaf)
3072:                    if prev and prev.type not in WHITESPACE:
3073:                        continue
3074:
3075:                ignored_nodes = list(generate_ignored_nodes(leaf))
3076:                if not ignored_nodes:
3077:                    continue
3078:
3079:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
3080:                parent = first.parent
3081:                prefix = first.prefix
3082:                first.prefix = prefix[comment.consumed :]
3083:                hidden_value = (
3084:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
3085:                )
3086:                if hidden_value.endswith("\n"):
3087:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
3088:                    # leaf (possibly followed by a DEDENT).
3089:                    hidden_value = hidden_value[:-1]
3090:                first_idx: Optional[int] = None
3091:                for ignored in ignored_nodes:
3092:                    index = ignored.remove()
3093:                    if first_idx is None:
3094:                        first_idx = index
3095:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
3096:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
3097:                parent.insert_child(

Calling tool: grepTool
FMT_ON|FMT_OFF|list_comments\(
Matched content:
2331:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2332:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2354:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2377:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
3009:    for pc in list_comments(node.prefix, is_endmarker=False):
3010:        if pc.value in FMT_OFF:
3065:        for comment in list_comments(leaf.prefix, is_endmarker=False):
3066:            if comment.value in FMT_OFF:
3135:    for comment in list_comments(container.prefix, is_endmarker=False):
3136:        if comment.value in FMT_OFF:
3138:        elif comment.value in FMT_ON:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py
2320:            and previous.value == "is"
2321:        )
2322:    ):
2323:        return COMPARATOR_PRIORITY
2324:
2325:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
2326:        return LOGIC_PRIORITY
2327:
2328:    return 0
2329:
2330:
2331:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2332:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2333:
2334:
2335:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2336:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2337:
2338:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2339:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2340:    move because it does away with modifying the grammar to include all the
2341:    possible places in which comments can be placed.
2342:
2343:    The sad consequence for us though is that comments don't "belong" anywhere.
2344:    This is why this function generates simple parentless Leaf objects for
2345:    comments.  We simply don't know what the correct parent should be.
2346:
2347:    No matter though, we can live without this.  We really only need to
2348:    differentiate between inline and standalone comments.  The latter don't
2349:    share the line with any code.
2350:
2351:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2352:    are emitted with a fake STANDALONE_COMMENT token identifier.
2353:    """
2354:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2355:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2356:
2357:
2358:@dataclass
2359:class ProtoComment:
2360:    """Describes a piece of syntax that is a comment.
2361:
2362:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2363:
2364:    * it can be cached (`Leaf` objects should not be reused more than once as
2365:      they store their lineno, column, prefix, and parent information);
2366:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2367:      simplifies handling of special marker comments like ``# fmt: off/on``.
2368:    """
2369:
2370:    type: int  # token.COMMENT or STANDALONE_COMMENT
2371:    value: str  # content of the comment
2372:    newlines: int  # how many newlines before the comment
2373:    consumed: int  # how many characters of the original leaf's prefix did we consume
2374:
2375:
2376:@lru_cache(maxsize=4096)
2377:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2378:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2379:    result: List[ProtoComment] = []
2380:    if not prefix or "#" not in prefix:
2381:        return result
2382:
2383:    consumed = 0
2384:    nlines = 0
2385:    ignored_lines = 0
2386:    for index, line in enumerate(prefix.split("\n")):
2387:        consumed += len(line) + 1  # adding the length of the split '\n'
2388:        line = line.lstrip()
2389:        if not line:
2390:            nlines += 1
2391:        if not line.startswith("#"):
2392:            # Escaped newlines outside of a comment are not really newlines at
2393:            # all. We treat a single-line comment following an escaped newline
2394:            # as a simple trailing comment.
2395:            if line.endswith("\\"):
2396:                ignored_lines += 1
2397:            continue
2398:
2399:        if index == ignored_lines and not is_endmarker:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py
100:
101:        #hey, that won't work
102:
103:
104:    # fmt: on
105:    pass
106:def on_and_off_broken():
107:    """Another known limitation."""
108:    # fmt: on
109:    # fmt: off
110:    this=should.not_be.formatted()
111:    and_=indeed . it  is  not  formatted
112:    because . the . handling . inside . generate_ignored_nodes()
113:    now . considers . multiple . fmt . directives . within . one . prefix
114:    # fmt: on
115:    # fmt: off
116:        # ...but comments still get reformatted even though they should not be
117:    # fmt: on
118:def long_lines():
119:    if True:
120:        typedargslist.extend(
121:            gen_annotated_params(ast_args.kwonlyargs, ast_args.kw_defaults, parameters, implicit_default=True)
122:        )
123:        # fmt: off
124:        a = (
125:            unnecessary_bracket()
126:        )
127:        # fmt: on
128:    _type_comment_re = re.compile(
129:        r"""
130:        ^
131:        [\t ]*
132:        \#[ ]type:[ ]*
133:        (?P<type>
134:            [^#\t\n]+?
135:        )
136:        (?<!ignore)     # note: this will force the non-greedy + in <type> to match
137:                        # a trailing space which is why we need the silliness below
138:        (?<!ignore[ ]{1})(?<!ignore[ ]{2})(?<!ignore[ ]{3})(?<!ignore[ ]{4})
139:        (?<!ignore[ ]{5})(?<!ignore[ ]{6})(?<!ignore[ ]{7})(?<!ignore[ ]{8})

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py
300:        .query(models.Customer.id)\
301:        .filter(models.Customer.account_id == account_id,
302:                models.Customer.email == email_address)\
303:        .order_by(models.Customer.id.asc())\
304:        .all()
305:    # fmt: on
306:
307:
308:def off_and_on_without_data():
309:    """All comments here are technically on the same prefix.
310:
311:    The comments between will be formatted. This is a known limitation.
312:    """
313:    # fmt: off
314:
315:    # hey, that won't work
316:
317:    # fmt: on
318:    pass
319:
320:
321:def on_and_off_broken():
322:    """Another known limitation."""
323:    # fmt: on
324:    # fmt: off
325:    this=should.not_be.formatted()
326:    and_=indeed . it  is  not  formatted
327:    because . the . handling . inside . generate_ignored_nodes()
328:    now . considers . multiple . fmt . directives . within . one . prefix
329:    # fmt: on
330:    # fmt: off
331:    # ...but comments still get reformatted even though they should not be
332:    # fmt: on
333:
334:
335:def long_lines():
336:    if True:
337:        typedargslist.extend(
338:            gen_annotated_params(
339:                ast_args.kwonlyargs,
340:                ast_args.kw_defaults,
341:                parameters,
342:                implicit_default=True,
343:            )
344:        )
345:        # fmt: off
346:        a = (
347:            unnecessary_bracket()
348:        )
349:        # fmt: on
350:    _type_comment_re = re.compile(
351:        r"""
352:        ^
353:        [\t ]*
354:        \#[ ]type:[ ]*
355:        (?P<type>
356:            [^#\t\n]+?
357:        )
358:        (?<!ignore)     # note: this will force the non-greedy + in <type> to match
359:                        # a trailing space which is why we need the silliness below

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: Docstring states it should generate nodes until a # fmt: on. Previously it returned when FMT_ON was found. The new code (black.py:3119-3121) returns when fmt_off(container) is True, which is the opposite of the contract. Therefore the early-return condition is inverted and incorrect.


Validating todo item 1 of 13
description: 'In black.py, verify that generate_ignored_nodes (around lines 3112-3131) still fulfills its documented contract: it should generate nodes until a "# fmt: on" marker is found. Check that the new early-return condition `if fmt_off(container): return` is consistent with this (it appears inverted vs the previous `FMT_ON`-based stop condition).'

Calling tool: grepTool
def generate_ignored_nodes\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3112:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py
3098:                    first_idx,
3099:                    Leaf(
3100:                        STANDALONE_COMMENT,
3101:                        hidden_value,
3102:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
3103:                    ),
3104:                )
3105:                return True
3106:
3107:            previous_consumed = comment.consumed
3108:
3109:    return False
3110:
3111:
3112:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
3113:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
3114:
3115:    Stops at the end of the block.
3116:    """
3117:    container: Optional[LN] = container_of(leaf)
3118:    while container is not None and container.type != token.ENDMARKER:
3119:        if fmt_off(container):
3120:            return
3121:
3122:        # fix for fmt: on in children
3123:        if contains_fmt_off_at_column(container, leaf.column):
3124:            for child in container.children:
3125:                if contains_fmt_off_at_column(child, leaf.column):
3126:                    return
3127:                yield child
3128:        else:
3129:            yield container
3130:            container = container.next_sibling
3131:
3132:
3133:def fmt_off(container: LN) -> bool:
3134:    is_fmt_off = False
3135:    for comment in list_comments(container.prefix, is_endmarker=False):
3136:        if comment.value in FMT_OFF:
3137:            is_fmt_off = True
3138:        elif comment.value in FMT_ON:
3139:            is_fmt_off = False
3140:    return is_fmt_off
3141:
3142:
3143:def contains_fmt_off_at_column(container: LN, column: int) -> bool:
3144:    for child in container.children:
3145:        if (
3146:            isinstance(child, Node)
3147:            and first_leaf_column(child) == column
3148:            or isinstance(child, Leaf)
3149:            and child.column == column
3150:        ):
3151:            if fmt_off(child):
3152:                return True
3153:
3154:    return False
3155:
3156:
3157:def first_leaf_column(node: Node) -> Optional[int]:
3158:    for child in node.children:
3159:        if isinstance(child, Leaf):
3160:            return child.column
3161:    return None
3162:
3163:
3164:def maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool:
3165:    """If it's safe, make the parens in the atom `node` invisible, recursively.
3166:    Additionally, remove repeated, adjacent invisible parens from the atom `node`
3167:    as they are redundant.
3168:
3169:    Returns whether the node should itself be wrapped in invisible parentheses.
3170:
3171:    """
3172:    if (
3173:        node.type != syms.atom
3174:        or is_empty_tuple(node)
3175:        or is_one_tuple(node)
3176:        or (is_yield(node) and parent.type != syms.expr_stmt)
3177:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
3178:    ):
3179:        return False
3180:
3181:    first = node.children[0]
3182:    last = node.children[-1]
3183:    if first.type == token.LPAR and last.type == token.RPAR:
3184:        middle = node.children[1]
3185:        # make parentheses invisible
3186:        first.value = ""  # type: ignore
3187:        last.value = ""  # type: ignore
3188:        maybe_make_parens_invisible_in_atom(middle, parent=parent)
3189:
3190:        if is_atom_with_invisible_parens(middle):
3191:            # Strip the invisible parens from `middle` by replacing
3192:            # it with the child in-between the invisible parens
3193:            middle.replace(middle.children[1])
3194:
3195:        return False
3196:
3197:    return True
3198:
3199:
3200:def is_atom_with_invisible_parens(node: LN) -> bool:
3201:    """Given a `LN`, determines whether it's an atom `node` with invisible
3202:    parens. Useful in dedupe-ing and normalizing parens.
3203:    """
3204:    if isinstance(node, Leaf) or node.type != syms.atom:
3205:        return False
3206:
3207:    first, last = node.children[0], node.children[-1]
3208:    return (
3209:        isinstance(first, Leaf)
3210:        and first.type == token.LPAR
3211:        and first.value == ""
3212:        and isinstance(last, Leaf)
3213:        and last.type == token.RPAR
3214:        and last.value == ""
3215:    )
3216:
3217:

Calling tool: grepTool
generate_ignored_nodes\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3075:                ignored_nodes = list(generate_ignored_nodes(leaf))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py:3112:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py:112:    because . the . handling . inside . generate_ignored_nodes()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py:327:    because . the . handling . inside . generate_ignored_nodes()

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py
3058:def convert_one_fmt_off_pair(node: Node) -> bool:
3059:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
3060:
3061:    Returns True if a pair was converted.
3062:    """
3063:    for leaf in node.leaves():
3064:        previous_consumed = 0
3065:        for comment in list_comments(leaf.prefix, is_endmarker=False):
3066:            if comment.value in FMT_OFF:
3067:                # We only want standalone comments. If there's no previous leaf or
3068:                # the previous leaf is indentation, it's a standalone comment in
3069:                # disguise.
3070:                if comment.type != STANDALONE_COMMENT:
3071:                    prev = preceding_leaf(leaf)
3072:                    if prev and prev.type not in WHITESPACE:
3073:                        continue
3074:
3075:                ignored_nodes = list(generate_ignored_nodes(leaf))
3076:                if not ignored_nodes:
3077:                    continue
3078:
3079:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
3080:                parent = first.parent
3081:                prefix = first.prefix
3082:                first.prefix = prefix[comment.consumed :]
3083:                hidden_value = (
3084:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
3085:                )
3086:                if hidden_value.endswith("\n"):
3087:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
3088:                    # leaf (possibly followed by a DEDENT).
3089:                    hidden_value = hidden_value[:-1]
3090:                first_idx: Optional[int] = None
3091:                for ignored in ignored_nodes:
3092:                    index = ignored.remove()
3093:                    if first_idx is None:
3094:                        first_idx = index
3095:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
3096:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
3097:                parent.insert_child(

Calling tool: grepTool
FMT_ON|FMT_OFF|list_comments\(
Matched content:
2331:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2332:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2354:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2377:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
3009:    for pc in list_comments(node.prefix, is_endmarker=False):
3010:        if pc.value in FMT_OFF:
3065:        for comment in list_comments(leaf.prefix, is_endmarker=False):
3066:            if comment.value in FMT_OFF:
3135:    for comment in list_comments(container.prefix, is_endmarker=False):
3136:        if comment.value in FMT_OFF:
3138:        elif comment.value in FMT_ON:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/black.py
2320:            and previous.value == "is"
2321:        )
2322:    ):
2323:        return COMPARATOR_PRIORITY
2324:
2325:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
2326:        return LOGIC_PRIORITY
2327:
2328:    return 0
2329:
2330:
2331:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2332:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2333:
2334:
2335:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2336:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2337:
2338:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2339:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2340:    move because it does away with modifying the grammar to include all the
2341:    possible places in which comments can be placed.
2342:
2343:    The sad consequence for us though is that comments don't "belong" anywhere.
2344:    This is why this function generates simple parentless Leaf objects for
2345:    comments.  We simply don't know what the correct parent should be.
2346:
2347:    No matter though, we can live without this.  We really only need to
2348:    differentiate between inline and standalone comments.  The latter don't
2349:    share the line with any code.
2350:
2351:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2352:    are emitted with a fake STANDALONE_COMMENT token identifier.
2353:    """
2354:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2355:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2356:
2357:
2358:@dataclass
2359:class ProtoComment:
2360:    """Describes a piece of syntax that is a comment.
2361:
2362:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2363:
2364:    * it can be cached (`Leaf` objects should not be reused more than once as
2365:      they store their lineno, column, prefix, and parent information);
2366:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2367:      simplifies handling of special marker comments like ``# fmt: off/on``.
2368:    """
2369:
2370:    type: int  # token.COMMENT or STANDALONE_COMMENT
2371:    value: str  # content of the comment
2372:    newlines: int  # how many newlines before the comment
2373:    consumed: int  # how many characters of the original leaf's prefix did we consume
2374:
2375:
2376:@lru_cache(maxsize=4096)
2377:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2378:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2379:    result: List[ProtoComment] = []
2380:    if not prefix or "#" not in prefix:
2381:        return result
2382:
2383:    consumed = 0
2384:    nlines = 0
2385:    ignored_lines = 0
2386:    for index, line in enumerate(prefix.split("\n")):
2387:        consumed += len(line) + 1  # adding the length of the split '\n'
2388:        line = line.lstrip()
2389:        if not line:
2390:            nlines += 1
2391:        if not line.startswith("#"):
2392:            # Escaped newlines outside of a comment are not really newlines at
2393:            # all. We treat a single-line comment following an escaped newline
2394:            # as a simple trailing comment.
2395:            if line.endswith("\\"):
2396:                ignored_lines += 1
2397:            continue
2398:
2399:        if index == ignored_lines and not is_endmarker:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py
100:
101:        #hey, that won't work
102:
103:
104:    # fmt: on
105:    pass
106:def on_and_off_broken():
107:    """Another known limitation."""
108:    # fmt: on
109:    # fmt: off
110:    this=should.not_be.formatted()
111:    and_=indeed . it  is  not  formatted
112:    because . the . handling . inside . generate_ignored_nodes()
113:    now . considers . multiple . fmt . directives . within . one . prefix
114:    # fmt: on
115:    # fmt: off
116:        # ...but comments still get reformatted even though they should not be
117:    # fmt: on
118:def long_lines():
119:    if True:
120:        typedargslist.extend(
121:            gen_annotated_params(ast_args.kwonlyargs, ast_args.kw_defaults, parameters, implicit_default=True)
122:        )
123:        # fmt: off
124:        a = (
125:            unnecessary_bracket()
126:        )
127:        # fmt: on
128:    _type_comment_re = re.compile(
129:        r"""
130:        ^
131:        [\t ]*
132:        \#[ ]type:[ ]*
133:        (?P<type>
134:            [^#\t\n]+?
135:        )
136:        (?<!ignore)     # note: this will force the non-greedy + in <type> to match
137:                        # a trailing space which is why we need the silliness below
138:        (?<!ignore[ ]{1})(?<!ignore[ ]{2})(?<!ignore[ ]{3})(?<!ignore[ ]{4})
139:        (?<!ignore[ ]{5})(?<!ignore[ ]{6})(?<!ignore[ ]{7})(?<!ignore[ ]{8})

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-2/bad/black/tests/data/fmtonoff.py
300:        .query(models.Customer.id)\
301:        .filter(models.Customer.account_id == account_id,
302:                models.Customer.email == email_address)\
303:        .order_by(models.Customer.id.asc())\
304:        .all()
305:    # fmt: on
306:
307:
308:def off_and_on_without_data():
309:    """All comments here are technically on the same prefix.
310:
311:    The comments between will be formatted. This is a known limitation.
312:    """
313:    # fmt: off
314:
315:    # hey, that won't work
316:
317:    # fmt: on
318:    pass
319:
320:
321:def on_and_off_broken():
322:    """Another known limitation."""
323:    # fmt: on
324:    # fmt: off
325:    this=should.not_be.formatted()
326:    and_=indeed . it  is  not  formatted
327:    because . the . handling . inside . generate_ignored_nodes()
328:    now . considers . multiple . fmt . directives . within . one . prefix
329:    # fmt: on
330:    # fmt: off
331:    # ...but comments still get reformatted even though they should not be
332:    # fmt: on
333:
334:
335:def long_lines():
336:    if True:
337:        typedargslist.extend(
338:            gen_annotated_params(
339:                ast_args.kwonlyargs,
340:                ast_args.kw_defaults,
341:                parameters,
342:                implicit_default=True,
343:            )
344:        )
345:        # fmt: off
346:        a = (
347:            unnecessary_bracket()
348:        )
349:        # fmt: on
350:    _type_comment_re = re.compile(
351:        r"""
352:        ^
353:        [\t ]*
354:        \#[ ]type:[ ]*
355:        (?P<type>
356:            [^#\t\n]+?
357:        )
358:        (?<!ignore)     # note: this will force the non-greedy + in <type> to match
359:                        # a trailing space which is why we need the silliness below

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: Docstring states it should generate nodes until a # fmt: on. Previously it returned when FMT_ON was found. The new code (black.py:3119-3121) returns when fmt_off(container) is True, which is the opposite of the contract. Therefore the early-return condition is inverted and incorrect.


=== PHASE 2 COMPLETE ===

