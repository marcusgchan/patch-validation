=== PHASE 1: ANALYSIS ===

[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_comments6", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def read_data\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def is_special_comment\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "STANDALONE_COMMENT",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def comments_after\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "is_special_comment\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py"
]
Calling tool: grepTool
test_comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_comments6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
340:
341:    @patch("black.dump_to_file", dump_to_stderr)
342:    def test_comments3(self) -> None:
343:        source, expected = read_data("comments3")
344:        actual = fs(source)
345:        self.assertFormatEqual(expected, actual)
346:        black.assert_equivalent(source, actual)
347:        black.assert_stable(source, actual, line_length=ll)
348:
349:    @patch("black.dump_to_file", dump_to_stderr)
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)
410:        black.assert_equivalent(source, actual)
411:        black.assert_stable(source, actual, line_length=ll)
412:
413:    @patch("black.dump_to_file", dump_to_stderr)
414:    def test_numeric_literals(self) -> None:
415:        source, expected = read_data("numeric_literals")
416:        actual = fs(source, mode=black.FileMode.PYTHON36)
417:        self.assertFormatEqual(expected, actual)
418:        black.assert_equivalent(source, actual)
419:        black.assert_stable(source, actual, line_length=ll)
420:
421:    @patch("black.dump_to_file", dump_to_stderr)
422:    def test_numeric_literals_ignoring_underscores(self) -> None:
423:        source, expected = read_data("numeric_literals_skip_underscores")
424:        mode = (
425:            black.FileMode.PYTHON36 | black.FileMode.NO_NUMERIC_UNDERSCORE_NORMALIZATION
426:        )
427:        actual = fs(source, mode=mode)
428:        self.assertFormatEqual(expected, actual)
429:        black.assert_equivalent(source, actual)
430:        black.assert_stable(source, actual, line_length=ll, mode=mode)
431:
432:    @patch("black.dump_to_file", dump_to_stderr)
433:    def test_numeric_literals_py2(self) -> None:
434:        source, expected = read_data("numeric_literals_py2")
435:        actual = fs(source)
436:        self.assertFormatEqual(expected, actual)
437:        black.assert_stable(source, actual, line_length=ll)
438:
439:    @patch("black.dump_to_file", dump_to_stderr)
440:    def test_python2(self) -> None:
441:        source, expected = read_data("python2")
442:        actual = fs(source)
443:        self.assertFormatEqual(expected, actual)
444:        # black.assert_equivalent(source, actual)
445:        black.assert_stable(source, actual, line_length=ll)
446:
447:    @patch("black.dump_to_file", dump_to_stderr)
448:    def test_python2_unicode_literals(self) -> None:
449:        source, expected = read_data("python2_unicode_literals")
450:        actual = fs(source)
451:        self.assertFormatEqual(expected, actual)
452:        black.assert_stable(source, actual, line_length=ll)
453:
454:    @patch("black.dump_to_file", dump_to_stderr)
455:    def test_stub(self) -> None:
456:        mode = black.FileMode.PYI
457:        source, expected = read_data("stub.pyi")
458:        actual = fs(source, mode=mode)
459:        self.assertFormatEqual(expected, actual)

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1770:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1784:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1802:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1812:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1824:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1834:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1846:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py:235:    def read_data(file, endian, num=1):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/coverage/html.py:63:def read_data(fname):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager, redirect_stderr
5:from functools import partial, wraps
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import re
10:import sys
11:from tempfile import TemporaryDirectory
12:from typing import (
13:    Any,
14:    BinaryIO,
15:    Callable,
16:    Coroutine,
17:    Generator,
18:    List,
19:    Tuple,
20:    Iterator,
21:    TypeVar,
22:)
23:import unittest
24:from unittest.mock import patch, MagicMock
25:
26:from click import unstyle
27:from click.testing import CliRunner
28:
29:import black
30:
31:try:
32:    import blackd
33:    from aiohttp.test_utils import TestClient, TestServer
34:except ImportError:
35:    has_blackd_deps = False
36:else:
37:    has_blackd_deps = True
38:
39:
40:ll = 88
41:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
42:fs = partial(black.format_str, line_length=ll)
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:T = TypeVar("T")
47:R = TypeVar("R")
48:
49:
50:def dump_to_stderr(*output: str) -> str:
51:    return "\n" + "\n".join(output) + "\n"
52:
53:
54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
55:    """read_data('test_name') -> 'input', 'output'"""
56:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
57:        name += ".py"
58:    _input: List[str] = []
59:    _output: List[str] = []
60:    base_dir = THIS_DIR / "data" if data else THIS_DIR
61:    with open(base_dir / name, "r", encoding="utf8") as test:
62:        lines = test.readlines()
63:    result = _input
64:    for line in lines:
65:        line = line.replace(EMPTY_LINE, "")
66:        if line.rstrip() == "# output":
67:            result = _output
68:            continue
69:
70:        result.append(line)
71:    if _input and not _output:
72:        # If there's no output marker, treat the entire file as already pre-formatted.
73:        _output = _input[:]
74:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
75:
76:
77:@contextmanager
78:def cache_dir(exists: bool = True) -> Iterator[Path]:
79:    with TemporaryDirectory() as workspace:
80:        cache_dir = Path(workspace)
81:        if not exists:
82:            cache_dir = cache_dir / "new"
83:        with patch("black.CACHE_DIR", cache_dir):
84:            yield cache_dir
85:
86:
87:@contextmanager
88:def event_loop(close: bool) -> Iterator[None]:
89:    policy = asyncio.get_event_loop_policy()
90:    old_loop = policy.get_event_loop()
91:    loop = policy.new_event_loop()
92:    asyncio.set_event_loop(loop)
93:    try:
94:        yield
95:
96:    finally:
97:        policy.set_event_loop(old_loop)
98:        if close:
99:            loop.close()
100:
101:
102:def async_test(f: Callable[..., Coroutine[Any, None, R]]) -> Callable[..., None]:
103:    @event_loop(close=True)
104:    @wraps(f)
105:    def wrapper(*args: Any, **kwargs: Any) -> None:
106:        asyncio.get_event_loop().run_until_complete(f(*args, **kwargs))
107:
108:    return wrapper
109:
110:
111:class BlackRunner(CliRunner):
112:    """Modify CliRunner so that stderr is not merged with stdout.
113:
114:    This is a hack that can be removed once we depend on Click 7.x"""
115:
116:    def __init__(self) -> None:
117:        self.stderrbuf = BytesIO()
118:        self.stdoutbuf = BytesIO()
119:        self.stdout_bytes = b""
120:        self.stderr_bytes = b""

Calling tool: globTool
**/tests/data/comments6.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2080:
2081:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2082:    space between the hash sign and the content.
2083:
2084:    If `content` didn't start with a hash sign, one is provided.
2085:    """
2086:    content = content.rstrip()
2087:    if not content:
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf

Calling tool: grepTool
def is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2440:
2441:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2442:        """Append `leaf` to current line or to new line if appending impossible."""
2443:        nonlocal current_line
2444:        try:
2445:            current_line.append_safe(leaf, preformatted=True)
2446:        except ValueError:
2447:            yield current_line
2448:
2449:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2450:            current_line.append(leaf)
2451:
2452:    for leaf in line.leaves:
2453:        yield from append_to_line(leaf)
2454:
2455:        for comment_after in line.comments_after(leaf):
2456:            yield from append_to_line(comment_after)
2457:
2458:    if current_line:
2459:        yield current_line
2460:
2461:
2462:def is_import(leaf: Leaf) -> bool:
2463:    """Return True if the given leaf starts an import statement."""
2464:    p = leaf.parent
2465:    t = leaf.type
2466:    v = leaf.value
2467:    return bool(
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.
2508:
2509:    Note: Mutates its argument.
2510:    """
2511:    match = re.match(r"^([furbFURB]*)(.*)$", leaf.value, re.DOTALL)
2512:    assert match is not None, f"failed to match string {leaf.value!r}"
2513:    orig_prefix = match.group(1)
2514:    new_prefix = orig_prefix.lower()
2515:    if remove_u_prefix:
2516:        new_prefix = new_prefix.replace("u", "")
2517:    leaf.value = f"{new_prefix}{match.group(2)}"
2518:
2519:

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
793:STANDALONE_COMMENT = 153
794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1161:            if leaf.type == STANDALONE_COMMENT:
1231:            comment.type == STANDALONE_COMMENT
1241:            comment.type = STANDALONE_COMMENT
1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
2067:            comment_type = STANDALONE_COMMENT
2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2735:                if comment.type != STANDALONE_COMMENT:
2765:                        STANDALONE_COMMENT,
3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1992:        )
1993:    ):
1994:        return COMPARATOR_PRIORITY
1995:
1996:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1997:        return LOGIC_PRIORITY
1998:
1999:    return 0
2000:
2001:
2002:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2003:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2004:
2005:
2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2007:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2008:
2009:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2010:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2011:    move because it does away with modifying the grammar to include all the
2012:    possible places in which comments can be placed.
2013:
2014:    The sad consequence for us though is that comments don't "belong" anywhere.
2015:    This is why this function generates simple parentless Leaf objects for
2016:    comments.  We simply don't know what the correct parent should be.
2017:
2018:    No matter though, we can live without this.  We really only need to
2019:    differentiate between inline and standalone comments.  The latter don't
2020:    share the line with any code.
2021:
2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
2024:    """
2025:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2026:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2027:
2028:
2029:@dataclass
2030:class ProtoComment:
2031:    """Describes a piece of syntax that is a comment.
2032:
2033:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2034:
2035:    * it can be cached (`Leaf` objects should not be reused more than once as
2036:      they store their lineno, column, prefix, and parent information);
2037:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2038:      simplifies handling of special marker comments like ``# fmt: off/on``.
2039:    """
2040:
2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
2042:    value: str  # content of the comment
2043:    newlines: int  # how many newlines before the comment
2044:    consumed: int  # how many characters of the original leaf's prefix did we consume
2045:
2046:
2047:@lru_cache(maxsize=4096)
2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2049:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2050:    result: List[ProtoComment] = []
2051:    if not prefix or "#" not in prefix:
2052:        return result
2053:
2054:    consumed = 0
2055:    nlines = 0
2056:    for index, line in enumerate(prefix.split("\n")):
2057:        consumed += len(line) + 1  # adding the length of the split '\n'
2058:        line = line.lstrip()
2059:        if not line:
2060:            nlines += 1
2061:        if not line.startswith("#"):
2062:            continue
2063:
2064:        if index == 0 and not is_endmarker:
2065:            comment_type = token.COMMENT  # simple trailing comment
2066:        else:
2067:            comment_type = STANDALONE_COMMENT
2068:        comment = make_comment(line)
2069:        result.append(
2070:            ProtoComment(
2071:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2072:            )
2073:        )
2074:        nlines = 0
2075:    return result
2076:
2077:
2078:def make_comment(content: str) -> str:
2079:    """Return a consistently formatted comment from the given `content` string.
2080:
2081:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2082:    space between the hash sign and the content.
2083:
2084:    If `content` didn't start with a hash sign, one is provided.
2085:    """
2086:    content = content.rstrip()
2087:    if not content:
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line

Calling tool: grepTool
def comments_after\(
Matched content:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1210:
1211:        for leaf in self.leaves[_opening_index + 1 :]:
1212:            if leaf is closing:
1213:                break
1214:
1215:            bracket_depth = leaf.bracket_depth
1216:            if bracket_depth == depth and leaf.type == token.COMMA:
1217:                commas += 1
1218:                if leaf.parent and leaf.parent.type == syms.arglist:
1219:                    commas += 1
1220:                    break
1221:
1222:        if commas > 1:
1223:            self.remove_trailing_comma()
1224:            return True
1225:
1226:        return False
1227:
1228:    def append_comment(self, comment: Leaf) -> bool:
1229:        """Add an inline or standalone comment to the line."""
1230:        if (
1231:            comment.type == STANDALONE_COMMENT
1232:            and self.bracket_tracker.any_open_brackets()
1233:        ):
1234:            comment.prefix = ""
1235:            return False
1236:
1237:        if comment.type != token.COMMENT:
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling
1278:
1279:        if isinstance(subscript_start, Node):
1280:            if subscript_start.type == syms.listmaker:
1281:                return False
1282:
1283:            if subscript_start.type == syms.subscriptlist:
1284:                subscript_start = child_towards(subscript_start, leaf)
1285:        return subscript_start is not None and any(
1286:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
1287:        )
1288:
1289:    def __str__(self) -> str:

Calling tool: grepTool
is_special_comment\(
Matched content:
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: createTodo
Todo List Created
Todo List (12 items):
- [ ] Verify that `split_line()` now guards the short-line early return with a check for special comments: it computes `has_special_comment` by scanning `line.leaves` and `line.comments_after(leaf)`, and only returns early if `not has_special_comment and not line.should_explode and is_line_short_enough(...)`. (ID: todo-1)
- [ ] Confirm that `has_special_comment` is set when an inline type comment follows a comma in a function parameter list: inside `split_line()`, the condition `leaf.type == token.COMMA and is_special_comment(comment)` should detect type comments like `a,  # type: int`. (ID: todo-2)
- [ ] Validate that `is_special_comment(leaf: Leaf) -> bool` exists and returns True only for comment leaves (`token.COMMENT` or `STANDALONE_COMMENT`) whose value starts with `"# type:"`. (ID: todo-3)
- [ ] Check that `STANDALONE_COMMENT` is defined and integrated in the tokenization logic so `is_special_comment` can safely reference it (e.g., constant defined, tok_name mapping, and comment handling in `list_comments`/`generate_comments`). (ID: todo-4)
- [ ] Ensure `split_line()` uses `line.comments_after(leaf)` correctly to retrieve inline comments and that `comments_after()` returns comments attached to the last emitted leaf (see `append_comment` logic). This ensures comments after a comma are discoverable. (ID: todo-5)
- [ ] Confirm that the new special comment handling does not interfere with lines that have only a standalone type comment for the return type (e.g., `# type: (...) -> None`) since `has_special_comment` only looks at inline comments after commas. The early return should still allow short single-line signatures without per-parameter comments to remain unchanged. (ID: todo-6)
- [ ] Verify that test fixture `tests/data/comments6.py` contains per-parameter inline type comments, `*args`/`**kwargs` with type comments, default-valued parameters with type comments, and nested structures (tuple items) with type comments, matching the PR intent. (ID: todo-7)
- [ ] Check that `tests/data/comments6.py` has no `# output` marker so `read_data("comments6")` returns the input as expected output; thus the test asserts formatting is a no-op for these cases. (ID: todo-8)
- [ ] Ensure `tests/test_black.py::BlackTestCase.test_comments6` loads `comments6` and asserts format equality (`self.assertFormatEqual(expected, actual)`), equivalence (`black.assert_equivalent`), and stability, tying the test to the PR requirement. (ID: todo-9)
- [ ] Confirm there are no other code paths in `split_line()` that could later recombine function parameters into a single line when `has_special_comment` is True (i.e., after bypassing the early return, it proceeds into splitting strategies without concatenating into a flat one-liner). (ID: todo-10)
- [ ] Verify that the added helper `is_special_comment` is referenced only where intended (currently within `split_line`) and does not alter unrelated formatting behavior. (ID: todo-11)
- [ ] Double-check imports/constants used by the change (e.g., `token`, `Leaf`, `Line`) are available in scope and the type hints are consistent with the rest of the module. (ID: todo-12)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 12
description: 'Verify that `split_line()` now guards the short-line early return with a check for special comments: it computes `has_special_comment` by scanning `line.leaves` and `line.comments_after(leaf)`, and only returns early if `not has_special_comment and not line.should_explode and is_line_short_enough(...)`.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def is_special_comment\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_comments6\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "STANDALONE_COMMENT",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2205:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2206:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2207:    bracket_split_succeeded_or_raise(head, body, tail)
2208:    for result in (head, body, tail):
2209:        if result:

Calling tool: grepTool
def is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.

Calling tool: grepTool
test_comments6\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2735:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2765:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2416:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2714:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2744:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3029:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, split_line() now computes has_special_comment by iterating over line.leaves and line.comments_after(leaf) and checking is_special_comment on comments after commas (lines 2116-2123). The early return is guarded by `not has_special_comment and not line.should_explode and is_line_short_enough(...)` (lines 2124-2130), matching the todo requirement.


Todo item 1 of 12 is correct
description: 'Verify that `split_line()` now guards the short-line early return with a check for special comments: it computes `has_special_comment` by scanning `line.leaves` and `line.comments_after(leaf)`, and only returns early if `not has_special_comment and not line.should_explode and is_line_short_enough(...)`.'
Validating todo item 2 of 12
description: 'Confirm that `has_special_comment` is set when an inline type comment follows a comma in a function parameter list: inside `split_line()`, the condition `leaf.type == token.COMMA and is_special_comment(comment)` should detect type comments like `a,  # type: int`.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def is_special_comment\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def comments_after\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "COMMA", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_comments6", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def read_data\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def maybe_comment\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "comment", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def generate_comments\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "STANDALONE_COMMENT",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2205:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2206:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2207:    bracket_split_succeeded_or_raise(head, body, tail)

Calling tool: grepTool
def is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.

Calling tool: grepTool
def comments_after\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling

Calling tool: grepTool
COMMA
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pgen2/token.pyi:18:COMMA: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pgen2/grammar.py:139:, COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pgen2/token.py:19:COMMA = 12
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:869:COMMA_PRIORITY = 18
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1178:            and self.leaves[-1].type == token.COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1216:            if bracket_depth == depth and leaf.type == token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1647:            elif prevp.type != token.COMMA and not complex_subscript:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1699:        if not prev or prev.type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1704:        if prev and prev.type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1721:        elif prev.type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1728:            if not prevp or prevp.type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1745:        elif prev.type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1900:    if leaf.type == token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1901:        return COMMA_PRIORITY
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2121:            if leaf.type == token.COMMA and is_special_comment(comment):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2342:                if leaves[-1].type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2343:                    leaves.append(Leaf(token.COMMA, ","))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2425:            and delimiter_priority == COMMA_PRIORITY
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2426:            and current_line.leaves[-1].type != token.COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2429:            current_line.append(Leaf(token.COMMA, ","))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2804:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2845:        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2850:        and node.children[1].type == token.COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2985:        exclude = {id(last_leaf)} if last_leaf.type == token.COMMA else set()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2990:    return max_priority == COMMA_PRIORITY
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3014:            and n.children[-1].type == token.COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:75:              COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:173:                    COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:234:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:375:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:386:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:456:                          COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:499:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:510:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:562:                            COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:573:                            COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:584:                            COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:618:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:629:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:679:                COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/blib2to3/pgen2/token.pyi:18:COMMA: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/blib2to3/pgen2/grammar.py:139:, COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/setuptools_scm/utils.py:40:        or k in ("GIT_EXEC_PATH", "GIT_SSH", "GIT_SSH_COMMAND")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/blib2to3/pgen2/token.py:19:COMMA = 12
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/packaging/requirements.py:34:COMMA = L(",").suppress()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/packaging/requirements.py:48:EXTRAS_LIST = EXTRA + ZeroOrMore(COMMA + EXTRA)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/packaging/requirements.py:56:    VERSION_ONE + ZeroOrMore(COMMA + VERSION_ONE), joinString=",", adjacent=False
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/aiohttp/_http_parser.c:34:#define __PYX_COMMA ,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/aiohttp/_websocket.c:34:#define __PYX_COMMA ,

Calling tool: grepTool
test_comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_comments6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments6

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)
410:        black.assert_equivalent(source, actual)
411:        black.assert_stable(source, actual, line_length=ll)
412:
413:    @patch("black.dump_to_file", dump_to_stderr)
414:    def test_numeric_literals(self) -> None:
415:        source, expected = read_data("numeric_literals")
416:        actual = fs(source, mode=black.FileMode.PYTHON36)
417:        self.assertFormatEqual(expected, actual)
418:        black.assert_equivalent(source, actual)
419:        black.assert_stable(source, actual, line_length=ll)
420:
421:    @patch("black.dump_to_file", dump_to_stderr)
422:    def test_numeric_literals_ignoring_underscores(self) -> None:
423:        source, expected = read_data("numeric_literals_skip_underscores")
424:        mode = (
425:            black.FileMode.PYTHON36 | black.FileMode.NO_NUMERIC_UNDERSCORE_NORMALIZATION
426:        )
427:        actual = fs(source, mode=mode)
428:        self.assertFormatEqual(expected, actual)
429:        black.assert_equivalent(source, actual)

Calling tool: globTool
**/tests/data/*comments6*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1770:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1784:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1802:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1812:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1824:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1834:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1846:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/coverage/html.py:63:def read_data(fname):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py:235:    def read_data(file, endian, num=1):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager, redirect_stderr
5:from functools import partial, wraps
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import re
10:import sys
11:from tempfile import TemporaryDirectory
12:from typing import (
13:    Any,
14:    BinaryIO,
15:    Callable,
16:    Coroutine,
17:    Generator,
18:    List,
19:    Tuple,
20:    Iterator,
21:    TypeVar,
22:)
23:import unittest
24:from unittest.mock import patch, MagicMock
25:
26:from click import unstyle
27:from click.testing import CliRunner
28:
29:import black
30:
31:try:
32:    import blackd
33:    from aiohttp.test_utils import TestClient, TestServer
34:except ImportError:
35:    has_blackd_deps = False
36:else:
37:    has_blackd_deps = True
38:
39:
40:ll = 88
41:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
42:fs = partial(black.format_str, line_length=ll)
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:T = TypeVar("T")
47:R = TypeVar("R")
48:
49:
50:def dump_to_stderr(*output: str) -> str:
51:    return "\n" + "\n".join(output) + "\n"
52:
53:
54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
55:    """read_data('test_name') -> 'input', 'output'"""
56:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
57:        name += ".py"
58:    _input: List[str] = []
59:    _output: List[str] = []
60:    base_dir = THIS_DIR / "data" if data else THIS_DIR
61:    with open(base_dir / name, "r", encoding="utf8") as test:
62:        lines = test.readlines()
63:    result = _input
64:    for line in lines:
65:        line = line.replace(EMPTY_LINE, "")
66:        if line.rstrip() == "# output":
67:            result = _output
68:            continue
69:
70:        result.append(line)
71:    if _input and not _output:
72:        # If there's no output marker, treat the entire file as already pre-formatted.
73:        _output = _input[:]
74:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
75:
76:
77:@contextmanager
78:def cache_dir(exists: bool = True) -> Iterator[Path]:
79:    with TemporaryDirectory() as workspace:
80:        cache_dir = Path(workspace)
81:        if not exists:
82:            cache_dir = cache_dir / "new"
83:        with patch("black.CACHE_DIR", cache_dir):
84:            yield cache_dir
85:
86:
87:@contextmanager
88:def event_loop(close: bool) -> Iterator[None]:
89:    policy = asyncio.get_event_loop_policy()
90:    old_loop = policy.get_event_loop()
91:    loop = policy.new_event_loop()
92:    asyncio.set_event_loop(loop)
93:    try:
94:        yield
95:
96:    finally:
97:        policy.set_event_loop(old_loop)
98:        if close:
99:            loop.close()
100:

Calling tool: grepTool
def maybe_comment\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
comment
Showing first 50 results from grep. Consider using a more specific pattern or path.
1027:    """Holds leaves and comments. Can be printed with `str(line)`."""
1031:    # The LeafID keys of comments must remain ordered by the corresponding leaf's index
1033:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)
1046:        Inline comments are put aside.
1063:        if not self.append_comment(leaf):
1067:        """Like :func:`append()` but disallow invalid standalone comment structure.
1069:        Raises ValueError when any `leaf` is appended after a standalone comment
1070:        or when a standalone comment is not the first leaf on the line.
1073:            if self.is_comment:
1074:                raise ValueError("cannot append to standalone comments")
1078:                    "cannot append standalone comments to a populated line"
1084:    def is_comment(self) -> bool:
1085:        """Is this line a standalone comment?"""
1158:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1228:    def append_comment(self, comment: Leaf) -> bool:
1229:        """Add an inline or standalone comment to the line."""
1231:            comment.type == STANDALONE_COMMENT
1234:            comment.prefix = ""
1237:        if comment.type != token.COMMENT:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1250:                self.comments[leaf_id].append(comment)
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1268:        self.comments.pop(id(self.leaves[-1]), None)
1300:        for comment in itertools.chain.from_iterable(self.comments.values()):
1301:            res += str(comment)
1305:        """Return True if the line has leaves or comments."""
1306:        return bool(self.leaves or self.comments)
1393:            self.previous_line.is_comment
1454:            for comment in generate_comments(node):
1456:                    # any comment within brackets is subject to splitting
1457:                    self.current_line.append(comment)
1458:                elif comment.type == token.COMMENT:
1459:                    # regular trailing comment
1460:                    self.current_line.append(comment)
1464:                    # regular standalone comment
1467:                    self.current_line.append(comment)
1482:        # In blib2to3 INDENT never holds comments.
1488:        # The current line might still wait for trailing comments.  At DEDENT time

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1008:        """See `maybe_increment_lambda_arguments` above for explanation."""
1009:        if (
1010:            self._lambda_argument_depths
1011:            and self._lambda_argument_depths[-1] == self.depth
1012:            and leaf.type == token.COLON
1013:        ):
1014:            self.depth -= 1
1015:            self._lambda_argument_depths.pop()
1016:            return True
1017:
1018:        return False
1019:
1020:    def get_open_lsqb(self) -> Optional[Leaf]:
1021:        """Return the most recent opening square bracket (if any)."""
1022:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1023:
1024:
1025:@dataclass
1026:class Line:
1027:    """Holds leaves and comments. Can be printed with `str(line)`."""
1028:
1029:    depth: int = 0
1030:    leaves: List[Leaf] = Factory(list)
1031:    # The LeafID keys of comments must remain ordered by the corresponding leaf's index
1032:    # in leaves
1033:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)
1034:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1035:    inside_brackets: bool = False
1036:    should_explode: bool = False
1037:
1038:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1039:        """Add a new `leaf` to the end of the line.
1040:
1041:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1042:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1043:        Trailing commas are maybe removed, unpacked for loop variables are
1044:        demoted from being delimiters.
1045:
1046:        Inline comments are put aside.
1047:        """
1048:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1049:        if not has_value:
1050:            return
1051:
1052:        if token.COLON == leaf.type and self.is_class_paren_empty:
1053:            del self.leaves[-2:]
1054:        if self.leaves and not preformatted:
1055:            # Note: at this point leaf.prefix should be empty except for
1056:            # imports, for which we only preserve newlines.
1057:            leaf.prefix += whitespace(
1058:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1059:            )
1060:        if self.inside_brackets or not preformatted:
1061:            self.bracket_tracker.mark(leaf)
1062:            self.maybe_remove_trailing_comma(leaf)
1063:        if not self.append_comment(leaf):
1064:            self.leaves.append(leaf)
1065:
1066:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1067:        """Like :func:`append()` but disallow invalid standalone comment structure.
1068:
1069:        Raises ValueError when any `leaf` is appended after a standalone comment
1070:        or when a standalone comment is not the first leaf on the line.
1071:        """
1072:        if self.bracket_tracker.depth == 0:
1073:            if self.is_comment:
1074:                raise ValueError("cannot append to standalone comments")
1075:
1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1077:                raise ValueError(
1078:                    "cannot append standalone comments to a populated line"
1079:                )
1080:
1081:        self.append(leaf, preformatted=preformatted)
1082:
1083:    @property
1084:    def is_comment(self) -> bool:
1085:        """Is this line a standalone comment?"""
1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1087:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1218:                if leaf.parent and leaf.parent.type == syms.arglist:
1219:                    commas += 1
1220:                    break
1221:
1222:        if commas > 1:
1223:            self.remove_trailing_comma()
1224:            return True
1225:
1226:        return False
1227:
1228:    def append_comment(self, comment: Leaf) -> bool:
1229:        """Add an inline or standalone comment to the line."""
1230:        if (
1231:            comment.type == STANDALONE_COMMENT
1232:            and self.bracket_tracker.any_open_brackets()
1233:        ):
1234:            comment.prefix = ""
1235:            return False
1236:
1237:        if comment.type != token.COMMENT:
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling
1278:
1279:        if isinstance(subscript_start, Node):
1280:            if subscript_start.type == syms.listmaker:
1281:                return False
1282:
1283:            if subscript_start.type == syms.subscriptlist:
1284:                subscript_start = child_towards(subscript_start, leaf)
1285:        return subscript_start is not None and any(
1286:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
1287:        )
1288:
1289:    def __str__(self) -> str:
1290:        """Render the line."""
1291:        if not self:
1292:            return "\n"
1293:
1294:        indent = "    " * self.depth
1295:        leaves = iter(self.leaves)
1296:        first = next(leaves)
1297:        res = f"{first.prefix}{indent}{first.value}"

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1428:    is_pyi: bool = False
1429:    normalize_strings: bool = True
1430:    current_line: Line = Factory(Line)
1431:    remove_u_prefix: bool = False
1432:    allow_underscores: bool = False
1433:
1434:    def line(self, indent: int = 0) -> Iterator[Line]:
1435:        """Generate a line.
1436:
1437:        If the line is empty, only emit if it makes sense.
1438:        If the line is too long, split it first and then generate.
1439:
1440:        If any lines were generated, set up a new current_line.
1441:        """
1442:        if not self.current_line:
1443:            self.current_line.depth += indent
1444:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1445:
1446:        complete_line = self.current_line
1447:        self.current_line = Line(depth=complete_line.depth + indent)
1448:        yield complete_line
1449:
1450:    def visit_default(self, node: LN) -> Iterator[Line]:
1451:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1452:        if isinstance(node, Leaf):
1453:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1454:            for comment in generate_comments(node):
1455:                if any_open_brackets:
1456:                    # any comment within brackets is subject to splitting
1457:                    self.current_line.append(comment)
1458:                elif comment.type == token.COMMENT:
1459:                    # regular trailing comment
1460:                    self.current_line.append(comment)
1461:                    yield from self.line()
1462:
1463:                else:
1464:                    # regular standalone comment
1465:                    yield from self.line()
1466:
1467:                    self.current_line.append(comment)
1468:                    yield from self.line()
1469:
1470:            normalize_prefix(node, inside_brackets=any_open_brackets)
1471:            if self.normalize_strings and node.type == token.STRING:
1472:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1473:                normalize_string_quotes(node)
1474:            if node.type == token.NUMBER:
1475:                normalize_numeric_literal(node, self.allow_underscores)
1476:            if node.type not in WHITESPACE:
1477:                self.current_line.append(node)
1478:        yield from super().visit_default(node)
1479:
1480:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1481:        """Increase indentation level, maybe yield a line."""
1482:        # In blib2to3 INDENT never holds comments.
1483:        yield from self.line(+1)
1484:        yield from self.visit_default(node)
1485:
1486:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1487:        """Decrease indentation level, maybe yield a line."""

Calling tool: grepTool
def generate_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1988:        and not (
1989:            previous is not None
1990:            and previous.type == token.NAME
1991:            and previous.value == "is"
1992:        )
1993:    ):
1994:        return COMPARATOR_PRIORITY
1995:
1996:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1997:        return LOGIC_PRIORITY
1998:
1999:    return 0
2000:
2001:
2002:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2003:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2004:
2005:
2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2007:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2008:
2009:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2010:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2011:    move because it does away with modifying the grammar to include all the
2012:    possible places in which comments can be placed.
2013:
2014:    The sad consequence for us though is that comments don't "belong" anywhere.
2015:    This is why this function generates simple parentless Leaf objects for
2016:    comments.  We simply don't know what the correct parent should be.
2017:
2018:    No matter though, we can live without this.  We really only need to
2019:    differentiate between inline and standalone comments.  The latter don't
2020:    share the line with any code.
2021:
2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
2024:    """
2025:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2026:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2027:
2028:
2029:@dataclass
2030:class ProtoComment:
2031:    """Describes a piece of syntax that is a comment.
2032:
2033:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2034:
2035:    * it can be cached (`Leaf` objects should not be reused more than once as
2036:      they store their lineno, column, prefix, and parent information);
2037:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2038:      simplifies handling of special marker comments like ``# fmt: off/on``.
2039:    """
2040:
2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
2042:    value: str  # content of the comment
2043:    newlines: int  # how many newlines before the comment
2044:    consumed: int  # how many characters of the original leaf's prefix did we consume
2045:
2046:
2047:@lru_cache(maxsize=4096)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2049:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2050:    result: List[ProtoComment] = []
2051:    if not prefix or "#" not in prefix:
2052:        return result
2053:
2054:    consumed = 0
2055:    nlines = 0
2056:    for index, line in enumerate(prefix.split("\n")):
2057:        consumed += len(line) + 1  # adding the length of the split '\n'
2058:        line = line.lstrip()
2059:        if not line:
2060:            nlines += 1
2061:        if not line.startswith("#"):
2062:            continue
2063:
2064:        if index == 0 and not is_endmarker:
2065:            comment_type = token.COMMENT  # simple trailing comment
2066:        else:
2067:            comment_type = STANDALONE_COMMENT
2068:        comment = make_comment(line)
2069:        result.append(
2070:            ProtoComment(
2071:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2072:            )
2073:        )
2074:        nlines = 0
2075:    return result
2076:
2077:
2078:def make_comment(content: str) -> str:
2079:    """Return a consistently formatted comment from the given `content` string.
2080:
2081:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2082:    space between the hash sign and the content.
2083:
2084:    If `content` didn't start with a hash sign, one is provided.
2085:    """
2086:    content = content.rstrip()
2087:    if not content:
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2735:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2765:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2416:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2714:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2744:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3029:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In split_line(), lines 21192122 iterate comments attached to each leaf and set has_special_comment when leaf.type == token.COMMA and is_special_comment(comment). is_special_comment (lines 24762483) returns True for inline comments starting with # type:. Since inline comments after a comma attach to that comma via Line.append_comment, this detects cases like a,  # type: int. 


Todo item 2 of 12 is correct
description: 'Confirm that `has_special_comment` is set when an inline type comment follows a comma in a function parameter list: inside `split_line()`, the condition `leaf.type == token.COMMA and is_special_comment(comment)` should detect type comments like `a,  # type: int`.'
Validating todo item 3 of 12
description: 'Validate that `is_special_comment(leaf: Leaf) -> bool` exists and returns True only for comment leaves (`token.COMMENT` or `STANDALONE_COMMENT`) whose value starts with `"# type:"`.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def is_special_comment\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
Calling tool: grepTool
def is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Found function `is_special_comment(leaf: Leaf) -> bool` in black.py at line 2476. It returns True only when the leaf type is `token.COMMENT` or `STANDALONE_COMMENT` and the value starts with `"# type:"`, matching the requirement.


Todo item 3 of 12 is correct
description: 'Validate that `is_special_comment(leaf: Leaf) -> bool` exists and returns True only for comment leaves (`token.COMMENT` or `STANDALONE_COMMENT`) whose value starts with `"# type:"`.'
Validating todo item 4 of 12
description: 'Check that `STANDALONE_COMMENT` is defined and integrated in the tokenization logic so `is_special_comment` can safely reference it (e.g., constant defined, tok_name mapping, and comment handling in `list_comments`/`generate_comments`).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "STANDALONE_COMMENT",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def list_comments\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def generate_comments\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2735:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2765:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2416:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2714:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2744:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3029:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
780:KEYWORDS = set(keyword.kwlist)
781:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
782:FLOW_CONTROL = {"return", "raise", "break", "continue"}
783:STATEMENT = {
784:    syms.if_stmt,
785:    syms.while_stmt,
786:    syms.for_stmt,
787:    syms.try_stmt,
788:    syms.except_clause,
789:    syms.with_stmt,
790:    syms.funcdef,
791:    syms.classdef,
792:}
793:STANDALONE_COMMENT = 153
794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
795:LOGIC_OPERATORS = {"and", "or"}
796:COMPARATORS = {
797:    token.LESS,
798:    token.GREATER,
799:    token.EQEQUAL,
800:    token.NOTEQUAL,
801:    token.LESSEQUAL,
802:    token.GREATEREQUAL,
803:}
804:MATH_OPERATORS = {
805:    token.VBAR,
806:    token.CIRCUMFLEX,
807:    token.AMPER,
808:    token.LEFTSHIFT,
809:    token.RIGHTSHIFT,
810:    token.PLUS,
811:    token.MINUS,
812:    token.STAR,
813:    token.SLASH,
814:    token.DOUBLESLASH,
815:    token.PERCENT,
816:    token.AT,
817:    token.TILDE,
818:    token.DOUBLESTAR,
819:}

Calling tool: grepTool
def list_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2020:    share the line with any code.
2021:
2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
2024:    """
2025:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2026:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2027:
2028:
2029:@dataclass
2030:class ProtoComment:
2031:    """Describes a piece of syntax that is a comment.
2032:
2033:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2034:
2035:    * it can be cached (`Leaf` objects should not be reused more than once as
2036:      they store their lineno, column, prefix, and parent information);
2037:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2038:      simplifies handling of special marker comments like ``# fmt: off/on``.
2039:    """
2040:
2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
2042:    value: str  # content of the comment
2043:    newlines: int  # how many newlines before the comment
2044:    consumed: int  # how many characters of the original leaf's prefix did we consume
2045:
2046:
2047:@lru_cache(maxsize=4096)
2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2049:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2050:    result: List[ProtoComment] = []
2051:    if not prefix or "#" not in prefix:
2052:        return result
2053:
2054:    consumed = 0
2055:    nlines = 0
2056:    for index, line in enumerate(prefix.split("\n")):
2057:        consumed += len(line) + 1  # adding the length of the split '\n'
2058:        line = line.lstrip()
2059:        if not line:
2060:            nlines += 1
2061:        if not line.startswith("#"):
2062:            continue
2063:
2064:        if index == 0 and not is_endmarker:
2065:            comment_type = token.COMMENT  # simple trailing comment
2066:        else:
2067:            comment_type = STANDALONE_COMMENT
2068:        comment = make_comment(line)
2069:        result.append(
2070:            ProtoComment(
2071:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2072:            )
2073:        )
2074:        nlines = 0
2075:    return result
2076:
2077:
2078:def make_comment(content: str) -> str:
2079:    """Return a consistently formatted comment from the given `content` string.
2080:
2081:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2082:    space between the hash sign and the content.
2083:
2084:    If `content` didn't start with a hash sign, one is provided.
2085:    """
2086:    content = content.rstrip()
2087:    if not content:
2088:        return "#"
2089:

Calling tool: grepTool
def generate_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1996:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1997:        return LOGIC_PRIORITY
1998:
1999:    return 0
2000:
2001:
2002:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2003:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2004:
2005:
2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2007:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2008:
2009:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2010:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2011:    move because it does away with modifying the grammar to include all the
2012:    possible places in which comments can be placed.
2013:
2014:    The sad consequence for us though is that comments don't "belong" anywhere.
2015:    This is why this function generates simple parentless Leaf objects for
2016:    comments.  We simply don't know what the correct parent should be.
2017:
2018:    No matter though, we can live without this.  We really only need to
2019:    differentiate between inline and standalone comments.  The latter don't
2020:    share the line with any code.
2021:
2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
2024:    """
2025:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2026:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2027:
2028:
2029:@dataclass
2030:class ProtoComment:
2031:    """Describes a piece of syntax that is a comment.
2032:
2033:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2034:
2035:    * it can be cached (`Leaf` objects should not be reused more than once as

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1598:        self.visit_import_from = partial(v, keywords=, parens={"import"})
1599:        self.visit_async_funcdef = self.visit_async_stmt
1600:        self.visit_decorated = self.visit_decorators
1601:
1602:
1603:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
1604:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1605:OPENING_BRACKETS = set(BRACKET.keys())
1606:CLOSING_BRACKETS = set(BRACKET.values())
1607:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1609:
1610:
1611:def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa C901
1612:    """Return whitespace prefix if needed for the given `leaf`.
1613:
1614:    `complex_subscript` signals whether the given leaf is part of a subscription
1615:    which has non-trivial arguments, like arithmetic expressions or function calls.
1616:    """
1617:    NO = ""

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1566:        """Remove a semicolon and put the other statement on a separate line."""
1567:        yield from self.line()
1568:
1569:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1570:        """End of file. Process outstanding comments and end with a newline."""
1571:        yield from self.visit_default(leaf)
1572:        yield from self.line()
1573:
1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1575:        if not self.current_line.bracket_tracker.any_open_brackets():
1576:            yield from self.line()
1577:        yield from self.visit_default(leaf)
1578:
1579:    def __attrs_post_init__(self) -> None:
1580:        """You are in a twisty little maze of passages."""
1581:        v = self.visit_stmt
1582:        : Set[str] = set()
1583:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1584:        self.visit_if_stmt = partial(
1585:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1068:
1069:        Raises ValueError when any `leaf` is appended after a standalone comment
1070:        or when a standalone comment is not the first leaf on the line.
1071:        """
1072:        if self.bracket_tracker.depth == 0:
1073:            if self.is_comment:
1074:                raise ValueError("cannot append to standalone comments")
1075:
1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1077:                raise ValueError(
1078:                    "cannot append standalone comments to a populated line"
1079:                )
1080:
1081:        self.append(leaf, preformatted=preformatted)
1082:
1083:    @property
1084:    def is_comment(self) -> bool:
1085:        """Is this line a standalone comment?"""
1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1087:
1088:    @property
1089:    def is_decorator(self) -> bool:
1090:        """Is this line a decorator?"""
1091:        return bool(self) and self.leaves[0].type == token.AT
1092:
1093:    @property
1094:    def is_import(self) -> bool:
1095:        """Is this an import line?"""
1096:        return bool(self) and is_import(self.leaves[0])
1097:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1218:                if leaf.parent and leaf.parent.type == syms.arglist:
1219:                    commas += 1
1220:                    break
1221:
1222:        if commas > 1:
1223:            self.remove_trailing_comma()
1224:            return True
1225:
1226:        return False
1227:
1228:    def append_comment(self, comment: Leaf) -> bool:
1229:        """Add an inline or standalone comment to the line."""
1230:        if (
1231:            comment.type == STANDALONE_COMMENT
1232:            and self.bracket_tracker.any_open_brackets()
1233:        ):
1234:            comment.prefix = ""
1235:            return False
1236:
1237:        if comment.type != token.COMMENT:
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling
1278:
1279:        if isinstance(subscript_start, Node):
1280:            if subscript_start.type == syms.listmaker:
1281:                return False
1282:
1283:            if subscript_start.type == syms.subscriptlist:
1284:                subscript_start = child_towards(subscript_start, leaf)
1285:        return subscript_start is not None and any(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
3036:    """
3037:
3038:    omit: Set[LeafID] = set()
3039:    yield omit
3040:
3041:    length = 4 * line.depth
3042:    opening_bracket = None
3043:    closing_bracket = None
3044:    inner_brackets: Set[LeafID] = set()
3045:    for index, leaf, leaf_length in enumerate_with_length(line, reversed=True):
3046:        length += leaf_length
3047:        if length > line_length:
3048:            break
3049:
3050:        has_inline_comment = leaf_length > len(leaf.value) + len(leaf.prefix)
3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
3052:            break
3053:
3054:        if opening_bracket:
3055:            if leaf is opening_bracket:
3056:                opening_bracket = None
3057:            elif leaf.type in CLOSING_BRACKETS:
3058:                inner_brackets.add(id(leaf))
3059:        elif leaf.type in CLOSING_BRACKETS:
3060:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
3061:                # Empty brackets would fail a split so treat them as "inner"
3062:                # brackets (e.g. only add them to the `omit` set if another
3063:                # pair of brackets was good enough.
3064:                inner_brackets.add(id(leaf))
3065:                continue

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: STANDALONE_COMMENT is defined (black.py:793) and registered in token.tok_name (black.py:794). The tokenization flow uses it: generate_comments() yields leaves with this type via list_comments() (black.py:2006-2026, 2048-2075), where inline vs standalone is distinguished and STANDALONE_COMMENT is assigned (black.py:2064-2068). is_special_comment safely references it (black.py:2476-2483).


Todo item 4 of 12 is correct
description: 'Check that `STANDALONE_COMMENT` is defined and integrated in the tokenization logic so `is_special_comment` can safely reference it (e.g., constant defined, tok_name mapping, and comment handling in `list_comments`/`generate_comments`).'
Validating todo item 5 of 12
description: 'Ensure `split_line()` uses `line.comments_after(leaf)` correctly to retrieve inline comments and that `comments_after()` returns comments attached to the last emitted leaf (see `append_comment` logic). This ensures comments after a comma are discoverable.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class Line\\b", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def comments_after\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "STANDALONE_COMMENT\\b",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_comments6\\b", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "comments6", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def read_data\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
Calling tool: grepTool
class Line\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1026:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1026:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/docutils/parsers/rst/states.py:2913:class Line(SpecializedText):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/tabulate.pyi:8:class Line(NamedTuple):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/werkzeug/debug/tbtools.pyi:16:class Line:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1000:        if leaf.type == token.NAME and leaf.value == "lambda":
1001:            self.depth += 1
1002:            self._lambda_argument_depths.append(self.depth)
1003:            return True
1004:
1005:        return False
1006:
1007:    def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:
1008:        """See `maybe_increment_lambda_arguments` above for explanation."""
1009:        if (
1010:            self._lambda_argument_depths
1011:            and self._lambda_argument_depths[-1] == self.depth
1012:            and leaf.type == token.COLON
1013:        ):
1014:            self.depth -= 1
1015:            self._lambda_argument_depths.pop()
1016:            return True
1017:
1018:        return False
1019:
1020:    def get_open_lsqb(self) -> Optional[Leaf]:
1021:        """Return the most recent opening square bracket (if any)."""
1022:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1023:
1024:
1025:@dataclass
1026:class Line:
1027:    """Holds leaves and comments. Can be printed with `str(line)`."""
1028:
1029:    depth: int = 0
1030:    leaves: List[Leaf] = Factory(list)
1031:    # The LeafID keys of comments must remain ordered by the corresponding leaf's index
1032:    # in leaves
1033:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)
1034:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1035:    inside_brackets: bool = False
1036:    should_explode: bool = False
1037:
1038:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1039:        """Add a new `leaf` to the end of the line.
1040:
1041:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1042:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1043:        Trailing commas are maybe removed, unpacked for loop variables are
1044:        demoted from being delimiters.
1045:
1046:        Inline comments are put aside.
1047:        """
1048:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1049:        if not has_value:
1050:            return
1051:
1052:        if token.COLON == leaf.type and self.is_class_paren_empty:
1053:            del self.leaves[-2:]
1054:        if self.leaves and not preformatted:
1055:            # Note: at this point leaf.prefix should be empty except for
1056:            # imports, for which we only preserve newlines.
1057:            leaf.prefix += whitespace(
1058:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1059:            )
1060:        if self.inside_brackets or not preformatted:
1061:            self.bracket_tracker.mark(leaf)
1062:            self.maybe_remove_trailing_comma(leaf)
1063:        if not self.append_comment(leaf):
1064:            self.leaves.append(leaf)
1065:
1066:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1067:        """Like :func:`append()` but disallow invalid standalone comment structure.
1068:
1069:        Raises ValueError when any `leaf` is appended after a standalone comment
1070:        or when a standalone comment is not the first leaf on the line.
1071:        """
1072:        if self.bracket_tracker.depth == 0:
1073:            if self.is_comment:
1074:                raise ValueError("cannot append to standalone comments")
1075:
1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1077:                raise ValueError(
1078:                    "cannot append standalone comments to a populated line"
1079:                )
1080:
1081:        self.append(leaf, preformatted=preformatted)
1082:
1083:    @property
1084:    def is_comment(self) -> bool:
1085:        """Is this line a standalone comment?"""
1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1087:
1088:    @property
1089:    def is_decorator(self) -> bool:
1090:        """Is this line a decorator?"""
1091:        return bool(self) and self.leaves[0].type == token.AT
1092:
1093:    @property
1094:    def is_import(self) -> bool:
1095:        """Is this an import line?"""
1096:        return bool(self) and is_import(self.leaves[0])
1097:
1098:    @property
1099:    def is_class(self) -> bool:
1100:        """Is this line a class definition?"""
1101:        return (
1102:            bool(self)
1103:            and self.leaves[0].type == token.NAME
1104:            and self.leaves[0].value == "class"
1105:        )
1106:
1107:    @property
1108:    def is_stub_class(self) -> bool:
1109:        """Is this line a class definition with a body consisting only of "..."?"""
1110:        return self.is_class and self.leaves[-3:] == [
1111:            Leaf(token.DOT, ".") for _ in range(3)
1112:        ]
1113:
1114:    @property
1115:    def is_def(self) -> bool:
1116:        """Is this a function definition? (Also returns True for async defs.)"""
1117:        try:
1118:            first_leaf = self.leaves[0]
1119:        except IndexError:

Calling tool: grepTool
def comments_after\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1200:        # change a tuple into a different type by removing the comma.
1201:        depth = closing.bracket_depth + 1
1202:        commas = 0
1203:        opening = closing.opening_bracket
1204:        for _opening_index, leaf in enumerate(self.leaves):
1205:            if leaf is opening:
1206:                break
1207:
1208:        else:
1209:            return False
1210:
1211:        for leaf in self.leaves[_opening_index + 1 :]:
1212:            if leaf is closing:
1213:                break
1214:
1215:            bracket_depth = leaf.bracket_depth
1216:            if bracket_depth == depth and leaf.type == token.COMMA:
1217:                commas += 1
1218:                if leaf.parent and leaf.parent.type == syms.arglist:
1219:                    commas += 1
1220:                    break
1221:
1222:        if commas > 1:
1223:            self.remove_trailing_comma()
1224:            return True
1225:
1226:        return False
1227:
1228:    def append_comment(self, comment: Leaf) -> bool:
1229:        """Add an inline or standalone comment to the line."""
1230:        if (
1231:            comment.type == STANDALONE_COMMENT
1232:            and self.bracket_tracker.any_open_brackets()
1233:        ):
1234:            comment.prefix = ""
1235:            return False
1236:
1237:        if comment.type != token.COMMENT:
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling
1278:
1279:        if isinstance(subscript_start, Node):
1280:            if subscript_start.type == syms.listmaker:
1281:                return False
1282:
1283:            if subscript_start.type == syms.subscriptlist:
1284:                subscript_start = child_towards(subscript_start, leaf)
1285:        return subscript_start is not None and any(
1286:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
1287:        )
1288:
1289:    def __str__(self) -> str:
1290:        """Render the line."""
1291:        if not self:
1292:            return "\n"
1293:
1294:        indent = "    " * self.depth
1295:        leaves = iter(self.leaves)
1296:        first = next(leaves)
1297:        res = f"{first.prefix}{indent}{first.value}"
1298:        for leaf in leaves:
1299:            res += str(leaf)
1300:        for comment in itertools.chain.from_iterable(self.comments.values()):
1301:            res += str(comment)
1302:        return res + "\n"
1303:
1304:    def __bool__(self) -> bool:
1305:        """Return True if the line has leaves or comments."""
1306:        return bool(self.leaves or self.comments)
1307:
1308:
1309:@dataclass
1310:class EmptyLineTracker:
1311:    """Provides a stateful method that returns the number of potential extra
1312:    empty lines needed before and after the currently processed line.
1313:
1314:    Note: this tracker works on lines that haven't been split yet.  It assumes
1315:    the prefix of the first leaf consists of optional newlines.  Those newlines
1316:    are consumed by `maybe_empty_lines()` and included in the computation.
1317:    """
1318:
1319:    is_pyi: bool = False

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2205:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2206:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2207:    bracket_split_succeeded_or_raise(head, body, tail)

Calling tool: grepTool
STANDALONE_COMMENT\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2735:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2765:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2416:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2714:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2744:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3029:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: grepTool
test_comments6\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_comments6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments6

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
330:        black.assert_equivalent(source, actual)
331:        black.assert_stable(source, actual, line_length=ll)
332:
333:    @patch("black.dump_to_file", dump_to_stderr)
334:    def test_comments2(self) -> None:
335:        source, expected = read_data("comments2")
336:        actual = fs(source)
337:        self.assertFormatEqual(expected, actual)
338:        black.assert_equivalent(source, actual)
339:        black.assert_stable(source, actual, line_length=ll)
340:
341:    @patch("black.dump_to_file", dump_to_stderr)
342:    def test_comments3(self) -> None:
343:        source, expected = read_data("comments3")
344:        actual = fs(source)
345:        self.assertFormatEqual(expected, actual)
346:        black.assert_equivalent(source, actual)
347:        black.assert_stable(source, actual, line_length=ll)
348:
349:    @patch("black.dump_to_file", dump_to_stderr)
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)

Calling tool: grepTool
comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:367:        source, expected = read_data("comments6")

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1770:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1784:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1802:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1812:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1824:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1834:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1846:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py:235:    def read_data(file, endian, num=1):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/coverage/html.py:63:def read_data(fname):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager, redirect_stderr
5:from functools import partial, wraps
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import re
10:import sys
11:from tempfile import TemporaryDirectory
12:from typing import (
13:    Any,
14:    BinaryIO,
15:    Callable,
16:    Coroutine,
17:    Generator,
18:    List,
19:    Tuple,
20:    Iterator,
21:    TypeVar,
22:)
23:import unittest
24:from unittest.mock import patch, MagicMock
25:
26:from click import unstyle
27:from click.testing import CliRunner
28:
29:import black
30:
31:try:
32:    import blackd
33:    from aiohttp.test_utils import TestClient, TestServer
34:except ImportError:
35:    has_blackd_deps = False
36:else:
37:    has_blackd_deps = True
38:
39:
40:ll = 88
41:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
42:fs = partial(black.format_str, line_length=ll)
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:T = TypeVar("T")
47:R = TypeVar("R")
48:
49:
50:def dump_to_stderr(*output: str) -> str:
51:    return "\n" + "\n".join(output) + "\n"
52:
53:
54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
55:    """read_data('test_name') -> 'input', 'output'"""
56:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
57:        name += ".py"
58:    _input: List[str] = []
59:    _output: List[str] = []
60:    base_dir = THIS_DIR / "data" if data else THIS_DIR
61:    with open(base_dir / name, "r", encoding="utf8") as test:
62:        lines = test.readlines()
63:    result = _input
64:    for line in lines:
65:        line = line.replace(EMPTY_LINE, "")
66:        if line.rstrip() == "# output":
67:            result = _output
68:            continue
69:
70:        result.append(line)
71:    if _input and not _output:
72:        # If there's no output marker, treat the entire file as already pre-formatted.
73:        _output = _input[:]
74:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
75:
76:
77:@contextmanager
78:def cache_dir(exists: bool = True) -> Iterator[Path]:
79:    with TemporaryDirectory() as workspace:
80:        cache_dir = Path(workspace)
81:        if not exists:
82:            cache_dir = cache_dir / "new"
83:        with patch("black.CACHE_DIR", cache_dir):
84:            yield cache_dir
85:
86:
87:@contextmanager
88:def event_loop(close: bool) -> Iterator[None]:
89:    policy = asyncio.get_event_loop_policy()
90:    old_loop = policy.get_event_loop()
91:    loop = policy.new_event_loop()
92:    asyncio.set_event_loop(loop)
93:    try:
94:        yield
95:
96:    finally:
97:        policy.set_event_loop(old_loop)
98:        if close:
99:            loop.close()
100:
101:
102:def async_test(f: Callable[..., Coroutine[Any, None, R]]) -> Callable[..., None]:
103:    @event_loop(close=True)
104:    @wraps(f)
105:    def wrapper(*args: Any, **kwargs: Any) -> None:
106:        asyncio.get_event_loop().run_until_complete(f(*args, **kwargs))
107:
108:    return wrapper
109:
110:
111:class BlackRunner(CliRunner):
112:    """Modify CliRunner so that stderr is not merged with stdout.
113:
114:    This is a hack that can be removed once we depend on Click 7.x"""
115:
116:    def __init__(self) -> None:
117:        self.stderrbuf = BytesIO()
118:        self.stdoutbuf = BytesIO()
119:        self.stdout_bytes = b""
120:        self.stderr_bytes = b""

Calling tool: globTool
**/tests/data/comments6.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1960:        leaf.value == "if"
1961:        and leaf.parent
1962:        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
1963:    ):
1964:        return COMPREHENSION_PRIORITY
1965:
1966:    if leaf.value in {"if", "else"} and leaf.parent and leaf.parent.type == syms.test:
1967:        return TERNARY_PRIORITY
1968:
1969:    if leaf.value == "is":
1970:        return COMPARATOR_PRIORITY
1971:
1972:    if (
1973:        leaf.value == "in"
1974:        and leaf.parent
1975:        and leaf.parent.type in {syms.comp_op, syms.comparison}
1976:        and not (
1977:            previous is not None
1978:            and previous.type == token.NAME
1979:            and previous.value == "not"
1980:        )
1981:    ):
1982:        return COMPARATOR_PRIORITY
1983:
1984:    if (
1985:        leaf.value == "not"
1986:        and leaf.parent
1987:        and leaf.parent.type == syms.comp_op
1988:        and not (
1989:            previous is not None
1990:            and previous.type == token.NAME
1991:            and previous.value == "is"
1992:        )
1993:    ):
1994:        return COMPARATOR_PRIORITY
1995:
1996:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1997:        return LOGIC_PRIORITY
1998:
1999:    return 0
2000:
2001:
2002:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2003:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2004:
2005:
2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2007:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2008:
2009:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2010:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2011:    move because it does away with modifying the grammar to include all the
2012:    possible places in which comments can be placed.
2013:
2014:    The sad consequence for us though is that comments don't "belong" anywhere.
2015:    This is why this function generates simple parentless Leaf objects for
2016:    comments.  We simply don't know what the correct parent should be.
2017:
2018:    No matter though, we can live without this.  We really only need to
2019:    differentiate between inline and standalone comments.  The latter don't
2020:    share the line with any code.
2021:
2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
2024:    """
2025:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2026:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2027:
2028:
2029:@dataclass
2030:class ProtoComment:
2031:    """Describes a piece of syntax that is a comment.
2032:
2033:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2034:
2035:    * it can be cached (`Leaf` objects should not be reused more than once as
2036:      they store their lineno, column, prefix, and parent information);
2037:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2038:      simplifies handling of special marker comments like ``# fmt: off/on``.
2039:    """
2040:
2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
2042:    value: str  # content of the comment
2043:    newlines: int  # how many newlines before the comment
2044:    consumed: int  # how many characters of the original leaf's prefix did we consume
2045:
2046:
2047:@lru_cache(maxsize=4096)
2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2049:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2050:    result: List[ProtoComment] = []
2051:    if not prefix or "#" not in prefix:
2052:        return result
2053:
2054:    consumed = 0
2055:    nlines = 0
2056:    for index, line in enumerate(prefix.split("\n")):
2057:        consumed += len(line) + 1  # adding the length of the split '\n'
2058:        line = line.lstrip()
2059:        if not line:
2060:            nlines += 1
2061:        if not line.startswith("#"):
2062:            continue
2063:
2064:        if index == 0 and not is_endmarker:
2065:            comment_type = token.COMMENT  # simple trailing comment
2066:        else:
2067:            comment_type = STANDALONE_COMMENT
2068:        comment = make_comment(line)
2069:        result.append(
2070:            ProtoComment(
2071:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2072:            )
2073:        )
2074:        nlines = 0
2075:    return result
2076:
2077:
2078:def make_comment(content: str) -> str:
2079:    """Return a consistently formatted comment from the given `content` string.
2080:
2081:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2082:    space between the hash sign and the content.
2083:
2084:    If `content` didn't start with a hash sign, one is provided.
2085:    """
2086:    content = content.rstrip()
2087:    if not content:
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: split_line iterates line.leaves and uses line.comments_after(leaf) to fetch inline comments. Line.append_comment attaches inline comments to id(self.leaves[-1]) (last emitted leaf), and comments_after returns self.comments.get(id(leaf), []). Thus comments after commas are discoverable and the logic correctly detects special comments attached to commas.


Todo item 5 of 12 is correct
description: 'Ensure `split_line()` uses `line.comments_after(leaf)` correctly to retrieve inline comments and that `comments_after()` returns comments attached to the last emitted leaf (see `append_comment` logic). This ensures comments after a comma are discoverable.'
Validating todo item 6 of 12
description: 'Confirm that the new special comment handling does not interfere with lines that have only a standalone type comment for the return type (e.g., `# type: (...) -> None`) since `has_special_comment` only looks at inline comments after commas. The early return should still allow short single-line signatures without per-parameter comments to remain unchanged.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def is_special_comment\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_comments6", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def .*\\):\\s+# type: \\(\\.\\.\\.\\) -> None",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "# type: \\(\\.\\.\\.\\) -> None",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "is_special_comment\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2085:    """
2086:    content = content.rstrip()
2087:    if not content:
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)

Calling tool: grepTool
def is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.

Calling tool: grepTool
test_comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_comments6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments6

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)
410:        black.assert_equivalent(source, actual)
411:        black.assert_stable(source, actual, line_length=ll)
412:
413:    @patch("black.dump_to_file", dump_to_stderr)
414:    def test_numeric_literals(self) -> None:
415:        source, expected = read_data("numeric_literals")
416:        actual = fs(source, mode=black.FileMode.PYTHON36)
417:        self.assertFormatEqual(expected, actual)
418:        black.assert_equivalent(source, actual)
419:        black.assert_stable(source, actual, line_length=ll)
420:
421:    @patch("black.dump_to_file", dump_to_stderr)
422:    def test_numeric_literals_ignoring_underscores(self) -> None:
423:        source, expected = read_data("numeric_literals_skip_underscores")
424:        mode = (
425:            black.FileMode.PYTHON36 | black.FileMode.NO_NUMERIC_UNDERSCORE_NORMALIZATION
426:        )
427:        actual = fs(source, mode=mode)
428:        self.assertFormatEqual(expected, actual)
429:        black.assert_equivalent(source, actual)

Calling tool: globTool
**/data/comments6*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: grepTool
def .*\):\s+# type: \(\.\.\.\) -> None
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
# type: \(\.\.\.\) -> None
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py:27:    # type: (...) -> None
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py:37:    # type: (...) -> None
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py:47:    # type: (...) -> None
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_checker.py:178:    # type: (...) -> None
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_checker.py:184:            ('# type: int', '# type: str', '# type: (...) -> None'),

Calling tool: grepTool
is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2121:            if leaf.type == token.COMMA and is_special_comment(comment):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In split_line(), has_special_comment is set only when a special type comment appears after a comma (leaf.type == token.COMMA). A standalone return type comment after the closing parenthesis/colon is not after a comma, so has_special_comment remains False. Therefore, the early return condition still triggers for short single-line signatures without per-parameter comments, leaving them unchanged.


Todo item 6 of 12 is correct
description: 'Confirm that the new special comment handling does not interfere with lines that have only a standalone type comment for the return type (e.g., `# type: (...) -> None`) since `has_special_comment` only looks at inline comments after commas. The early return should still allow short single-line signatures without per-parameter comments to remain unchanged.'
Validating todo item 7 of 12
description: 'Verify that test fixture `tests/data/comments6.py` contains per-parameter inline type comments, `*args`/`**kwargs` with type comments, default-valued parameters with type comments, and nested structures (tuple items) with type comments, matching the PR intent.'
Calling tool: globTool
**/tests/data/comments6.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Reviewed tests/data/comments6.py and confirmed it includes per-parameter inline type comments for multiline functions, *args/**kwargs with type comments, a default-valued parameter with a type comment, and a tuple with per-item inline type comments plus an overall Tuple[...] type, aligning with the PR intent.


Todo item 7 of 12 is correct
description: 'Verify that test fixture `tests/data/comments6.py` contains per-parameter inline type comments, `*args`/`**kwargs` with type comments, default-valued parameters with type comments, and nested structures (tuple items) with type comments, matching the PR intent.'
Validating todo item 8 of 12
description: 'Check that `tests/data/comments6.py` has no `# output` marker so `read_data("comments6")` returns the input as expected output; thus the test asserts formatting is a no-op for these cases.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "comments6", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def read_data\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
Calling tool: grepTool
comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_bug.info:4:test_file="tests/data/comments6.py;tests/test_black.py"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_comments6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:367:        source, expected = read_data("comments6")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments6

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
340:
341:    @patch("black.dump_to_file", dump_to_stderr)
342:    def test_comments3(self) -> None:
343:        source, expected = read_data("comments3")
344:        actual = fs(source)
345:        self.assertFormatEqual(expected, actual)
346:        black.assert_equivalent(source, actual)
347:        black.assert_stable(source, actual, line_length=ll)
348:
349:    @patch("black.dump_to_file", dump_to_stderr)
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)
410:        black.assert_equivalent(source, actual)
411:        black.assert_stable(source, actual, line_length=ll)
412:
413:    @patch("black.dump_to_file", dump_to_stderr)
414:    def test_numeric_literals(self) -> None:
415:        source, expected = read_data("numeric_literals")
416:        actual = fs(source, mode=black.FileMode.PYTHON36)
417:        self.assertFormatEqual(expected, actual)
418:        black.assert_equivalent(source, actual)
419:        black.assert_stable(source, actual, line_length=ll)

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1770:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1784:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1802:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1812:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1824:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1834:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1846:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py:235:    def read_data(file, endian, num=1):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/coverage/html.py:63:def read_data(fname):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager, redirect_stderr
5:from functools import partial, wraps
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import re
10:import sys
11:from tempfile import TemporaryDirectory
12:from typing import (
13:    Any,
14:    BinaryIO,
15:    Callable,
16:    Coroutine,
17:    Generator,
18:    List,
19:    Tuple,
20:    Iterator,
21:    TypeVar,
22:)
23:import unittest
24:from unittest.mock import patch, MagicMock
25:
26:from click import unstyle
27:from click.testing import CliRunner
28:
29:import black
30:
31:try:
32:    import blackd
33:    from aiohttp.test_utils import TestClient, TestServer
34:except ImportError:
35:    has_blackd_deps = False
36:else:
37:    has_blackd_deps = True
38:
39:
40:ll = 88
41:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
42:fs = partial(black.format_str, line_length=ll)
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:T = TypeVar("T")
47:R = TypeVar("R")
48:
49:
50:def dump_to_stderr(*output: str) -> str:
51:    return "\n" + "\n".join(output) + "\n"
52:
53:
54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
55:    """read_data('test_name') -> 'input', 'output'"""
56:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
57:        name += ".py"
58:    _input: List[str] = []
59:    _output: List[str] = []
60:    base_dir = THIS_DIR / "data" if data else THIS_DIR
61:    with open(base_dir / name, "r", encoding="utf8") as test:
62:        lines = test.readlines()
63:    result = _input
64:    for line in lines:
65:        line = line.replace(EMPTY_LINE, "")
66:        if line.rstrip() == "# output":
67:            result = _output
68:            continue
69:
70:        result.append(line)
71:    if _input and not _output:
72:        # If there's no output marker, treat the entire file as already pre-formatted.
73:        _output = _input[:]
74:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
75:
76:
77:@contextmanager
78:def cache_dir(exists: bool = True) -> Iterator[Path]:
79:    with TemporaryDirectory() as workspace:
80:        cache_dir = Path(workspace)
81:        if not exists:
82:            cache_dir = cache_dir / "new"
83:        with patch("black.CACHE_DIR", cache_dir):
84:            yield cache_dir
85:
86:
87:@contextmanager
88:def event_loop(close: bool) -> Iterator[None]:
89:    policy = asyncio.get_event_loop_policy()
90:    old_loop = policy.get_event_loop()
91:    loop = policy.new_event_loop()
92:    asyncio.set_event_loop(loop)
93:    try:
94:        yield
95:
96:    finally:
97:        policy.set_event_loop(old_loop)
98:        if close:
99:            loop.close()
100:
101:
102:def async_test(f: Callable[..., Coroutine[Any, None, R]]) -> Callable[..., None]:
103:    @event_loop(close=True)
104:    @wraps(f)
105:    def wrapper(*args: Any, **kwargs: Any) -> None:
106:        asyncio.get_event_loop().run_until_complete(f(*args, **kwargs))
107:
108:    return wrapper
109:
110:
111:class BlackRunner(CliRunner):
112:    """Modify CliRunner so that stderr is not merged with stdout.
113:
114:    This is a hack that can be removed once we depend on Click 7.x"""
115:
116:    def __init__(self) -> None:
117:        self.stderrbuf = BytesIO()
118:        self.stdoutbuf = BytesIO()
119:        self.stdout_bytes = b""
120:        self.stderr_bytes = b""

Calling tool: globTool
**/tests/data/comments6.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: tests/data/comments6.py contains no # output marker. The read_data() helper treats such files as pre-formatted and returns the input as expected output, so test_comments6 asserts formatting is a no-op.


Todo item 8 of 12 is correct
description: 'Check that `tests/data/comments6.py` has no `# output` marker so `read_data("comments6")` returns the input as expected output; thus the test asserts formatting is a no-op for these cases.'
Validating todo item 9 of 12
description: 'Ensure `tests/test_black.py::BlackTestCase.test_comments6` loads `comments6` and asserts format equality (`self.assertFormatEqual(expected, actual)`), equivalence (`black.assert_equivalent`), and stability, tying the test to the PR requirement.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def test_comments6",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class BlackTestCase",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
Calling tool: grepTool
def test_comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
340:
341:    @patch("black.dump_to_file", dump_to_stderr)
342:    def test_comments3(self) -> None:
343:        source, expected = read_data("comments3")
344:        actual = fs(source)
345:        self.assertFormatEqual(expected, actual)
346:        black.assert_equivalent(source, actual)
347:        black.assert_stable(source, actual, line_length=ll)
348:
349:    @patch("black.dump_to_file", dump_to_stderr)
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)
410:        black.assert_equivalent(source, actual)
411:        black.assert_stable(source, actual, line_length=ll)
412:
413:    @patch("black.dump_to_file", dump_to_stderr)
414:    def test_numeric_literals(self) -> None:
415:        source, expected = read_data("numeric_literals")
416:        actual = fs(source, mode=black.FileMode.PYTHON36)
417:        self.assertFormatEqual(expected, actual)
418:        black.assert_equivalent(source, actual)
419:        black.assert_stable(source, actual, line_length=ll)

Calling tool: grepTool
class BlackTestCase
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:136:class BlackTestCase(unittest.TestCase):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/test_black.py:136:class BlackTestCase(unittest.TestCase):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
120:        self.stderr_bytes = b""
121:        super().__init__()
122:
123:    @contextmanager
124:    def isolation(self, *args: Any, **kwargs: Any) -> Generator[BinaryIO, None, None]:
125:        with super().isolation(*args, **kwargs) as output:
126:            try:
127:                hold_stderr = sys.stderr
128:                sys.stderr = TextIOWrapper(self.stderrbuf, encoding=self.charset)
129:                yield output
130:            finally:
131:                self.stdout_bytes = sys.stdout.buffer.getvalue()  # type: ignore
132:                self.stderr_bytes = sys.stderr.buffer.getvalue()  # type: ignore
133:                sys.stderr = hold_stderr
134:
135:
136:class BlackTestCase(unittest.TestCase):
137:    maxDiff = None
138:
139:    def assertFormatEqual(self, expected: str, actual: str) -> None:
140:        if actual != expected and not os.environ.get("SKIP_AST_PRINT"):
141:            bdv: black.DebugVisitor[Any]
142:            black.out("Expected tree:", fg="green")
143:            try:
144:                exp_node = black.lib2to3_parse(expected)
145:                bdv = black.DebugVisitor()
146:                list(bdv.visit(exp_node))
147:            except Exception as ve:
148:                black.err(str(ve))
149:            black.out("Actual tree:", fg="red")
150:            try:
151:                exp_node = black.lib2to3_parse(actual)
152:                bdv = black.DebugVisitor()
153:                list(bdv.visit(exp_node))
154:            except Exception as ve:
155:                black.err(str(ve))
156:        self.assertEqual(expected, actual)
157:
158:    @patch("black.dump_to_file", dump_to_stderr)
159:    def test_empty(self) -> None:
160:        source = expected = ""
161:        actual = fs(source)
162:        self.assertFormatEqual(expected, actual)
163:        black.assert_equivalent(source, actual)
164:        black.assert_stable(source, actual, line_length=ll)
165:
166:    def test_empty_ff(self) -> None:
167:        expected = ""
168:        tmp_file = Path(black.dump_to_file())
169:        try:
170:            self.assertFalse(ff(tmp_file, write_back=black.WriteBack.YES))
171:            with open(tmp_file, encoding="utf8") as f:
172:                actual = f.read()
173:        finally:
174:            os.unlink(tmp_file)
175:        self.assertFormatEqual(expected, actual)
176:
177:    @patch("black.dump_to_file", dump_to_stderr)
178:    def test_self(self) -> None:
179:        source, expected = read_data("test_black", data=False)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Found tests/test_black.py::BlackTestCase.test_comments6. It loads comments6 via read_data("comments6"), formats with fs(source), and asserts format equality, equivalence, and stability (assertFormatEqual, black.assert_equivalent, black.assert_stable).


Todo item 9 of 12 is correct
description: 'Ensure `tests/test_black.py::BlackTestCase.test_comments6` loads `comments6` and asserts format equality (`self.assertFormatEqual(expected, actual)`), equivalence (`black.assert_equivalent`), and stability, tying the test to the PR requirement.'
Validating todo item 10 of 12
description: 'Confirm there are no other code paths in `split_line()` that could later recombine function parameters into a single line when `has_special_comment` is True (i.e., after bypassing the early return, it proceeds into splitting strategies without concatenating into a flat one-liner).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def right_hand_split\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2205:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2206:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2207:    bracket_split_succeeded_or_raise(head, body, tail)

Calling tool: grepTool
def right_hand_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2202:def right_hand_split(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2213:def right_hand_split(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2208:    for result in (head, body, tail):
2209:        if result:
2210:            yield result
2211:
2212:
2213:def right_hand_split(
2214:    line: Line, line_length: int, py36: bool = False, omit: Collection[LeafID] = ()
2215:) -> Iterator[Line]:
2216:    """Split line into many lines, starting with the last matching bracket pair.
2217:
2218:    If the split was by optional parentheses, attempt splitting without them, too.
2219:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2220:    this split.
2221:
2222:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2223:    """
2224:    tail_leaves: List[Leaf] = []
2225:    body_leaves: List[Leaf] = []
2226:    head_leaves: List[Leaf] = []
2227:    current_leaves = tail_leaves
2228:    opening_bracket = None
2229:    closing_bracket = None
2230:    for leaf in reversed(line.leaves):
2231:        if current_leaves is body_leaves:
2232:            if leaf is opening_bracket:
2233:                current_leaves = head_leaves if body_leaves else tail_leaves
2234:        current_leaves.append(leaf)
2235:        if current_leaves is tail_leaves:
2236:            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:
2237:                opening_bracket = leaf.opening_bracket
2238:                closing_bracket = leaf
2239:                current_leaves = body_leaves
2240:    if not (opening_bracket and closing_bracket and head_leaves):
2241:        # If there is no opening or closing_bracket that means the split failed and
2242:        # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means
2243:        # the matching `opening_bracket` wasn't available on `line` anymore.
2244:        raise CannotSplit("No brackets found")
2245:
2246:    tail_leaves.reverse()
2247:    body_leaves.reverse()
2248:    head_leaves.reverse()
2249:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
2250:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
2251:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
2252:    bracket_split_succeeded_or_raise(head, body, tail)
2253:    if (
2254:        # the body shouldn't be exploded
2255:        not body.should_explode
2256:        # the opening bracket is an optional paren
2257:        and opening_bracket.type == token.LPAR
2258:        and not opening_bracket.value
2259:        # the closing bracket is an optional paren
2260:        and closing_bracket.type == token.RPAR
2261:        and not closing_bracket.value
2262:        # it's not an import (optional parens are the only thing we can split on
2263:        # in this case; attempting a split without them is a waste of time)
2264:        and not line.is_import
2265:        # there are no standalone comments in the body
2266:        and not body.contains_standalone_comments(0)
2267:        # and we can actually remove the parens
2268:        and can_omit_invisible_parens(body, line_length)
2269:    ):
2270:        omit = {id(closing_bracket), *omit}
2271:        try:
2272:            yield from right_hand_split(line, line_length, py36=py36, omit=omit)
2273:            return
2274:
2275:        except CannotSplit:
2276:            if not (
2277:                can_be_split(body)
2278:                or is_line_short_enough(body, line_length=line_length)
2279:            ):
2280:                raise CannotSplit(
2281:                    "Splitting failed, body is still too long and can't be split."
2282:                )
2283:
2284:            elif head.contains_multiline_strings() or tail.contains_multiline_strings():
2285:                raise CannotSplit(
2286:                    "The current optional pair of parentheses is bound to fail to "
2287:                    "satisfy the splitting algorithm because the head or the tail "
2288:                    "contains multiline strings which by definition never fit one "
2289:                    "line."
2290:                )
2291:
2292:    ensure_visible(opening_bracket)
2293:    ensure_visible(closing_bracket)
2294:    for result in (head, body, tail):
2295:        if result:
2296:            yield result
2297:
2298:
2299:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
2300:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
2301:
2302:    Do nothing otherwise.
2303:
2304:    A left- or right-hand split is based on a pair of brackets. Content before
2305:    (and including) the opening bracket is left on one line, content inside the
2306:    brackets is put on a separate line, and finally content starting with and
2307:    following the closing bracket is put on a separate line.
2308:
2309:    Those are called `head`, `body`, and `tail`, respectively. If the split
2310:    produced the same line (all content in `head`) or ended up with an empty `body`
2311:    and the `tail` is just the closing bracket, then it's considered failed.
2312:    """
2313:    tail_len = len(str(tail).strip())
2314:    if not body:
2315:        if tail_len == 0:
2316:            raise CannotSplit("Splitting brackets produced the same line")
2317:
2318:        elif tail_len < 3:
2319:            raise CannotSplit(
2320:                f"Splitting brackets on an empty body to save "
2321:                f"{tail_len} characters is not worth it"
2322:            )
2323:
2324:
2325:def bracket_split_build_line(
2326:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2327:) -> Line:
2328:    """Return a new line with given `leaves` and respective comments from `original`.
2329:
2330:    If `is_body` is True, the result line is one-indented inside brackets and as such
2331:    has its first leaf's prefix normalized and a trailing comma added when expected.
2332:    """
2333:    result = Line(depth=original.depth)
2334:    if is_body:
2335:        result.inside_brackets = True
2336:        result.depth += 1
2337:        if leaves:
2338:            # Since body is a new indent level, remove spurious leading whitespace.
2339:            normalize_prefix(leaves[0], inside_brackets=True)
2340:            # Ensure a trailing comma when expected.
2341:            if original.is_import:
2342:                if leaves[-1].type != token.COMMA:
2343:                    leaves.append(Leaf(token.COMMA, ","))
2344:    # Populate the line
2345:    for leaf in leaves:
2346:        result.append(leaf, preformatted=True)
2347:        for comment_after in original.comments_after(leaf):
2348:            result.append(comment_after, preformatted=True)
2349:    if is_body:
2350:        result.should_explode = should_explode(result, opening_bracket)
2351:    return result
2352:
2353:
2354:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2355:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2356:
2357:    This is a decorator over relevant split functions.
2358:    """
2359:
2360:    @wraps(split_func)
2361:    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:
2362:        for l in split_func(line, py36):
2363:            normalize_prefix(l.leaves[0], inside_brackets=True)
2364:            yield l
2365:
2366:    return split_wrapper
2367:
2368:
2369:@dont_increase_indentation
2370:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:
2371:    """Split according to delimiters of the highest priority.
2372:
2373:    If `py36` is True, the split will add trailing commas also in function
2374:    signatures that contain `*` and `**`.
2375:    """
2376:    try:
2377:        last_leaf = line.leaves[-1]
2378:    except IndexError:
2379:        raise CannotSplit("Line empty")
2380:
2381:    bt = line.bracket_tracker
2382:    try:
2383:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2384:    except ValueError:
2385:        raise CannotSplit("No delimiters found")
2386:
2387:    if delimiter_priority == DOT_PRIORITY:
2388:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2389:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2390:
2391:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2392:    lowest_depth = sys.maxsize
2393:    trailing_comma_safe = True
2394:
2395:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2396:        """Append `leaf` to current line or to new line if appending impossible."""
2397:        nonlocal current_line
2398:        try:
2399:            current_line.append_safe(leaf, preformatted=True)
2400:        except ValueError:
2401:            yield current_line
2402:
2403:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2404:            current_line.append(leaf)
2405:
2406:    for leaf in line.leaves:
2407:        yield from append_to_line(leaf)
2408:
2409:        for comment_after in line.comments_after(leaf):
2410:            yield from append_to_line(comment_after)
2411:
2412:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2413:        if leaf.bracket_depth == lowest_depth and is_vararg(
2414:            leaf, within=VARARGS_PARENTS
2415:        ):
2416:            trailing_comma_safe = trailing_comma_safe and py36
2417:        leaf_priority = bt.delimiters.get(id(leaf))
2418:        if leaf_priority == delimiter_priority:
2419:            yield current_line
2420:
2421:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2422:    if current_line:
2423:        if (
2424:            trailing_comma_safe
2425:            and delimiter_priority == COMMA_PRIORITY
2426:            and current_line.leaves[-1].type != token.COMMA
2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2428:        ):
2429:            current_line.append(Leaf(token.COMMA, ","))
2430:        yield current_line
2431:
2432:
2433:@dont_increase_indentation
2434:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
2435:    """Split standalone comments from the rest of the line."""
2436:    if not line.contains_standalone_comments(0):
2437:        raise CannotSplit("Line does not have any standalone comments")
2438:
2439:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2440:
2441:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2442:        """Append `leaf` to current line or to new line if appending impossible."""
2443:        nonlocal current_line
2444:        try:
2445:            current_line.append_safe(leaf, preformatted=True)
2446:        except ValueError:
2447:            yield current_line
2448:
2449:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2450:            current_line.append(leaf)
2451:
2452:    for leaf in line.leaves:
2453:        yield from append_to_line(leaf)
2454:
2455:        for comment_after in line.comments_after(leaf):
2456:            yield from append_to_line(comment_after)
2457:
2458:    if current_line:
2459:        yield current_line
2460:
2461:
2462:def is_import(leaf: Leaf) -> bool:
2463:    """Return True if the given leaf starts an import statement."""
2464:    p = leaf.parent
2465:    t = leaf.type
2466:    v = leaf.value
2467:    return bool(
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.
2508:
2509:    Note: Mutates its argument.
2510:    """
2511:    match = re.match(r"^([furbFURB]*)(.*)$", leaf.value, re.DOTALL)
2512:    assert match is not None, f"failed to match string {leaf.value!r}"
2513:    orig_prefix = match.group(1)
2514:    new_prefix = orig_prefix.lower()
2515:    if remove_u_prefix:
2516:        new_prefix = new_prefix.replace("u", "")
2517:    leaf.value = f"{new_prefix}{match.group(2)}"
2518:
2519:
2520:def normalize_string_quotes(leaf: Leaf) -> None:
2521:    """Prefer double quotes but only if it doesn't cause more escaping.
2522:
2523:    Adds or removes backslashes as appropriate. Doesn't parse and fix
2524:    strings nested in f-strings (yet).
2525:
2526:    Note: Mutates its argument.
2527:    """
2528:    value = leaf.value.lstrip("furbFURB")
2529:    if value[:3] == '"""':
2530:        return
2531:
2532:    elif value[:3] == "'''":
2533:        orig_quote = "'''"
2534:        new_quote = '"""'
2535:    elif value[0] == '"':
2536:        orig_quote = '"'
2537:        new_quote = "'"
2538:    else:
2539:        orig_quote = "'"
2540:        new_quote = '"'
2541:    first_quote_pos = leaf.value.find(orig_quote)
2542:    if first_quote_pos == -1:
2543:        return  # There's an internal error
2544:
2545:    prefix = leaf.value[:first_quote_pos]
2546:    unescaped_new_quote = re.compile(rf"(([^\\]|^)(\\\\)*){new_quote}")
2547:    escaped_new_quote = re.compile(rf"([^\\]|^)\\((?:\\\\)*){new_quote}")
2548:    escaped_orig_quote = re.compile(rf"([^\\]|^)\\((?:\\\\)*){orig_quote}")
2549:    body = leaf.value[first_quote_pos + len(orig_quote) : -len(orig_quote)]
2550:    if "r" in prefix.casefold():
2551:        if unescaped_new_quote.search(body):
2552:            # There's at least one unescaped new_quote in this raw string
2553:            # so converting is impossible
2554:            return
2555:
2556:        # Do not introduce or remove backslashes in raw strings
2557:        new_body = body
2558:    else:
2559:        # remove unnecessary escapes
2560:        new_body = sub_twice(escaped_new_quote, rf"\1\2{new_quote}", body)
2561:        if body != new_body:
2562:            # Consider the string without unnecessary escapes as the original
2563:            body = new_body
2564:            leaf.value = f"{prefix}{orig_quote}{body}{orig_quote}"
2565:        new_body = sub_twice(escaped_orig_quote, rf"\1\2{orig_quote}", new_body)
2566:        new_body = sub_twice(unescaped_new_quote, rf"\1\\{new_quote}", new_body)
2567:    if "f" in prefix.casefold():
2568:        matches = re.findall(r"[^{]\{(.*?)\}[^}]", new_body)
2569:        for m in matches:
2570:            if "\\" in str(m):
2571:                # Do not introduce backslashes in interpolated expressions
2572:                return
2573:    if new_quote == '"""' and new_body[-1:] == '"':
2574:        # edge case:
2575:        new_body = new_body[:-1] + '\\"'
2576:    orig_escape_count = body.count("\\")
2577:    new_escape_count = new_body.count("\\")
2578:    if new_escape_count > orig_escape_count:
2579:        return  # Do not introduce more escaping
2580:
2581:    if new_escape_count == orig_escape_count and orig_quote == '"':
2582:        return  # Prefer double quotes
2583:
2584:    leaf.value = f"{prefix}{new_quote}{new_body}{new_quote}"
2585:
2586:
2587:def normalize_numeric_literal(leaf: Leaf, allow_underscores: bool) -> None:
2588:    """Normalizes numeric (float, int, and complex) literals.
2589:
2590:    All letters used in the representation are normalized to lowercase (except
2591:    in Python 2 long literals), and long number literals are split using underscores.
2592:    """
2593:    text = leaf.value.lower()
2594:    if text.startswith(("0o", "0b")):
2595:        # Leave octal and binary literals alone.
2596:        pass
2597:    elif text.startswith("0x"):
2598:        # Change hex literals to upper case.
2599:        before, after = text[:2], text[2:]
2600:        text = f"{before}{after.upper()}"
2601:    elif "e" in text:
2602:        before, after = text.split("e")
2603:        sign = ""
2604:        if after.startswith("-"):
2605:            after = after[1:]
2606:            sign = "-"
2607:        elif after.startswith("+"):
2608:            after = after[1:]
2609:        before = format_float_or_int_string(before, allow_underscores)
2610:        after = format_int_string(after, allow_underscores)
2611:        text = f"{before}e{sign}{after}"
2612:    elif text.endswith(("j", "l")):
2613:        number = text[:-1]
2614:        suffix = text[-1]
2615:        # Capitalize in "2L" because "l" looks too similar to "1".
2616:        if suffix == "l":
2617:            suffix = "L"
2618:        text = f"{format_float_or_int_string(number, allow_underscores)}{suffix}"
2619:    else:
2620:        text = format_float_or_int_string(text, allow_underscores)
2621:    leaf.value = text
2622:
2623:
2624:def format_float_or_int_string(text: str, allow_underscores: bool) -> str:
2625:    """Formats a float string like "1.0"."""
2626:    if "." not in text:
2627:        return format_int_string(text, allow_underscores)
2628:
2629:    before, after = text.split(".")
2630:    before = format_int_string(before, allow_underscores) if before else "0"
2631:    if after:
2632:        after = format_int_string(after, allow_underscores, count_from_end=False)
2633:    else:
2634:        after = "0"
2635:    return f"{before}.{after}"
2636:
2637:
2638:def format_int_string(
2639:    text: str, allow_underscores: bool, count_from_end: bool = True
2640:) -> str:
2641:    """Normalizes underscores in a string to e.g. 1_000_000.
2642:
2643:    Input must be a string of digits and optional underscores.
2644:    If count_from_end is False, we add underscores after groups of three digits
2645:    counting from the beginning instead of the end of the strings. This is used
2646:    for the fractional part of float literals.
2647:    """

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Reviewed split_line: when has_special_comment is True, the early single-line return is skipped. The remaining paths invoke left_hand_split (for defs) or delimiter/standalone/RHS splits. These functions yield multiple lines and never recombine into a flat one-liner; the only single-line yields are the guarded early return and a final fallback, which wont trigger for function defs with parentheses.


Todo item 10 of 12 is correct
description: 'Confirm there are no other code paths in `split_line()` that could later recombine function parameters into a single line when `has_special_comment` is True (i.e., after bypassing the early return, it proceeds into splitting strategies without concatenating into a flat one-liner).'
Validating todo item 11 of 12
description: 'Verify that the added helper `is_special_comment` is referenced only where intended (currently within `split_line`) and does not alter unrelated formatting behavior.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "is_special_comment\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
Calling tool: grepTool
is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2121:            if leaf.type == token.COMMA and is_special_comment(comment):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2205:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2206:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2207:    bracket_split_succeeded_or_raise(head, body, tail)
2208:    for result in (head, body, tail):
2209:        if result:
2210:            yield result
2211:
2212:
2213:def right_hand_split(
2214:    line: Line, line_length: int, py36: bool = False, omit: Collection[LeafID] = ()
2215:) -> Iterator[Line]:
2216:    """Split line into many lines, starting with the last matching bracket pair.
2217:
2218:    If the split was by optional parentheses, attempt splitting without them, too.
2219:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2220:    this split.
2221:
2222:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2223:    """
2224:    tail_leaves: List[Leaf] = []
2225:    body_leaves: List[Leaf] = []
2226:    head_leaves: List[Leaf] = []
2227:    current_leaves = tail_leaves
2228:    opening_bracket = None
2229:    closing_bracket = None
2230:    for leaf in reversed(line.leaves):
2231:        if current_leaves is body_leaves:
2232:            if leaf is opening_bracket:
2233:                current_leaves = head_leaves if body_leaves else tail_leaves
2234:        current_leaves.append(leaf)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Searched for is_special_comment usage and found only two occurrences: its definition and a single call inside split_line. Reviewed the modified split_line code block and confirmed the new logic only gatekeeps the early-return path when a special # type: comment follows a comma, leaving other formatting paths unchanged. No other parts of the code reference the helper, so unrelated behavior is unaffected.


Todo item 11 of 12 is correct
description: 'Verify that the added helper `is_special_comment` is referenced only where intended (currently within `split_line`) and does not alter unrelated formatting behavior.'
Validating todo item 12 of 12
description: 'Double-check imports/constants used by the change (e.g., `token`, `Leaf`, `Line`) are available in scope and the type hints are consistent with the rest of the module.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "(?i)^import token|from\\s+token\\s+import|token\\.",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/{{FOLDER_PATH}}"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "(?i)^import token|from\\s+token\\s+import|\\btoken\\.",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "\\bSTANDALONE_COMMENT\\b",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class\\s+Line\\b", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def\\s+comments_after\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def\\s+is_line_short_enough\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "\\btoken\\.COMMENT\\b",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black"
]
Calling tool: grepTool
(?i)^import token|from\s+token\s+import|token\.
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
(?i)^import token|from\s+token\s+import|\btoken\.
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pytree.py:26:        # from .pgen2 import token // token.__dict__.items():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/Grammar.txt:132:# "test '=' test" is really "keyword '=' test", but we have no such token.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pgen2/tokenize.py:11:    the token type (see token.py)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pgen2/tokenize.py:472:                    assert not token.endswith("\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:18:import tokenize
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:732:            name = token.tok_name[node.type]
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:760:            _type = token.tok_name.get(node.type, str(node.type))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:781:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:797:    token.LESS,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:798:    token.GREATER,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:799:    token.EQEQUAL,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:800:    token.NOTEQUAL,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:801:    token.LESSEQUAL,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:802:    token.GREATEREQUAL,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:805:    token.VBAR,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:806:    token.CIRCUMFLEX,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:807:    token.AMPER,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:808:    token.LEFTSHIFT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:809:    token.RIGHTSHIFT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:810:    token.PLUS,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:811:    token.MINUS,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:812:    token.STAR,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:813:    token.SLASH,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:814:    token.DOUBLESLASH,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:815:    token.PERCENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:816:    token.AT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:817:    token.TILDE,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:818:    token.DOUBLESTAR,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:820:STARS = {token.STAR, token.DOUBLESTAR}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:875:    token.VBAR: 9,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:876:    token.CIRCUMFLEX: 8,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:877:    token.AMPER: 7,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:878:    token.LEFTSHIFT: 6,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:879:    token.RIGHTSHIFT: 6,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:880:    token.PLUS: 5,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:881:    token.MINUS: 5,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:882:    token.STAR: 4,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:883:    token.SLASH: 4,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:884:    token.DOUBLESLASH: 4,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:885:    token.PERCENT: 4,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:886:    token.AT: 4,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:887:    token.TILDE: 3,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:888:    token.DOUBLESTAR: 2,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:919:        if leaf.type == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:973:        if leaf.type == token.NAME and leaf.value == "for":
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:985:            and leaf.type == token.NAME
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1000:        if leaf.type == token.NAME and leaf.value == "lambda":
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1012:            and leaf.type == token.COLON
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1022:        return self.bracket_match.get((self.depth - 1, token.RSQB))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import itertools
9:import keyword
10:import logging
11:from multiprocessing import Manager, freeze_support
12:import os
13:from pathlib import Path
14:import pickle
15:import re
16:import signal
17:import sys
18:import tokenize
19:from typing import (
20:    Any,
21:    Callable,
22:    Collection,
23:    Dict,
24:    Generator,
25:    Generic,
26:    Iterable,
27:    Iterator,
28:    List,
29:    Optional,
30:    Pattern,
31:    Sequence,
32:    Set,
33:    Tuple,
34:    TypeVar,
35:    Union,
36:    cast,
37:)
38:
39:from appdirs import user_cache_dir
40:from attr import dataclass, Factory
41:import click
42:import toml
43:
44:# lib2to3 fork
45:from blib2to3.pytree import Node, Leaf, type_repr
46:from blib2to3 import pygram, pytree
47:from blib2to3.pgen2 import driver, token
48:from blib2to3.pgen2.parse import ParseError
49:
50:
51:__version__ = "18.9b0"
52:DEFAULT_LINE_LENGTH = 88
53:DEFAULT_EXCLUDES = (
54:    r"/(\.eggs|\.git|\.hg|\.mypy_cache|\.nox|\.tox|\.venv|_build|buck-out|build|dist)/"
55:)
56:DEFAULT_INCLUDES = r"\.pyi?$"
57:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
58:
59:
60:# types
61:FileContent = str
62:Encoding = str
63:NewLine = str
64:Depth = int
65:NodeType = int
66:LeafID = int
67:Priority = int
68:Index = int
69:LN = Union[Leaf, Node]
70:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
71:Timestamp = float
72:FileSize = int
73:CacheInfo = Tuple[Timestamp, FileSize]
74:Cache = Dict[Path, CacheInfo]
75:out = partial(click.secho, bold=True, err=True)
76:err = partial(click.secho, fg="red", err=True)
77:
78:pygram.initialize(CACHE_DIR)
79:syms = pygram.python_symbols
80:
81:
82:class NothingChanged(UserWarning):
83:    """Raised when reformatted code is the same as source."""
84:
85:
86:class CannotSplit(Exception):
87:    """A readable split that fits the allotted line length is impossible."""
88:
89:
90:class InvalidInput(ValueError):
91:    """Raised when input source code fails all parse attempts."""
92:
93:
94:class WriteBack(Enum):
95:    NO = 0
96:    YES = 1
97:    DIFF = 2
98:    CHECK = 3
99:
100:    @classmethod
101:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
102:        if check and not diff:
103:            return cls.CHECK
104:
105:        return cls.DIFF if diff else cls.YES
106:
107:
108:class Changed(Enum):
109:    NO = 0
110:    CACHED = 1
111:    YES = 2
112:
113:
114:class FileMode(Flag):
115:    AUTO_DETECT = 0
116:    PYTHON36 = 1
117:    PYI = 2
118:    NO_STRING_NORMALIZATION = 4
119:    NO_NUMERIC_UNDERSCORE_NORMALIZATION = 8
120:

Calling tool: grepTool
\bSTANDALONE_COMMENT\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2735:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2765:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2416:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2714:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2744:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3029:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2380:
2381:    bt = line.bracket_tracker
2382:    try:
2383:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2384:    except ValueError:
2385:        raise CannotSplit("No delimiters found")
2386:
2387:    if delimiter_priority == DOT_PRIORITY:
2388:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2389:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2390:
2391:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2392:    lowest_depth = sys.maxsize
2393:    trailing_comma_safe = True
2394:
2395:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2396:        """Append `leaf` to current line or to new line if appending impossible."""
2397:        nonlocal current_line
2398:        try:
2399:            current_line.append_safe(leaf, preformatted=True)
2400:        except ValueError:
2401:            yield current_line
2402:
2403:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2404:            current_line.append(leaf)
2405:
2406:    for leaf in line.leaves:
2407:        yield from append_to_line(leaf)
2408:
2409:        for comment_after in line.comments_after(leaf):
2410:            yield from append_to_line(comment_after)
2411:
2412:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2413:        if leaf.bracket_depth == lowest_depth and is_vararg(
2414:            leaf, within=VARARGS_PARENTS
2415:        ):
2416:            trailing_comma_safe = trailing_comma_safe and py36
2417:        leaf_priority = bt.delimiters.get(id(leaf))
2418:        if leaf_priority == delimiter_priority:
2419:            yield current_line
2420:
2421:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2422:    if current_line:
2423:        if (
2424:            trailing_comma_safe
2425:            and delimiter_priority == COMMA_PRIORITY
2426:            and current_line.leaves[-1].type != token.COMMA
2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
2428:        ):
2429:            current_line.append(Leaf(token.COMMA, ","))
2430:        yield current_line
2431:
2432:
2433:@dont_increase_indentation
2434:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
2435:    """Split standalone comments from the rest of the line."""
2436:    if not line.contains_standalone_comments(0):
2437:        raise CannotSplit("Line does not have any standalone comments")
2438:
2439:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2440:
2441:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2442:        """Append `leaf` to current line or to new line if appending impossible."""
2443:        nonlocal current_line
2444:        try:
2445:            current_line.append_safe(leaf, preformatted=True)
2446:        except ValueError:
2447:            yield current_line
2448:
2449:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2450:            current_line.append(leaf)
2451:
2452:    for leaf in line.leaves:
2453:        yield from append_to_line(leaf)
2454:
2455:        for comment_after in line.comments_after(leaf):
2456:            yield from append_to_line(comment_after)
2457:
2458:    if current_line:
2459:        yield current_line
2460:
2461:
2462:def is_import(leaf: Leaf) -> bool:
2463:    """Return True if the given leaf starts an import statement."""
2464:    p = leaf.parent
2465:    t = leaf.type
2466:    v = leaf.value
2467:    return bool(
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.
2508:
2509:    Note: Mutates its argument.
2510:    """
2511:    match = re.match(r"^([furbFURB]*)(.*)$", leaf.value, re.DOTALL)
2512:    assert match is not None, f"failed to match string {leaf.value!r}"
2513:    orig_prefix = match.group(1)
2514:    new_prefix = orig_prefix.lower()
2515:    if remove_u_prefix:
2516:        new_prefix = new_prefix.replace("u", "")
2517:    leaf.value = f"{new_prefix}{match.group(2)}"
2518:
2519:
2520:def normalize_string_quotes(leaf: Leaf) -> None:
2521:    """Prefer double quotes but only if it doesn't cause more escaping.
2522:
2523:    Adds or removes backslashes as appropriate. Doesn't parse and fix
2524:    strings nested in f-strings (yet).
2525:
2526:    Note: Mutates its argument.
2527:    """
2528:    value = leaf.value.lstrip("furbFURB")
2529:    if value[:3] == '"""':
2530:        return
2531:
2532:    elif value[:3] == "'''":
2533:        orig_quote = "'''"
2534:        new_quote = '"""'
2535:    elif value[0] == '"':
2536:        orig_quote = '"'
2537:        new_quote = "'"
2538:    else:
2539:        orig_quote = "'"

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:

Calling tool: grepTool
class\s+Line\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1026:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1026:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/docutils/parsers/rst/states.py:2913:class Line(SpecializedText):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/tabulate.pyi:8:class Line(NamedTuple):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/werkzeug/debug/tbtools.pyi:16:class Line:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1010:            self._lambda_argument_depths
1011:            and self._lambda_argument_depths[-1] == self.depth
1012:            and leaf.type == token.COLON
1013:        ):
1014:            self.depth -= 1
1015:            self._lambda_argument_depths.pop()
1016:            return True
1017:
1018:        return False
1019:
1020:    def get_open_lsqb(self) -> Optional[Leaf]:
1021:        """Return the most recent opening square bracket (if any)."""
1022:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1023:
1024:
1025:@dataclass
1026:class Line:
1027:    """Holds leaves and comments. Can be printed with `str(line)`."""
1028:
1029:    depth: int = 0
1030:    leaves: List[Leaf] = Factory(list)
1031:    # The LeafID keys of comments must remain ordered by the corresponding leaf's index
1032:    # in leaves
1033:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)
1034:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1035:    inside_brackets: bool = False
1036:    should_explode: bool = False
1037:
1038:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1039:        """Add a new `leaf` to the end of the line.
1040:
1041:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1042:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1043:        Trailing commas are maybe removed, unpacked for loop variables are
1044:        demoted from being delimiters.
1045:
1046:        Inline comments are put aside.
1047:        """
1048:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1049:        if not has_value:
1050:            return
1051:
1052:        if token.COLON == leaf.type and self.is_class_paren_empty:
1053:            del self.leaves[-2:]
1054:        if self.leaves and not preformatted:
1055:            # Note: at this point leaf.prefix should be empty except for
1056:            # imports, for which we only preserve newlines.
1057:            leaf.prefix += whitespace(
1058:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1059:            )
1060:        if self.inside_brackets or not preformatted:
1061:            self.bracket_tracker.mark(leaf)
1062:            self.maybe_remove_trailing_comma(leaf)
1063:        if not self.append_comment(leaf):
1064:            self.leaves.append(leaf)
1065:
1066:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1067:        """Like :func:`append()` but disallow invalid standalone comment structure.
1068:
1069:        Raises ValueError when any `leaf` is appended after a standalone comment
1070:        or when a standalone comment is not the first leaf on the line.
1071:        """
1072:        if self.bracket_tracker.depth == 0:
1073:            if self.is_comment:
1074:                raise ValueError("cannot append to standalone comments")
1075:
1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1077:                raise ValueError(
1078:                    "cannot append standalone comments to a populated line"
1079:                )
1080:
1081:        self.append(leaf, preformatted=preformatted)
1082:
1083:    @property
1084:    def is_comment(self) -> bool:
1085:        """Is this line a standalone comment?"""
1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1087:
1088:    @property
1089:    def is_decorator(self) -> bool:
1090:        """Is this line a decorator?"""
1091:        return bool(self) and self.leaves[0].type == token.AT
1092:
1093:    @property
1094:    def is_import(self) -> bool:
1095:        """Is this an import line?"""
1096:        return bool(self) and is_import(self.leaves[0])
1097:
1098:    @property
1099:    def is_class(self) -> bool:
1100:        """Is this line a class definition?"""
1101:        return (
1102:            bool(self)
1103:            and self.leaves[0].type == token.NAME
1104:            and self.leaves[0].value == "class"
1105:        )
1106:
1107:    @property
1108:    def is_stub_class(self) -> bool:
1109:        """Is this line a class definition with a body consisting only of "..."?"""
1110:        return self.is_class and self.leaves[-3:] == [
1111:            Leaf(token.DOT, ".") for _ in range(3)
1112:        ]
1113:
1114:    @property
1115:    def is_def(self) -> bool:
1116:        """Is this a function definition? (Also returns True for async defs.)"""
1117:        try:
1118:            first_leaf = self.leaves[0]
1119:        except IndexError:
1120:            return False
1121:
1122:        try:
1123:            second_leaf: Optional[Leaf] = self.leaves[1]
1124:        except IndexError:
1125:            second_leaf = None
1126:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1127:            first_leaf.type == token.ASYNC
1128:            and second_leaf is not None
1129:            and second_leaf.type == token.NAME

Calling tool: grepTool
def\s+comments_after\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling

Calling tool: grepTool
def\s+is_line_short_enough\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3464:def is_line_short_enough(line: Line, *, line_length: int, line_str: str = "") -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3442:def is_line_short_enough(line: Line, *, line_length: int, line_str: str = "") -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
3450:        enumerate_reversed if reversed else enumerate,
3451:    )
3452:    for index, leaf in op(line.leaves):
3453:        length = len(leaf.prefix) + len(leaf.value)
3454:        if "\n" in leaf.value:
3455:            return  # Multiline strings, we can't continue.
3456:
3457:        comment: Optional[Leaf]
3458:        for comment in line.comments_after(leaf):
3459:            length += len(comment.value)
3460:
3461:        yield index, leaf, length
3462:
3463:
3464:def is_line_short_enough(line: Line, *, line_length: int, line_str: str = "") -> bool:
3465:    """Return True if `line` is no longer than `line_length`.
3466:
3467:    Uses the provided `line_str` rendering, if any, otherwise computes a new one.
3468:    """
3469:    if not line_str:
3470:        line_str = str(line).strip("\n")
3471:    return (
3472:        len(line_str) <= line_length
3473:        and "\n" not in line_str  # multiline strings
3474:        and not line.contains_standalone_comments()
3475:    )
3476:
3477:
3478:def can_be_split(line: Line) -> bool:
3479:    """Return False if the line cannot be split *for sure*.
3480:
3481:    This is not an exhaustive search but a cheap heuristic that we can use to
3482:    avoid some unfortunate formattings (mostly around wrapping unsplittable code
3483:    in unnecessary parentheses).
3484:    """
3485:    leaves = line.leaves
3486:    if len(leaves) < 2:
3487:        return False
3488:
3489:    if leaves[0].type == token.STRING and leaves[1].type == token.DOT:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
776:            code = lib2to3_parse(code)
777:        list(v.visit(code))
778:
779:
780:KEYWORDS = set(keyword.kwlist)
781:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
782:FLOW_CONTROL = {"return", "raise", "break", "continue"}
783:STATEMENT = {
784:    syms.if_stmt,
785:    syms.while_stmt,
786:    syms.for_stmt,
787:    syms.try_stmt,
788:    syms.except_clause,
789:    syms.with_stmt,
790:    syms.funcdef,
791:    syms.classdef,
792:}
793:STANDALONE_COMMENT = 153
794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
795:LOGIC_OPERATORS = {"and", "or"}
796:COMPARATORS = {
797:    token.LESS,
798:    token.GREATER,
799:    token.EQEQUAL,
800:    token.NOTEQUAL,
801:    token.LESSEQUAL,
802:    token.GREATEREQUAL,
803:}
804:MATH_OPERATORS = {
805:    token.VBAR,
806:    token.CIRCUMFLEX,
807:    token.AMPER,
808:    token.LEFTSHIFT,
809:    token.RIGHTSHIFT,
810:    token.PLUS,
811:    token.MINUS,
812:    token.STAR,
813:    token.SLASH,
814:    token.DOUBLESLASH,
815:    token.PERCENT,

Calling tool: grepTool
\btoken\.COMMENT\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:919:        if leaf.type == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1237:        if comment.type != token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1458:                elif comment.type == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1626:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2065:            comment_type = token.COMMENT  # simple trailing comment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/empty_lines.py:16:    if t == token.COMMENT:  # another trailing comment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/empty_lines.py:69:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/empty_lines.py:113:    if t == token.COMMENT:  # another trailing comment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/empty_lines.py:164:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/data/empty_lines.py:16:    if t == token.COMMENT:  # another trailing comment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/data/empty_lines.py:69:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/data/empty_lines.py:113:    if t == token.COMMENT:  # another trailing comment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/data/empty_lines.py:164:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:919:        if leaf.type == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1237:        if comment.type != token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1458:                elif comment.type == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1626:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2065:            comment_type = token.COMMENT  # simple trailing comment

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified in black/black.py: token is imported from blib2to3.pgen2 (line 47), Leaf is imported (line 45), Line class is defined (line 1026) before usage in split_line signature (line 2097). STANDALONE_COMMENT is defined (line 793). The new is_special_comment(leaf: Leaf) -> bool (line 2476) matches module typing style (same as is_import). All identifiers are in scope and consistent.


Todo item 12 of 12 is correct
description: 'Double-check imports/constants used by the change (e.g., `token`, `Leaf`, `Line`) are available in scope and the type hints are consistent with the rest of the module.'
Validating todo item 1 of 12
description: 'Verify that `split_line()` now guards the short-line early return with a check for special comments: it computes `has_special_comment` by scanning `line.leaves` and `line.comments_after(leaf)`, and only returns early if `not has_special_comment and not line.should_explode and is_line_short_enough(...)`.'

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2205:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2206:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2207:    bracket_split_succeeded_or_raise(head, body, tail)
2208:    for result in (head, body, tail):
2209:        if result:

Calling tool: grepTool
def is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.

Calling tool: grepTool
test_comments6\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2735:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2765:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2416:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2714:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2744:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3029:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, split_line() now computes has_special_comment by iterating over line.leaves and line.comments_after(leaf) and checking is_special_comment on comments after commas (lines 2116-2123). The early return is guarded by `not has_special_comment and not line.should_explode and is_line_short_enough(...)` (lines 2124-2130), matching the todo requirement.

Todo item 1 of 12 is correct
description: 'Verify that `split_line()` now guards the short-line early return with a check for special comments: it computes `has_special_comment` by scanning `line.leaves` and `line.comments_after(leaf)`, and only returns early if `not has_special_comment and not line.should_explode and is_line_short_enough(...)`.'

Validating todo item 2 of 12
description: 'Confirm that `has_special_comment` is set when an inline type comment follows a comma in a function parameter list: inside `split_line()`, the condition `leaf.type == token.COMMA and is_special_comment(comment)` should detect type comments like `a,  # type: int`.'

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2205:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2206:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2207:    bracket_split_succeeded_or_raise(head, body, tail)

Calling tool: grepTool
def is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.

Calling tool: grepTool
def comments_after\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling

Calling tool: grepTool
COMMA
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pgen2/token.pyi:18:COMMA: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pgen2/grammar.py:139:, COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pgen2/token.py:19:COMMA = 12
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:869:COMMA_PRIORITY = 18
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1178:            and self.leaves[-1].type == token.COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1216:            if bracket_depth == depth and leaf.type == token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1647:            elif prevp.type != token.COMMA and not complex_subscript:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1699:        if not prev or prev.type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1704:        if prev and prev.type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1721:        elif prev.type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1728:            if not prevp or prevp.type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1745:        elif prev.type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1900:    if leaf.type == token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1901:        return COMMA_PRIORITY
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2121:            if leaf.type == token.COMMA and is_special_comment(comment):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2342:                if leaves[-1].type != token.COMMA:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2343:                    leaves.append(Leaf(token.COMMA, ","))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2425:            and delimiter_priority == COMMA_PRIORITY
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2426:            and current_line.leaves[-1].type != token.COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2429:            current_line.append(Leaf(token.COMMA, ","))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2804:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2845:        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2850:        and node.children[1].type == token.COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2985:        exclude = {id(last_leaf)} if last_leaf.type == token.COMMA else set()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2990:    return max_priority == COMMA_PRIORITY
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3014:            and n.children[-1].type == token.COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:75:              COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:173:                    COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:234:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:375:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:386:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:456:                          COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:499:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:510:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:562:                            COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:573:                            COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:584:                            COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:618:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:629:                        COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/debug_visitor.out:679:                COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/blib2to3/pgen2/token.pyi:18:COMMA: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/blib2to3/pgen2/grammar.py:139:, COMMA
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/setuptools_scm/utils.py:40:        or k in ("GIT_EXEC_PATH", "GIT_SSH", "GIT_SSH_COMMAND")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/blib2to3/pgen2/token.py:19:COMMA = 12
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/packaging/requirements.py:34:COMMA = L(",").suppress()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/packaging/requirements.py:48:EXTRAS_LIST = EXTRA + ZeroOrMore(COMMA + EXTRA)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/packaging/requirements.py:56:    VERSION_ONE + ZeroOrMore(COMMA + VERSION_ONE), joinString=",", adjacent=False
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/aiohttp/_http_parser.c:34:#define __PYX_COMMA ,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/aiohttp/_websocket.c:34:#define __PYX_COMMA ,

Calling tool: grepTool
test_comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_comments6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments6

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)
410:        black.assert_equivalent(source, actual)
411:        black.assert_stable(source, actual, line_length=ll)
412:
413:    @patch("black.dump_to_file", dump_to_stderr)
414:    def test_numeric_literals(self) -> None:
415:        source, expected = read_data("numeric_literals")
416:        actual = fs(source, mode=black.FileMode.PYTHON36)
417:        self.assertFormatEqual(expected, actual)
418:        black.assert_equivalent(source, actual)
419:        black.assert_stable(source, actual, line_length=ll)
420:
421:    @patch("black.dump_to_file", dump_to_stderr)
422:    def test_numeric_literals_ignoring_underscores(self) -> None:
423:        source, expected = read_data("numeric_literals_skip_underscores")
424:        mode = (
425:            black.FileMode.PYTHON36 | black.FileMode.NO_NUMERIC_UNDERSCORE_NORMALIZATION
426:        )
427:        actual = fs(source, mode=mode)
428:        self.assertFormatEqual(expected, actual)
429:        black.assert_equivalent(source, actual)

Calling tool: globTool
**/tests/data/*comments6*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1770:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1784:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1802:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1812:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1824:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1834:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1846:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/coverage/html.py:63:def read_data(fname):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py:235:    def read_data(file, endian, num=1):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager, redirect_stderr
5:from functools import partial, wraps
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import re
10:import sys
11:from tempfile import TemporaryDirectory
12:from typing import (
13:    Any,
14:    BinaryIO,
15:    Callable,
16:    Coroutine,
17:    Generator,
18:    List,
19:    Tuple,
20:    Iterator,
21:    TypeVar,
22:)
23:import unittest
24:from unittest.mock import patch, MagicMock
25:
26:from click import unstyle
27:from click.testing import CliRunner
28:
29:import black
30:
31:try:
32:    import blackd
33:    from aiohttp.test_utils import TestClient, TestServer
34:except ImportError:
35:    has_blackd_deps = False
36:else:
37:    has_blackd_deps = True
38:
39:
40:ll = 88
41:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
42:fs = partial(black.format_str, line_length=ll)
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:T = TypeVar("T")
47:R = TypeVar("R")
48:
49:
50:def dump_to_stderr(*output: str) -> str:
51:    return "\n" + "\n".join(output) + "\n"
52:
53:
54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
55:    """read_data('test_name') -> 'input', 'output'"""
56:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
57:        name += ".py"
58:    _input: List[str] = []
59:    _output: List[str] = []
60:    base_dir = THIS_DIR / "data" if data else THIS_DIR
61:    with open(base_dir / name, "r", encoding="utf8") as test:
62:        lines = test.readlines()
63:    result = _input
64:    for line in lines:
65:        line = line.replace(EMPTY_LINE, "")
66:        if line.rstrip() == "# output":
67:            result = _output
68:            continue
69:
70:        result.append(line)
71:    if _input and not _output:
72:        # If there's no output marker, treat the entire file as already pre-formatted.
73:        _output = _input[:]
74:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
75:
76:
77:@contextmanager
78:def cache_dir(exists: bool = True) -> Iterator[Path]:
79:    with TemporaryDirectory() as workspace:
80:        cache_dir = Path(workspace)
81:        if not exists:
82:            cache_dir = cache_dir / "new"
83:        with patch("black.CACHE_DIR", cache_dir):
84:            yield cache_dir
85:
86:
87:@contextmanager
88:def event_loop(close: bool) -> Iterator[None]:
89:    policy = asyncio.get_event_loop_policy()
90:    old_loop = policy.get_event_loop()
91:    loop = policy.new_event_loop()
92:    asyncio.set_event_loop(loop)
93:    try:
94:        yield
95:
96:    finally:
97:        policy.set_event_loop(old_loop)
98:        if close:
99:            loop.close()
100:

Calling tool: grepTool
def maybe_comment\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
comment
Showing first 50 results from grep. Consider using a more specific pattern or path.
1027:    """Holds leaves and comments. Can be printed with `str(line)`."""
1031:    # The LeafID keys of comments must remain ordered by the corresponding leaf's index
1033:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)
1046:        Inline comments are put aside.
1063:        if not self.append_comment(leaf):
1067:        """Like :func:`append()` but disallow invalid standalone comment structure.
1069:        Raises ValueError when any `leaf` is appended after a standalone comment
1070:        or when a standalone comment is not the first leaf on the line.
1073:            if self.is_comment:
1074:                raise ValueError("cannot append to standalone comments")
1078:                    "cannot append standalone comments to a populated line"
1084:    def is_comment(self) -> bool:
1085:        """Is this line a standalone comment?"""
1158:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1228:    def append_comment(self, comment: Leaf) -> bool:
1229:        """Add an inline or standalone comment to the line."""
1231:            comment.type == STANDALONE_COMMENT
1234:            comment.prefix = ""
1237:        if comment.type != token.COMMENT:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1250:                self.comments[leaf_id].append(comment)
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1268:        self.comments.pop(id(self.leaves[-1]), None)
1300:        for comment in itertools.chain.from_iterable(self.comments.values()):
1301:            res += str(comment)
1305:        """Return True if the line has leaves or comments."""
1306:        return bool(self.leaves or self.comments)
1393:            self.previous_line.is_comment
1454:            for comment in generate_comments(node):
1456:                    # any comment within brackets is subject to splitting
1457:                    self.current_line.append(comment)
1458:                elif comment.type == token.COMMENT:
1459:                    # regular trailing comment
1460:                    self.current_line.append(comment)
1464:                    # regular standalone comment
1467:                    self.current_line.append(comment)
1482:        # In blib2to3 INDENT never holds comments.
1488:        # The current line might still wait for trailing comments.  At DEDENT time

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1008:        """See `maybe_increment_lambda_arguments` above for explanation."""
1009:        if (
1010:            self._lambda_argument_depths
1011:            and self._lambda_argument_depths[-1] == self.depth
1012:            and leaf.type == token.COLON
1013:        ):
1014:            self.depth -= 1
1015:            self._lambda_argument_depths.pop()
1016:            return True
1017:
1018:        return False
1019:
1020:    def get_open_lsqb(self) -> Optional[Leaf]:
1021:        """Return the most recent opening square bracket (if any)."""
1022:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1023:
1024:
1025:@dataclass
1026:class Line:
1027:    """Holds leaves and comments. Can be printed with `str(line)`."""
1028:
1029:    depth: int = 0
1030:    leaves: List[Leaf] = Factory(list)
1031:    # The LeafID keys of comments must remain ordered by the corresponding leaf's index
1032:    # in leaves
1033:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)
1034:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1035:    inside_brackets: bool = False
1036:    should_explode: bool = False
1037:
1038:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1039:        """Add a new `leaf` to the end of the line.
1040:
1041:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1042:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1043:        Trailing commas are maybe removed, unpacked for loop variables are
1044:        demoted from being delimiters.
1045:
1046:        Inline comments are put aside.
1047:        """
1048:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1049:        if not has_value:
1050:            return
1051:
1052:        if token.COLON == leaf.type and self.is_class_paren_empty:
1053:            del self.leaves[-2:]
1054:        if self.leaves and not preformatted:
1055:            # Note: at this point leaf.prefix should be empty except for
1056:            # imports, for which we only preserve newlines.
1057:            leaf.prefix += whitespace(
1058:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1059:            )
1060:        if self.inside_brackets or not preformatted:
1061:            self.bracket_tracker.mark(leaf)
1062:            self.maybe_remove_trailing_comma(leaf)
1063:        if not self.append_comment(leaf):
1064:            self.leaves.append(leaf)
1065:
1066:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1067:        """Like :func:`append()` but disallow invalid standalone comment structure.
1068:
1069:        Raises ValueError when any `leaf` is appended after a standalone comment
1070:        or when a standalone comment is not the first leaf on the line.
1071:        """
1072:        if self.bracket_tracker.depth == 0:
1073:            if self.is_comment:
1074:                raise ValueError("cannot append to standalone comments")
1075:
1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1077:                raise ValueError(
1078:                    "cannot append standalone comments to a populated line"
1079:                )
1080:
1081:        self.append(leaf, preformatted=preformatted)
1082:
1083:    @property
1084:    def is_comment(self) -> bool:
1085:        """Is this line a standalone comment?"""
1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1087:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1218:                if leaf.parent and leaf.parent.type == syms.arglist:
1219:                    commas += 1
1220:                    break
1221:
1222:        if commas > 1:
1223:            self.remove_trailing_comma()
1224:            return True
1225:
1226:        return False
1227:
1228:    def append_comment(self, comment: Leaf) -> bool:
1229:        """Add an inline or standalone comment to the line."""
1230:        if (
1231:            comment.type == STANDALONE_COMMENT
1232:            and self.bracket_tracker.any_open_brackets()
1233:        ):
1234:            comment.prefix = ""
1235:            return False
1236:
1237:        if comment.type != token.COMMENT:
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling
1278:
1279:        if isinstance(subscript_start, Node):
1280:            if subscript_start.type == syms.listmaker:
1281:                return False
1282:
1283:            if subscript_start.type == syms.subscriptlist:
1284:                subscript_start = child_towards(subscript_start, leaf)
1285:        return subscript_start is not None and any(
1286:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
1287:        )
1288:
1289:    def __str__(self) -> str:
1290:        """Render the line."""
1291:        if not self:
1292:            return "\n"
1293:
1294:        indent = "    " * self.depth
1295:        leaves = iter(self.leaves)
1296:        first = next(leaves)
1297:        res = f"{first.prefix}{indent}{first.value}"

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1428:    is_pyi: bool = False
1429:    normalize_strings: bool = True
1430:    current_line: Line = Factory(Line)
1431:    remove_u_prefix: bool = False
1432:    allow_underscores: bool = False
1433:
1434:    def line(self, indent: int = 0) -> Iterator[Line]:
1435:        """Generate a line.
1436:
1437:        If the line is empty, only emit if it makes sense.
1438:        If the line is too long, split it first and then generate.
1439:
1440:        If any lines were generated, set up a new current_line.
1441:        """
1442:        if not self.current_line:
1443:            self.current_line.depth += indent
1444:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1445:
1446:        complete_line = self.current_line
1447:        self.current_line = Line(depth=complete_line.depth + indent)
1448:        yield complete_line
1449:
1450:    def visit_default(self, node: LN) -> Iterator[Line]:
1451:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1452:        if isinstance(node, Leaf):
1453:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1454:            for comment in generate_comments(node):
1455:                if any_open_brackets:
1456:                    # any comment within brackets is subject to splitting
1457:                    self.current_line.append(comment)
1458:                elif comment.type == token.COMMENT:
1459:                    # regular trailing comment
1460:                    self.current_line.append(comment)
1461:                    yield from self.line()
1462:
1463:                else:
1464:                    # regular standalone comment
1465:                    yield from self.line()
1466:
1467:                    self.current_line.append(comment)
1468:                    yield from self.line()
1469:
1470:            normalize_prefix(node, inside_brackets=any_open_brackets)
1471:            if self.normalize_strings and node.type == token.STRING:
1472:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1473:                normalize_string_quotes(node)
1474:            if node.type == token.NUMBER:
1475:                normalize_numeric_literal(node, self.allow_underscores)
1476:            if node.type not in WHITESPACE:
1477:                self.current_line.append(node)
1478:        yield from super().visit_default(node)
1479:
1480:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1481:        """Increase indentation level, maybe yield a line."""
1482:        # In blib2to3 INDENT never holds comments.
1483:        yield from self.line(+1)
1484:        yield from self.visit_default(node)
1485:
1486:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1487:        """Decrease indentation level, maybe yield a line."""

Calling tool: grepTool
def generate_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1988:        and not (
1989:            previous is not None
1990:            and previous.type == token.NAME
1991:            and previous.value == "is"
1992:        )
1993:    ):
1994:        return COMPARATOR_PRIORITY
1995:
1996:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1997:        return LOGIC_PRIORITY
1998:
1999:    return 0
2000:
2001:
2002:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2003:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2004:
2005:
2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2007:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2008:
2009:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2010:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2011:    move because it does away with modifying the grammar to include all the
2012:    possible places in which comments can be placed.
2013:
2014:    The sad consequence for us though is that comments don't "belong" anywhere.
2015:    This is why this function generates simple parentless Leaf objects for
2016:    comments.  We simply don't know what the correct parent should be.
2017:
2018:    No matter though, we can live without this.  We really only need to
2019:    differentiate between inline and standalone comments.  The latter don't
2020:    share the line with any code.
2021:
2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
2024:    """
2025:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2026:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2027:
2028:
2029:@dataclass
2030:class ProtoComment:
2031:    """Describes a piece of syntax that is a comment.
2032:
2033:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2034:
2035:    * it can be cached (`Leaf` objects should not be reused more than once as
2036:      they store their lineno, column, prefix, and parent information);
2037:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2038:      simplifies handling of special marker comments like ``# fmt: off/on``.
2039:    """
2040:
2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
2042:    value: str  # content of the comment
2043:    newlines: int  # how many newlines before the comment
2044:    consumed: int  # how many characters of the original leaf's prefix did we consume
2045:
2046:
2047:@lru_cache(maxsize=4096)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2049:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2050:    result: List[ProtoComment] = []
2051:    if not prefix or "#" not in prefix:
2052:        return result
2053:
2054:    consumed = 0
2055:    nlines = 0
2056:    for index, line in enumerate(prefix.split("\n")):
2057:        consumed += len(line) + 1  # adding the length of the split '\n'
2058:        line = line.lstrip()
2059:        if not line:
2060:            nlines += 1
2061:        if not line.startswith("#"):
2062:            continue
2063:
2064:        if index == 0 and not is_endmarker:
2065:            comment_type = token.COMMENT  # simple trailing comment
2066:        else:
2067:            comment_type = STANDALONE_COMMENT
2068:        comment = make_comment(line)
2069:        result.append(
2070:            ProtoComment(
2071:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2072:            )
2073:        )
2074:        nlines = 0
2075:    return result
2076:
2077:
2078:def make_comment(content: str) -> str:
2079:    """Return a consistently formatted comment from the given `content` string.
2080:
2081:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2082:    space between the hash sign and the content.
2083:
2084:    If `content` didn't start with a hash sign, one is provided.
2085:    """
2086:    content = content.rstrip()
2087:    if not content:
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2735:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2765:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2416:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2714:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2744:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3029:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In split_line(), lines 21192122 iterate comments attached to each leaf and set has_special_comment when leaf.type == token.COMMA and is_special_comment(comment). is_special_comment (lines 24762483) returns True for inline comments starting with # type:. Since inline comments after a comma attach to that comma via Line.append_comment, this detects cases like a,  # type: int. 

Todo item 2 of 12 is correct
description: 'Confirm that `has_special_comment` is set when an inline type comment follows a comma in a function parameter list: inside `split_line()`, the condition `leaf.type == token.COMMA and is_special_comment(comment)` should detect type comments like `a,  # type: int`.'

Validating todo item 3 of 12
description: 'Validate that `is_special_comment(leaf: Leaf) -> bool` exists and returns True only for comment leaves (`token.COMMENT` or `STANDALONE_COMMENT`) whose value starts with `"# type:"`.'

Calling tool: grepTool
def is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Found function `is_special_comment(leaf: Leaf) -> bool` in black.py at line 2476. It returns True only when the leaf type is `token.COMMENT` or `STANDALONE_COMMENT` and the value starts with `"# type:"`, matching the requirement.

Todo item 3 of 12 is correct
description: 'Validate that `is_special_comment(leaf: Leaf) -> bool` exists and returns True only for comment leaves (`token.COMMENT` or `STANDALONE_COMMENT`) whose value starts with `"# type:"`.'

Validating todo item 4 of 12
description: 'Check that `STANDALONE_COMMENT` is defined and integrated in the tokenization logic so `is_special_comment` can safely reference it (e.g., constant defined, tok_name mapping, and comment handling in `list_comments`/`generate_comments`).'

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2735:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2765:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2416:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2714:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2744:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3029:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
780:KEYWORDS = set(keyword.kwlist)
781:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
782:FLOW_CONTROL = {"return", "raise", "break", "continue"}
783:STATEMENT = {
784:    syms.if_stmt,
785:    syms.while_stmt,
786:    syms.for_stmt,
787:    syms.try_stmt,
788:    syms.except_clause,
789:    syms.with_stmt,
790:    syms.funcdef,
791:    syms.classdef,
792:}
793:STANDALONE_COMMENT = 153
794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
795:LOGIC_OPERATORS = {"and", "or"}
796:COMPARATORS = {
797:    token.LESS,
798:    token.GREATER,
799:    token.EQEQUAL,
800:    token.NOTEQUAL,
801:    token.LESSEQUAL,
802:    token.GREATEREQUAL,
803:}
804:MATH_OPERATORS = {
805:    token.VBAR,
806:    token.CIRCUMFLEX,
807:    token.AMPER,
808:    token.LEFTSHIFT,
809:    token.RIGHTSHIFT,
810:    token.PLUS,
811:    token.MINUS,
812:    token.STAR,
813:    token.SLASH,
814:    token.DOUBLESLASH,
815:    token.PERCENT,
816:    token.AT,
817:    token.TILDE,
818:    token.DOUBLESTAR,
819:}

Calling tool: grepTool
def list_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2020:    share the line with any code.
2021:
2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
2024:    """
2025:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2026:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2027:
2028:
2029:@dataclass
2030:class ProtoComment:
2031:    """Describes a piece of syntax that is a comment.
2032:
2033:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2034:
2035:    * it can be cached (`Leaf` objects should not be reused more than once as
2036:      they store their lineno, column, prefix, and parent information);
2037:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2038:      simplifies handling of special marker comments like ``# fmt: off/on``.
2039:    """
2040:
2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
2042:    value: str  # content of the comment
2043:    newlines: int  # how many newlines before the comment
2044:    consumed: int  # how many characters of the original leaf's prefix did we consume
2045:
2046:
2047:@lru_cache(maxsize=4096)
2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2049:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2050:    result: List[ProtoComment] = []
2051:    if not prefix or "#" not in prefix:
2052:        return result
2053:
2054:    consumed = 0
2055:    nlines = 0
2056:    for index, line in enumerate(prefix.split("\n")):
2057:        consumed += len(line) + 1  # adding the length of the split '\n'
2058:        line = line.lstrip()
2059:        if not line:
2060:            nlines += 1
2061:        if not line.startswith("#"):
2062:            continue
2063:
2064:        if index == 0 and not is_endmarker:
2065:            comment_type = token.COMMENT  # simple trailing comment
2066:        else:
2067:            comment_type = STANDALONE_COMMENT
2068:        comment = make_comment(line)
2069:        result.append(
2070:            ProtoComment(
2071:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2072:            )
2073:        )
2074:        nlines = 0
2075:    return result
2076:
2077:
2078:def make_comment(content: str) -> str:
2079:    """Return a consistently formatted comment from the given `content` string.
2080:
2081:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2082:    space between the hash sign and the content.
2083:
2084:    If `content` didn't start with a hash sign, one is provided.
2085:    """
2086:    content = content.rstrip()
2087:    if not content:
2088:        return "#"
2089:

Calling tool: grepTool
def generate_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1996:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1997:        return LOGIC_PRIORITY
1998:
1999:    return 0
2000:
2001:
2002:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2003:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2004:
2005:
2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2007:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2008:
2009:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2010:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2011:    move because it does away with modifying the grammar to include all the
2012:    possible places in which comments can be placed.
2013:
2014:    The sad consequence for us though is that comments don't "belong" anywhere.
2015:    This is why this function generates simple parentless Leaf objects for
2016:    comments.  We simply don't know what the correct parent should be.
2017:
2018:    No matter though, we can live without this.  We really only need to
2019:    differentiate between inline and standalone comments.  The latter don't
2020:    share the line with any code.
2021:
2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
2024:    """
2025:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2026:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2027:
2028:
2029:@dataclass
2030:class ProtoComment:
2031:    """Describes a piece of syntax that is a comment.
2032:
2033:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2034:
2035:    * it can be cached (`Leaf` objects should not be reused more than once as

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1598:        self.visit_import_from = partial(v, keywords=, parens={"import"})
1599:        self.visit_async_funcdef = self.visit_async_stmt
1600:        self.visit_decorated = self.visit_decorators
1601:
1602:
1603:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
1604:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1605:OPENING_BRACKETS = set(BRACKET.keys())
1606:CLOSING_BRACKETS = set(BRACKET.values())
1607:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1609:
1610:
1611:def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa C901
1612:    """Return whitespace prefix if needed for the given `leaf`.
1613:
1614:    `complex_subscript` signals whether the given leaf is part of a subscription
1615:    which has non-trivial arguments, like arithmetic expressions or function calls.
1616:    """
1617:    NO = ""

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1566:        """Remove a semicolon and put the other statement on a separate line."""
1567:        yield from self.line()
1568:
1569:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1570:        """End of file. Process outstanding comments and end with a newline."""
1571:        yield from self.visit_default(leaf)
1572:        yield from self.line()
1573:
1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1575:        if not self.current_line.bracket_tracker.any_open_brackets():
1576:            yield from self.line()
1577:        yield from self.visit_default(leaf)
1578:
1579:    def __attrs_post_init__(self) -> None:
1580:        """You are in a twisty little maze of passages."""
1581:        v = self.visit_stmt
1582:        : Set[str] = set()
1583:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1584:        self.visit_if_stmt = partial(
1585:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1068:
1069:        Raises ValueError when any `leaf` is appended after a standalone comment
1070:        or when a standalone comment is not the first leaf on the line.
1071:        """
1072:        if self.bracket_tracker.depth == 0:
1073:            if self.is_comment:
1074:                raise ValueError("cannot append to standalone comments")
1075:
1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1077:                raise ValueError(
1078:                    "cannot append standalone comments to a populated line"
1079:                )
1080:
1081:        self.append(leaf, preformatted=preformatted)
1082:
1083:    @property
1084:    def is_comment(self) -> bool:
1085:        """Is this line a standalone comment?"""
1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1087:
1088:    @property
1089:    def is_decorator(self) -> bool:
1090:        """Is this line a decorator?"""
1091:        return bool(self) and self.leaves[0].type == token.AT
1092:
1093:    @property
1094:    def is_import(self) -> bool:
1095:        """Is this an import line?"""
1096:        return bool(self) and is_import(self.leaves[0])
1097:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1218:                if leaf.parent and leaf.parent.type == syms.arglist:
1219:                    commas += 1
1220:                    break
1221:
1222:        if commas > 1:
1223:            self.remove_trailing_comma()
1224:            return True
1225:
1226:        return False
1227:
1228:    def append_comment(self, comment: Leaf) -> bool:
1229:        """Add an inline or standalone comment to the line."""
1230:        if (
1231:            comment.type == STANDALONE_COMMENT
1232:            and self.bracket_tracker.any_open_brackets()
1233:        ):
1234:            comment.prefix = ""
1235:            return False
1236:
1237:        if comment.type != token.COMMENT:
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling
1278:
1279:        if isinstance(subscript_start, Node):
1280:            if subscript_start.type == syms.listmaker:
1281:                return False
1282:
1283:            if subscript_start.type == syms.subscriptlist:
1284:                subscript_start = child_towards(subscript_start, leaf)
1285:        return subscript_start is not None and any(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
3036:    """
3037:
3038:    omit: Set[LeafID] = set()
3039:    yield omit
3040:
3041:    length = 4 * line.depth
3042:    opening_bracket = None
3043:    closing_bracket = None
3044:    inner_brackets: Set[LeafID] = set()
3045:    for index, leaf, leaf_length in enumerate_with_length(line, reversed=True):
3046:        length += leaf_length
3047:        if length > line_length:
3048:            break
3049:
3050:        has_inline_comment = leaf_length > len(leaf.value) + len(leaf.prefix)
3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
3052:            break
3053:
3054:        if opening_bracket:
3055:            if leaf is opening_bracket:
3056:                opening_bracket = None
3057:            elif leaf.type in CLOSING_BRACKETS:
3058:                inner_brackets.add(id(leaf))
3059:        elif leaf.type in CLOSING_BRACKETS:
3060:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
3061:                # Empty brackets would fail a split so treat them as "inner"
3062:                # brackets (e.g. only add them to the `omit` set if another
3063:                # pair of brackets was good enough.
3064:                inner_brackets.add(id(leaf))
3065:                continue

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: STANDALONE_COMMENT is defined (black.py:793) and registered in token.tok_name (black.py:794). The tokenization flow uses it: generate_comments() yields leaves with this type via list_comments() (black.py:2006-2026, 2048-2075), where inline vs standalone is distinguished and STANDALONE_COMMENT is assigned (black.py:2064-2068). is_special_comment safely references it (black.py:2476-2483).

Todo item 4 of 12 is correct
description: 'Check that `STANDALONE_COMMENT` is defined and integrated in the tokenization logic so `is_special_comment` can safely reference it (e.g., constant defined, tok_name mapping, and comment handling in `list_comments`/`generate_comments`).'

Validating todo item 5 of 12
description: 'Ensure `split_line()` uses `line.comments_after(leaf)` correctly to retrieve inline comments and that `comments_after()` returns comments attached to the last emitted leaf (see `append_comment` logic). This ensures comments after a comma are discoverable.'

Calling tool: grepTool
class Line\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1026:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1026:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/docutils/parsers/rst/states.py:2913:class Line(SpecializedText):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/tabulate.pyi:8:class Line(NamedTuple):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/werkzeug/debug/tbtools.pyi:16:class Line:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1000:        if leaf.type == token.NAME and leaf.value == "lambda":
1001:            self.depth += 1
1002:            self._lambda_argument_depths.append(self.depth)
1003:            return True
1004:
1005:        return False
1006:
1007:    def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:
1008:        """See `maybe_increment_lambda_arguments` above for explanation."""
1009:        if (
1010:            self._lambda_argument_depths
1011:            and self._lambda_argument_depths[-1] == self.depth
1012:            and leaf.type == token.COLON
1013:        ):
1014:            self.depth -= 1
1015:            self._lambda_argument_depths.pop()
1016:            return True
1017:
1018:        return False
1019:
1020:    def get_open_lsqb(self) -> Optional[Leaf]:
1021:        """Return the most recent opening square bracket (if any)."""
1022:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1023:
1024:
1025:@dataclass
1026:class Line:
1027:    """Holds leaves and comments. Can be printed with `str(line)`."""
1028:
1029:    depth: int = 0
1030:    leaves: List[Leaf] = Factory(list)
1031:    # The LeafID keys of comments must remain ordered by the corresponding leaf's index
1032:    # in leaves
1033:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)
1034:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1035:    inside_brackets: bool = False
1036:    should_explode: bool = False
1037:
1038:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1039:        """Add a new `leaf` to the end of the line.
1040:
1041:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1042:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1043:        Trailing commas are maybe removed, unpacked for loop variables are
1044:        demoted from being delimiters.
1045:
1046:        Inline comments are put aside.
1047:        """
1048:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1049:        if not has_value:
1050:            return
1051:
1052:        if token.COLON == leaf.type and self.is_class_paren_empty:
1053:            del self.leaves[-2:]
1054:        if self.leaves and not preformatted:
1055:            # Note: at this point leaf.prefix should be empty except for
1056:            # imports, for which we only preserve newlines.
1057:            leaf.prefix += whitespace(
1058:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1059:            )
1060:        if self.inside_brackets or not preformatted:
1061:            self.bracket_tracker.mark(leaf)
1062:            self.maybe_remove_trailing_comma(leaf)
1063:        if not self.append_comment(leaf):
1064:            self.leaves.append(leaf)
1065:
1066:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1067:        """Like :func:`append()` but disallow invalid standalone comment structure.
1068:
1069:        Raises ValueError when any `leaf` is appended after a standalone comment
1070:        or when a standalone comment is not the first leaf on the line.
1071:        """
1072:        if self.bracket_tracker.depth == 0:
1073:            if self.is_comment:
1074:                raise ValueError("cannot append to standalone comments")
1075:
1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1077:                raise ValueError(
1078:                    "cannot append standalone comments to a populated line"
1079:                )
1080:
1081:        self.append(leaf, preformatted=preformatted)
1082:
1083:    @property
1084:    def is_comment(self) -> bool:
1085:        """Is this line a standalone comment?"""
1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1087:
1088:    @property
1089:    def is_decorator(self) -> bool:
1090:        """Is this line a decorator?"""
1091:        return bool(self) and self.leaves[0].type == token.AT
1092:
1093:    @property
1094:    def is_import(self) -> bool:
1095:        """Is this an import line?"""
1096:        return bool(self) and is_import(self.leaves[0])
1097:
1098:    @property
1099:    def is_class(self) -> bool:
1100:        """Is this line a class definition?"""
1101:        return (
1102:            bool(self)
1103:            and self.leaves[0].type == token.NAME
1104:            and self.leaves[0].value == "class"
1105:        )
1106:
1107:    @property
1108:    def is_stub_class(self) -> bool:
1109:        """Is this line a class definition with a body consisting only of "..."?"""
1110:        return self.is_class and self.leaves[-3:] == [
1111:            Leaf(token.DOT, ".") for _ in range(3)
1112:        ]
1113:
1114:    @property
1115:    def is_def(self) -> bool:
1116:        """Is this a function definition? (Also returns True for async defs.)"""
1117:        try:
1118:            first_leaf = self.leaves[0]
1119:        except IndexError:

Calling tool: grepTool
def comments_after\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1200:        # change a tuple into a different type by removing the comma.
1201:        depth = closing.bracket_depth + 1
1202:        commas = 0
1203:        opening = closing.opening_bracket
1204:        for _opening_index, leaf in enumerate(self.leaves):
1205:            if leaf is opening:
1206:                break
1207:
1208:        else:
1209:            return False
1210:
1211:        for leaf in self.leaves[_opening_index + 1 :]:
1212:            if leaf is closing:
1213:                break
1214:
1215:            bracket_depth = leaf.bracket_depth
1216:            if bracket_depth == depth and leaf.type == token.COMMA:
1217:                commas += 1
1218:                if leaf.parent and leaf.parent.type == syms.arglist:
1219:                    commas += 1
1220:                    break
1221:
1222:        if commas > 1:
1223:            self.remove_trailing_comma()
1224:            return True
1225:
1226:        return False
1227:
1228:    def append_comment(self, comment: Leaf) -> bool:
1229:        """Add an inline or standalone comment to the line."""
1230:        if (
1231:            comment.type == STANDALONE_COMMENT
1232:            and self.bracket_tracker.any_open_brackets()
1233:        ):
1234:            comment.prefix = ""
1235:            return False
1236:
1237:        if comment.type != token.COMMENT:
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling
1278:
1279:        if isinstance(subscript_start, Node):
1280:            if subscript_start.type == syms.listmaker:
1281:                return False
1282:
1283:            if subscript_start.type == syms.subscriptlist:
1284:                subscript_start = child_towards(subscript_start, leaf)
1285:        return subscript_start is not None and any(
1286:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
1287:        )
1288:
1289:    def __str__(self) -> str:
1290:        """Render the line."""
1291:        if not self:
1292:            return "\n"
1293:
1294:        indent = "    " * self.depth
1295:        leaves = iter(self.leaves)
1296:        first = next(leaves)
1297:        res = f"{first.prefix}{indent}{first.value}"
1298:        for leaf in leaves:
1299:            res += str(leaf)
1300:        for comment in itertools.chain.from_iterable(self.comments.values()):
1301:            res += str(comment)
1302:        return res + "\n"
1303:
1304:    def __bool__(self) -> bool:
1305:        """Return True if the line has leaves or comments."""
1306:        return bool(self.leaves or self.comments)
1307:
1308:
1309:@dataclass
1310:class EmptyLineTracker:
1311:    """Provides a stateful method that returns the number of potential extra
1312:    empty lines needed before and after the currently processed line.
1313:
1314:    Note: this tracker works on lines that haven't been split yet.  It assumes
1315:    the prefix of the first leaf consists of optional newlines.  Those newlines
1316:    are consumed by `maybe_empty_lines()` and included in the computation.
1317:    """
1318:
1319:    is_pyi: bool = False

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2205:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2206:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2207:    bracket_split_succeeded_or_raise(head, body, tail)

Calling tool: grepTool
STANDALONE_COMMENT\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2735:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2765:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1574:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2416:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2714:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2744:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3029:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: grepTool
test_comments6\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_comments6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments6

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
330:        black.assert_equivalent(source, actual)
331:        black.assert_stable(source, actual, line_length=ll)
332:
333:    @patch("black.dump_to_file", dump_to_stderr)
334:    def test_comments2(self) -> None:
335:        source, expected = read_data("comments2")
336:        actual = fs(source)
337:        self.assertFormatEqual(expected, actual)
338:        black.assert_equivalent(source, actual)
339:        black.assert_stable(source, actual, line_length=ll)
340:
341:    @patch("black.dump_to_file", dump_to_stderr)
342:    def test_comments3(self) -> None:
343:        source, expected = read_data("comments3")
344:        actual = fs(source)
345:        self.assertFormatEqual(expected, actual)
346:        black.assert_equivalent(source, actual)
347:        black.assert_stable(source, actual, line_length=ll)
348:
349:    @patch("black.dump_to_file", dump_to_stderr)
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)

Calling tool: grepTool
comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:367:        source, expected = read_data("comments6")

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1770:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1784:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1802:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1812:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1824:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1834:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1846:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py:235:    def read_data(file, endian, num=1):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/coverage/html.py:63:def read_data(fname):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager, redirect_stderr
5:from functools import partial, wraps
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import re
10:import sys
11:from tempfile import TemporaryDirectory
12:from typing import (
13:    Any,
14:    BinaryIO,
15:    Callable,
16:    Coroutine,
17:    Generator,
18:    List,
19:    Tuple,
20:    Iterator,
21:    TypeVar,
22:)
23:import unittest
24:from unittest.mock import patch, MagicMock
25:
26:from click import unstyle
27:from click.testing import CliRunner
28:
29:import black
30:
31:try:
32:    import blackd
33:    from aiohttp.test_utils import TestClient, TestServer
34:except ImportError:
35:    has_blackd_deps = False
36:else:
37:    has_blackd_deps = True
38:
39:
40:ll = 88
41:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
42:fs = partial(black.format_str, line_length=ll)
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:T = TypeVar("T")
47:R = TypeVar("R")
48:
49:
50:def dump_to_stderr(*output: str) -> str:
51:    return "\n" + "\n".join(output) + "\n"
52:
53:
54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
55:    """read_data('test_name') -> 'input', 'output'"""
56:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
57:        name += ".py"
58:    _input: List[str] = []
59:    _output: List[str] = []
60:    base_dir = THIS_DIR / "data" if data else THIS_DIR
61:    with open(base_dir / name, "r", encoding="utf8") as test:
62:        lines = test.readlines()
63:    result = _input
64:    for line in lines:
65:        line = line.replace(EMPTY_LINE, "")
66:        if line.rstrip() == "# output":
67:            result = _output
68:            continue
69:
70:        result.append(line)
71:    if _input and not _output:
72:        # If there's no output marker, treat the entire file as already pre-formatted.
73:        _output = _input[:]
74:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
75:
76:
77:@contextmanager
78:def cache_dir(exists: bool = True) -> Iterator[Path]:
79:    with TemporaryDirectory() as workspace:
80:        cache_dir = Path(workspace)
81:        if not exists:
82:            cache_dir = cache_dir / "new"
83:        with patch("black.CACHE_DIR", cache_dir):
84:            yield cache_dir
85:
86:
87:@contextmanager
88:def event_loop(close: bool) -> Iterator[None]:
89:    policy = asyncio.get_event_loop_policy()
90:    old_loop = policy.get_event_loop()
91:    loop = policy.new_event_loop()
92:    asyncio.set_event_loop(loop)
93:    try:
94:        yield
95:
96:    finally:
97:        policy.set_event_loop(old_loop)
98:        if close:
99:            loop.close()
100:
101:
102:def async_test(f: Callable[..., Coroutine[Any, None, R]]) -> Callable[..., None]:
103:    @event_loop(close=True)
104:    @wraps(f)
105:    def wrapper(*args: Any, **kwargs: Any) -> None:
106:        asyncio.get_event_loop().run_until_complete(f(*args, **kwargs))
107:
108:    return wrapper
109:
110:
111:class BlackRunner(CliRunner):
112:    """Modify CliRunner so that stderr is not merged with stdout.
113:
114:    This is a hack that can be removed once we depend on Click 7.x"""
115:
116:    def __init__(self) -> None:
117:        self.stderrbuf = BytesIO()
118:        self.stdoutbuf = BytesIO()
119:        self.stdout_bytes = b""
120:        self.stderr_bytes = b""

Calling tool: globTool
**/tests/data/comments6.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1960:        leaf.value == "if"
1961:        and leaf.parent
1962:        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
1963:    ):
1964:        return COMPREHENSION_PRIORITY
1965:
1966:    if leaf.value in {"if", "else"} and leaf.parent and leaf.parent.type == syms.test:
1967:        return TERNARY_PRIORITY
1968:
1969:    if leaf.value == "is":
1970:        return COMPARATOR_PRIORITY
1971:
1972:    if (
1973:        leaf.value == "in"
1974:        and leaf.parent
1975:        and leaf.parent.type in {syms.comp_op, syms.comparison}
1976:        and not (
1977:            previous is not None
1978:            and previous.type == token.NAME
1979:            and previous.value == "not"
1980:        )
1981:    ):
1982:        return COMPARATOR_PRIORITY
1983:
1984:    if (
1985:        leaf.value == "not"
1986:        and leaf.parent
1987:        and leaf.parent.type == syms.comp_op
1988:        and not (
1989:            previous is not None
1990:            and previous.type == token.NAME
1991:            and previous.value == "is"
1992:        )
1993:    ):
1994:        return COMPARATOR_PRIORITY
1995:
1996:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1997:        return LOGIC_PRIORITY
1998:
1999:    return 0
2000:
2001:
2002:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2003:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2004:
2005:
2006:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2007:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2008:
2009:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2010:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2011:    move because it does away with modifying the grammar to include all the
2012:    possible places in which comments can be placed.
2013:
2014:    The sad consequence for us though is that comments don't "belong" anywhere.
2015:    This is why this function generates simple parentless Leaf objects for
2016:    comments.  We simply don't know what the correct parent should be.
2017:
2018:    No matter though, we can live without this.  We really only need to
2019:    differentiate between inline and standalone comments.  The latter don't
2020:    share the line with any code.
2021:
2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
2024:    """
2025:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2026:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2027:
2028:
2029:@dataclass
2030:class ProtoComment:
2031:    """Describes a piece of syntax that is a comment.
2032:
2033:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2034:
2035:    * it can be cached (`Leaf` objects should not be reused more than once as
2036:      they store their lineno, column, prefix, and parent information);
2037:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2038:      simplifies handling of special marker comments like ``# fmt: off/on``.
2039:    """
2040:
2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
2042:    value: str  # content of the comment
2043:    newlines: int  # how many newlines before the comment
2044:    consumed: int  # how many characters of the original leaf's prefix did we consume
2045:
2046:
2047:@lru_cache(maxsize=4096)
2048:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2049:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2050:    result: List[ProtoComment] = []
2051:    if not prefix or "#" not in prefix:
2052:        return result
2053:
2054:    consumed = 0
2055:    nlines = 0
2056:    for index, line in enumerate(prefix.split("\n")):
2057:        consumed += len(line) + 1  # adding the length of the split '\n'
2058:        line = line.lstrip()
2059:        if not line:
2060:            nlines += 1
2061:        if not line.startswith("#"):
2062:            continue
2063:
2064:        if index == 0 and not is_endmarker:
2065:            comment_type = token.COMMENT  # simple trailing comment
2066:        else:
2067:            comment_type = STANDALONE_COMMENT
2068:        comment = make_comment(line)
2069:        result.append(
2070:            ProtoComment(
2071:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2072:            )
2073:        )
2074:        nlines = 0
2075:    return result
2076:
2077:
2078:def make_comment(content: str) -> str:
2079:    """Return a consistently formatted comment from the given `content` string.
2080:
2081:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2082:    space between the hash sign and the content.
2083:
2084:    If `content` didn't start with a hash sign, one is provided.
2085:    """
2086:    content = content.rstrip()
2087:    if not content:
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: split_line iterates line.leaves and uses line.comments_after(leaf) to fetch inline comments. Line.append_comment attaches inline comments to id(self.leaves[-1]) (last emitted leaf), and comments_after returns self.comments.get(id(leaf), []). Thus comments after commas are discoverable and the logic correctly detects special comments attached to commas.

Todo item 5 of 12 is correct
description: 'Ensure `split_line()` uses `line.comments_after(leaf)` correctly to retrieve inline comments and that `comments_after()` returns comments attached to the last emitted leaf (see `append_comment` logic). This ensures comments after a comma are discoverable.'

Validating todo item 6 of 12
description: 'Confirm that the new special comment handling does not interfere with lines that have only a standalone type comment for the return type (e.g., `# type: (...) -> None`) since `has_special_comment` only looks at inline comments after commas. The early return should still allow short single-line signatures without per-parameter comments to remain unchanged.'

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2085:    """
2086:    content = content.rstrip()
2087:    if not content:
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)

Calling tool: grepTool
def is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.

Calling tool: grepTool
test_comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_comments6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments6

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)
410:        black.assert_equivalent(source, actual)
411:        black.assert_stable(source, actual, line_length=ll)
412:
413:    @patch("black.dump_to_file", dump_to_stderr)
414:    def test_numeric_literals(self) -> None:
415:        source, expected = read_data("numeric_literals")
416:        actual = fs(source, mode=black.FileMode.PYTHON36)
417:        self.assertFormatEqual(expected, actual)
418:        black.assert_equivalent(source, actual)
419:        black.assert_stable(source, actual, line_length=ll)
420:
421:    @patch("black.dump_to_file", dump_to_stderr)
422:    def test_numeric_literals_ignoring_underscores(self) -> None:
423:        source, expected = read_data("numeric_literals_skip_underscores")
424:        mode = (
425:            black.FileMode.PYTHON36 | black.FileMode.NO_NUMERIC_UNDERSCORE_NORMALIZATION
426:        )
427:        actual = fs(source, mode=mode)
428:        self.assertFormatEqual(expected, actual)
429:        black.assert_equivalent(source, actual)

Calling tool: globTool
**/data/comments6*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: grepTool
def .*\):\s+# type: \(\.\.\.\) -> None
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
# type: \(\.\.\.\) -> None
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py:27:    # type: (...) -> None
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py:37:    # type: (...) -> None
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py:47:    # type: (...) -> None
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_checker.py:178:    # type: (...) -> None
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_checker.py:184:            ('# type: int', '# type: str', '# type: (...) -> None'),

Calling tool: grepTool
is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2121:            if leaf.type == token.COMMA and is_special_comment(comment):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In split_line(), has_special_comment is set only when a special type comment appears after a comma (leaf.type == token.COMMA). A standalone return type comment after the closing parenthesis/colon is not after a comma, so has_special_comment remains False. Therefore, the early return condition still triggers for short single-line signatures without per-parameter comments, leaving them unchanged.

Todo item 6 of 12 is correct
description: 'Confirm that the new special comment handling does not interfere with lines that have only a standalone type comment for the return type (e.g., `# type: (...) -> None`) since `has_special_comment` only looks at inline comments after commas. The early return should still allow short single-line signatures without per-parameter comments to remain unchanged.'

Validating todo item 7 of 12
description: 'Verify that test fixture `tests/data/comments6.py` contains per-parameter inline type comments, `*args`/`**kwargs` with type comments, default-valued parameters with type comments, and nested structures (tuple items) with type comments, matching the PR intent.'

Calling tool: globTool
**/tests/data/comments6.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Reviewed tests/data/comments6.py and confirmed it includes per-parameter inline type comments for multiline functions, *args/**kwargs with type comments, a default-valued parameter with a type comment, and a tuple with per-item inline type comments plus an overall Tuple[...] type, aligning with the PR intent.

Todo item 7 of 12 is correct
description: 'Verify that test fixture `tests/data/comments6.py` contains per-parameter inline type comments, `*args`/`**kwargs` with type comments, default-valued parameters with type comments, and nested structures (tuple items) with type comments, matching the PR intent.'

Validating todo item 8 of 12
description: 'Check that `tests/data/comments6.py` has no `# output` marker so `read_data("comments6")` returns the input as expected output; thus the test asserts formatting is a no-op for these cases.'

Calling tool: grepTool
comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_bug.info:4:test_file="tests/data/comments6.py;tests/test_black.py"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_comments6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:367:        source, expected = read_data("comments6")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments6

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
340:
341:    @patch("black.dump_to_file", dump_to_stderr)
342:    def test_comments3(self) -> None:
343:        source, expected = read_data("comments3")
344:        actual = fs(source)
345:        self.assertFormatEqual(expected, actual)
346:        black.assert_equivalent(source, actual)
347:        black.assert_stable(source, actual, line_length=ll)
348:
349:    @patch("black.dump_to_file", dump_to_stderr)
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)
410:        black.assert_equivalent(source, actual)
411:        black.assert_stable(source, actual, line_length=ll)
412:
413:    @patch("black.dump_to_file", dump_to_stderr)
414:    def test_numeric_literals(self) -> None:
415:        source, expected = read_data("numeric_literals")
416:        actual = fs(source, mode=black.FileMode.PYTHON36)
417:        self.assertFormatEqual(expected, actual)
418:        black.assert_equivalent(source, actual)
419:        black.assert_stable(source, actual, line_length=ll)

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/test_black.py:54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1770:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1784:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1802:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1812:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1824:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1834:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1846:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py:235:    def read_data(file, endian, num=1):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/coverage/html.py:63:def read_data(fname):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager, redirect_stderr
5:from functools import partial, wraps
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import re
10:import sys
11:from tempfile import TemporaryDirectory
12:from typing import (
13:    Any,
14:    BinaryIO,
15:    Callable,
16:    Coroutine,
17:    Generator,
18:    List,
19:    Tuple,
20:    Iterator,
21:    TypeVar,
22:)
23:import unittest
24:from unittest.mock import patch, MagicMock
25:
26:from click import unstyle
27:from click.testing import CliRunner
28:
29:import black
30:
31:try:
32:    import blackd
33:    from aiohttp.test_utils import TestClient, TestServer
34:except ImportError:
35:    has_blackd_deps = False
36:else:
37:    has_blackd_deps = True
38:
39:
40:ll = 88
41:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
42:fs = partial(black.format_str, line_length=ll)
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:T = TypeVar("T")
47:R = TypeVar("R")
48:
49:
50:def dump_to_stderr(*output: str) -> str:
51:    return "\n" + "\n".join(output) + "\n"
52:
53:
54:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
55:    """read_data('test_name') -> 'input', 'output'"""
56:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
57:        name += ".py"
58:    _input: List[str] = []
59:    _output: List[str] = []
60:    base_dir = THIS_DIR / "data" if data else THIS_DIR
61:    with open(base_dir / name, "r", encoding="utf8") as test:
62:        lines = test.readlines()
63:    result = _input
64:    for line in lines:
65:        line = line.replace(EMPTY_LINE, "")
66:        if line.rstrip() == "# output":
67:            result = _output
68:            continue
69:
70:        result.append(line)
71:    if _input and not _output:
72:        # If there's no output marker, treat the entire file as already pre-formatted.
73:        _output = _input[:]
74:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
75:
76:
77:@contextmanager
78:def cache_dir(exists: bool = True) -> Iterator[Path]:
79:    with TemporaryDirectory() as workspace:
80:        cache_dir = Path(workspace)
81:        if not exists:
82:            cache_dir = cache_dir / "new"
83:        with patch("black.CACHE_DIR", cache_dir):
84:            yield cache_dir
85:
86:
87:@contextmanager
88:def event_loop(close: bool) -> Iterator[None]:
89:    policy = asyncio.get_event_loop_policy()
90:    old_loop = policy.get_event_loop()
91:    loop = policy.new_event_loop()
92:    asyncio.set_event_loop(loop)
93:    try:
94:        yield
95:
96:    finally:
97:        policy.set_event_loop(old_loop)
98:        if close:
99:            loop.close()
100:
101:
102:def async_test(f: Callable[..., Coroutine[Any, None, R]]) -> Callable[..., None]:
103:    @event_loop(close=True)
104:    @wraps(f)
105:    def wrapper(*args: Any, **kwargs: Any) -> None:
106:        asyncio.get_event_loop().run_until_complete(f(*args, **kwargs))
107:
108:    return wrapper
109:
110:
111:class BlackRunner(CliRunner):
112:    """Modify CliRunner so that stderr is not merged with stdout.
113:
114:    This is a hack that can be removed once we depend on Click 7.x"""
115:
116:    def __init__(self) -> None:
117:        self.stderrbuf = BytesIO()
118:        self.stdoutbuf = BytesIO()
119:        self.stdout_bytes = b""
120:        self.stderr_bytes = b""

Calling tool: globTool
**/tests/data/comments6.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/comments6.py
1:from typing import Any, Tuple
2:
3:
4:def f(
5:    a,  # type: int
6:):
7:    pass
8:
9:
10:# test type comments
11:def f(a, b, c, d, e, f, g, h, i):
12:    # type: (int, int, int, int, int, int, int, int, int) -> None
13:    pass
14:
15:
16:def f(
17:    a,  # type: int
18:    b,  # type: int
19:    c,  # type: int
20:    d,  # type: int
21:    e,  # type: int
22:    f,  # type: int
23:    g,  # type: int
24:    h,  # type: int
25:    i,  # type: int
26:):
27:    # type: (...) -> None
28:    pass
29:
30:
31:def f(
32:    arg,  # type: int
33:    *args,  # type: *Any
34:    default=False,  # type: bool
35:    **kwargs,  # type: **Any
36:):
37:    # type: (...) -> None
38:    pass
39:
40:
41:def f(
42:    a,  # type: int
43:    b,  # type: int
44:    c,  # type: int
45:    d,  # type: int
46:):
47:    # type: (...) -> None
48:
49:    element = 0  # type: int
50:    another_element = 1  # type: float
51:    another_element_with_long_name = 2  # type: int
52:    another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style = (
53:        3
54:    )  # type: int
55:
56:    tup = (
57:        another_element,  # type: int
58:        another_really_really_long_element_with_a_unnecessarily_long_name_to_describe_what_it_does_enterprise_style,  # type: int
59:    )  # type: Tuple[int, int]
60:
61:    a = (
62:        element
63:        + another_element
64:        + another_element_with_long_name
65:        + element
66:        + another_element
67:        + another_element_with_long_name
68:    )  # type: int

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: tests/data/comments6.py contains no # output marker. The read_data() helper treats such files as pre-formatted and returns the input as expected output, so test_comments6 asserts formatting is a no-op.

Todo item 8 of 12 is correct
description: 'Check that `tests/data/comments6.py` has no `# output` marker so `read_data("comments6")` returns the input as expected output; thus the test asserts formatting is a no-op for these cases.'

Validating todo item 9 of 12
description: 'Ensure `tests/test_black.py::BlackTestCase.test_comments6` loads `comments6` and asserts format equality (`self.assertFormatEqual(expected, actual)`), equivalence (`black.assert_equivalent`), and stability, tying the test to the PR requirement.'

Calling tool: grepTool
def test_comments6
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:366:    def test_comments6(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
340:
341:    @patch("black.dump_to_file", dump_to_stderr)
342:    def test_comments3(self) -> None:
343:        source, expected = read_data("comments3")
344:        actual = fs(source)
345:        self.assertFormatEqual(expected, actual)
346:        black.assert_equivalent(source, actual)
347:        black.assert_stable(source, actual, line_length=ll)
348:
349:    @patch("black.dump_to_file", dump_to_stderr)
350:    def test_comments4(self) -> None:
351:        source, expected = read_data("comments4")
352:        actual = fs(source)
353:        self.assertFormatEqual(expected, actual)
354:        black.assert_equivalent(source, actual)
355:        black.assert_stable(source, actual, line_length=ll)
356:
357:    @patch("black.dump_to_file", dump_to_stderr)
358:    def test_comments5(self) -> None:
359:        source, expected = read_data("comments5")
360:        actual = fs(source)
361:        self.assertFormatEqual(expected, actual)
362:        black.assert_equivalent(source, actual)
363:        black.assert_stable(source, actual, line_length=ll)
364:
365:    @patch("black.dump_to_file", dump_to_stderr)
366:    def test_comments6(self) -> None:
367:        source, expected = read_data("comments6")
368:        actual = fs(source)
369:        self.assertFormatEqual(expected, actual)
370:        black.assert_equivalent(source, actual)
371:        black.assert_stable(source, actual, line_length=ll)
372:
373:    @patch("black.dump_to_file", dump_to_stderr)
374:    def test_cantfit(self) -> None:
375:        source, expected = read_data("cantfit")
376:        actual = fs(source)
377:        self.assertFormatEqual(expected, actual)
378:        black.assert_equivalent(source, actual)
379:        black.assert_stable(source, actual, line_length=ll)
380:
381:    @patch("black.dump_to_file", dump_to_stderr)
382:    def test_import_spacing(self) -> None:
383:        source, expected = read_data("import_spacing")
384:        actual = fs(source)
385:        self.assertFormatEqual(expected, actual)
386:        black.assert_equivalent(source, actual)
387:        black.assert_stable(source, actual, line_length=ll)
388:
389:    @patch("black.dump_to_file", dump_to_stderr)
390:    def test_composition(self) -> None:
391:        source, expected = read_data("composition")
392:        actual = fs(source)
393:        self.assertFormatEqual(expected, actual)
394:        black.assert_equivalent(source, actual)
395:        black.assert_stable(source, actual, line_length=ll)
396:
397:    @patch("black.dump_to_file", dump_to_stderr)
398:    def test_empty_lines(self) -> None:
399:        source, expected = read_data("empty_lines")
400:        actual = fs(source)
401:        self.assertFormatEqual(expected, actual)
402:        black.assert_equivalent(source, actual)
403:        black.assert_stable(source, actual, line_length=ll)
404:
405:    @patch("black.dump_to_file", dump_to_stderr)
406:    def test_string_prefixes(self) -> None:
407:        source, expected = read_data("string_prefixes")
408:        actual = fs(source)
409:        self.assertFormatEqual(expected, actual)
410:        black.assert_equivalent(source, actual)
411:        black.assert_stable(source, actual, line_length=ll)
412:
413:    @patch("black.dump_to_file", dump_to_stderr)
414:    def test_numeric_literals(self) -> None:
415:        source, expected = read_data("numeric_literals")
416:        actual = fs(source, mode=black.FileMode.PYTHON36)
417:        self.assertFormatEqual(expected, actual)
418:        black.assert_equivalent(source, actual)
419:        black.assert_stable(source, actual, line_length=ll)

Calling tool: grepTool
class BlackTestCase
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py:136:class BlackTestCase(unittest.TestCase):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/test_black.py:136:class BlackTestCase(unittest.TestCase):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/test_black.py
120:        self.stderr_bytes = b""
121:        super().__init__()
122:
123:    @contextmanager
124:    def isolation(self, *args: Any, **kwargs: Any) -> Generator[BinaryIO, None, None]:
125:        with super().isolation(*args, **kwargs) as output:
126:            try:
127:                hold_stderr = sys.stderr
128:                sys.stderr = TextIOWrapper(self.stderrbuf, encoding=self.charset)
129:                yield output
130:            finally:
131:                self.stdout_bytes = sys.stdout.buffer.getvalue()  # type: ignore
132:                self.stderr_bytes = sys.stderr.buffer.getvalue()  # type: ignore
133:                sys.stderr = hold_stderr
134:
135:
136:class BlackTestCase(unittest.TestCase):
137:    maxDiff = None
138:
139:    def assertFormatEqual(self, expected: str, actual: str) -> None:
140:        if actual != expected and not os.environ.get("SKIP_AST_PRINT"):
141:            bdv: black.DebugVisitor[Any]
142:            black.out("Expected tree:", fg="green")
143:            try:
144:                exp_node = black.lib2to3_parse(expected)
145:                bdv = black.DebugVisitor()
146:                list(bdv.visit(exp_node))
147:            except Exception as ve:
148:                black.err(str(ve))
149:            black.out("Actual tree:", fg="red")
150:            try:
151:                exp_node = black.lib2to3_parse(actual)
152:                bdv = black.DebugVisitor()
153:                list(bdv.visit(exp_node))
154:            except Exception as ve:
155:                black.err(str(ve))
156:        self.assertEqual(expected, actual)
157:
158:    @patch("black.dump_to_file", dump_to_stderr)
159:    def test_empty(self) -> None:
160:        source = expected = ""
161:        actual = fs(source)
162:        self.assertFormatEqual(expected, actual)
163:        black.assert_equivalent(source, actual)
164:        black.assert_stable(source, actual, line_length=ll)
165:
166:    def test_empty_ff(self) -> None:
167:        expected = ""
168:        tmp_file = Path(black.dump_to_file())
169:        try:
170:            self.assertFalse(ff(tmp_file, write_back=black.WriteBack.YES))
171:            with open(tmp_file, encoding="utf8") as f:
172:                actual = f.read()
173:        finally:
174:            os.unlink(tmp_file)
175:        self.assertFormatEqual(expected, actual)
176:
177:    @patch("black.dump_to_file", dump_to_stderr)
178:    def test_self(self) -> None:
179:        source, expected = read_data("test_black", data=False)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Found tests/test_black.py::BlackTestCase.test_comments6. It loads comments6 via read_data("comments6"), formats with fs(source), and asserts format equality, equivalence, and stability (assertFormatEqual, black.assert_equivalent, black.assert_stable).

Todo item 9 of 12 is correct
description: 'Ensure `tests/test_black.py::BlackTestCase.test_comments6` loads `comments6` and asserts format equality (`self.assertFormatEqual(expected, actual)`), equivalence (`black.assert_equivalent`), and stability, tying the test to the PR requirement.'

Validating todo item 10 of 12
description: 'Confirm there are no other code paths in `split_line()` that could later recombine function parameters into a single line when `has_special_comment` is True (i.e., after bypassing the early return, it proceeds into splitting strategies without concatenating into a flat one-liner).'

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2088:        return "#"
2089:
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2205:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2206:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2207:    bracket_split_succeeded_or_raise(head, body, tail)

Calling tool: grepTool
def right_hand_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2202:def right_hand_split(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2213:def right_hand_split(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2208:    for result in (head, body, tail):
2209:        if result:
2210:            yield result
2211:
2212:
2213:def right_hand_split(
2214:    line: Line, line_length: int, py36: bool = False, omit: Collection[LeafID] = ()
2215:) -> Iterator[Line]:
2216:    """Split line into many lines, starting with the last matching bracket pair.
2217:
2218:    If the split was by optional parentheses, attempt splitting without them, too.
2219:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2220:    this split.
2221:
2222:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2223:    """
2224:    tail_leaves: List[Leaf] = []
2225:    body_leaves: List[Leaf] = []
2226:    head_leaves: List[Leaf] = []
2227:    current_leaves = tail_leaves
2228:    opening_bracket = None
2229:    closing_bracket = None
2230:    for leaf in reversed(line.leaves):
2231:        if current_leaves is body_leaves:
2232:            if leaf is opening_bracket:
2233:                current_leaves = head_leaves if body_leaves else tail_leaves
2234:        current_leaves.append(leaf)
2235:        if current_leaves is tail_leaves:
2236:            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:
2237:                opening_bracket = leaf.opening_bracket
2238:                closing_bracket = leaf
2239:                current_leaves = body_leaves
2240:    if not (opening_bracket and closing_bracket and head_leaves):
2241:        # If there is no opening or closing_bracket that means the split failed and
2242:        # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means
2243:        # the matching `opening_bracket` wasn't available on `line` anymore.
2244:        raise CannotSplit("No brackets found")
2245:
2246:    tail_leaves.reverse()
2247:    body_leaves.reverse()
2248:    head_leaves.reverse()
2249:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
2250:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
2251:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
2252:    bracket_split_succeeded_or_raise(head, body, tail)
2253:    if (
2254:        # the body shouldn't be exploded
2255:        not body.should_explode
2256:        # the opening bracket is an optional paren
2257:        and opening_bracket.type == token.LPAR
2258:        and not opening_bracket.value
2259:        # the closing bracket is an optional paren
2260:        and closing_bracket.type == token.RPAR
2261:        and not closing_bracket.value
2262:        # it's not an import (optional parens are the only thing we can split on
2263:        # in this case; attempting a split without them is a waste of time)
2264:        and not line.is_import
2265:        # there are no standalone comments in the body
2266:        and not body.contains_standalone_comments(0)
2267:        # and we can actually remove the parens
2268:        and can_omit_invisible_parens(body, line_length)
2269:    ):
2270:        omit = {id(closing_bracket), *omit}
2271:        try:
2272:            yield from right_hand_split(line, line_length, py36=py36, omit=omit)
2273:            return
2274:
2275:        except CannotSplit:
2276:            if not (
2277:                can_be_split(body)
2278:                or is_line_short_enough(body, line_length=line_length)
2279:            ):
2280:                raise CannotSplit(
2281:                    "Splitting failed, body is still too long and can't be split."
2282:                )
2283:
2284:            elif head.contains_multiline_strings() or tail.contains_multiline_strings():
2285:                raise CannotSplit(
2286:                    "The current optional pair of parentheses is bound to fail to "
2287:                    "satisfy the splitting algorithm because the head or the tail "
2288:                    "contains multiline strings which by definition never fit one "
2289:                    "line."
2290:                )
2291:
2292:    ensure_visible(opening_bracket)
2293:    ensure_visible(closing_bracket)
2294:    for result in (head, body, tail):
2295:        if result:
2296:            yield result
2297:
2298:
2299:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
2300:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
2301:
2302:    Do nothing otherwise.
2303:
2304:    A left- or right-hand split is based on a pair of brackets. Content before
2305:    (and including) the opening bracket is left on one line, content inside the
2306:    brackets is put on a separate line, and finally content starting with and
2307:    following the closing bracket is put on a separate line.
2308:
2309:    Those are called `head`, `body`, and `tail`, respectively. If the split
2310:    produced the same line (all content in `head`) or ended up with an empty `body`
2311:    and the `tail` is just the closing bracket, then it's considered failed.
2312:    """
2313:    tail_len = len(str(tail).strip())
2314:    if not body:
2315:        if tail_len == 0:
2316:            raise CannotSplit("Splitting brackets produced the same line")
2317:
2318:        elif tail_len < 3:
2319:            raise CannotSplit(
2320:                f"Splitting brackets on an empty body to save "
2321:                f"{tail_len} characters is not worth it"
2322:            )
2323:
2324:
2325:def bracket_split_build_line(
2326:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2327:) -> Line:
2328:    """Return a new line with given `leaves` and respective comments from `original`.
2329:
2330:    If `is_body` is True, the result line is one-indented inside brackets and as such
2331:    has its first leaf's prefix normalized and a trailing comma added when expected.
2332:    """
2333:    result = Line(depth=original.depth)
2334:    if is_body:
2335:        result.inside_brackets = True
2336:        result.depth += 1
2337:        if leaves:
2338:            # Since body is a new indent level, remove spurious leading whitespace.
2339:            normalize_prefix(leaves[0], inside_brackets=True)
2340:            # Ensure a trailing comma when expected.
2341:            if original.is_import:
2342:                if leaves[-1].type != token.COMMA:
2343:                    leaves.append(Leaf(token.COMMA, ","))
2344:    # Populate the line
2345:    for leaf in leaves:
2346:        result.append(leaf, preformatted=True)
2347:        for comment_after in original.comments_after(leaf):
2348:            result.append(comment_after, preformatted=True)
2349:    if is_body:
2350:        result.should_explode = should_explode(result, opening_bracket)
2351:    return result
2352:
2353:
2354:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2355:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2356:
2357:    This is a decorator over relevant split functions.
2358:    """
2359:
2360:    @wraps(split_func)
2361:    def split_wrapper(line: Line, py36: bool = False) -> Iterator[Line]:
2362:        for l in split_func(line, py36):
2363:            normalize_prefix(l.leaves[0], inside_brackets=True)
2364:            yield l
2365:
2366:    return split_wrapper
2367:
2368:
2369:@dont_increase_indentation
2370:def delimiter_split(line: Line, py36: bool = False) -> Iterator[Line]:
2371:    """Split according to delimiters of the highest priority.
2372:
2373:    If `py36` is True, the split will add trailing commas also in function
2374:    signatures that contain `*` and `**`.
2375:    """
2376:    try:
2377:        last_leaf = line.leaves[-1]
2378:    except IndexError:
2379:        raise CannotSplit("Line empty")
2380:
2381:    bt = line.bracket_tracker
2382:    try:
2383:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2384:    except ValueError:
2385:        raise CannotSplit("No delimiters found")
2386:
2387:    if delimiter_priority == DOT_PRIORITY:
2388:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2389:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2390:
2391:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2392:    lowest_depth = sys.maxsize
2393:    trailing_comma_safe = True
2394:
2395:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2396:        """Append `leaf` to current line or to new line if appending impossible."""
2397:        nonlocal current_line
2398:        try:
2399:            current_line.append_safe(leaf, preformatted=True)
2400:        except ValueError:
2401:            yield current_line
2402:
2403:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2404:            current_line.append(leaf)
2405:
2406:    for leaf in line.leaves:
2407:        yield from append_to_line(leaf)
2408:
2409:        for comment_after in line.comments_after(leaf):
2410:            yield from append_to_line(comment_after)
2411:
2412:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2413:        if leaf.bracket_depth == lowest_depth and is_vararg(
2414:            leaf, within=VARARGS_PARENTS
2415:        ):
2416:            trailing_comma_safe = trailing_comma_safe and py36
2417:        leaf_priority = bt.delimiters.get(id(leaf))
2418:        if leaf_priority == delimiter_priority:
2419:            yield current_line
2420:
2421:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2422:    if current_line:
2423:        if (
2424:            trailing_comma_safe
2425:            and delimiter_priority == COMMA_PRIORITY
2426:            and current_line.leaves[-1].type != token.COMMA
2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2428:        ):
2429:            current_line.append(Leaf(token.COMMA, ","))
2430:        yield current_line
2431:
2432:
2433:@dont_increase_indentation
2434:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
2435:    """Split standalone comments from the rest of the line."""
2436:    if not line.contains_standalone_comments(0):
2437:        raise CannotSplit("Line does not have any standalone comments")
2438:
2439:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2440:
2441:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2442:        """Append `leaf` to current line or to new line if appending impossible."""
2443:        nonlocal current_line
2444:        try:
2445:            current_line.append_safe(leaf, preformatted=True)
2446:        except ValueError:
2447:            yield current_line
2448:
2449:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2450:            current_line.append(leaf)
2451:
2452:    for leaf in line.leaves:
2453:        yield from append_to_line(leaf)
2454:
2455:        for comment_after in line.comments_after(leaf):
2456:            yield from append_to_line(comment_after)
2457:
2458:    if current_line:
2459:        yield current_line
2460:
2461:
2462:def is_import(leaf: Leaf) -> bool:
2463:    """Return True if the given leaf starts an import statement."""
2464:    p = leaf.parent
2465:    t = leaf.type
2466:    v = leaf.value
2467:    return bool(
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.
2508:
2509:    Note: Mutates its argument.
2510:    """
2511:    match = re.match(r"^([furbFURB]*)(.*)$", leaf.value, re.DOTALL)
2512:    assert match is not None, f"failed to match string {leaf.value!r}"
2513:    orig_prefix = match.group(1)
2514:    new_prefix = orig_prefix.lower()
2515:    if remove_u_prefix:
2516:        new_prefix = new_prefix.replace("u", "")
2517:    leaf.value = f"{new_prefix}{match.group(2)}"
2518:
2519:
2520:def normalize_string_quotes(leaf: Leaf) -> None:
2521:    """Prefer double quotes but only if it doesn't cause more escaping.
2522:
2523:    Adds or removes backslashes as appropriate. Doesn't parse and fix
2524:    strings nested in f-strings (yet).
2525:
2526:    Note: Mutates its argument.
2527:    """
2528:    value = leaf.value.lstrip("furbFURB")
2529:    if value[:3] == '"""':
2530:        return
2531:
2532:    elif value[:3] == "'''":
2533:        orig_quote = "'''"
2534:        new_quote = '"""'
2535:    elif value[0] == '"':
2536:        orig_quote = '"'
2537:        new_quote = "'"
2538:    else:
2539:        orig_quote = "'"
2540:        new_quote = '"'
2541:    first_quote_pos = leaf.value.find(orig_quote)
2542:    if first_quote_pos == -1:
2543:        return  # There's an internal error
2544:
2545:    prefix = leaf.value[:first_quote_pos]
2546:    unescaped_new_quote = re.compile(rf"(([^\\]|^)(\\\\)*){new_quote}")
2547:    escaped_new_quote = re.compile(rf"([^\\]|^)\\((?:\\\\)*){new_quote}")
2548:    escaped_orig_quote = re.compile(rf"([^\\]|^)\\((?:\\\\)*){orig_quote}")
2549:    body = leaf.value[first_quote_pos + len(orig_quote) : -len(orig_quote)]
2550:    if "r" in prefix.casefold():
2551:        if unescaped_new_quote.search(body):
2552:            # There's at least one unescaped new_quote in this raw string
2553:            # so converting is impossible
2554:            return
2555:
2556:        # Do not introduce or remove backslashes in raw strings
2557:        new_body = body
2558:    else:
2559:        # remove unnecessary escapes
2560:        new_body = sub_twice(escaped_new_quote, rf"\1\2{new_quote}", body)
2561:        if body != new_body:
2562:            # Consider the string without unnecessary escapes as the original
2563:            body = new_body
2564:            leaf.value = f"{prefix}{orig_quote}{body}{orig_quote}"
2565:        new_body = sub_twice(escaped_orig_quote, rf"\1\2{orig_quote}", new_body)
2566:        new_body = sub_twice(unescaped_new_quote, rf"\1\\{new_quote}", new_body)
2567:    if "f" in prefix.casefold():
2568:        matches = re.findall(r"[^{]\{(.*?)\}[^}]", new_body)
2569:        for m in matches:
2570:            if "\\" in str(m):
2571:                # Do not introduce backslashes in interpolated expressions
2572:                return
2573:    if new_quote == '"""' and new_body[-1:] == '"':
2574:        # edge case:
2575:        new_body = new_body[:-1] + '\\"'
2576:    orig_escape_count = body.count("\\")
2577:    new_escape_count = new_body.count("\\")
2578:    if new_escape_count > orig_escape_count:
2579:        return  # Do not introduce more escaping
2580:
2581:    if new_escape_count == orig_escape_count and orig_quote == '"':
2582:        return  # Prefer double quotes
2583:
2584:    leaf.value = f"{prefix}{new_quote}{new_body}{new_quote}"
2585:
2586:
2587:def normalize_numeric_literal(leaf: Leaf, allow_underscores: bool) -> None:
2588:    """Normalizes numeric (float, int, and complex) literals.
2589:
2590:    All letters used in the representation are normalized to lowercase (except
2591:    in Python 2 long literals), and long number literals are split using underscores.
2592:    """
2593:    text = leaf.value.lower()
2594:    if text.startswith(("0o", "0b")):
2595:        # Leave octal and binary literals alone.
2596:        pass
2597:    elif text.startswith("0x"):
2598:        # Change hex literals to upper case.
2599:        before, after = text[:2], text[2:]
2600:        text = f"{before}{after.upper()}"
2601:    elif "e" in text:
2602:        before, after = text.split("e")
2603:        sign = ""
2604:        if after.startswith("-"):
2605:            after = after[1:]
2606:            sign = "-"
2607:        elif after.startswith("+"):
2608:            after = after[1:]
2609:        before = format_float_or_int_string(before, allow_underscores)
2610:        after = format_int_string(after, allow_underscores)
2611:        text = f"{before}e{sign}{after}"
2612:    elif text.endswith(("j", "l")):
2613:        number = text[:-1]
2614:        suffix = text[-1]
2615:        # Capitalize in "2L" because "l" looks too similar to "1".
2616:        if suffix == "l":
2617:            suffix = "L"
2618:        text = f"{format_float_or_int_string(number, allow_underscores)}{suffix}"
2619:    else:
2620:        text = format_float_or_int_string(text, allow_underscores)
2621:    leaf.value = text
2622:
2623:
2624:def format_float_or_int_string(text: str, allow_underscores: bool) -> str:
2625:    """Formats a float string like "1.0"."""
2626:    if "." not in text:
2627:        return format_int_string(text, allow_underscores)
2628:
2629:    before, after = text.split(".")
2630:    before = format_int_string(before, allow_underscores) if before else "0"
2631:    if after:
2632:        after = format_int_string(after, allow_underscores, count_from_end=False)
2633:    else:
2634:        after = "0"
2635:    return f"{before}.{after}"
2636:
2637:
2638:def format_int_string(
2639:    text: str, allow_underscores: bool, count_from_end: bool = True
2640:) -> str:
2641:    """Normalizes underscores in a string to e.g. 1_000_000.
2642:
2643:    Input must be a string of digits and optional underscores.
2644:    If count_from_end is False, we add underscores after groups of three digits
2645:    counting from the beginning instead of the end of the strings. This is used
2646:    for the fractional part of float literals.
2647:    """

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Reviewed split_line: when has_special_comment is True, the early single-line return is skipped. The remaining paths invoke left_hand_split (for defs) or delimiter/standalone/RHS splits. These functions yield multiple lines and never recombine into a flat one-liner; the only single-line yields are the guarded early return and a final fallback, which wont trigger for function defs with parentheses.

Todo item 10 of 12 is correct
description: 'Confirm there are no other code paths in `split_line()` that could later recombine function parameters into a single line when `has_special_comment` is True (i.e., after bypassing the early return, it proceeds into splitting strategies without concatenating into a flat one-liner).'

Validating todo item 11 of 12
description: 'Verify that the added helper `is_special_comment` is referenced only where intended (currently within `split_line`) and does not alter unrelated formatting behavior.'

Calling tool: grepTool
is_special_comment\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2121:            if leaf.type == token.COMMA and is_special_comment(comment):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2476:def is_special_comment(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:
2170:            yield from result
2171:            break
2172:
2173:    else:
2174:        yield line
2175:
2176:
2177:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2178:    """Split line into many lines, starting with the first matching bracket pair.
2179:
2180:    Note: this usually looks weird, only use this for function definitions.
2181:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2182:    :func:`right_hand_split` which also handles optional parentheses.
2183:    """
2184:    tail_leaves: List[Leaf] = []
2185:    body_leaves: List[Leaf] = []
2186:    head_leaves: List[Leaf] = []
2187:    current_leaves = head_leaves
2188:    matching_bracket = None
2189:    for leaf in line.leaves:
2190:        if (
2191:            current_leaves is body_leaves
2192:            and leaf.type in CLOSING_BRACKETS
2193:            and leaf.opening_bracket is matching_bracket
2194:        ):
2195:            current_leaves = tail_leaves if body_leaves else head_leaves
2196:        current_leaves.append(leaf)
2197:        if current_leaves is head_leaves:
2198:            if leaf.type in OPENING_BRACKETS:
2199:                matching_bracket = leaf
2200:                current_leaves = body_leaves
2201:    if not matching_bracket:
2202:        raise CannotSplit("No brackets found")
2203:
2204:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2205:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2206:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2207:    bracket_split_succeeded_or_raise(head, body, tail)
2208:    for result in (head, body, tail):
2209:        if result:
2210:            yield result
2211:
2212:
2213:def right_hand_split(
2214:    line: Line, line_length: int, py36: bool = False, omit: Collection[LeafID] = ()
2215:) -> Iterator[Line]:
2216:    """Split line into many lines, starting with the last matching bracket pair.
2217:
2218:    If the split was by optional parentheses, attempt splitting without them, too.
2219:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2220:    this split.
2221:
2222:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2223:    """
2224:    tail_leaves: List[Leaf] = []
2225:    body_leaves: List[Leaf] = []
2226:    head_leaves: List[Leaf] = []
2227:    current_leaves = tail_leaves
2228:    opening_bracket = None
2229:    closing_bracket = None
2230:    for leaf in reversed(line.leaves):
2231:        if current_leaves is body_leaves:
2232:            if leaf is opening_bracket:
2233:                current_leaves = head_leaves if body_leaves else tail_leaves
2234:        current_leaves.append(leaf)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Searched for is_special_comment usage and found only two occurrences: its definition and a single call inside split_line. Reviewed the modified split_line code block and confirmed the new logic only gatekeeps the early-return path when a special # type: comment follows a comma, leaving other formatting paths unchanged. No other parts of the code reference the helper, so unrelated behavior is unaffected.

Todo item 11 of 12 is correct
description: 'Verify that the added helper `is_special_comment` is referenced only where intended (currently within `split_line`) and does not alter unrelated formatting behavior.'

Validating todo item 12 of 12
description: 'Double-check imports/constants used by the change (e.g., `token`, `Leaf`, `Line`) are available in scope and the type hints are consistent with the rest of the module.'

Calling tool: grepTool
(?i)^import token|from\s+token\s+import|token\.
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
(?i)^import token|from\s+token\s+import|\btoken\.
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pytree.py:26:        # from .pgen2 import token // token.__dict__.items():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/Grammar.txt:132:# "test '=' test" is really "keyword '=' test", but we have no such token.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pgen2/tokenize.py:11:    the token type (see token.py)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/blib2to3/pgen2/tokenize.py:472:                    assert not token.endswith("\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:18:import tokenize
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:732:            name = token.tok_name[node.type]
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:760:            _type = token.tok_name.get(node.type, str(node.type))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:781:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:797:    token.LESS,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:798:    token.GREATER,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:799:    token.EQEQUAL,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:800:    token.NOTEQUAL,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:801:    token.LESSEQUAL,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:802:    token.GREATEREQUAL,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:805:    token.VBAR,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:806:    token.CIRCUMFLEX,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:807:    token.AMPER,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:808:    token.LEFTSHIFT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:809:    token.RIGHTSHIFT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:810:    token.PLUS,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:811:    token.MINUS,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:812:    token.STAR,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:813:    token.SLASH,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:814:    token.DOUBLESLASH,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:815:    token.PERCENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:816:    token.AT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:817:    token.TILDE,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:818:    token.DOUBLESTAR,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:820:STARS = {token.STAR, token.DOUBLESTAR}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:875:    token.VBAR: 9,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:876:    token.CIRCUMFLEX: 8,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:877:    token.AMPER: 7,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:878:    token.LEFTSHIFT: 6,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:879:    token.RIGHTSHIFT: 6,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:880:    token.PLUS: 5,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:881:    token.MINUS: 5,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:882:    token.STAR: 4,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:883:    token.SLASH: 4,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:884:    token.DOUBLESLASH: 4,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:885:    token.PERCENT: 4,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:886:    token.AT: 4,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:887:    token.TILDE: 3,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:888:    token.DOUBLESTAR: 2,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:919:        if leaf.type == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:973:        if leaf.type == token.NAME and leaf.value == "for":
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:985:            and leaf.type == token.NAME
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1000:        if leaf.type == token.NAME and leaf.value == "lambda":
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1012:            and leaf.type == token.COLON
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1022:        return self.bracket_match.get((self.depth - 1, token.RSQB))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import itertools
9:import keyword
10:import logging
11:from multiprocessing import Manager, freeze_support
12:import os
13:from pathlib import Path
14:import pickle
15:import re
16:import signal
17:import sys
18:import tokenize
19:from typing import (
20:    Any,
21:    Callable,
22:    Collection,
23:    Dict,
24:    Generator,
25:    Generic,
26:    Iterable,
27:    Iterator,
28:    List,
29:    Optional,
30:    Pattern,
31:    Sequence,
32:    Set,
33:    Tuple,
34:    TypeVar,
35:    Union,
36:    cast,
37:)
38:
39:from appdirs import user_cache_dir
40:from attr import dataclass, Factory
41:import click
42:import toml
43:
44:# lib2to3 fork
45:from blib2to3.pytree import Node, Leaf, type_repr
46:from blib2to3 import pygram, pytree
47:from blib2to3.pgen2 import driver, token
48:from blib2to3.pgen2.parse import ParseError
49:
50:
51:__version__ = "18.9b0"
52:DEFAULT_LINE_LENGTH = 88
53:DEFAULT_EXCLUDES = (
54:    r"/(\.eggs|\.git|\.hg|\.mypy_cache|\.nox|\.tox|\.venv|_build|buck-out|build|dist)/"
55:)
56:DEFAULT_INCLUDES = r"\.pyi?$"
57:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
58:
59:
60:# types
61:FileContent = str
62:Encoding = str
63:NewLine = str
64:Depth = int
65:NodeType = int
66:LeafID = int
67:Priority = int
68:Index = int
69:LN = Union[Leaf, Node]
70:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
71:Timestamp = float
72:FileSize = int
73:CacheInfo = Tuple[Timestamp, FileSize]
74:Cache = Dict[Path, CacheInfo]
75:out = partial(click.secho, bold=True, err=True)
76:err = partial(click.secho, fg="red", err=True)
77:
78:pygram.initialize(CACHE_DIR)
79:syms = pygram.python_symbols
80:
81:
82:class NothingChanged(UserWarning):
83:    """Raised when reformatted code is the same as source."""
84:
85:
86:class CannotSplit(Exception):
87:    """A readable split that fits the allotted line length is impossible."""
88:
89:
90:class InvalidInput(ValueError):
91:    """Raised when input source code fails all parse attempts."""
92:
93:
94:class WriteBack(Enum):
95:    NO = 0
96:    YES = 1
97:    DIFF = 2
98:    CHECK = 3
99:
100:    @classmethod
101:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
102:        if check and not diff:
103:            return cls.CHECK
104:
105:        return cls.DIFF if diff else cls.YES
106:
107:
108:class Changed(Enum):
109:    NO = 0
110:    CACHED = 1
111:    YES = 2
112:
113:
114:class FileMode(Flag):
115:    AUTO_DETECT = 0
116:    PYTHON36 = 1
117:    PYI = 2
118:    NO_STRING_NORMALIZATION = 4
119:    NO_NUMERIC_UNDERSCORE_NORMALIZATION = 8
120:

Calling tool: grepTool
\bSTANDALONE_COMMENT\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2735:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2765:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3051:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:793:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1161:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1231:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1241:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1608:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2023:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2067:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2416:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2714:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2744:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3029:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2380:
2381:    bt = line.bracket_tracker
2382:    try:
2383:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2384:    except ValueError:
2385:        raise CannotSplit("No delimiters found")
2386:
2387:    if delimiter_priority == DOT_PRIORITY:
2388:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2389:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2390:
2391:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2392:    lowest_depth = sys.maxsize
2393:    trailing_comma_safe = True
2394:
2395:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2396:        """Append `leaf` to current line or to new line if appending impossible."""
2397:        nonlocal current_line
2398:        try:
2399:            current_line.append_safe(leaf, preformatted=True)
2400:        except ValueError:
2401:            yield current_line
2402:
2403:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2404:            current_line.append(leaf)
2405:
2406:    for leaf in line.leaves:
2407:        yield from append_to_line(leaf)
2408:
2409:        for comment_after in line.comments_after(leaf):
2410:            yield from append_to_line(comment_after)
2411:
2412:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2413:        if leaf.bracket_depth == lowest_depth and is_vararg(
2414:            leaf, within=VARARGS_PARENTS
2415:        ):
2416:            trailing_comma_safe = trailing_comma_safe and py36
2417:        leaf_priority = bt.delimiters.get(id(leaf))
2418:        if leaf_priority == delimiter_priority:
2419:            yield current_line
2420:
2421:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2422:    if current_line:
2423:        if (
2424:            trailing_comma_safe
2425:            and delimiter_priority == COMMA_PRIORITY
2426:            and current_line.leaves[-1].type != token.COMMA
2427:            and current_line.leaves[-1].type != STANDALONE_COMMENT
2428:        ):
2429:            current_line.append(Leaf(token.COMMA, ","))
2430:        yield current_line
2431:
2432:
2433:@dont_increase_indentation
2434:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
2435:    """Split standalone comments from the rest of the line."""
2436:    if not line.contains_standalone_comments(0):
2437:        raise CannotSplit("Line does not have any standalone comments")
2438:
2439:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2440:
2441:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2442:        """Append `leaf` to current line or to new line if appending impossible."""
2443:        nonlocal current_line
2444:        try:
2445:            current_line.append_safe(leaf, preformatted=True)
2446:        except ValueError:
2447:            yield current_line
2448:
2449:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2450:            current_line.append(leaf)
2451:
2452:    for leaf in line.leaves:
2453:        yield from append_to_line(leaf)
2454:
2455:        for comment_after in line.comments_after(leaf):
2456:            yield from append_to_line(comment_after)
2457:
2458:    if current_line:
2459:        yield current_line
2460:
2461:
2462:def is_import(leaf: Leaf) -> bool:
2463:    """Return True if the given leaf starts an import statement."""
2464:    p = leaf.parent
2465:    t = leaf.type
2466:    v = leaf.value
2467:    return bool(
2468:        t == token.NAME
2469:        and (
2470:            (v == "import" and p and p.type == syms.import_name)
2471:            or (v == "from" and p and p.type == syms.import_from)
2472:        )
2473:    )
2474:
2475:
2476:def is_special_comment(leaf: Leaf) -> bool:
2477:    """Return True if the given leaf is a special comment.
2478:    Only returns true for type comments for now."""
2479:    t = leaf.type
2480:    v = leaf.value
2481:    return bool(
2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
2483:    )
2484:
2485:
2486:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2487:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2488:    else.
2489:
2490:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2491:    """
2492:    if not inside_brackets:
2493:        spl = leaf.prefix.split("#")
2494:        if "\\" not in spl[0]:
2495:            nl_count = spl[-1].count("\n")
2496:            if len(spl) > 1:
2497:                nl_count -= 1
2498:            leaf.prefix = "\n" * nl_count
2499:            return
2500:
2501:    leaf.prefix = ""
2502:
2503:
2504:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2505:    """Make all string prefixes lowercase.
2506:
2507:    If remove_u_prefix is given, also removes any u prefix from the string.
2508:
2509:    Note: Mutates its argument.
2510:    """
2511:    match = re.match(r"^([furbFURB]*)(.*)$", leaf.value, re.DOTALL)
2512:    assert match is not None, f"failed to match string {leaf.value!r}"
2513:    orig_prefix = match.group(1)
2514:    new_prefix = orig_prefix.lower()
2515:    if remove_u_prefix:
2516:        new_prefix = new_prefix.replace("u", "")
2517:    leaf.value = f"{new_prefix}{match.group(2)}"
2518:
2519:
2520:def normalize_string_quotes(leaf: Leaf) -> None:
2521:    """Prefer double quotes but only if it doesn't cause more escaping.
2522:
2523:    Adds or removes backslashes as appropriate. Doesn't parse and fix
2524:    strings nested in f-strings (yet).
2525:
2526:    Note: Mutates its argument.
2527:    """
2528:    value = leaf.value.lstrip("furbFURB")
2529:    if value[:3] == '"""':
2530:        return
2531:
2532:    elif value[:3] == "'''":
2533:        orig_quote = "'''"
2534:        new_quote = '"""'
2535:    elif value[0] == '"':
2536:        orig_quote = '"'
2537:        new_quote = "'"
2538:    else:
2539:        orig_quote = "'"

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2097:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
2090:    if content[0] == "#":
2091:        content = content[1:]
2092:    if content and content[0] not in " !:#'%":
2093:        content = " " + content
2094:    return "#" + content
2095:
2096:
2097:def split_line(
2098:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2099:) -> Iterator[Line]:
2100:    """Split a `line` into potentially many lines.
2101:
2102:    They should fit in the allotted `line_length` but might not be able to.
2103:    `inner` signifies that there were a pair of brackets somewhere around the
2104:    current `line`, possibly transitively. This means we can fallback to splitting
2105:    by delimiters if the LHS/RHS don't yield any results.
2106:
2107:    If `py36` is True, splitting may generate syntax that is only compatible
2108:    with Python 3.6 and later.
2109:    """
2110:    if line.is_comment:
2111:        yield line
2112:        return
2113:
2114:    line_str = str(line).strip("\n")
2115:
2116:    # we don't want to split special comments like type annotations
2117:    # https://github.com/python/typing/issues/186
2118:    has_special_comment = False
2119:    for leaf in line.leaves:
2120:        for comment in line.comments_after(leaf):
2121:            if leaf.type == token.COMMA and is_special_comment(comment):
2122:                has_special_comment = True
2123:
2124:    if (
2125:        not has_special_comment
2126:        and not line.should_explode
2127:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2128:    ):
2129:        yield line
2130:        return
2131:
2132:    split_funcs: List[SplitFunc]
2133:    if line.is_def:
2134:        split_funcs = [left_hand_split]
2135:    else:
2136:
2137:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2138:            for omit in generate_trailers_to_omit(line, line_length):
2139:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2140:                if is_line_short_enough(lines[0], line_length=line_length):
2141:                    yield from lines
2142:                    return
2143:
2144:            # All splits failed, best effort split with no omits.
2145:            # This mostly happens to multiline strings that are by definition
2146:            # reported as not fitting a single line.
2147:            yield from right_hand_split(line, py36)
2148:
2149:        if line.inside_brackets:
2150:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2151:        else:
2152:            split_funcs = [rhs]
2153:    for split_func in split_funcs:
2154:        # We are accumulating lines in `result` because we might want to abort
2155:        # mission and return the original line in the end, or attempt a different
2156:        # split altogether.
2157:        result: List[Line] = []
2158:        try:
2159:            for l in split_func(line, py36):
2160:                if str(l).strip("\n") == line_str:
2161:                    raise CannotSplit("Split function returned an unchanged result")
2162:
2163:                result.extend(
2164:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2165:                )
2166:        except CannotSplit:
2167:            continue
2168:
2169:        else:

Calling tool: grepTool
class\s+Line\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1026:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1026:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/docutils/parsers/rst/states.py:2913:class Line(SpecializedText):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/tabulate.pyi:8:class Line(NamedTuple):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/werkzeug/debug/tbtools.pyi:16:class Line:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1010:            self._lambda_argument_depths
1011:            and self._lambda_argument_depths[-1] == self.depth
1012:            and leaf.type == token.COLON
1013:        ):
1014:            self.depth -= 1
1015:            self._lambda_argument_depths.pop()
1016:            return True
1017:
1018:        return False
1019:
1020:    def get_open_lsqb(self) -> Optional[Leaf]:
1021:        """Return the most recent opening square bracket (if any)."""
1022:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1023:
1024:
1025:@dataclass
1026:class Line:
1027:    """Holds leaves and comments. Can be printed with `str(line)`."""
1028:
1029:    depth: int = 0
1030:    leaves: List[Leaf] = Factory(list)
1031:    # The LeafID keys of comments must remain ordered by the corresponding leaf's index
1032:    # in leaves
1033:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)
1034:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1035:    inside_brackets: bool = False
1036:    should_explode: bool = False
1037:
1038:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1039:        """Add a new `leaf` to the end of the line.
1040:
1041:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1042:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1043:        Trailing commas are maybe removed, unpacked for loop variables are
1044:        demoted from being delimiters.
1045:
1046:        Inline comments are put aside.
1047:        """
1048:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1049:        if not has_value:
1050:            return
1051:
1052:        if token.COLON == leaf.type and self.is_class_paren_empty:
1053:            del self.leaves[-2:]
1054:        if self.leaves and not preformatted:
1055:            # Note: at this point leaf.prefix should be empty except for
1056:            # imports, for which we only preserve newlines.
1057:            leaf.prefix += whitespace(
1058:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1059:            )
1060:        if self.inside_brackets or not preformatted:
1061:            self.bracket_tracker.mark(leaf)
1062:            self.maybe_remove_trailing_comma(leaf)
1063:        if not self.append_comment(leaf):
1064:            self.leaves.append(leaf)
1065:
1066:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1067:        """Like :func:`append()` but disallow invalid standalone comment structure.
1068:
1069:        Raises ValueError when any `leaf` is appended after a standalone comment
1070:        or when a standalone comment is not the first leaf on the line.
1071:        """
1072:        if self.bracket_tracker.depth == 0:
1073:            if self.is_comment:
1074:                raise ValueError("cannot append to standalone comments")
1075:
1076:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1077:                raise ValueError(
1078:                    "cannot append standalone comments to a populated line"
1079:                )
1080:
1081:        self.append(leaf, preformatted=preformatted)
1082:
1083:    @property
1084:    def is_comment(self) -> bool:
1085:        """Is this line a standalone comment?"""
1086:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1087:
1088:    @property
1089:    def is_decorator(self) -> bool:
1090:        """Is this line a decorator?"""
1091:        return bool(self) and self.leaves[0].type == token.AT
1092:
1093:    @property
1094:    def is_import(self) -> bool:
1095:        """Is this an import line?"""
1096:        return bool(self) and is_import(self.leaves[0])
1097:
1098:    @property
1099:    def is_class(self) -> bool:
1100:        """Is this line a class definition?"""
1101:        return (
1102:            bool(self)
1103:            and self.leaves[0].type == token.NAME
1104:            and self.leaves[0].value == "class"
1105:        )
1106:
1107:    @property
1108:    def is_stub_class(self) -> bool:
1109:        """Is this line a class definition with a body consisting only of "..."?"""
1110:        return self.is_class and self.leaves[-3:] == [
1111:            Leaf(token.DOT, ".") for _ in range(3)
1112:        ]
1113:
1114:    @property
1115:    def is_def(self) -> bool:
1116:        """Is this a function definition? (Also returns True for async defs.)"""
1117:        try:
1118:            first_leaf = self.leaves[0]
1119:        except IndexError:
1120:            return False
1121:
1122:        try:
1123:            second_leaf: Optional[Leaf] = self.leaves[1]
1124:        except IndexError:
1125:            second_leaf = None
1126:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1127:            first_leaf.type == token.ASYNC
1128:            and second_leaf is not None
1129:            and second_leaf.type == token.NAME

Calling tool: grepTool
def\s+comments_after\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
1238:            return False
1239:
1240:        if not self.leaves:
1241:            comment.type = STANDALONE_COMMENT
1242:            comment.prefix = ""
1243:            return False
1244:
1245:        else:
1246:            leaf_id = id(self.leaves[-1])
1247:            if leaf_id not in self.comments:
1248:                self.comments[leaf_id] = [comment]
1249:            else:
1250:                self.comments[leaf_id].append(comment)
1251:            return True
1252:
1253:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1254:        """Generate comments that should appear directly after `leaf`."""
1255:        return self.comments.get(id(leaf), [])
1256:
1257:    def remove_trailing_comma(self) -> None:
1258:        """Remove the trailing comma and moves the comments attached to it."""
1259:        # Remember, the LeafID keys of self.comments are ordered by the
1260:        # corresponding leaf's index in self.leaves
1261:        # If id(self.leaves[-2]) is in self.comments, the order doesn't change.
1262:        # Otherwise, we insert it into self.comments, and it becomes the last entry.
1263:        # However, since we delete id(self.leaves[-1]) from self.comments, the invariant
1264:        # is maintained
1265:        self.comments.setdefault(id(self.leaves[-2]), []).extend(
1266:            self.comments.get(id(self.leaves[-1]), [])
1267:        )
1268:        self.comments.pop(id(self.leaves[-1]), None)
1269:        self.leaves.pop()
1270:
1271:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1272:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1273:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1274:        if open_lsqb is None:
1275:            return False
1276:
1277:        subscript_start = open_lsqb.next_sibling

Calling tool: grepTool
def\s+is_line_short_enough\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:3464:def is_line_short_enough(line: Line, *, line_length: int, line_str: str = "") -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:3442:def is_line_short_enough(line: Line, *, line_length: int, line_str: str = "") -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
3450:        enumerate_reversed if reversed else enumerate,
3451:    )
3452:    for index, leaf in op(line.leaves):
3453:        length = len(leaf.prefix) + len(leaf.value)
3454:        if "\n" in leaf.value:
3455:            return  # Multiline strings, we can't continue.
3456:
3457:        comment: Optional[Leaf]
3458:        for comment in line.comments_after(leaf):
3459:            length += len(comment.value)
3460:
3461:        yield index, leaf, length
3462:
3463:
3464:def is_line_short_enough(line: Line, *, line_length: int, line_str: str = "") -> bool:
3465:    """Return True if `line` is no longer than `line_length`.
3466:
3467:    Uses the provided `line_str` rendering, if any, otherwise computes a new one.
3468:    """
3469:    if not line_str:
3470:        line_str = str(line).strip("\n")
3471:    return (
3472:        len(line_str) <= line_length
3473:        and "\n" not in line_str  # multiline strings
3474:        and not line.contains_standalone_comments()
3475:    )
3476:
3477:
3478:def can_be_split(line: Line) -> bool:
3479:    """Return False if the line cannot be split *for sure*.
3480:
3481:    This is not an exhaustive search but a cheap heuristic that we can use to
3482:    avoid some unfortunate formattings (mostly around wrapping unsplittable code
3483:    in unnecessary parentheses).
3484:    """
3485:    leaves = line.leaves
3486:    if len(leaves) < 2:
3487:        return False
3488:
3489:    if leaves[0].type == token.STRING and leaves[1].type == token.DOT:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py
776:            code = lib2to3_parse(code)
777:        list(v.visit(code))
778:
779:
780:KEYWORDS = set(keyword.kwlist)
781:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
782:FLOW_CONTROL = {"return", "raise", "break", "continue"}
783:STATEMENT = {
784:    syms.if_stmt,
785:    syms.while_stmt,
786:    syms.for_stmt,
787:    syms.try_stmt,
788:    syms.except_clause,
789:    syms.with_stmt,
790:    syms.funcdef,
791:    syms.classdef,
792:}
793:STANDALONE_COMMENT = 153
794:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
795:LOGIC_OPERATORS = {"and", "or"}
796:COMPARATORS = {
797:    token.LESS,
798:    token.GREATER,
799:    token.EQEQUAL,
800:    token.NOTEQUAL,
801:    token.LESSEQUAL,
802:    token.GREATEREQUAL,
803:}
804:MATH_OPERATORS = {
805:    token.VBAR,
806:    token.CIRCUMFLEX,
807:    token.AMPER,
808:    token.LEFTSHIFT,
809:    token.RIGHTSHIFT,
810:    token.PLUS,
811:    token.MINUS,
812:    token.STAR,
813:    token.SLASH,
814:    token.DOUBLESLASH,
815:    token.PERCENT,

Calling tool: grepTool
\btoken\.COMMENT\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:919:        if leaf.type == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1237:        if comment.type != token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1458:                elif comment.type == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:1626:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2065:            comment_type = token.COMMENT  # simple trailing comment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/black.py:2482:        (t == token.COMMENT or t == STANDALONE_COMMENT) and (v.startswith("# type:"))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/empty_lines.py:16:    if t == token.COMMENT:  # another trailing comment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/empty_lines.py:69:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/empty_lines.py:113:    if t == token.COMMENT:  # another trailing comment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/tests/data/empty_lines.py:164:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/data/empty_lines.py:16:    if t == token.COMMENT:  # another trailing comment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/data/empty_lines.py:69:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/data/empty_lines.py:113:    if t == token.COMMENT:  # another trailing comment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/tests/data/empty_lines.py:164:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:919:        if leaf.type == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1237:        if comment.type != token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1458:                elif comment.type == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:1626:    if t == token.COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2022:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2041:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-11/good/black/env/src/black/black.py:2065:            comment_type = token.COMMENT  # simple trailing comment

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified in black/black.py: token is imported from blib2to3.pgen2 (line 47), Leaf is imported (line 45), Line class is defined (line 1026) before usage in split_line signature (line 2097). STANDALONE_COMMENT is defined (line 793). The new is_special_comment(leaf: Leaf) -> bool (line 2476) matches module typing style (same as is_import). All identifiers are in scope and consistent.

Todo item 12 of 12 is correct
description: 'Double-check imports/constants used by the change (e.g., `token`, `Leaf`, `Line`) are available in scope and the type hints are consistent with the rest of the module.'


=== PHASE 2 COMPLETE ===

