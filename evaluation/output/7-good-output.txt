=== PHASE 1: ANALYSIS ===

[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_invisible_parens\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_tuple_assign",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "tupleassign", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black" ]
Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:
2820:                        first_idx = index
2821:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2822:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2823:                parent.insert_child(
2824:                    first_idx,
2825:                    Leaf(
2826:                        STANDALONE_COMMENT,
2827:                        hidden_value,

Calling tool: grepTool
test_tuple_assign
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_tuple_assign
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_tuple_assign
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py:546:    def test_tuple_assign(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py
520:
521:    @patch("black.dump_to_file", dump_to_stderr)
522:    def test_remove_empty_parentheses_after_class(self) -> None:
523:        source, expected = read_data("class_blank_parentheses")
524:        actual = fs(source)
525:        self.assertFormatEqual(expected, actual)
526:        black.assert_equivalent(source, actual)
527:        black.assert_stable(source, actual, black.FileMode())
528:
529:    @patch("black.dump_to_file", dump_to_stderr)
530:    def test_new_line_between_class_and_code(self) -> None:
531:        source, expected = read_data("class_methods_new_line")
532:        actual = fs(source)
533:        self.assertFormatEqual(expected, actual)
534:        black.assert_equivalent(source, actual)
535:        black.assert_stable(source, actual, black.FileMode())
536:
537:    @patch("black.dump_to_file", dump_to_stderr)
538:    def test_bracket_match(self) -> None:
539:        source, expected = read_data("bracketmatch")
540:        actual = fs(source)
541:        self.assertFormatEqual(expected, actual)
542:        black.assert_equivalent(source, actual)
543:        black.assert_stable(source, actual, black.FileMode())
544:
545:    @patch("black.dump_to_file", dump_to_stderr)
546:    def test_tuple_assign(self) -> None:
547:        source, expected = read_data("tupleassign")
548:        actual = fs(source)
549:        self.assertFormatEqual(expected, actual)
550:        black.assert_equivalent(source, actual)
551:        black.assert_stable(source, actual, black.FileMode())
552:
553:    def test_tab_comment_indentation(self) -> None:
554:        contents_tab = "if 1:\n\tif 2:\n\t\tpass\n\t# comment\n\tpass\n"
555:        contents_spc = "if 1:\n    if 2:\n        pass\n    # comment\n    pass\n"
556:        self.assertFormatEqual(contents_spc, fs(contents_spc))
557:        self.assertFormatEqual(contents_spc, fs(contents_tab))
558:
559:        contents_tab = "if 1:\n\tif 2:\n\t\tpass\n\t\t# comment\n\tpass\n"
560:        contents_spc = "if 1:\n    if 2:\n        pass\n        # comment\n    pass\n"
561:        self.assertFormatEqual(contents_spc, fs(contents_spc))
562:        self.assertFormatEqual(contents_spc, fs(contents_tab))
563:
564:        # mixed tabs and spaces (valid Python 2 code)
565:        contents_tab = "if 1:\n        if 2:\n\t\tpass\n\t# comment\n        pass\n"
566:        contents_spc = "if 1:\n    if 2:\n        pass\n    # comment\n    pass\n"
567:        self.assertFormatEqual(contents_spc, fs(contents_spc))
568:        self.assertFormatEqual(contents_spc, fs(contents_tab))
569:
570:        contents_tab = "if 1:\n        if 2:\n\t\tpass\n\t\t# comment\n        pass\n"
571:        contents_spc = "if 1:\n    if 2:\n        pass\n        # comment\n    pass\n"
572:        self.assertFormatEqual(contents_spc, fs(contents_spc))
573:        self.assertFormatEqual(contents_spc, fs(contents_tab))
574:
575:    def test_report_verbose(self) -> None:
576:        report = black.Report(verbose=True)
577:        out_lines = []
578:        err_lines = []
579:
580:        def out(msg: str, **kwargs: Any) -> None:
581:            out_lines.append(msg)
582:
583:        def err(msg: str, **kwargs: Any) -> None:
584:            err_lines.append(msg)
585:
586:        with patch("black.out", out), patch("black.err", err):
587:            report.done(Path("f1"), black.Changed.NO)
588:            self.assertEqual(len(out_lines), 1)
589:            self.assertEqual(len(err_lines), 0)
590:            self.assertEqual(out_lines[-1], "f1 already well formatted, good job.")
591:            self.assertEqual(unstyle(str(report)), "1 file left unchanged.")
592:            self.assertEqual(report.return_code, 0)
593:            report.done(Path("f2"), black.Changed.YES)
594:            self.assertEqual(len(out_lines), 2)
595:            self.assertEqual(len(err_lines), 0)
596:            self.assertEqual(out_lines[-1], "reformatted f2")
597:            self.assertEqual(
598:                unstyle(str(report)), "1 file reformatted, 1 file left unchanged."
599:            )

Calling tool: grepTool
tupleassign
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/bugsinpy_bug.info:4:test_file="tests/data/tupleassign.py;tests/test_black.py"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py:547:        source, expected = read_data("tupleassign")

Calling tool: globTool
**/tupleassign*
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black: No such file or directory (os error 2)


Calling tool: globTool
**/tests/data/*tupleassign*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/data/tupleassign.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/data/tupleassign.py
1:sdfjklsdfsjldkflkjsf, sdfjsdfjlksdljkfsdlkf, sdfsdjfklsdfjlksdljkf, sdsfsdfjskdflsfsdf = 1, 2, 3
2:
3:
4:# output
5:(
6:    sdfjklsdfsjldkflkjsf,
7:    sdfjsdfjlksdljkfsdlkf,
8:    sdfsdjfklsdfjlksdljkf,
9:    sdsfsdfjskdflsfsdf,
10:) = (1, 2, 3)

Calling tool: createTodo
Todo List Created
Todo List (9 items):
- [ ] In black.py, verify normalize_invisible_parens sets check_lpar = True when the first child (index == 0) is a Node of type syms.testlist_star_expr (the tuple LHS in assignments). (ID: todo-1)
- [ ] In normalize_invisible_parens, confirm that when check_lpar is True and the current child is not a multiline string Leaf, the child node is wrapped into a Node(syms.atom, [Leaf(token.LPAR, ""), child, Leaf(token.RPAR, "")]) and reinserted at the original index (i.e., invisible parentheses wrapping occurs). (ID: todo-2)
- [ ] Verify that during the above wrapping, the child's original prefix is preserved by moving it to the new atom node: prefix = child.prefix; child.prefix = ""; new_child.prefix = prefix; node.insert_child(index, new_child). (ID: todo-3)
- [ ] Ensure the guard to not wrap multiline strings is present: the wrap path is skipped when isinstance(child, Leaf) and is_multiline_string(child) is True. (ID: todo-4)
- [ ] Confirm that at the end of each loop iteration, check_lpar is updated using existing logic: check_lpar = isinstance(child, Leaf) and child.value in parens_after (no regressions to this behavior). (ID: todo-5)
- [ ] Validate that the special-case logic for import_from nodes remains unchanged and unaffected by the new tuple-assignment handling (i.e., parentheses for import_from are handled as before within the check_lpar block). (ID: todo-6)
- [ ] In tests/test_black.py, confirm BlackTestCase.test_tuple_assign reads data tupleassign via read_data("tupleassign"), formats with fs(source), and asserts equality to expected, and also calls black.assert_equivalent and black.assert_stable. (ID: todo-7)
- [ ] In tests/data/tupleassign.py, verify the input (before '# output') is a long tuple-unpack assignment without LHS parentheses and the expected output shows the LHS parenthesized and split across multiple lines, with the RHS formatted as a parenthesized tuple. (ID: todo-8)
- [ ] Check that the new condition triggers only at the first child (index == 0) to avoid adding parentheses in non-LHS positions, aligning with the PR intent to target tuple-unpack assignments' LHS. (ID: todo-9)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 9
description: 'In black.py, verify normalize_invisible_parens sets check_lpar = True when the first child (index == 0) is a Node of type syms.testlist_star_expr (the tuple LHS in assignments).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_invisible_parens\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:
2820:                        first_idx = index
2821:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2822:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2823:                parent.insert_child(
2824:                    first_idx,
2825:                    Leaf(
2826:                        STANDALONE_COMMENT,
2827:                        hidden_value,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True
2820:
2821:            previous_consumed = comment.consumed
2822:
2823:    return False
2824:
2825:
2826:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2827:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py within normalize_invisible_parens, lines 2729-2735 add a check for the first child: if index == 0 and isinstance(child, Node) and child.type == syms.testlist_star_expr then check_lpar is set to True, satisfying the requirement.


Todo item 1 of 9 is correct
description: 'In black.py, verify normalize_invisible_parens sets check_lpar = True when the first child (index == 0) is a Node of type syms.testlist_star_expr (the tuple LHS in assignments).'
Validating todo item 2 of 9
description: 'In normalize_invisible_parens, confirm that when check_lpar is True and the current child is not a multiline string Leaf, the child node is wrapped into a Node(syms.atom, [Leaf(token.LPAR, ""), child, Leaf(token.RPAR, "")]) and reinserted at the original index (i.e., invisible parentheses wrapping occurs).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_invisible_parens\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py within normalize_invisible_parens, when check_lpar is True and the child is not a multiline string Leaf, the code wraps the child in invisible parentheses and reinserts at the original index: lpar/rpar are created with empty strings, index = child.remove(), then node.insert_child(index, Node(syms.atom, [lpar, child, rpar])) with prefix preserved (lines ~2763â€“2772).


Todo item 2 of 9 is correct
description: 'In normalize_invisible_parens, confirm that when check_lpar is True and the current child is not a multiline string Leaf, the child node is wrapped into a Node(syms.atom, [Leaf(token.LPAR, ""), child, Leaf(token.RPAR, "")]) and reinserted at the original index (i.e., invisible parentheses wrapping occurs).'
Validating todo item 3 of 9
description: 'Verify that during the above wrapping, the child's original prefix is preserved by moving it to the new atom node: prefix = child.prefix; child.prefix = ""; new_child.prefix = prefix; node.insert_child(index, new_child).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_invisible_parens\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py

Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pyâ€™s normalize_invisible_parens, the wrapping branch now preserves the childâ€™s original prefix exactly as required: it assigns prefix = child.prefix, sets child.prefix = "", creates new_child = Node(...), then sets new_child.prefix = prefix and inserts it (lines 2768â€“2772).


Todo item 3 of 9 is correct
description: 'Verify that during the above wrapping, the child's original prefix is preserved by moving it to the new atom node: prefix = child.prefix; child.prefix = ""; new_child.prefix = prefix; node.insert_child(index, new_child).'
Validating todo item 4 of 9
description: 'Ensure the guard to not wrap multiline strings is present: the wrap path is skipped when isinstance(child, Leaf) and is_multiline_string(child) is True.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_invisible_parens\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def is_multiline_string\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:
2820:                        first_idx = index
2821:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2822:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2823:                parent.insert_child(
2824:                    first_idx,
2825:                    Leaf(

Calling tool: grepTool
def is_multiline_string\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2959:def is_multiline_string(leaf: Leaf) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2947:def is_multiline_string(leaf: Leaf) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/flake8/processor.py:379:def is_multiline_string(token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2948:    if p.type == syms.star_expr:
2949:        # Star expressions are also used as assignment targets in extended
2950:        # iterable unpacking (PEP 3132).  See what its parent is instead.
2951:        if not p.parent:
2952:            return False
2953:
2954:        p = p.parent
2955:
2956:    return p.type in within
2957:
2958:
2959:def is_multiline_string(leaf: Leaf) -> bool:
2960:    """Return True if `leaf` is a multiline string that actually spans many lines."""
2961:    value = leaf.value.lstrip("furbFURB")
2962:    return value[:3] in {'"""', "'''"} and "\n" in value
2963:
2964:
2965:def is_stub_suite(node: Node) -> bool:
2966:    """Return True if `node` is a suite with a stub body."""
2967:    if (
2968:        len(node.children) != 4
2969:        or node.children[0].type != token.NEWLINE
2970:        or node.children[1].type != token.INDENT
2971:        or node.children[3].type != token.DEDENT
2972:    ):
2973:        return False
2974:
2975:    return is_stub_body(node.children[2])
2976:
2977:
2978:def is_stub_body(node: LN) -> bool:
2979:    """Return True if `node` is a simple statement containing an ellipsis."""
2980:    if not isinstance(node, Node) or node.type != syms.simple_stmt:
2981:        return False
2982:
2983:    if len(node.children) != 2:
2984:        return False
2985:
2986:    child = node.children[0]
2987:    return (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True
2820:
2821:            previous_consumed = comment.consumed
2822:
2823:    return False
2824:
2825:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2938:        # iterable unpacking (PEP 3132).  See what its parent is instead.
2939:        if not p.parent:
2940:            return False
2941:
2942:        p = p.parent
2943:
2944:    return p.type in within
2945:
2946:
2947:def is_multiline_string(leaf: Leaf) -> bool:
2948:    """Return True if `leaf` is a multiline string that actually spans many lines."""
2949:    value = leaf.value.lstrip("furbFURB")
2950:    return value[:3] in {'"""', "'''"} and "\n" in value
2951:
2952:
2953:def is_stub_suite(node: Node) -> bool:
2954:    """Return True if `node` is a suite with a stub body."""
2955:    if (
2956:        len(node.children) != 4
2957:        or node.children[0].type != token.NEWLINE
2958:        or node.children[1].type != token.INDENT
2959:        or node.children[3].type != token.DEDENT
2960:    ):
2961:        return False
2962:
2963:    return is_stub_body(node.children[2])
2964:
2965:
2966:def is_stub_body(node: LN) -> bool:
2967:    """Return True if `node` is a simple statement containing an ellipsis."""
2968:    if not isinstance(node, Node) or node.type != syms.simple_stmt:
2969:        return False
2970:
2971:    if len(node.children) != 2:
2972:        return False
2973:
2974:    child = node.children[0]
2975:    return (
2976:        child.type == syms.atom
2977:        and len(child.children) == 3

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In normalize_invisible_parens, before wrapping a child in invisible parentheses, the code checks `elif not (isinstance(child, Leaf) and is_multiline_string(child)):` ensuring wrapping is skipped for multiline string leaves. Verified in both black/black.py and env/src/black/black.py implementations.


Todo item 4 of 9 is correct
description: 'Ensure the guard to not wrap multiline strings is present: the wrap path is skipped when isinstance(child, Leaf) and is_multiline_string(child) is True.'
Validating todo item 5 of 9
description: 'Confirm that at the end of each loop iteration, check_lpar is updated using existing logic: check_lpar = isinstance(child, Leaf) and child.value in parens_after (no regressions to this behavior).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_invisible_parens\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In `black.py`â€™s `normalize_invisible_parens`, the loop ends with `check_lpar = isinstance(child, Leaf) and child.value in parens_after` (line ~2774 in root file). This matches existing behavior and is unchanged despite added logic earlier in the loop. The env copy also retains the same end-of-loop update.


Todo item 5 of 9 is correct
description: 'Confirm that at the end of each loop iteration, check_lpar is updated using existing logic: check_lpar = isinstance(child, Leaf) and child.value in parens_after (no regressions to this behavior).'
Validating todo item 6 of 9
description: 'Validate that the special-case logic for import_from nodes remains unchanged and unaffected by the new tuple-assignment handling (i.e., parentheses for import_from are handled as before within the check_lpar block).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "import_from", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/{{FOLDER_PATH}}" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "import_from", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_invisible_parens\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
Calling tool: grepTool
import_from
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
import_from
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/blib2to3/pygram.pyi:55:    import_from: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/blib2to3/Grammar.txt:55:import_stmt: import_name | import_from
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/blib2to3/Grammar.txt:57:import_from: ('from' ('.'* dotted_name | '.'+)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:1666:        self.visit_import_from = partial(v, keywords=Ã˜, parens={"import"})
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:1892:    elif p.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:1991:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2554:            or (v == "from" and p and p.type == syms.import_from)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2750:            elif node.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:3026:    :func:`normalize_invible_parens` and :func:`visit_import_from`).
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:3039:        and opening_bracket.parent.type in {syms.atom, syms.import_from}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:3186:        elif first_child.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:1666:        self.visit_import_from = partial(v, keywords=Ã˜, parens={"import"})
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:1892:    elif p.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:1991:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2554:            or (v == "from" and p and p.type == syms.import_from)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2742:            elif node.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:3014:    :func:`normalize_invible_parens` and :func:`visit_import_from`).
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:3027:        and opening_bracket.parent.type in {syms.atom, syms.import_from}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:3174:        elif first_child.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/blib2to3/Grammar.txt:55:import_stmt: import_name | import_from
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/blib2to3/Grammar.txt:57:import_from: ('from' ('.'* dotted_name | '.'+)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/blib2to3/pygram.pyi:55:    import_from: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypyc/genopsvisitor.py:72:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypyc/genopsvisitor.py:73:        self.builder.visit_import_from(node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypyc/genops.py:283:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/pygments/lexers/_scilab_builtins.py:637:    'import_from_hdf5',
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/semanal.py:1688:    def visit_import_from(self, imp: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/checker.py:1935:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/strconv.py:113:    def visit_import_from(self, o: 'mypy.nodes.ImportFrom') -> str:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/nodes.py:368:        return visitor.visit_import_from(self)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/renaming.py:167:    def visit_import_from(self, imp: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/traverser.py:284:    def visit_import_from(self, o: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stats.py:91:    def visit_import_from(self, imp: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/reachability.py:275:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/reachability.py:292:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/visitor.py:242:    def visit_import_from(self, o: 'mypy.nodes.ImportFrom') -> T:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/visitor.py:335:    def visit_import_from(self, o: 'mypy.nodes.ImportFrom') -> T:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/semanal_pass1.py:79:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/semanal_pass1.py:81:        super().visit_import_from(node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/server/deps.py:328:    def visit_import_from(self, o: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/server/aststrip.py:175:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/treetransform.py:74:    def visit_import_from(self, node: ImportFrom) -> ImportFrom:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2/symbol.pyi:32:import_from: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stubgen.py:349:    def add_import_from(self, module: str, names: List[Tuple[str, Optional[str]]]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stubgen.py:513:        self.import_tracker.add_import_from("collections", [("namedtuple", None)])
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stubgen.py:533:            self.import_tracker.add_import_from("typing", [(t, alias)])
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stubgen.py:897:    def visit_import_from(self, o: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stubgen.py:945:        self.import_tracker.add_import_from('.' * relative + module, import_names)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/3/symbol.pyi:37:import_from: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2and3/lib2to3/pygram.pyi:54:    import_from: int

Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2698:        text = f"{format_float_or_int_string(number)}{suffix}"
2699:    else:
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2698:        text = f"{format_float_or_int_string(number)}{suffix}"
2699:    else:
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
1658:            v, keywords={"try", "except", "else", "finally"}, parens=Ã˜
1659:        )
1660:        self.visit_except_clause = partial(v, keywords={"except"}, parens=Ã˜)
1661:        self.visit_with_stmt = partial(v, keywords={"with"}, parens=Ã˜)
1662:        self.visit_funcdef = partial(v, keywords={"def"}, parens=Ã˜)
1663:        self.visit_classdef = partial(v, keywords={"class"}, parens=Ã˜)
1664:        self.visit_expr_stmt = partial(v, keywords=Ã˜, parens=ASSIGNMENTS)
1665:        self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})
1666:        self.visit_import_from = partial(v, keywords=Ã˜, parens={"import"})
1667:        self.visit_del_stmt = partial(v, keywords=Ã˜, parens={"del"})
1668:        self.visit_async_funcdef = self.visit_async_stmt
1669:        self.visit_decorated = self.visit_decorators
1670:
1671:
1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
1673:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1674:OPENING_BRACKETS = set(BRACKET.keys())
1675:CLOSING_BRACKETS = set(BRACKET.values())
1676:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1678:
1679:
1680:def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa: C901
1681:    """Return whitespace prefix if needed for the given `leaf`.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pyâ€™s normalize_invisible_parens, the import_from special-case remains inside the check_lpar block and its logic is unchanged. The new tuple-assignment handling only sets check_lpar early for testlist_star_expr at index 0 and does not affect import_from nodes, which still rely on parens_after={"import"} to trigger. Verified by comparing the modified file to the env/src baseline around lines ~2729â€“2761.


Todo item 6 of 9 is correct
description: 'Validate that the special-case logic for import_from nodes remains unchanged and unaffected by the new tuple-assignment handling (i.e., parentheses for import_from are handled as before within the check_lpar block).'
Validating todo item 7 of 9
description: 'In tests/test_black.py, confirm BlackTestCase.test_tuple_assign reads data tupleassign via read_data("tupleassign"), formats with fs(source), and asserts equality to expected, and also calls black.assert_equivalent and black.assert_stable.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def test_tuple_assign\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class BlackTestCase\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests"
]
Calling tool: grepTool
def test_tuple_assign\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py:546:    def test_tuple_assign(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py
520:
521:    @patch("black.dump_to_file", dump_to_stderr)
522:    def test_remove_empty_parentheses_after_class(self) -> None:
523:        source, expected = read_data("class_blank_parentheses")
524:        actual = fs(source)
525:        self.assertFormatEqual(expected, actual)
526:        black.assert_equivalent(source, actual)
527:        black.assert_stable(source, actual, black.FileMode())
528:
529:    @patch("black.dump_to_file", dump_to_stderr)
530:    def test_new_line_between_class_and_code(self) -> None:
531:        source, expected = read_data("class_methods_new_line")
532:        actual = fs(source)
533:        self.assertFormatEqual(expected, actual)
534:        black.assert_equivalent(source, actual)
535:        black.assert_stable(source, actual, black.FileMode())
536:
537:    @patch("black.dump_to_file", dump_to_stderr)
538:    def test_bracket_match(self) -> None:
539:        source, expected = read_data("bracketmatch")
540:        actual = fs(source)
541:        self.assertFormatEqual(expected, actual)
542:        black.assert_equivalent(source, actual)
543:        black.assert_stable(source, actual, black.FileMode())
544:
545:    @patch("black.dump_to_file", dump_to_stderr)
546:    def test_tuple_assign(self) -> None:
547:        source, expected = read_data("tupleassign")
548:        actual = fs(source)
549:        self.assertFormatEqual(expected, actual)
550:        black.assert_equivalent(source, actual)
551:        black.assert_stable(source, actual, black.FileMode())
552:
553:    def test_tab_comment_indentation(self) -> None:
554:        contents_tab = "if 1:\n\tif 2:\n\t\tpass\n\t# comment\n\tpass\n"
555:        contents_spc = "if 1:\n    if 2:\n        pass\n    # comment\n    pass\n"
556:        self.assertFormatEqual(contents_spc, fs(contents_spc))
557:        self.assertFormatEqual(contents_spc, fs(contents_tab))
558:
559:        contents_tab = "if 1:\n\tif 2:\n\t\tpass\n\t\t# comment\n\tpass\n"
560:        contents_spc = "if 1:\n    if 2:\n        pass\n        # comment\n    pass\n"
561:        self.assertFormatEqual(contents_spc, fs(contents_spc))
562:        self.assertFormatEqual(contents_spc, fs(contents_tab))
563:
564:        # mixed tabs and spaces (valid Python 2 code)
565:        contents_tab = "if 1:\n        if 2:\n\t\tpass\n\t# comment\n        pass\n"
566:        contents_spc = "if 1:\n    if 2:\n        pass\n    # comment\n    pass\n"
567:        self.assertFormatEqual(contents_spc, fs(contents_spc))
568:        self.assertFormatEqual(contents_spc, fs(contents_tab))
569:
570:        contents_tab = "if 1:\n        if 2:\n\t\tpass\n\t\t# comment\n        pass\n"
571:        contents_spc = "if 1:\n    if 2:\n        pass\n        # comment\n    pass\n"
572:        self.assertFormatEqual(contents_spc, fs(contents_spc))
573:        self.assertFormatEqual(contents_spc, fs(contents_tab))
574:
575:    def test_report_verbose(self) -> None:
576:        report = black.Report(verbose=True)
577:        out_lines = []
578:        err_lines = []
579:
580:        def out(msg: str, **kwargs: Any) -> None:
581:            out_lines.append(msg)
582:
583:        def err(msg: str, **kwargs: Any) -> None:
584:            err_lines.append(msg)
585:
586:        with patch("black.out", out), patch("black.err", err):
587:            report.done(Path("f1"), black.Changed.NO)
588:            self.assertEqual(len(out_lines), 1)
589:            self.assertEqual(len(err_lines), 0)
590:            self.assertEqual(out_lines[-1], "f1 already well formatted, good job.")
591:            self.assertEqual(unstyle(str(report)), "1 file left unchanged.")
592:            self.assertEqual(report.return_code, 0)
593:            report.done(Path("f2"), black.Changed.YES)
594:            self.assertEqual(len(out_lines), 2)
595:            self.assertEqual(len(err_lines), 0)
596:            self.assertEqual(out_lines[-1], "reformatted f2")
597:            self.assertEqual(
598:                unstyle(str(report)), "1 file reformatted, 1 file left unchanged."
599:            )
600:            report.done(Path("f3"), black.Changed.CACHED)
601:            self.assertEqual(len(out_lines), 3)
602:            self.assertEqual(len(err_lines), 0)
603:            self.assertEqual(
604:                out_lines[-1], "f3 wasn't modified on disk since last run."
605:            )
606:            self.assertEqual(
607:                unstyle(str(report)), "1 file reformatted, 2 files left unchanged."
608:            )
609:            self.assertEqual(report.return_code, 0)
610:            report.check = True
611:            self.assertEqual(report.return_code, 1)
612:            report.check = False
613:            report.failed(Path("e1"), "boom")
614:            self.assertEqual(len(out_lines), 3)
615:            self.assertEqual(len(err_lines), 1)
616:            self.assertEqual(err_lines[-1], "error: cannot format e1: boom")
617:            self.assertEqual(
618:                unstyle(str(report)),
619:                "1 file reformatted, 2 files left unchanged, "
620:                "1 file failed to reformat.",
621:            )
622:            self.assertEqual(report.return_code, 123)
623:            report.done(Path("f3"), black.Changed.YES)
624:            self.assertEqual(len(out_lines), 4)
625:            self.assertEqual(len(err_lines), 1)
626:            self.assertEqual(out_lines[-1], "reformatted f3")
627:            self.assertEqual(
628:                unstyle(str(report)),
629:                "2 files reformatted, 2 files left unchanged, "
630:                "1 file failed to reformat.",
631:            )
632:            self.assertEqual(report.return_code, 123)
633:            report.failed(Path("e2"), "boom")
634:            self.assertEqual(len(out_lines), 4)
635:            self.assertEqual(len(err_lines), 2)
636:            self.assertEqual(err_lines[-1], "error: cannot format e2: boom")
637:            self.assertEqual(
638:                unstyle(str(report)),
639:                "2 files reformatted, 2 files left unchanged, "

Calling tool: grepTool
class BlackTestCase\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py:139:class BlackTestCase(unittest.TestCase):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py
136:                sys.stderr = hold_stderr
137:
138:
139:class BlackTestCase(unittest.TestCase):
140:    maxDiff = None
141:
142:    def assertFormatEqual(self, expected: str, actual: str) -> None:
143:        if actual != expected and not os.environ.get("SKIP_AST_PRINT"):
144:            bdv: black.DebugVisitor[Any]
145:            black.out("Expected tree:", fg="green")
146:            try:
147:                exp_node = black.lib2to3_parse(expected)
148:                bdv = black.DebugVisitor()
149:                list(bdv.visit(exp_node))
150:            except Exception as ve:
151:                black.err(str(ve))
152:            black.out("Actual tree:", fg="red")
153:            try:
154:                exp_node = black.lib2to3_parse(actual)
155:                bdv = black.DebugVisitor()
156:                list(bdv.visit(exp_node))
157:            except Exception as ve:
158:                black.err(str(ve))
159:        self.assertEqual(expected, actual)
160:
161:    def invokeBlack(
162:        self, args: List[str], exit_code: int = 0, ignore_config: bool = True
163:    ) -> None:
164:        runner = BlackRunner()
165:        if ignore_config:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In tests/test_black.py within class BlackTestCase, test_tuple_assign reads source and expected via read_data("tupleassign"), formats with fs(source), asserts equality using self.assertFormatEqual, and calls black.assert_equivalent and black.assert_stable with black.FileMode().


Todo item 7 of 9 is correct
description: 'In tests/test_black.py, confirm BlackTestCase.test_tuple_assign reads data tupleassign via read_data("tupleassign"), formats with fs(source), and asserts equality to expected, and also calls black.assert_equivalent and black.assert_stable.'
Validating todo item 8 of 9
description: 'In tests/data/tupleassign.py, verify the input (before '# output') is a long tuple-unpack assignment without LHS parentheses and the expected output shows the LHS parenthesized and split across multiple lines, with the RHS formatted as a parenthesized tuple.'
Calling tool: globTool
**/tests/data/tupleassign.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/data/tupleassign.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/data/tupleassign.py
1:sdfjklsdfsjldkflkjsf, sdfjsdfjlksdljkfsdlkf, sdfsdjfklsdfjlksdljkf, sdsfsdfjskdflsfsdf = 1, 2, 3
2:
3:
4:# output
5:(
6:    sdfjklsdfsjldkflkjsf,
7:    sdfjsdfjlksdljkfsdlkf,
8:    sdfsdjfklsdfjlksdljkf,
9:    sdsfsdfjskdflsfsdf,
10:) = (1, 2, 3)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The test file shows an unparenthesized long tuple-unpack assignment on the LHS before '# output' and the expected output has the LHS parenthesized and split across multiple lines, with the RHS formatted as a parenthesized tuple '(1, 2, 3)'.


Todo item 8 of 9 is correct
description: 'In tests/data/tupleassign.py, verify the input (before '# output') is a long tuple-unpack assignment without LHS parentheses and the expected output shows the LHS parenthesized and split across multiple lines, with the RHS formatted as a parenthesized tuple.'
Validating todo item 9 of 9
description: 'Check that the new condition triggers only at the first child (index == 0) to avoid adding parentheses in non-LHS positions, aligning with the PR intent to target tuple-unpack assignments' LHS.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_invisible_parens\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black"
]
Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In normalize_invisible_parens, the new trigger is guarded by `index == 0` and `child.type == syms.testlist_star_expr` (lines 2729â€“2735), ensuring it only activates for the first child (LHS). Additionally, `check_lpar` is reset each iteration (line 2774), preventing it from affecting non-LHS positions.


Todo item 9 of 9 is correct
description: 'Check that the new condition triggers only at the first child (index == 0) to avoid adding parentheses in non-LHS positions, aligning with the PR intent to target tuple-unpack assignments' LHS.'
Validating todo item 1 of 9
description: 'In black.py, verify normalize_invisible_parens sets check_lpar = True when the first child (index == 0) is a Node of type syms.testlist_star_expr (the tuple LHS in assignments).'

Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:
2820:                        first_idx = index
2821:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2822:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2823:                parent.insert_child(
2824:                    first_idx,
2825:                    Leaf(
2826:                        STANDALONE_COMMENT,
2827:                        hidden_value,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True
2820:
2821:            previous_consumed = comment.consumed
2822:
2823:    return False
2824:
2825:
2826:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2827:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py within normalize_invisible_parens, lines 2729-2735 add a check for the first child: if index == 0 and isinstance(child, Node) and child.type == syms.testlist_star_expr then check_lpar is set to True, satisfying the requirement.

Todo item 1 of 9 is correct
description: 'In black.py, verify normalize_invisible_parens sets check_lpar = True when the first child (index == 0) is a Node of type syms.testlist_star_expr (the tuple LHS in assignments).'

Validating todo item 2 of 9
description: 'In normalize_invisible_parens, confirm that when check_lpar is True and the current child is not a multiline string Leaf, the child node is wrapped into a Node(syms.atom, [Leaf(token.LPAR, ""), child, Leaf(token.RPAR, "")]) and reinserted at the original index (i.e., invisible parentheses wrapping occurs).'

Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py within normalize_invisible_parens, when check_lpar is True and the child is not a multiline string Leaf, the code wraps the child in invisible parentheses and reinserts at the original index: lpar/rpar are created with empty strings, index = child.remove(), then node.insert_child(index, Node(syms.atom, [lpar, child, rpar])) with prefix preserved (lines ~2763â€“2772).

Todo item 2 of 9 is correct
description: 'In normalize_invisible_parens, confirm that when check_lpar is True and the current child is not a multiline string Leaf, the child node is wrapped into a Node(syms.atom, [Leaf(token.LPAR, ""), child, Leaf(token.RPAR, "")]) and reinserted at the original index (i.e., invisible parentheses wrapping occurs).'

Validating todo item 3 of 9
description: 'Verify that during the above wrapping, the child's original prefix is preserved by moving it to the new atom node: prefix = child.prefix; child.prefix = ""; new_child.prefix = prefix; node.insert_child(index, new_child).'

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py

Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pyâ€™s normalize_invisible_parens, the wrapping branch now preserves the childâ€™s original prefix exactly as required: it assigns prefix = child.prefix, sets child.prefix = "", creates new_child = Node(...), then sets new_child.prefix = prefix and inserts it (lines 2768â€“2772).

Todo item 3 of 9 is correct
description: 'Verify that during the above wrapping, the child's original prefix is preserved by moving it to the new atom node: prefix = child.prefix; child.prefix = ""; new_child.prefix = prefix; node.insert_child(index, new_child).'

Validating todo item 4 of 9
description: 'Ensure the guard to not wrap multiline strings is present: the wrap path is skipped when isinstance(child, Leaf) and is_multiline_string(child) is True.'

Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:
2820:                        first_idx = index
2821:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2822:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2823:                parent.insert_child(
2824:                    first_idx,
2825:                    Leaf(

Calling tool: grepTool
def is_multiline_string\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2959:def is_multiline_string(leaf: Leaf) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2947:def is_multiline_string(leaf: Leaf) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/flake8/processor.py:379:def is_multiline_string(token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2948:    if p.type == syms.star_expr:
2949:        # Star expressions are also used as assignment targets in extended
2950:        # iterable unpacking (PEP 3132).  See what its parent is instead.
2951:        if not p.parent:
2952:            return False
2953:
2954:        p = p.parent
2955:
2956:    return p.type in within
2957:
2958:
2959:def is_multiline_string(leaf: Leaf) -> bool:
2960:    """Return True if `leaf` is a multiline string that actually spans many lines."""
2961:    value = leaf.value.lstrip("furbFURB")
2962:    return value[:3] in {'"""', "'''"} and "\n" in value
2963:
2964:
2965:def is_stub_suite(node: Node) -> bool:
2966:    """Return True if `node` is a suite with a stub body."""
2967:    if (
2968:        len(node.children) != 4
2969:        or node.children[0].type != token.NEWLINE
2970:        or node.children[1].type != token.INDENT
2971:        or node.children[3].type != token.DEDENT
2972:    ):
2973:        return False
2974:
2975:    return is_stub_body(node.children[2])
2976:
2977:
2978:def is_stub_body(node: LN) -> bool:
2979:    """Return True if `node` is a simple statement containing an ellipsis."""
2980:    if not isinstance(node, Node) or node.type != syms.simple_stmt:
2981:        return False
2982:
2983:    if len(node.children) != 2:
2984:        return False
2985:
2986:    child = node.children[0]
2987:    return (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True
2820:
2821:            previous_consumed = comment.consumed
2822:
2823:    return False
2824:
2825:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2938:        # iterable unpacking (PEP 3132).  See what its parent is instead.
2939:        if not p.parent:
2940:            return False
2941:
2942:        p = p.parent
2943:
2944:    return p.type in within
2945:
2946:
2947:def is_multiline_string(leaf: Leaf) -> bool:
2948:    """Return True if `leaf` is a multiline string that actually spans many lines."""
2949:    value = leaf.value.lstrip("furbFURB")
2950:    return value[:3] in {'"""', "'''"} and "\n" in value
2951:
2952:
2953:def is_stub_suite(node: Node) -> bool:
2954:    """Return True if `node` is a suite with a stub body."""
2955:    if (
2956:        len(node.children) != 4
2957:        or node.children[0].type != token.NEWLINE
2958:        or node.children[1].type != token.INDENT
2959:        or node.children[3].type != token.DEDENT
2960:    ):
2961:        return False
2962:
2963:    return is_stub_body(node.children[2])
2964:
2965:
2966:def is_stub_body(node: LN) -> bool:
2967:    """Return True if `node` is a simple statement containing an ellipsis."""
2968:    if not isinstance(node, Node) or node.type != syms.simple_stmt:
2969:        return False
2970:
2971:    if len(node.children) != 2:
2972:        return False
2973:
2974:    child = node.children[0]
2975:    return (
2976:        child.type == syms.atom
2977:        and len(child.children) == 3

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In normalize_invisible_parens, before wrapping a child in invisible parentheses, the code checks `elif not (isinstance(child, Leaf) and is_multiline_string(child)):` ensuring wrapping is skipped for multiline string leaves. Verified in both black/black.py and env/src/black/black.py implementations.

Todo item 4 of 9 is correct
description: 'Ensure the guard to not wrap multiline strings is present: the wrap path is skipped when isinstance(child, Leaf) and is_multiline_string(child) is True.'

Validating todo item 5 of 9
description: 'Confirm that at the end of each loop iteration, check_lpar is updated using existing logic: check_lpar = isinstance(child, Leaf) and child.value in parens_after (no regressions to this behavior).'

Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In `black.py`â€™s `normalize_invisible_parens`, the loop ends with `check_lpar = isinstance(child, Leaf) and child.value in parens_after` (line ~2774 in root file). This matches existing behavior and is unchanged despite added logic earlier in the loop. The env copy also retains the same end-of-loop update.

Todo item 5 of 9 is correct
description: 'Confirm that at the end of each loop iteration, check_lpar is updated using existing logic: check_lpar = isinstance(child, Leaf) and child.value in parens_after (no regressions to this behavior).'

Validating todo item 6 of 9
description: 'Validate that the special-case logic for import_from nodes remains unchanged and unaffected by the new tuple-assignment handling (i.e., parentheses for import_from are handled as before within the check_lpar block).'

Calling tool: grepTool
import_from
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
import_from
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/blib2to3/pygram.pyi:55:    import_from: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/blib2to3/Grammar.txt:55:import_stmt: import_name | import_from
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/blib2to3/Grammar.txt:57:import_from: ('from' ('.'* dotted_name | '.'+)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:1666:        self.visit_import_from = partial(v, keywords=Ã˜, parens={"import"})
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:1892:    elif p.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:1991:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2554:            or (v == "from" and p and p.type == syms.import_from)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2750:            elif node.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:3026:    :func:`normalize_invible_parens` and :func:`visit_import_from`).
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:3039:        and opening_bracket.parent.type in {syms.atom, syms.import_from}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:3186:        elif first_child.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:1666:        self.visit_import_from = partial(v, keywords=Ã˜, parens={"import"})
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:1892:    elif p.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:1991:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2554:            or (v == "from" and p and p.type == syms.import_from)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2742:            elif node.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:3014:    :func:`normalize_invible_parens` and :func:`visit_import_from`).
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:3027:        and opening_bracket.parent.type in {syms.atom, syms.import_from}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:3174:        elif first_child.type == syms.import_from:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/blib2to3/Grammar.txt:55:import_stmt: import_name | import_from
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/blib2to3/Grammar.txt:57:import_from: ('from' ('.'* dotted_name | '.'+)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/blib2to3/pygram.pyi:55:    import_from: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypyc/genopsvisitor.py:72:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypyc/genopsvisitor.py:73:        self.builder.visit_import_from(node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypyc/genops.py:283:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/pygments/lexers/_scilab_builtins.py:637:    'import_from_hdf5',
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/semanal.py:1688:    def visit_import_from(self, imp: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/checker.py:1935:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/strconv.py:113:    def visit_import_from(self, o: 'mypy.nodes.ImportFrom') -> str:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/nodes.py:368:        return visitor.visit_import_from(self)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/renaming.py:167:    def visit_import_from(self, imp: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/traverser.py:284:    def visit_import_from(self, o: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stats.py:91:    def visit_import_from(self, imp: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/reachability.py:275:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/reachability.py:292:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/visitor.py:242:    def visit_import_from(self, o: 'mypy.nodes.ImportFrom') -> T:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/visitor.py:335:    def visit_import_from(self, o: 'mypy.nodes.ImportFrom') -> T:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/semanal_pass1.py:79:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/semanal_pass1.py:81:        super().visit_import_from(node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/server/deps.py:328:    def visit_import_from(self, o: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/server/aststrip.py:175:    def visit_import_from(self, node: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/treetransform.py:74:    def visit_import_from(self, node: ImportFrom) -> ImportFrom:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2/symbol.pyi:32:import_from: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stubgen.py:349:    def add_import_from(self, module: str, names: List[Tuple[str, Optional[str]]]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stubgen.py:513:        self.import_tracker.add_import_from("collections", [("namedtuple", None)])
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stubgen.py:533:            self.import_tracker.add_import_from("typing", [(t, alias)])
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stubgen.py:897:    def visit_import_from(self, o: ImportFrom) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/stubgen.py:945:        self.import_tracker.add_import_from('.' * relative + module, import_names)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/3/symbol.pyi:37:import_from: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2and3/lib2to3/pygram.pyi:54:    import_from: int

Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2698:        text = f"{format_float_or_int_string(number)}{suffix}"
2699:    else:
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py
2698:        text = f"{format_float_or_int_string(number)}{suffix}"
2699:    else:
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
1658:            v, keywords={"try", "except", "else", "finally"}, parens=Ã˜
1659:        )
1660:        self.visit_except_clause = partial(v, keywords={"except"}, parens=Ã˜)
1661:        self.visit_with_stmt = partial(v, keywords={"with"}, parens=Ã˜)
1662:        self.visit_funcdef = partial(v, keywords={"def"}, parens=Ã˜)
1663:        self.visit_classdef = partial(v, keywords={"class"}, parens=Ã˜)
1664:        self.visit_expr_stmt = partial(v, keywords=Ã˜, parens=ASSIGNMENTS)
1665:        self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})
1666:        self.visit_import_from = partial(v, keywords=Ã˜, parens={"import"})
1667:        self.visit_del_stmt = partial(v, keywords=Ã˜, parens={"del"})
1668:        self.visit_async_funcdef = self.visit_async_stmt
1669:        self.visit_decorated = self.visit_decorators
1670:
1671:
1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
1673:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1674:OPENING_BRACKETS = set(BRACKET.keys())
1675:CLOSING_BRACKETS = set(BRACKET.values())
1676:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1678:
1679:
1680:def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa: C901
1681:    """Return whitespace prefix if needed for the given `leaf`.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pyâ€™s normalize_invisible_parens, the import_from special-case remains inside the check_lpar block and its logic is unchanged. The new tuple-assignment handling only sets check_lpar early for testlist_star_expr at index 0 and does not affect import_from nodes, which still rely on parens_after={"import"} to trigger. Verified by comparing the modified file to the env/src baseline around lines ~2729â€“2761.

Todo item 6 of 9 is correct
description: 'Validate that the special-case logic for import_from nodes remains unchanged and unaffected by the new tuple-assignment handling (i.e., parentheses for import_from are handled as before within the check_lpar block).'

Validating todo item 7 of 9
description: 'In tests/test_black.py, confirm BlackTestCase.test_tuple_assign reads data tupleassign via read_data("tupleassign"), formats with fs(source), and asserts equality to expected, and also calls black.assert_equivalent and black.assert_stable.'

Calling tool: grepTool
def test_tuple_assign\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py:546:    def test_tuple_assign(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py
520:
521:    @patch("black.dump_to_file", dump_to_stderr)
522:    def test_remove_empty_parentheses_after_class(self) -> None:
523:        source, expected = read_data("class_blank_parentheses")
524:        actual = fs(source)
525:        self.assertFormatEqual(expected, actual)
526:        black.assert_equivalent(source, actual)
527:        black.assert_stable(source, actual, black.FileMode())
528:
529:    @patch("black.dump_to_file", dump_to_stderr)
530:    def test_new_line_between_class_and_code(self) -> None:
531:        source, expected = read_data("class_methods_new_line")
532:        actual = fs(source)
533:        self.assertFormatEqual(expected, actual)
534:        black.assert_equivalent(source, actual)
535:        black.assert_stable(source, actual, black.FileMode())
536:
537:    @patch("black.dump_to_file", dump_to_stderr)
538:    def test_bracket_match(self) -> None:
539:        source, expected = read_data("bracketmatch")
540:        actual = fs(source)
541:        self.assertFormatEqual(expected, actual)
542:        black.assert_equivalent(source, actual)
543:        black.assert_stable(source, actual, black.FileMode())
544:
545:    @patch("black.dump_to_file", dump_to_stderr)
546:    def test_tuple_assign(self) -> None:
547:        source, expected = read_data("tupleassign")
548:        actual = fs(source)
549:        self.assertFormatEqual(expected, actual)
550:        black.assert_equivalent(source, actual)
551:        black.assert_stable(source, actual, black.FileMode())
552:
553:    def test_tab_comment_indentation(self) -> None:
554:        contents_tab = "if 1:\n\tif 2:\n\t\tpass\n\t# comment\n\tpass\n"
555:        contents_spc = "if 1:\n    if 2:\n        pass\n    # comment\n    pass\n"
556:        self.assertFormatEqual(contents_spc, fs(contents_spc))
557:        self.assertFormatEqual(contents_spc, fs(contents_tab))
558:
559:        contents_tab = "if 1:\n\tif 2:\n\t\tpass\n\t\t# comment\n\tpass\n"
560:        contents_spc = "if 1:\n    if 2:\n        pass\n        # comment\n    pass\n"
561:        self.assertFormatEqual(contents_spc, fs(contents_spc))
562:        self.assertFormatEqual(contents_spc, fs(contents_tab))
563:
564:        # mixed tabs and spaces (valid Python 2 code)
565:        contents_tab = "if 1:\n        if 2:\n\t\tpass\n\t# comment\n        pass\n"
566:        contents_spc = "if 1:\n    if 2:\n        pass\n    # comment\n    pass\n"
567:        self.assertFormatEqual(contents_spc, fs(contents_spc))
568:        self.assertFormatEqual(contents_spc, fs(contents_tab))
569:
570:        contents_tab = "if 1:\n        if 2:\n\t\tpass\n\t\t# comment\n        pass\n"
571:        contents_spc = "if 1:\n    if 2:\n        pass\n        # comment\n    pass\n"
572:        self.assertFormatEqual(contents_spc, fs(contents_spc))
573:        self.assertFormatEqual(contents_spc, fs(contents_tab))
574:
575:    def test_report_verbose(self) -> None:
576:        report = black.Report(verbose=True)
577:        out_lines = []
578:        err_lines = []
579:
580:        def out(msg: str, **kwargs: Any) -> None:
581:            out_lines.append(msg)
582:
583:        def err(msg: str, **kwargs: Any) -> None:
584:            err_lines.append(msg)
585:
586:        with patch("black.out", out), patch("black.err", err):
587:            report.done(Path("f1"), black.Changed.NO)
588:            self.assertEqual(len(out_lines), 1)
589:            self.assertEqual(len(err_lines), 0)
590:            self.assertEqual(out_lines[-1], "f1 already well formatted, good job.")
591:            self.assertEqual(unstyle(str(report)), "1 file left unchanged.")
592:            self.assertEqual(report.return_code, 0)
593:            report.done(Path("f2"), black.Changed.YES)
594:            self.assertEqual(len(out_lines), 2)
595:            self.assertEqual(len(err_lines), 0)
596:            self.assertEqual(out_lines[-1], "reformatted f2")
597:            self.assertEqual(
598:                unstyle(str(report)), "1 file reformatted, 1 file left unchanged."
599:            )
600:            report.done(Path("f3"), black.Changed.CACHED)
601:            self.assertEqual(len(out_lines), 3)
602:            self.assertEqual(len(err_lines), 0)
603:            self.assertEqual(
604:                out_lines[-1], "f3 wasn't modified on disk since last run."
605:            )
606:            self.assertEqual(
607:                unstyle(str(report)), "1 file reformatted, 2 files left unchanged."
608:            )
609:            self.assertEqual(report.return_code, 0)
610:            report.check = True
611:            self.assertEqual(report.return_code, 1)
612:            report.check = False
613:            report.failed(Path("e1"), "boom")
614:            self.assertEqual(len(out_lines), 3)
615:            self.assertEqual(len(err_lines), 1)
616:            self.assertEqual(err_lines[-1], "error: cannot format e1: boom")
617:            self.assertEqual(
618:                unstyle(str(report)),
619:                "1 file reformatted, 2 files left unchanged, "
620:                "1 file failed to reformat.",
621:            )
622:            self.assertEqual(report.return_code, 123)
623:            report.done(Path("f3"), black.Changed.YES)
624:            self.assertEqual(len(out_lines), 4)
625:            self.assertEqual(len(err_lines), 1)
626:            self.assertEqual(out_lines[-1], "reformatted f3")
627:            self.assertEqual(
628:                unstyle(str(report)),
629:                "2 files reformatted, 2 files left unchanged, "
630:                "1 file failed to reformat.",
631:            )
632:            self.assertEqual(report.return_code, 123)
633:            report.failed(Path("e2"), "boom")
634:            self.assertEqual(len(out_lines), 4)
635:            self.assertEqual(len(err_lines), 2)
636:            self.assertEqual(err_lines[-1], "error: cannot format e2: boom")
637:            self.assertEqual(
638:                unstyle(str(report)),
639:                "2 files reformatted, 2 files left unchanged, "

Calling tool: grepTool
class BlackTestCase\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py:139:class BlackTestCase(unittest.TestCase):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/test_black.py
136:                sys.stderr = hold_stderr
137:
138:
139:class BlackTestCase(unittest.TestCase):
140:    maxDiff = None
141:
142:    def assertFormatEqual(self, expected: str, actual: str) -> None:
143:        if actual != expected and not os.environ.get("SKIP_AST_PRINT"):
144:            bdv: black.DebugVisitor[Any]
145:            black.out("Expected tree:", fg="green")
146:            try:
147:                exp_node = black.lib2to3_parse(expected)
148:                bdv = black.DebugVisitor()
149:                list(bdv.visit(exp_node))
150:            except Exception as ve:
151:                black.err(str(ve))
152:            black.out("Actual tree:", fg="red")
153:            try:
154:                exp_node = black.lib2to3_parse(actual)
155:                bdv = black.DebugVisitor()
156:                list(bdv.visit(exp_node))
157:            except Exception as ve:
158:                black.err(str(ve))
159:        self.assertEqual(expected, actual)
160:
161:    def invokeBlack(
162:        self, args: List[str], exit_code: int = 0, ignore_config: bool = True
163:    ) -> None:
164:        runner = BlackRunner()
165:        if ignore_config:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In tests/test_black.py within class BlackTestCase, test_tuple_assign reads source and expected via read_data("tupleassign"), formats with fs(source), asserts equality using self.assertFormatEqual, and calls black.assert_equivalent and black.assert_stable with black.FileMode().

Todo item 7 of 9 is correct
description: 'In tests/test_black.py, confirm BlackTestCase.test_tuple_assign reads data tupleassign via read_data("tupleassign"), formats with fs(source), and asserts equality to expected, and also calls black.assert_equivalent and black.assert_stable.'

Validating todo item 8 of 9
description: 'In tests/data/tupleassign.py, verify the input (before '# output') is a long tuple-unpack assignment without LHS parentheses and the expected output shows the LHS parenthesized and split across multiple lines, with the RHS formatted as a parenthesized tuple.'

Calling tool: globTool
**/tests/data/tupleassign.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/data/tupleassign.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/tests/data/tupleassign.py
1:sdfjklsdfsjldkflkjsf, sdfjsdfjlksdljkfsdlkf, sdfsdjfklsdfjlksdljkf, sdsfsdfjskdflsfsdf = 1, 2, 3
2:
3:
4:# output
5:(
6:    sdfjklsdfsjldkflkjsf,
7:    sdfjsdfjlksdljkfsdlkf,
8:    sdfsdjfklsdfjlksdljkf,
9:    sdsfsdfjskdflsfsdf,
10:) = (1, 2, 3)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The test file shows an unparenthesized long tuple-unpack assignment on the LHS before '# output' and the expected output has the LHS parenthesized and split across multiple lines, with the RHS formatted as a parenthesized tuple '(1, 2, 3)'.

Todo item 8 of 9 is correct
description: 'In tests/data/tupleassign.py, verify the input (before '# output') is a long tuple-unpack assignment without LHS parentheses and the expected output shows the LHS parenthesized and split across multiple lines, with the RHS formatted as a parenthesized tuple.'

Validating todo item 9 of 9
description: 'Check that the new condition triggers only at the first child (index == 0) to avoid adding parentheses in non-LHS positions, aligning with the PR intent to target tuple-unpack assignments' LHS.'

Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/good/black/black.py
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        # Add parentheses around long tuple unpacking in assignments.
2730:        if (
2731:            index == 0
2732:            and isinstance(child, Node)
2733:            and child.type == syms.testlist_star_expr
2734:        ):
2735:            check_lpar = True
2736:
2737:        if check_lpar:
2738:            if child.type == syms.atom:
2739:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2740:                    lpar = Leaf(token.LPAR, "")
2741:                    rpar = Leaf(token.RPAR, "")
2742:                    index = child.remove() or 0
2743:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2744:            elif is_one_tuple(child):
2745:                # wrap child in visible parentheses
2746:                lpar = Leaf(token.LPAR, "(")
2747:                rpar = Leaf(token.RPAR, ")")
2748:                child.remove()
2749:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2750:            elif node.type == syms.import_from:
2751:                # "import from" nodes store parentheses directly as part of
2752:                # the statement
2753:                if child.type == token.LPAR:
2754:                    # make parentheses invisible
2755:                    child.value = ""  # type: ignore
2756:                    node.children[-1].value = ""  # type: ignore
2757:                elif child.type != token.STAR:
2758:                    # insert invisible parentheses
2759:                    node.insert_child(index, Leaf(token.LPAR, ""))
2760:                    node.append_child(Leaf(token.RPAR, ""))
2761:                break
2762:
2763:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2764:                # wrap child in invisible parentheses
2765:                lpar = Leaf(token.LPAR, "")
2766:                rpar = Leaf(token.RPAR, "")
2767:                index = child.remove() or 0
2768:                prefix = child.prefix
2769:                child.prefix = ""
2770:                new_child = Node(syms.atom, [lpar, child, rpar])
2771:                new_child.prefix = prefix
2772:                node.insert_child(index, new_child)
2773:
2774:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2775:
2776:
2777:def normalize_fmt_off(node: Node) -> None:
2778:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2779:    try_again = True
2780:    while try_again:
2781:        try_again = convert_one_fmt_off_pair(node)
2782:
2783:
2784:def convert_one_fmt_off_pair(node: Node) -> bool:
2785:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2786:
2787:    Returns True if a pair was converted.
2788:    """
2789:    for leaf in node.leaves():
2790:        previous_consumed = 0
2791:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2792:            if comment.value in FMT_OFF:
2793:                # We only want standalone comments. If there's no previous leaf or
2794:                # the previous leaf is indentation, it's a standalone comment in
2795:                # disguise.
2796:                if comment.type != STANDALONE_COMMENT:
2797:                    prev = preceding_leaf(leaf)
2798:                    if prev and prev.type not in WHITESPACE:
2799:                        continue
2800:
2801:                ignored_nodes = list(generate_ignored_nodes(leaf))
2802:                if not ignored_nodes:
2803:                    continue
2804:
2805:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2806:                parent = first.parent
2807:                prefix = first.prefix
2808:                first.prefix = prefix[comment.consumed :]
2809:                hidden_value = (
2810:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2811:                )
2812:                if hidden_value.endswith("\n"):
2813:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2814:                    # leaf (possibly followed by a DEDENT).
2815:                    hidden_value = hidden_value[:-1]
2816:                first_idx = None
2817:                for ignored in ignored_nodes:
2818:                    index = ignored.remove()
2819:                    if first_idx is None:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In normalize_invisible_parens, the new trigger is guarded by `index == 0` and `child.type == syms.testlist_star_expr` (lines 2729â€“2735), ensuring it only activates for the first child (LHS). Additionally, `check_lpar` is reset each iteration (line 2774), preventing it from affecting non-LHS positions.

Todo item 9 of 9 is correct
description: 'Check that the new condition triggers only at the first child (index == 0) to avoid adding parentheses in non-LHS positions, aligning with the PR intent to target tuple-unpack assignments' LHS.'


=== PHASE 2 COMPLETE ===

