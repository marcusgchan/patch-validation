=== PHASE 1: ANALYSIS ===

[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "from typing import \\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def test_get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "type\\s*=\\s*TypeVar|LN\\]",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "^LN\\s*=", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "from lib2to3.pgen2 import token|from lib2to3.pytree import Leaf, Node|syms = pygram.python_symbols",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "lib2to3", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py" ]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2890:                inner_brackets.add(id(leaf))
2891:        elif leaf.type in CLOSING_BRACKETS:
2892:            if not leaf.value:
2893:                optional_brackets.add(id(opening_bracket))
2894:                continue
2895:
2896:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2897:                # Empty brackets would fail a split so treat them as "inner"
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:
3005:    If no directory in the tree contains a marker that would specify it's the
3006:    project root, the root of the file system is returned.
3007:    """
3008:    if not srcs:
3009:        return Path("/").resolve()

Calling tool: grepTool
from typing import \(
Matched content:
18:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generator,
24:    Generic,
25:    Iterable,
26:    Iterator,
27:    List,
28:    Optional,
29:    Pattern,
30:    Sequence,
31:    Set,
32:    Tuple,
33:    TypeVar,
34:    Union,
35:    cast,
36:)
37:
38:from appdirs import user_cache_dir
39:from attr import dataclass, Factory
40:import click

Calling tool: grepTool
def test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py
1:#!/usr/bin/env python2
2:from __future__ import unicode_literals as _unicode_literals
3:from __future__ import absolute_import
4:from __future__ import print_function as lol, with_function
5:
6:u'hello'
7:U"hello"
8:Ur"hello"
9:
10:# output
11:
12:
13:#!/usr/bin/env python2
14:from __future__ import unicode_literals as _unicode_literals
15:from __future__ import absolute_import
16:from __future__ import print_function as lol, with_function
17:
18:"hello"
19:"hello"
20:r"hello"

Calling tool: grepTool
type\s*=\s*TypeVar|LN\]
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1812:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1830:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:1832:    node: Optional[LN] = descendant
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2617:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2622:    container: Optional[LN] = container_of(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:1811:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:1829:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:1831:    node: Optional[LN] = descendant
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2616:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2621:    container: Optional[LN] = container_of(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/plugins/attrs.py:611:    tvd_type = TypeVarType(tvd)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/plugins/dataclasses.py:135:                cmp_other_type = TypeVarType(cmp_tvar_def)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/plugins/dataclasses.py:158:                order_other_type = TypeVarType(order_tvar_def)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/semanal_namedtuple.py:409:        selftype = TypeVarType(tvd)

Calling tool: grepTool
^LN\s*=
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:68:LN = Union[Leaf, Node]
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:67:LN = Union[Leaf, Node]

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
60:FileContent = str
61:Encoding = str
62:NewLine = str
63:Depth = int
64:NodeType = int
65:LeafID = int
66:Priority = int
67:Index = int
68:LN = Union[Leaf, Node]
69:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
70:Timestamp = float
71:FileSize = int
72:CacheInfo = Tuple[Timestamp, FileSize]
73:Cache = Dict[Path, CacheInfo]
74:out = partial(click.secho, bold=True, err=True)
75:err = partial(click.secho, fg="red", err=True)
76:
77:pygram.initialize(CACHE_DIR)
78:syms = pygram.python_symbols
79:

Calling tool: grepTool
from lib2to3.pgen2 import token|from lib2to3.pytree import Leaf, Node|syms = pygram.python_symbols
Matched content:
78:syms = pygram.python_symbols

Calling tool: grepTool
lib2to3
Matched content:
43:# lib2to3 fork
44:from blib2to3.pytree import Node, Leaf, type_repr
45:from blib2to3 import pygram, pytree
46:from blib2to3.pgen2 import driver, token
47:from blib2to3.pgen2.parse import ParseError
597:    src_node = lib2to3_parse(src_contents)
647:def lib2to3_parse(src_txt: str) -> Node:
648:    """Given a string with source, return the lib2to3 Node."""
674:def lib2to3_unparse(node: Node) -> str:
675:    """Given a lib2to3 node, return its string representation."""
684:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
735:        """Pretty-print the lib2to3 AST of a given string of `code`.
741:            code = lib2to3_parse(code)
1453:        # In blib2to3 INDENT never holds comments.
1975:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
40:import click
41:import toml
42:
43:# lib2to3 fork
44:from blib2to3.pytree import Node, Leaf, type_repr
45:from blib2to3 import pygram, pytree
46:from blib2to3.pgen2 import driver, token
47:from blib2to3.pgen2.parse import ParseError
48:
49:
50:__version__ = "18.6b4"
51:DEFAULT_LINE_LENGTH = 88

Calling tool: createTodo
Todo List Created
Todo List (14 items):
- [ ] Verify typing imports in black/black.py include Generator and that Generator is used as the return annotation of the helper generator inside get_future_imports. (ID: todo-1)
- [ ] Inspect get_future_imports implementation: ensure a nested helper function get_imports_from_children(children: List[LN]) -> Generator[str, None, None] exists and yields only original import names (token.NAME) while ignoring alias names. (ID: todo-2)
- [ ] Within get_imports_from_children, confirm the syms.import_as_name branch selects the original name via child.children[0], asserts it is a Leaf of type token.NAME, and yields its value (not the alias). (ID: todo-3)
- [ ] Within get_imports_from_children, confirm the syms.import_as_names branch recurses into child.children and collects all names, supporting multiple and mixed alias/non-alias items in a single import list. (ID: todo-4)
- [ ] Confirm that Leaf children that are not token.NAME (e.g., commas and parentheses) are ignored and do not trigger the final assert False branch. (ID: todo-5)
- [ ] Check that get_future_imports unions collected names across multiple consecutive 'from __future__ import ...' statements at the top of the file using 'imports |= set(get_imports_from_children(...))'. (ID: todo-6)
- [ ] Verify that get_future_imports stops scanning when encountering a simple_stmt whose first child is a Leaf that is not a docstring, or an import_from from a module other than '__future__', matching tests expecting an empty set in such cases. (ID: todo-7)
- [ ] Verify that get_future_imports continues scanning past a module-level docstring (a simple_stmt with STRING followed by NEWLINE), consistent with the test that allows a docstring before __future__ imports. (ID: todo-8)
- [ ] Ensure get_future_imports correctly handles parenthesized future imports by ignoring '(' and ')' Leaf tokens and recursing into import_as_names to collect names. (ID: todo-9)
- [ ] Confirm the return type of get_future_imports is Set[str] and the local variable 'imports' is annotated as Set[str] and initialized to set(). (ID: todo-10)
- [ ] Confirm tests/test_black.py::test_get_future_imports contains assertions for alias handling: (a) 'from __future__ import unicode_literals as _unicode_literals' -> {'unicode_literals'} and (b) 'from __future__ import unicode_literals as _lol, print' -> {'unicode_literals', 'print'}. (ID: todo-11)
- [ ] Verify test coverage for multiple names and parenthesized names exists in test_get_future_imports and matches the implemented logic. (ID: todo-12)
- [ ] Confirm tests/data/python2_unicode_literals.py has been updated to use aliased future imports (unicode_literals as _unicode_literals and print_function as lol, with_function) and that these constructs are supported by get_future_imports' parsing logic. (ID: todo-13)
- [ ] Check that no alias names (e.g., '_unicode_literals', 'lol') are added to the returned set by get_future_imports. (ID: todo-14)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 14
description: 'Verify typing imports in black/black.py include Generator and that Generator is used as the return annotation of the helper generator inside get_future_imports.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/**/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "from typing import .*Generator",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "from typing import \\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/**/black.py: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/**/black.py: No such file or directory (os error 2)


Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:
3005:    If no directory in the tree contains a marker that would specify it's the
3006:    project root, the root of the file system is returned.
3007:    """
3008:    if not srcs:
3009:        return Path("/").resolve()
3010:
3011:    common_base = min(Path(src).resolve() for src in srcs)
3012:    if common_base.is_dir():
3013:        # Append a fake file so `parents` below returns `common_base_dir`, too.
3014:        common_base /= "fake-file"
3015:    for directory in common_base.parents:
3016:        if (directory / ".git").is_dir():
3017:            return directory
3018:
3019:        if (directory / ".hg").is_dir():

Calling tool: grepTool
from typing import .*Generator
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
from typing import \(
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:18:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:18:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/abc.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/cookiejar.py:9:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/frozenlist.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_request.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_urldispatcher.py:14:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/helpers.py:23:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/client.py:12:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_response.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_protocol.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_app.py:5:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/test_utils.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/flake8_mypy.py:13:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/connector.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/multipart.py:10:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_fileresponse.py:6:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/client_reqrep.py:11:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/payload.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_routedef.py:3:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/typedefs.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypyc/ops.py:14:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypyc/ir_builder.py:11:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/multidict/__init__.pyi:2:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/packaging/specifiers.py:16:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/packaging/tags.py:28:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/propcache/_helpers_py.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/attr/__init__.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/attr/validators.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/importlib_metadata/_meta.py:4:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pkg_resources/_vendor/packaging/specifiers.py:17:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pkg_resources/_vendor/packaging/tags.py:28:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/sphinx/config.py:17:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/setuptools/_vendor/packaging/specifiers.py:17:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/setuptools/_vendor/packaging/tags.py:28:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/progress.py:16:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/segment.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/table.py:2:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/syntax.py:7:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/console.py:19:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/text.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/layout.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/containers.py:2:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/repr.py:3:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/pretty.py:13:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/semanal.py:53:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/checker.py:7:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/distro/distro.py:40:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/checkexpr.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/nodes.py:6:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generator,
24:    Generic,
25:    Iterable,
26:    Iterator,
27:    List,
28:    Optional,
29:    Pattern,
30:    Sequence,
31:    Set,
32:    Tuple,
33:    TypeVar,
34:    Union,
35:    cast,
36:)
37:
38:from appdirs import user_cache_dir
39:from attr import dataclass, Factory
40:import click
41:import toml
42:
43:# lib2to3 fork
44:from blib2to3.pytree import Node, Leaf, type_repr
45:from blib2to3 import pygram, pytree
46:from blib2to3.pgen2 import driver, token
47:from blib2to3.pgen2.parse import ParseError
48:
49:
50:__version__ = "18.6b4"
51:DEFAULT_LINE_LENGTH = 88
52:DEFAULT_EXCLUDES = (
53:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
54:)
55:DEFAULT_INCLUDES = r"\.pyi?$"
56:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
57:
58:
59:# types
60:FileContent = str

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Generator is imported from typing at the top of black.py (line 23), and the helper function get_imports_from_children inside get_future_imports is annotated to return Generator[str, None, None] (line 2916).


Todo item 1 of 14 is correct
description: 'Verify typing imports in black/black.py include Generator and that Generator is used as the return annotation of the helper generator inside get_future_imports.'
Validating todo item 2 of 14
description: 'Inspect get_future_imports implementation: ensure a nested helper function get_imports_from_children(children: List[LN]) -> Generator[str, None, None] exists and yields only original import names (token.NAME) while ignoring alias names.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "from typing import \\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: grepTool
from typing import \(
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:18:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/abc.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/cookiejar.py:9:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/frozenlist.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/helpers.py:23:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_fileresponse.py:6:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:18:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/typedefs.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/client.py:12:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_urldispatcher.py:14:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/connector.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/payload.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_protocol.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_request.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_routedef.py:3:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/client_reqrep.py:11:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/flake8_mypy.py:13:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_app.py:5:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/multipart.py:10:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/test_utils.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_response.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/propcache/_helpers_py.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypyc/ir_builder.py:11:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypyc/ops.py:14:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/packaging/specifiers.py:16:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/packaging/tags.py:28:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/importlib_metadata/_meta.py:4:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/attr/__init__.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/attr/validators.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/distro/distro.py:40:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/pyparsing/core.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/progress.py:16:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/pyparsing/diagram/__init__.py:4:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/segment.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/table.py:2:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/syntax.py:7:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/text.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/pretty.py:13:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/repr.py:3:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/console.py:19:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/packaging/specifiers.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/containers.py:2:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/layout.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/packaging/tags.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_internal/metadata/base.py:9:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_internal/metadata/importlib/_dists.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/sphinx/config.py:17:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_internal/operations/install/wheel.py:18:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_internal/index/collector.py:16:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/multidict/__init__.pyi:2:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generator,
24:    Generic,
25:    Iterable,
26:    Iterator,
27:    List,
28:    Optional,
29:    Pattern,
30:    Sequence,
31:    Set,
32:    Tuple,
33:    TypeVar,
34:    Union,
35:    cast,
36:)
37:
38:from appdirs import user_cache_dir
39:from attr import dataclass, Factory
40:import click

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, get_future_imports defines a nested helper get_imports_from_children(children: List[LN]) -> Generator[str, None, None] that yields Leaf NAME values and, for import_as_name nodes, yields only the original name (child.children[0]). It recurses through import_as_names. Alias names are ignored, satisfying the requirement.


Todo item 2 of 14 is correct
description: 'Inspect get_future_imports implementation: ensure a nested helper function get_imports_from_children(children: List[LN]) -> Generator[str, None, None] exists and yields only original import names (token.NAME) while ignoring alias names.'
Validating todo item 3 of 14
description: 'Within get_imports_from_children, confirm the syms.import_as_name branch selects the original name via child.children[0], asserts it is a Leaf of type token.NAME, and yields its value (not the alias).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Inspected black/black.py lines 2916-2926. In the syms.import_as_name branch, it selects child.children[0] as orig_name, asserts it is a Leaf of type token.NAME, and yields orig_name.value, ensuring the original name (not alias) is used.


Todo item 3 of 14 is correct
description: 'Within get_imports_from_children, confirm the syms.import_as_name branch selects the original name via child.children[0], asserts it is a Leaf of type token.NAME, and yields its value (not the alias).'
Validating todo item 4 of 14
description: 'Within get_imports_from_children, confirm the syms.import_as_names branch recurses into child.children and collects all names, supporting multiple and mixed alias/non-alias items in a single import list.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_get_future_imports",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2895:
2896:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2897:                # Empty brackets would fail a split so treat them as "inner"
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py
2895:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2896:                # Empty brackets would fail a split so treat them as "inner"
2897:                # brackets (e.g. only add them to the `omit` set if another
2898:                # pair of brackets was good enough.
2899:                inner_brackets.add(id(leaf))
2900:                continue
2901:
2902:            opening_bracket = leaf.opening_bracket
2903:            if closing_bracket:
2904:                omit.add(id(closing_bracket))
2905:                omit.update(inner_brackets)
2906:                inner_brackets.clear()
2907:                yield omit
2908:            closing_bracket = leaf
2909:
2910:
2911:def get_future_imports(node: Node) -> Set[str]:
2912:    """Return a set of __future__ imports in the file."""
2913:    imports = set()
2914:    for child in node.children:
2915:        if child.type != syms.simple_stmt:
2916:            break
2917:        first_child = child.children[0]
2918:        if isinstance(first_child, Leaf):
2919:            # Continue looking if we see a docstring; otherwise stop.
2920:            if (
2921:                len(child.children) == 2
2922:                and first_child.type == token.STRING
2923:                and child.children[1].type == token.NEWLINE
2924:            ):
2925:                continue
2926:            else:
2927:                break
2928:        elif first_child.type == syms.import_from:
2929:            module_name = first_child.children[1]
2930:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2931:                break
2932:            for import_from_child in first_child.children[3:]:
2933:                if isinstance(import_from_child, Leaf):
2934:                    if import_from_child.type == token.NAME:
2935:                        imports.add(import_from_child.value)
2936:                else:
2937:                    assert import_from_child.type == syms.import_as_names
2938:                    for leaf in import_from_child.children:
2939:                        if isinstance(leaf, Leaf) and leaf.type == token.NAME:
2940:                            imports.add(leaf.value)
2941:        else:
2942:            break
2943:    return imports
2944:
2945:
2946:def gen_python_files_in_dir(
2947:    path: Path,
2948:    root: Path,
2949:    include: Pattern[str],
2950:    exclude: Pattern[str],
2951:    report: "Report",
2952:) -> Iterator[Path]:
2953:    """Generate all files under `path` whose paths are not excluded by the
2954:    `exclude` regex, but are included by the `include` regex.
2955:
2956:    Symbolic links pointing outside of the `root` directory are ignored.
2957:
2958:    `report` is where output about exclusions goes.
2959:    """
2960:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2961:    for child in path.iterdir():
2962:        try:
2963:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2964:        except ValueError:
2965:            if child.is_symlink():
2966:                report.path_ignored(
2967:                    child, f"is a symbolic link that points outside {root}"
2968:                )
2969:                continue
2970:
2971:            raise
2972:
2973:        if child.is_dir():
2974:            normalized_path += "/"

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py lines 29162929, get_imports_from_children handles syms.import_as_names by recursively yielding from child.children, while collecting names from both Leaf NAMEs and syms.import_as_name nodes. This supports multiple and mixed alias/non-alias items in a single import list as required.


Todo item 4 of 14 is correct
description: 'Within get_imports_from_children, confirm the syms.import_as_names branch recurses into child.children and collects all names, supporting multiple and mixed alias/non-alias items in a single import list.'
Validating todo item 5 of 14
description: 'Confirm that Leaf children that are not token.NAME (e.g., commas and parentheses) are ignored and do not trigger the final assert False branch.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py
2895:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2896:                # Empty brackets would fail a split so treat them as "inner"
2897:                # brackets (e.g. only add them to the `omit` set if another
2898:                # pair of brackets was good enough.
2899:                inner_brackets.add(id(leaf))
2900:                continue
2901:
2902:            opening_bracket = leaf.opening_bracket
2903:            if closing_bracket:
2904:                omit.add(id(closing_bracket))
2905:                omit.update(inner_brackets)
2906:                inner_brackets.clear()
2907:                yield omit
2908:            closing_bracket = leaf
2909:
2910:
2911:def get_future_imports(node: Node) -> Set[str]:
2912:    """Return a set of __future__ imports in the file."""
2913:    imports = set()
2914:    for child in node.children:
2915:        if child.type != syms.simple_stmt:
2916:            break
2917:        first_child = child.children[0]
2918:        if isinstance(first_child, Leaf):
2919:            # Continue looking if we see a docstring; otherwise stop.
2920:            if (
2921:                len(child.children) == 2
2922:                and first_child.type == token.STRING
2923:                and child.children[1].type == token.NEWLINE
2924:            ):
2925:                continue
2926:            else:
2927:                break
2928:        elif first_child.type == syms.import_from:
2929:            module_name = first_child.children[1]
2930:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2931:                break
2932:            for import_from_child in first_child.children[3:]:
2933:                if isinstance(import_from_child, Leaf):
2934:                    if import_from_child.type == token.NAME:
2935:                        imports.add(import_from_child.value)
2936:                else:
2937:                    assert import_from_child.type == syms.import_as_names
2938:                    for leaf in import_from_child.children:
2939:                        if isinstance(leaf, Leaf) and leaf.type == token.NAME:
2940:                            imports.add(leaf.value)
2941:        else:
2942:            break
2943:    return imports
2944:
2945:
2946:def gen_python_files_in_dir(
2947:    path: Path,
2948:    root: Path,
2949:    include: Pattern[str],
2950:    exclude: Pattern[str],
2951:    report: "Report",
2952:) -> Iterator[Path]:
2953:    """Generate all files under `path` whose paths are not excluded by the
2954:    `exclude` regex, but are included by the `include` regex.
2955:
2956:    Symbolic links pointing outside of the `root` directory are ignored.
2957:
2958:    `report` is where output about exclusions goes.
2959:    """
2960:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2961:    for child in path.iterdir():
2962:        try:
2963:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2964:        except ValueError:
2965:            if child.is_symlink():
2966:                report.path_ignored(
2967:                    child, f"is a symbolic link that points outside {root}"
2968:                )
2969:                continue
2970:
2971:            raise
2972:
2973:        if child.is_dir():
2974:            normalized_path += "/"

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2895:
2896:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2897:                # Empty brackets would fail a split so treat them as "inner"
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In get_imports_from_children(), non-NAME Leaf nodes (e.g., commas, parentheses) are simply skipped (lines 29182921) and only NAME leaves yield values. The assert False (line 2929) only triggers for non-Leaf nodes not matching import_as_name/import_as_names, so non-NAME Leaves cannot hit it.


Todo item 5 of 14 is correct
description: 'Confirm that Leaf children that are not token.NAME (e.g., commas and parentheses) are ignored and do not trigger the final assert False branch.'
Validating todo item 6 of 14
description: 'Check that get_future_imports unions collected names across multiple consecutive 'from __future__ import ...' statements at the top of the file using 'imports |= set(get_imports_from_children(...))'.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py get_future_imports, within the loop over top-level simple_stmt nodes, the code performs `imports |= set(get_imports_from_children(first_child.children[3:]))`, ensuring union of names across consecutive `from __future__ import ...` statements.


Todo item 6 of 14 is correct
description: 'Check that get_future_imports unions collected names across multiple consecutive 'from __future__ import ...' statements at the top of the file using 'imports |= set(get_imports_from_children(...))'.'
Validating todo item 7 of 14
description: 'Verify that get_future_imports stops scanning when encountering a simple_stmt whose first child is a Leaf that is not a docstring, or an import_from from a module other than '__future__', matching tests expecting an empty set in such cases.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_get_future_imports",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The implementation breaks out when encountering a simple_stmt whose first child is a Leaf that isnt a docstring (lines 29352944) and also breaks when an import_from is not from __future__ (lines 29462948). This matches tests expecting an empty set in those cases.


Todo item 7 of 14 is correct
description: 'Verify that get_future_imports stops scanning when encountering a simple_stmt whose first child is a Leaf that is not a docstring, or an import_from from a module other than '__future__', matching tests expecting an empty set in such cases.'
Validating todo item 8 of 14
description: 'Verify that get_future_imports continues scanning past a module-level docstring (a simple_stmt with STRING followed by NEWLINE), consistent with the test that allows a docstring before __future__ imports.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_get_future_imports",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:
3005:    If no directory in the tree contains a marker that would specify it's the
3006:    project root, the root of the file system is returned.
3007:    """
3008:    if not srcs:
3009:        return Path("/").resolve()
3010:
3011:    common_base = min(Path(src).resolve() for src in srcs)
3012:    if common_base.is_dir():
3013:        # Append a fake file so `parents` below returns `common_base_dir`, too.
3014:        common_base /= "fake-file"
3015:    for directory in common_base.parents:
3016:        if (directory / ".git").is_dir():
3017:            return directory
3018:
3019:        if (directory / ".hg").is_dir():

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py
2900:                continue
2901:
2902:            opening_bracket = leaf.opening_bracket
2903:            if closing_bracket:
2904:                omit.add(id(closing_bracket))
2905:                omit.update(inner_brackets)
2906:                inner_brackets.clear()
2907:                yield omit
2908:            closing_bracket = leaf
2909:
2910:
2911:def get_future_imports(node: Node) -> Set[str]:
2912:    """Return a set of __future__ imports in the file."""
2913:    imports = set()
2914:    for child in node.children:
2915:        if child.type != syms.simple_stmt:
2916:            break
2917:        first_child = child.children[0]
2918:        if isinstance(first_child, Leaf):
2919:            # Continue looking if we see a docstring; otherwise stop.
2920:            if (
2921:                len(child.children) == 2
2922:                and first_child.type == token.STRING
2923:                and child.children[1].type == token.NEWLINE
2924:            ):
2925:                continue
2926:            else:
2927:                break
2928:        elif first_child.type == syms.import_from:
2929:            module_name = first_child.children[1]
2930:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2931:                break
2932:            for import_from_child in first_child.children[3:]:
2933:                if isinstance(import_from_child, Leaf):
2934:                    if import_from_child.type == token.NAME:
2935:                        imports.add(import_from_child.value)
2936:                else:
2937:                    assert import_from_child.type == syms.import_as_names
2938:                    for leaf in import_from_child.children:
2939:                        if isinstance(leaf, Leaf) and leaf.type == token.NAME:
2940:                            imports.add(leaf.value)
2941:        else:
2942:            break
2943:    return imports
2944:
2945:
2946:def gen_python_files_in_dir(
2947:    path: Path,
2948:    root: Path,
2949:    include: Pattern[str],
2950:    exclude: Pattern[str],
2951:    report: "Report",
2952:) -> Iterator[Path]:
2953:    """Generate all files under `path` whose paths are not excluded by the
2954:    `exclude` regex, but are included by the `include` regex.
2955:
2956:    Symbolic links pointing outside of the `root` directory are ignored.
2957:
2958:    `report` is where output about exclusions goes.
2959:    """
2960:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2961:    for child in path.iterdir():
2962:        try:
2963:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2964:        except ValueError:
2965:            if child.is_symlink():
2966:                report.path_ignored(
2967:                    child, f"is a symbolic link that points outside {root}"
2968:                )
2969:                continue
2970:
2971:            raise
2972:
2973:        if child.is_dir():
2974:            normalized_path += "/"
2975:        exclude_match = exclude.search(normalized_path)
2976:        if exclude_match and exclude_match.group(0):
2977:            report.path_ignored(child, f"matches the --exclude regular expression")
2978:            continue
2979:
2980:        if child.is_dir():
2981:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2982:
2983:        elif child.is_file():
2984:            include_match = include.search(normalized_path)
2985:            if include_match:
2986:                yield child
2987:
2988:
2989:@lru_cache()
2990:def find_project_root(srcs: Iterable[str]) -> Path:
2991:    """Return a directory containing .git, .hg, or pyproject.toml.
2992:
2993:    That directory can be one of the directories passed in `srcs` or their
2994:    common parent.
2995:
2996:    If no directory in the tree contains a marker that would specify it's the
2997:    project root, the root of the file system is returned.
2998:    """
2999:    if not srcs:
3000:        return Path("/").resolve()
3001:
3002:    common_base = min(Path(src).resolve() for src in srcs)
3003:    if common_base.is_dir():
3004:        # Append a fake file so `parents` below returns `common_base_dir`, too.
3005:        common_base /= "fake-file"
3006:    for directory in common_base.parents:
3007:        if (directory / ".git").is_dir():
3008:            return directory
3009:
3010:        if (directory / ".hg").is_dir():
3011:            return directory
3012:
3013:        if (directory / "pyproject.toml").is_file():
3014:            return directory
3015:
3016:    return directory
3017:
3018:
3019:@dataclass

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py get_future_imports, lines 29362944 explicitly detect a module-level docstring (simple_stmt with STRING then NEWLINE) and use `continue` to keep scanning, ensuring future imports after a docstring are found, matching the test expectation.


Todo item 8 of 14 is correct
description: 'Verify that get_future_imports continues scanning past a module-level docstring (a simple_stmt with STRING followed by NEWLINE), consistent with the test that allows a docstring before __future__ imports.'
Validating todo item 9 of 14
description: 'Ensure get_future_imports correctly handles parenthesized future imports by ignoring '(' and ')' Leaf tokens and recursing into import_as_names to collect names.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py lines 29122952, get_future_imports now uses a helper that yields only NAME leaves (ignoring '(' and ')') and recurses into import_as_names, correctly collecting names from parenthesized and aliased future imports, matching tests (test_get_future_imports).


Todo item 9 of 14 is correct
description: 'Ensure get_future_imports correctly handles parenthesized future imports by ignoring '(' and ')' Leaf tokens and recursing into import_as_names to collect names.'
Validating todo item 10 of 14
description: 'Confirm the return type of get_future_imports is Set[str] and the local variable 'imports' is annotated as Set[str] and initialized to set().'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py
2906:                inner_brackets.clear()
2907:                yield omit
2908:            closing_bracket = leaf
2909:
2910:
2911:def get_future_imports(node: Node) -> Set[str]:
2912:    """Return a set of __future__ imports in the file."""
2913:    imports = set()
2914:    for child in node.children:
2915:        if child.type != syms.simple_stmt:
2916:            break
2917:        first_child = child.children[0]
2918:        if isinstance(first_child, Leaf):
2919:            # Continue looking if we see a docstring; otherwise stop.
2920:            if (
2921:                len(child.children) == 2
2922:                and first_child.type == token.STRING
2923:                and child.children[1].type == token.NEWLINE
2924:            ):
2925:                continue
2926:            else:
2927:                break
2928:        elif first_child.type == syms.import_from:
2929:            module_name = first_child.children[1]
2930:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2931:                break
2932:            for import_from_child in first_child.children[3:]:
2933:                if isinstance(import_from_child, Leaf):
2934:                    if import_from_child.type == token.NAME:
2935:                        imports.add(import_from_child.value)
2936:                else:
2937:                    assert import_from_child.type == syms.import_as_names
2938:                    for leaf in import_from_child.children:
2939:                        if isinstance(leaf, Leaf) and leaf.type == token.NAME:
2940:                            imports.add(leaf.value)
2941:        else:
2942:            break
2943:    return imports
2944:
2945:
2946:def gen_python_files_in_dir(
2947:    path: Path,
2948:    root: Path,
2949:    include: Pattern[str],
2950:    exclude: Pattern[str],
2951:    report: "Report",
2952:) -> Iterator[Path]:
2953:    """Generate all files under `path` whose paths are not excluded by the
2954:    `exclude` regex, but are included by the `include` regex.
2955:
2956:    Symbolic links pointing outside of the `root` directory are ignored.
2957:
2958:    `report` is where output about exclusions goes.
2959:    """
2960:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2961:    for child in path.iterdir():
2962:        try:
2963:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2964:        except ValueError:
2965:            if child.is_symlink():
2966:                report.path_ignored(
2967:                    child, f"is a symbolic link that points outside {root}"
2968:                )
2969:                continue
2970:
2971:            raise
2972:
2973:        if child.is_dir():
2974:            normalized_path += "/"
2975:        exclude_match = exclude.search(normalized_path)
2976:        if exclude_match and exclude_match.group(0):
2977:            report.path_ignored(child, f"matches the --exclude regular expression")
2978:            continue
2979:
2980:        if child.is_dir():
2981:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2982:
2983:        elif child.is_file():
2984:            include_match = include.search(normalized_path)
2985:            if include_match:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py at lines 2912-2915, get_future_imports is defined with return type Set[str] and the local variable is annotated as imports: Set[str] = set(). Verified by reading the exact lines.


Todo item 10 of 14 is correct
description: 'Confirm the return type of get_future_imports is Set[str] and the local variable 'imports' is annotated as Set[str] and initialized to set().'
Validating todo item 11 of 14
description: 'Confirm tests/test_black.py::test_get_future_imports contains assertions for alias handling: (a) 'from __future__ import unicode_literals as _unicode_literals' -> {'unicode_literals'} and (b) 'from __future__ import unicode_literals as _lol, print' -> {'unicode_literals', 'print'}.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests"
]
Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
680:                "2 files failed to reformat.",
681:            )
682:            self.assertEqual(report.return_code, 123)
683:            report.done(Path("f4"), black.Changed.NO)
684:            self.assertEqual(len(out_lines), 2)
685:            self.assertEqual(len(err_lines), 2)
686:            self.assertEqual(
687:                unstyle(str(report)),
688:                "2 files reformatted, 3 files left unchanged, "
689:                "2 files failed to reformat.",
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):
780:            black.format_file_contents(same, line_length=ll, fast=False)
781:        different = "l = [1,2,3]"
782:        expected = same
783:        actual = black.format_file_contents(different, line_length=ll, fast=False)
784:        self.assertEqual(expected, actual)
785:        invalid = "return if you can"
786:        with self.assertRaises(ValueError) as e:
787:            black.format_file_contents(invalid, line_length=ll, fast=False)
788:        self.assertEqual(str(e.exception), "Cannot parse: 1:7: return if you can")
789:
790:    def test_endmarker(self) -> None:
791:        n = black.lib2to3_parse("\n")
792:        self.assertEqual(n.type, black.syms.file_input)
793:        self.assertEqual(len(n.children), 1)
794:        self.assertEqual(n.children[0].type, black.token.ENDMARKER)
795:
796:    @unittest.skipIf(os.environ.get("SKIP_AST_PRINT"), "user set SKIP_AST_PRINT")
797:    def test_assertFormatEqual(self) -> None:
798:        out_lines = []
799:        err_lines = []

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified in tests/test_black.py lines 739-745: assertions for alias handling exist for both cases: (a) 'from __future__ import unicode_literals as _unicode_literals' expects {'unicode_literals'} and (b) 'from __future__ import unicode_literals as _lol, print' expects {'unicode_literals', 'print'}.


Todo item 11 of 14 is correct
description: 'Confirm tests/test_black.py::test_get_future_imports contains assertions for alias handling: (a) 'from __future__ import unicode_literals as _unicode_literals' -> {'unicode_literals'} and (b) 'from __future__ import unicode_literals as _lol, print' -> {'unicode_literals', 'print'}.'
Validating todo item 12 of 14
description: 'Verify test coverage for multiple names and parenthesized names exists in test_get_future_imports and matches the implemented logic.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
680:                "2 files failed to reformat.",
681:            )
682:            self.assertEqual(report.return_code, 123)
683:            report.done(Path("f4"), black.Changed.NO)
684:            self.assertEqual(len(out_lines), 2)
685:            self.assertEqual(len(err_lines), 2)
686:            self.assertEqual(
687:                unstyle(str(report)),
688:                "2 files reformatted, 3 files left unchanged, "
689:                "2 files failed to reformat.",
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):
780:            black.format_file_contents(same, line_length=ll, fast=False)
781:        different = "l = [1,2,3]"
782:        expected = same
783:        actual = black.format_file_contents(different, line_length=ll, fast=False)
784:        self.assertEqual(expected, actual)
785:        invalid = "return if you can"
786:        with self.assertRaises(ValueError) as e:
787:            black.format_file_contents(invalid, line_length=ll, fast=False)
788:        self.assertEqual(str(e.exception), "Cannot parse: 1:7: return if you can")
789:
790:    def test_endmarker(self) -> None:
791:        n = black.lib2to3_parse("\n")
792:        self.assertEqual(n.type, black.syms.file_input)
793:        self.assertEqual(len(n.children), 1)
794:        self.assertEqual(n.children[0].type, black.token.ENDMARKER)
795:
796:    @unittest.skipIf(os.environ.get("SKIP_AST_PRINT"), "user set SKIP_AST_PRINT")
797:    def test_assertFormatEqual(self) -> None:
798:        out_lines = []
799:        err_lines = []

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The tests in tests/test_black.py::test_get_future_imports include cases for multiple names and parenthesized names, and they align with the implemented logic in get_future_imports which handles Leaf NAMEs, import_as_name, and import_as_names (including parentheses).


Todo item 12 of 14 is correct
description: 'Verify test coverage for multiple names and parenthesized names exists in test_get_future_imports and matches the implemented logic.'
Validating todo item 13 of 14
description: 'Confirm tests/data/python2_unicode_literals.py has been updated to use aliased future imports (unicode_literals as _unicode_literals and print_function as lol, with_function) and that these constructs are supported by get_future_imports' parsing logic.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:

Calling tool: globTool
**/tests/data/python2_unicode_literals.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/data/python2_unicode_literals.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py
1:#!/usr/bin/env python2
2:from __future__ import unicode_literals as _unicode_literals
3:from __future__ import absolute_import
4:from __future__ import print_function as lol, with_function
5:
6:u'hello'
7:U"hello"
8:Ur"hello"
9:
10:# output
11:
12:
13:#!/usr/bin/env python2
14:from __future__ import unicode_literals as _unicode_literals
15:from __future__ import absolute_import
16:from __future__ import print_function as lol, with_function
17:
18:"hello"
19:"hello"
20:r"hello"

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified tests/data/python2_unicode_literals.py now uses aliased future imports exactly as specified. The updated get_future_imports implements get_imports_from_children handling import_as_name and import_as_names to return original names, covering aliases and multiple imports. Tests in test_get_future_imports assert alias support and pass with this logic.


Todo item 13 of 14 is correct
description: 'Confirm tests/data/python2_unicode_literals.py has been updated to use aliased future imports (unicode_literals as _unicode_literals and print_function as lol, with_function) and that these constructs are supported by get_future_imports' parsing logic.'
Validating todo item 14 of 14
description: 'Check that no alias names (e.g., '_unicode_literals', 'lol') are added to the returned set by get_future_imports.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def get_future_imports\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_get_future_imports",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black"
]
Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py
2907:                yield omit
2908:            closing_bracket = leaf
2909:
2910:
2911:def get_future_imports(node: Node) -> Set[str]:
2912:    """Return a set of __future__ imports in the file."""
2913:    imports = set()
2914:    for child in node.children:
2915:        if child.type != syms.simple_stmt:
2916:            break
2917:        first_child = child.children[0]
2918:        if isinstance(first_child, Leaf):
2919:            # Continue looking if we see a docstring; otherwise stop.
2920:            if (
2921:                len(child.children) == 2
2922:                and first_child.type == token.STRING
2923:                and child.children[1].type == token.NEWLINE
2924:            ):
2925:                continue
2926:            else:
2927:                break
2928:        elif first_child.type == syms.import_from:
2929:            module_name = first_child.children[1]
2930:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2931:                break
2932:            for import_from_child in first_child.children[3:]:
2933:                if isinstance(import_from_child, Leaf):
2934:                    if import_from_child.type == token.NAME:
2935:                        imports.add(import_from_child.value)
2936:                else:
2937:                    assert import_from_child.type == syms.import_as_names
2938:                    for leaf in import_from_child.children:
2939:                        if isinstance(leaf, Leaf) and leaf.type == token.NAME:
2940:                            imports.add(leaf.value)
2941:        else:
2942:            break
2943:    return imports
2944:
2945:
2946:def gen_python_files_in_dir(
2947:    path: Path,
2948:    root: Path,
2949:    include: Pattern[str],
2950:    exclude: Pattern[str],
2951:    report: "Report",
2952:) -> Iterator[Path]:
2953:    """Generate all files under `path` whose paths are not excluded by the
2954:    `exclude` regex, but are included by the `include` regex.
2955:
2956:    Symbolic links pointing outside of the `root` directory are ignored.
2957:
2958:    `report` is where output about exclusions goes.
2959:    """
2960:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2961:    for child in path.iterdir():
2962:        try:
2963:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2964:        except ValueError:
2965:            if child.is_symlink():
2966:                report.path_ignored(

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The updated get_future_imports parses import_as_name nodes to yield only the original names (child.children[0]) and recurses through import_as_names, ignoring alias names. Tests (test_get_future_imports) verify that aliases like '_unicode_literals' and 'lol' are excluded and pass with this implementation.


Todo item 14 of 14 is correct
description: 'Check that no alias names (e.g., '_unicode_literals', 'lol') are added to the returned set by get_future_imports.'
Validating todo item 1 of 14
description: 'Verify typing imports in black/black.py include Generator and that Generator is used as the return annotation of the helper generator inside get_future_imports.'

Calling tool: grepTool
def get_future_imports\(
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/**/black.py: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/**/black.py: No such file or directory (os error 2)


Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:
3005:    If no directory in the tree contains a marker that would specify it's the
3006:    project root, the root of the file system is returned.
3007:    """
3008:    if not srcs:
3009:        return Path("/").resolve()
3010:
3011:    common_base = min(Path(src).resolve() for src in srcs)
3012:    if common_base.is_dir():
3013:        # Append a fake file so `parents` below returns `common_base_dir`, too.
3014:        common_base /= "fake-file"
3015:    for directory in common_base.parents:
3016:        if (directory / ".git").is_dir():
3017:            return directory
3018:
3019:        if (directory / ".hg").is_dir():

Calling tool: grepTool
from typing import .*Generator
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
from typing import \(
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:18:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:18:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/abc.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/cookiejar.py:9:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/frozenlist.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_request.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_urldispatcher.py:14:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/helpers.py:23:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/client.py:12:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_response.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_protocol.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_app.py:5:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/test_utils.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/flake8_mypy.py:13:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/connector.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/multipart.py:10:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_fileresponse.py:6:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/client_reqrep.py:11:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/payload.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_routedef.py:3:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/typedefs.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypyc/ops.py:14:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypyc/ir_builder.py:11:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/multidict/__init__.pyi:2:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/packaging/specifiers.py:16:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/packaging/tags.py:28:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/propcache/_helpers_py.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/attr/__init__.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/attr/validators.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/importlib_metadata/_meta.py:4:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pkg_resources/_vendor/packaging/specifiers.py:17:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pkg_resources/_vendor/packaging/tags.py:28:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/sphinx/config.py:17:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/setuptools/_vendor/packaging/specifiers.py:17:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/setuptools/_vendor/packaging/tags.py:28:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/progress.py:16:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/segment.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/table.py:2:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/syntax.py:7:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/console.py:19:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/text.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/layout.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/containers.py:2:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/repr.py:3:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/pretty.py:13:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/semanal.py:53:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/checker.py:7:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/distro/distro.py:40:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/checkexpr.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypy/nodes.py:6:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generator,
24:    Generic,
25:    Iterable,
26:    Iterator,
27:    List,
28:    Optional,
29:    Pattern,
30:    Sequence,
31:    Set,
32:    Tuple,
33:    TypeVar,
34:    Union,
35:    cast,
36:)
37:
38:from appdirs import user_cache_dir
39:from attr import dataclass, Factory
40:import click
41:import toml
42:
43:# lib2to3 fork
44:from blib2to3.pytree import Node, Leaf, type_repr
45:from blib2to3 import pygram, pytree
46:from blib2to3.pgen2 import driver, token
47:from blib2to3.pgen2.parse import ParseError
48:
49:
50:__version__ = "18.6b4"
51:DEFAULT_LINE_LENGTH = 88
52:DEFAULT_EXCLUDES = (
53:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
54:)
55:DEFAULT_INCLUDES = r"\.pyi?$"
56:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
57:
58:
59:# types
60:FileContent = str

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Generator is imported from typing at the top of black.py (line 23), and the helper function get_imports_from_children inside get_future_imports is annotated to return Generator[str, None, None] (line 2916).

Todo item 1 of 14 is correct
description: 'Verify typing imports in black/black.py include Generator and that Generator is used as the return annotation of the helper generator inside get_future_imports.'

Validating todo item 2 of 14
description: 'Inspect get_future_imports implementation: ensure a nested helper function get_imports_from_children(children: List[LN]) -> Generator[str, None, None] exists and yields only original import names (token.NAME) while ignoring alias names.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: grepTool
from typing import \(
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:18:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/abc.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/cookiejar.py:9:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/frozenlist.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/helpers.py:23:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_fileresponse.py:6:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:18:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/typedefs.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/client.py:12:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_urldispatcher.py:14:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/connector.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/payload.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_protocol.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_request.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_routedef.py:3:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/client_reqrep.py:11:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/flake8_mypy.py:13:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_app.py:5:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/multipart.py:10:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/test_utils.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/aiohttp/web_response.py:13:from typing import (  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/propcache/_helpers_py.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypyc/ir_builder.py:11:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/mypyc/ops.py:14:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/packaging/specifiers.py:16:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/packaging/tags.py:28:    from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/importlib_metadata/_meta.py:4:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/attr/__init__.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/attr/validators.pyi:1:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/distro/distro.py:40:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/pyparsing/core.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/progress.py:16:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/pyparsing/diagram/__init__.py:4:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/segment.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/table.py:2:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/syntax.py:7:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/text.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/pretty.py:13:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/repr.py:3:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/console.py:19:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/packaging/specifiers.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/containers.py:2:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/layout.py:5:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_vendor/packaging/tags.py:10:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_internal/metadata/base.py:9:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_internal/metadata/importlib/_dists.py:6:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/sphinx/config.py:17:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_internal/operations/install/wheel.py:18:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/pip/_internal/index/collector.py:16:from typing import (
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/lib/python3.8/site-packages/multidict/__init__.pyi:2:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generator,
24:    Generic,
25:    Iterable,
26:    Iterator,
27:    List,
28:    Optional,
29:    Pattern,
30:    Sequence,
31:    Set,
32:    Tuple,
33:    TypeVar,
34:    Union,
35:    cast,
36:)
37:
38:from appdirs import user_cache_dir
39:from attr import dataclass, Factory
40:import click

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, get_future_imports defines a nested helper get_imports_from_children(children: List[LN]) -> Generator[str, None, None] that yields Leaf NAME values and, for import_as_name nodes, yields only the original name (child.children[0]). It recurses through import_as_names. Alias names are ignored, satisfying the requirement.

Todo item 2 of 14 is correct
description: 'Inspect get_future_imports implementation: ensure a nested helper function get_imports_from_children(children: List[LN]) -> Generator[str, None, None] exists and yields only original import names (token.NAME) while ignoring alias names.'

Validating todo item 3 of 14
description: 'Within get_imports_from_children, confirm the syms.import_as_name branch selects the original name via child.children[0], asserts it is a Leaf of type token.NAME, and yields its value (not the alias).'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Inspected black/black.py lines 2916-2926. In the syms.import_as_name branch, it selects child.children[0] as orig_name, asserts it is a Leaf of type token.NAME, and yields orig_name.value, ensuring the original name (not alias) is used.

Todo item 3 of 14 is correct
description: 'Within get_imports_from_children, confirm the syms.import_as_name branch selects the original name via child.children[0], asserts it is a Leaf of type token.NAME, and yields its value (not the alias).'

Validating todo item 4 of 14
description: 'Within get_imports_from_children, confirm the syms.import_as_names branch recurses into child.children and collects all names, supporting multiple and mixed alias/non-alias items in a single import list.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2895:
2896:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2897:                # Empty brackets would fail a split so treat them as "inner"
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py
2895:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2896:                # Empty brackets would fail a split so treat them as "inner"
2897:                # brackets (e.g. only add them to the `omit` set if another
2898:                # pair of brackets was good enough.
2899:                inner_brackets.add(id(leaf))
2900:                continue
2901:
2902:            opening_bracket = leaf.opening_bracket
2903:            if closing_bracket:
2904:                omit.add(id(closing_bracket))
2905:                omit.update(inner_brackets)
2906:                inner_brackets.clear()
2907:                yield omit
2908:            closing_bracket = leaf
2909:
2910:
2911:def get_future_imports(node: Node) -> Set[str]:
2912:    """Return a set of __future__ imports in the file."""
2913:    imports = set()
2914:    for child in node.children:
2915:        if child.type != syms.simple_stmt:
2916:            break
2917:        first_child = child.children[0]
2918:        if isinstance(first_child, Leaf):
2919:            # Continue looking if we see a docstring; otherwise stop.
2920:            if (
2921:                len(child.children) == 2
2922:                and first_child.type == token.STRING
2923:                and child.children[1].type == token.NEWLINE
2924:            ):
2925:                continue
2926:            else:
2927:                break
2928:        elif first_child.type == syms.import_from:
2929:            module_name = first_child.children[1]
2930:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2931:                break
2932:            for import_from_child in first_child.children[3:]:
2933:                if isinstance(import_from_child, Leaf):
2934:                    if import_from_child.type == token.NAME:
2935:                        imports.add(import_from_child.value)
2936:                else:
2937:                    assert import_from_child.type == syms.import_as_names
2938:                    for leaf in import_from_child.children:
2939:                        if isinstance(leaf, Leaf) and leaf.type == token.NAME:
2940:                            imports.add(leaf.value)
2941:        else:
2942:            break
2943:    return imports
2944:
2945:
2946:def gen_python_files_in_dir(
2947:    path: Path,
2948:    root: Path,
2949:    include: Pattern[str],
2950:    exclude: Pattern[str],
2951:    report: "Report",
2952:) -> Iterator[Path]:
2953:    """Generate all files under `path` whose paths are not excluded by the
2954:    `exclude` regex, but are included by the `include` regex.
2955:
2956:    Symbolic links pointing outside of the `root` directory are ignored.
2957:
2958:    `report` is where output about exclusions goes.
2959:    """
2960:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2961:    for child in path.iterdir():
2962:        try:
2963:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2964:        except ValueError:
2965:            if child.is_symlink():
2966:                report.path_ignored(
2967:                    child, f"is a symbolic link that points outside {root}"
2968:                )
2969:                continue
2970:
2971:            raise
2972:
2973:        if child.is_dir():
2974:            normalized_path += "/"

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py lines 29162929, get_imports_from_children handles syms.import_as_names by recursively yielding from child.children, while collecting names from both Leaf NAMEs and syms.import_as_name nodes. This supports multiple and mixed alias/non-alias items in a single import list as required.

Todo item 4 of 14 is correct
description: 'Within get_imports_from_children, confirm the syms.import_as_names branch recurses into child.children and collects all names, supporting multiple and mixed alias/non-alias items in a single import list.'

Validating todo item 5 of 14
description: 'Confirm that Leaf children that are not token.NAME (e.g., commas and parentheses) are ignored and do not trigger the final assert False branch.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py
2895:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2896:                # Empty brackets would fail a split so treat them as "inner"
2897:                # brackets (e.g. only add them to the `omit` set if another
2898:                # pair of brackets was good enough.
2899:                inner_brackets.add(id(leaf))
2900:                continue
2901:
2902:            opening_bracket = leaf.opening_bracket
2903:            if closing_bracket:
2904:                omit.add(id(closing_bracket))
2905:                omit.update(inner_brackets)
2906:                inner_brackets.clear()
2907:                yield omit
2908:            closing_bracket = leaf
2909:
2910:
2911:def get_future_imports(node: Node) -> Set[str]:
2912:    """Return a set of __future__ imports in the file."""
2913:    imports = set()
2914:    for child in node.children:
2915:        if child.type != syms.simple_stmt:
2916:            break
2917:        first_child = child.children[0]
2918:        if isinstance(first_child, Leaf):
2919:            # Continue looking if we see a docstring; otherwise stop.
2920:            if (
2921:                len(child.children) == 2
2922:                and first_child.type == token.STRING
2923:                and child.children[1].type == token.NEWLINE
2924:            ):
2925:                continue
2926:            else:
2927:                break
2928:        elif first_child.type == syms.import_from:
2929:            module_name = first_child.children[1]
2930:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2931:                break
2932:            for import_from_child in first_child.children[3:]:
2933:                if isinstance(import_from_child, Leaf):
2934:                    if import_from_child.type == token.NAME:
2935:                        imports.add(import_from_child.value)
2936:                else:
2937:                    assert import_from_child.type == syms.import_as_names
2938:                    for leaf in import_from_child.children:
2939:                        if isinstance(leaf, Leaf) and leaf.type == token.NAME:
2940:                            imports.add(leaf.value)
2941:        else:
2942:            break
2943:    return imports
2944:
2945:
2946:def gen_python_files_in_dir(
2947:    path: Path,
2948:    root: Path,
2949:    include: Pattern[str],
2950:    exclude: Pattern[str],
2951:    report: "Report",
2952:) -> Iterator[Path]:
2953:    """Generate all files under `path` whose paths are not excluded by the
2954:    `exclude` regex, but are included by the `include` regex.
2955:
2956:    Symbolic links pointing outside of the `root` directory are ignored.
2957:
2958:    `report` is where output about exclusions goes.
2959:    """
2960:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2961:    for child in path.iterdir():
2962:        try:
2963:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2964:        except ValueError:
2965:            if child.is_symlink():
2966:                report.path_ignored(
2967:                    child, f"is a symbolic link that points outside {root}"
2968:                )
2969:                continue
2970:
2971:            raise
2972:
2973:        if child.is_dir():
2974:            normalized_path += "/"

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2895:
2896:            if index > 0 and line.leaves[index - 1].type in OPENING_BRACKETS:
2897:                # Empty brackets would fail a split so treat them as "inner"
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In get_imports_from_children(), non-NAME Leaf nodes (e.g., commas, parentheses) are simply skipped (lines 29182921) and only NAME leaves yield values. The assert False (line 2929) only triggers for non-Leaf nodes not matching import_as_name/import_as_names, so non-NAME Leaves cannot hit it.

Todo item 5 of 14 is correct
description: 'Confirm that Leaf children that are not token.NAME (e.g., commas and parentheses) are ignored and do not trigger the final assert False branch.'

Validating todo item 6 of 14
description: 'Check that get_future_imports unions collected names across multiple consecutive 'from __future__ import ...' statements at the top of the file using 'imports |= set(get_imports_from_children(...))'.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2898:                # brackets (e.g. only add them to the `omit` set if another
2899:                # pair of brackets was good enough.
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py get_future_imports, within the loop over top-level simple_stmt nodes, the code performs `imports |= set(get_imports_from_children(first_child.children[3:]))`, ensuring union of names across consecutive `from __future__ import ...` statements.

Todo item 6 of 14 is correct
description: 'Check that get_future_imports unions collected names across multiple consecutive 'from __future__ import ...' statements at the top of the file using 'imports |= set(get_imports_from_children(...))'.'

Validating todo item 7 of 14
description: 'Verify that get_future_imports stops scanning when encountering a simple_stmt whose first child is a Leaf that is not a docstring, or an import_from from a module other than '__future__', matching tests expecting an empty set in such cases.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The implementation breaks out when encountering a simple_stmt whose first child is a Leaf that isnt a docstring (lines 29352944) and also breaks when an import_from is not from __future__ (lines 29462948). This matches tests expecting an empty set in those cases.

Todo item 7 of 14 is correct
description: 'Verify that get_future_imports stops scanning when encountering a simple_stmt whose first child is a Leaf that is not a docstring, or an import_from from a module other than '__future__', matching tests expecting an empty set in such cases.'

Validating todo item 8 of 14
description: 'Verify that get_future_imports continues scanning past a module-level docstring (a simple_stmt with STRING followed by NEWLINE), consistent with the test that allows a docstring before __future__ imports.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)
2985:        if exclude_match and exclude_match.group(0):
2986:            report.path_ignored(child, f"matches the --exclude regular expression")
2987:            continue
2988:
2989:        if child.is_dir():
2990:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2991:
2992:        elif child.is_file():
2993:            include_match = include.search(normalized_path)
2994:            if include_match:
2995:                yield child
2996:
2997:
2998:@lru_cache()
2999:def find_project_root(srcs: Iterable[str]) -> Path:
3000:    """Return a directory containing .git, .hg, or pyproject.toml.
3001:
3002:    That directory can be one of the directories passed in `srcs` or their
3003:    common parent.
3004:
3005:    If no directory in the tree contains a marker that would specify it's the
3006:    project root, the root of the file system is returned.
3007:    """
3008:    if not srcs:
3009:        return Path("/").resolve()
3010:
3011:    common_base = min(Path(src).resolve() for src in srcs)
3012:    if common_base.is_dir():
3013:        # Append a fake file so `parents` below returns `common_base_dir`, too.
3014:        common_base /= "fake-file"
3015:    for directory in common_base.parents:
3016:        if (directory / ".git").is_dir():
3017:            return directory
3018:
3019:        if (directory / ".hg").is_dir():

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py
2900:                continue
2901:
2902:            opening_bracket = leaf.opening_bracket
2903:            if closing_bracket:
2904:                omit.add(id(closing_bracket))
2905:                omit.update(inner_brackets)
2906:                inner_brackets.clear()
2907:                yield omit
2908:            closing_bracket = leaf
2909:
2910:
2911:def get_future_imports(node: Node) -> Set[str]:
2912:    """Return a set of __future__ imports in the file."""
2913:    imports = set()
2914:    for child in node.children:
2915:        if child.type != syms.simple_stmt:
2916:            break
2917:        first_child = child.children[0]
2918:        if isinstance(first_child, Leaf):
2919:            # Continue looking if we see a docstring; otherwise stop.
2920:            if (
2921:                len(child.children) == 2
2922:                and first_child.type == token.STRING
2923:                and child.children[1].type == token.NEWLINE
2924:            ):
2925:                continue
2926:            else:
2927:                break
2928:        elif first_child.type == syms.import_from:
2929:            module_name = first_child.children[1]
2930:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2931:                break
2932:            for import_from_child in first_child.children[3:]:
2933:                if isinstance(import_from_child, Leaf):
2934:                    if import_from_child.type == token.NAME:
2935:                        imports.add(import_from_child.value)
2936:                else:
2937:                    assert import_from_child.type == syms.import_as_names
2938:                    for leaf in import_from_child.children:
2939:                        if isinstance(leaf, Leaf) and leaf.type == token.NAME:
2940:                            imports.add(leaf.value)
2941:        else:
2942:            break
2943:    return imports
2944:
2945:
2946:def gen_python_files_in_dir(
2947:    path: Path,
2948:    root: Path,
2949:    include: Pattern[str],
2950:    exclude: Pattern[str],
2951:    report: "Report",
2952:) -> Iterator[Path]:
2953:    """Generate all files under `path` whose paths are not excluded by the
2954:    `exclude` regex, but are included by the `include` regex.
2955:
2956:    Symbolic links pointing outside of the `root` directory are ignored.
2957:
2958:    `report` is where output about exclusions goes.
2959:    """
2960:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2961:    for child in path.iterdir():
2962:        try:
2963:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2964:        except ValueError:
2965:            if child.is_symlink():
2966:                report.path_ignored(
2967:                    child, f"is a symbolic link that points outside {root}"
2968:                )
2969:                continue
2970:
2971:            raise
2972:
2973:        if child.is_dir():
2974:            normalized_path += "/"
2975:        exclude_match = exclude.search(normalized_path)
2976:        if exclude_match and exclude_match.group(0):
2977:            report.path_ignored(child, f"matches the --exclude regular expression")
2978:            continue
2979:
2980:        if child.is_dir():
2981:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2982:
2983:        elif child.is_file():
2984:            include_match = include.search(normalized_path)
2985:            if include_match:
2986:                yield child
2987:
2988:
2989:@lru_cache()
2990:def find_project_root(srcs: Iterable[str]) -> Path:
2991:    """Return a directory containing .git, .hg, or pyproject.toml.
2992:
2993:    That directory can be one of the directories passed in `srcs` or their
2994:    common parent.
2995:
2996:    If no directory in the tree contains a marker that would specify it's the
2997:    project root, the root of the file system is returned.
2998:    """
2999:    if not srcs:
3000:        return Path("/").resolve()
3001:
3002:    common_base = min(Path(src).resolve() for src in srcs)
3003:    if common_base.is_dir():
3004:        # Append a fake file so `parents` below returns `common_base_dir`, too.
3005:        common_base /= "fake-file"
3006:    for directory in common_base.parents:
3007:        if (directory / ".git").is_dir():
3008:            return directory
3009:
3010:        if (directory / ".hg").is_dir():
3011:            return directory
3012:
3013:        if (directory / "pyproject.toml").is_file():
3014:            return directory
3015:
3016:    return directory
3017:
3018:
3019:@dataclass

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py get_future_imports, lines 29362944 explicitly detect a module-level docstring (simple_stmt with STRING then NEWLINE) and use `continue` to keep scanning, ensuring future imports after a docstring are found, matching the test expectation.

Todo item 8 of 14 is correct
description: 'Verify that get_future_imports continues scanning past a module-level docstring (a simple_stmt with STRING followed by NEWLINE), consistent with the test that allows a docstring before __future__ imports.'

Validating todo item 9 of 14
description: 'Ensure get_future_imports correctly handles parenthesized future imports by ignoring '(' and ')' Leaf tokens and recursing into import_as_names to collect names.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py lines 29122952, get_future_imports now uses a helper that yields only NAME leaves (ignoring '(' and ')') and recurses into import_as_names, correctly collecting names from parenthesized and aliased future imports, matching tests (test_get_future_imports).

Todo item 9 of 14 is correct
description: 'Ensure get_future_imports correctly handles parenthesized future imports by ignoring '(' and ')' Leaf tokens and recursing into import_as_names to collect names.'

Validating todo item 10 of 14
description: 'Confirm the return type of get_future_imports is Set[str] and the local variable 'imports' is annotated as Set[str] and initialized to set().'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py
2906:                inner_brackets.clear()
2907:                yield omit
2908:            closing_bracket = leaf
2909:
2910:
2911:def get_future_imports(node: Node) -> Set[str]:
2912:    """Return a set of __future__ imports in the file."""
2913:    imports = set()
2914:    for child in node.children:
2915:        if child.type != syms.simple_stmt:
2916:            break
2917:        first_child = child.children[0]
2918:        if isinstance(first_child, Leaf):
2919:            # Continue looking if we see a docstring; otherwise stop.
2920:            if (
2921:                len(child.children) == 2
2922:                and first_child.type == token.STRING
2923:                and child.children[1].type == token.NEWLINE
2924:            ):
2925:                continue
2926:            else:
2927:                break
2928:        elif first_child.type == syms.import_from:
2929:            module_name = first_child.children[1]
2930:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2931:                break
2932:            for import_from_child in first_child.children[3:]:
2933:                if isinstance(import_from_child, Leaf):
2934:                    if import_from_child.type == token.NAME:
2935:                        imports.add(import_from_child.value)
2936:                else:
2937:                    assert import_from_child.type == syms.import_as_names
2938:                    for leaf in import_from_child.children:
2939:                        if isinstance(leaf, Leaf) and leaf.type == token.NAME:
2940:                            imports.add(leaf.value)
2941:        else:
2942:            break
2943:    return imports
2944:
2945:
2946:def gen_python_files_in_dir(
2947:    path: Path,
2948:    root: Path,
2949:    include: Pattern[str],
2950:    exclude: Pattern[str],
2951:    report: "Report",
2952:) -> Iterator[Path]:
2953:    """Generate all files under `path` whose paths are not excluded by the
2954:    `exclude` regex, but are included by the `include` regex.
2955:
2956:    Symbolic links pointing outside of the `root` directory are ignored.
2957:
2958:    `report` is where output about exclusions goes.
2959:    """
2960:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2961:    for child in path.iterdir():
2962:        try:
2963:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2964:        except ValueError:
2965:            if child.is_symlink():
2966:                report.path_ignored(
2967:                    child, f"is a symbolic link that points outside {root}"
2968:                )
2969:                continue
2970:
2971:            raise
2972:
2973:        if child.is_dir():
2974:            normalized_path += "/"
2975:        exclude_match = exclude.search(normalized_path)
2976:        if exclude_match and exclude_match.group(0):
2977:            report.path_ignored(child, f"matches the --exclude regular expression")
2978:            continue
2979:
2980:        if child.is_dir():
2981:            yield from gen_python_files_in_dir(child, root, include, exclude, report)
2982:
2983:        elif child.is_file():
2984:            include_match = include.search(normalized_path)
2985:            if include_match:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py at lines 2912-2915, get_future_imports is defined with return type Set[str] and the local variable is annotated as imports: Set[str] = set(). Verified by reading the exact lines.

Todo item 10 of 14 is correct
description: 'Confirm the return type of get_future_imports is Set[str] and the local variable 'imports' is annotated as Set[str] and initialized to set().'

Validating todo item 11 of 14
description: 'Confirm tests/test_black.py::test_get_future_imports contains assertions for alias handling: (a) 'from __future__ import unicode_literals as _unicode_literals' -> {'unicode_literals'} and (b) 'from __future__ import unicode_literals as _lol, print' -> {'unicode_literals', 'print'}.'

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
680:                "2 files failed to reformat.",
681:            )
682:            self.assertEqual(report.return_code, 123)
683:            report.done(Path("f4"), black.Changed.NO)
684:            self.assertEqual(len(out_lines), 2)
685:            self.assertEqual(len(err_lines), 2)
686:            self.assertEqual(
687:                unstyle(str(report)),
688:                "2 files reformatted, 3 files left unchanged, "
689:                "2 files failed to reformat.",
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):
780:            black.format_file_contents(same, line_length=ll, fast=False)
781:        different = "l = [1,2,3]"
782:        expected = same
783:        actual = black.format_file_contents(different, line_length=ll, fast=False)
784:        self.assertEqual(expected, actual)
785:        invalid = "return if you can"
786:        with self.assertRaises(ValueError) as e:
787:            black.format_file_contents(invalid, line_length=ll, fast=False)
788:        self.assertEqual(str(e.exception), "Cannot parse: 1:7: return if you can")
789:
790:    def test_endmarker(self) -> None:
791:        n = black.lib2to3_parse("\n")
792:        self.assertEqual(n.type, black.syms.file_input)
793:        self.assertEqual(len(n.children), 1)
794:        self.assertEqual(n.children[0].type, black.token.ENDMARKER)
795:
796:    @unittest.skipIf(os.environ.get("SKIP_AST_PRINT"), "user set SKIP_AST_PRINT")
797:    def test_assertFormatEqual(self) -> None:
798:        out_lines = []
799:        err_lines = []

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified in tests/test_black.py lines 739-745: assertions for alias handling exist for both cases: (a) 'from __future__ import unicode_literals as _unicode_literals' expects {'unicode_literals'} and (b) 'from __future__ import unicode_literals as _lol, print' expects {'unicode_literals', 'print'}.

Todo item 11 of 14 is correct
description: 'Confirm tests/test_black.py::test_get_future_imports contains assertions for alias handling: (a) 'from __future__ import unicode_literals as _unicode_literals' -> {'unicode_literals'} and (b) 'from __future__ import unicode_literals as _lol, print' -> {'unicode_literals', 'print'}.'

Validating todo item 12 of 14
description: 'Verify test coverage for multiple names and parenthesized names exists in test_get_future_imports and matches the implemented logic.'

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
680:                "2 files failed to reformat.",
681:            )
682:            self.assertEqual(report.return_code, 123)
683:            report.done(Path("f4"), black.Changed.NO)
684:            self.assertEqual(len(out_lines), 2)
685:            self.assertEqual(len(err_lines), 2)
686:            self.assertEqual(
687:                unstyle(str(report)),
688:                "2 files reformatted, 3 files left unchanged, "
689:                "2 files failed to reformat.",
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )
770:
771:    def test_format_file_contents(self) -> None:
772:        empty = ""
773:        with self.assertRaises(black.NothingChanged):
774:            black.format_file_contents(empty, line_length=ll, fast=False)
775:        just_nl = "\n"
776:        with self.assertRaises(black.NothingChanged):
777:            black.format_file_contents(just_nl, line_length=ll, fast=False)
778:        same = "l = [1, 2, 3]\n"
779:        with self.assertRaises(black.NothingChanged):
780:            black.format_file_contents(same, line_length=ll, fast=False)
781:        different = "l = [1,2,3]"
782:        expected = same
783:        actual = black.format_file_contents(different, line_length=ll, fast=False)
784:        self.assertEqual(expected, actual)
785:        invalid = "return if you can"
786:        with self.assertRaises(ValueError) as e:
787:            black.format_file_contents(invalid, line_length=ll, fast=False)
788:        self.assertEqual(str(e.exception), "Cannot parse: 1:7: return if you can")
789:
790:    def test_endmarker(self) -> None:
791:        n = black.lib2to3_parse("\n")
792:        self.assertEqual(n.type, black.syms.file_input)
793:        self.assertEqual(len(n.children), 1)
794:        self.assertEqual(n.children[0].type, black.token.ENDMARKER)
795:
796:    @unittest.skipIf(os.environ.get("SKIP_AST_PRINT"), "user set SKIP_AST_PRINT")
797:    def test_assertFormatEqual(self) -> None:
798:        out_lines = []
799:        err_lines = []

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The tests in tests/test_black.py::test_get_future_imports include cases for multiple names and parenthesized names, and they align with the implemented logic in get_future_imports which handles Leaf NAMEs, import_as_name, and import_as_names (including parentheses).

Todo item 12 of 14 is correct
description: 'Verify test coverage for multiple names and parenthesized names exists in test_get_future_imports and matches the implemented logic.'

Validating todo item 13 of 14
description: 'Confirm tests/data/python2_unicode_literals.py has been updated to use aliased future imports (unicode_literals as _unicode_literals and print_function as lol, with_function) and that these constructs are supported by get_future_imports' parsing logic.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2900:                inner_brackets.add(id(leaf))
2901:                continue
2902:
2903:            opening_bracket = leaf.opening_bracket
2904:            if closing_bracket:
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:

Calling tool: globTool
**/tests/data/python2_unicode_literals.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/data/python2_unicode_literals.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/data/python2_unicode_literals.py
1:#!/usr/bin/env python2
2:from __future__ import unicode_literals as _unicode_literals
3:from __future__ import absolute_import
4:from __future__ import print_function as lol, with_function
5:
6:u'hello'
7:U"hello"
8:Ur"hello"
9:
10:# output
11:
12:
13:#!/usr/bin/env python2
14:from __future__ import unicode_literals as _unicode_literals
15:from __future__ import absolute_import
16:from __future__ import print_function as lol, with_function
17:
18:"hello"
19:"hello"
20:r"hello"

Calling tool: grepTool
test_get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
690:            )
691:            self.assertEqual(report.return_code, 123)
692:            report.check = True
693:            self.assertEqual(
694:                unstyle(str(report)),
695:                "2 files would be reformatted, 3 files would be left unchanged, "
696:                "2 files would fail to reformat.",
697:            )
698:
699:    def test_is_python36(self) -> None:
700:        node = black.lib2to3_parse("def f(*, arg): ...\n")
701:        self.assertFalse(black.is_python36(node))
702:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
703:        self.assertTrue(black.is_python36(node))
704:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)
765:        self.assertEqual(
766:            expected,
767:            actual,
768:            f"AST print out is different. Actual version dumped to {log_name}",
769:        )

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified tests/data/python2_unicode_literals.py now uses aliased future imports exactly as specified. The updated get_future_imports implements get_imports_from_children handling import_as_name and import_as_names to return original names, covering aliases and multiple imports. Tests in test_get_future_imports assert alias support and pass with this logic.

Todo item 13 of 14 is correct
description: 'Confirm tests/data/python2_unicode_literals.py has been updated to use aliased future imports (unicode_literals as _unicode_literals and print_function as lol, with_function) and that these constructs are supported by get_future_imports' parsing logic.'

Validating todo item 14 of 14
description: 'Check that no alias names (e.g., '_unicode_literals', 'lol') are added to the returned set by get_future_imports.'

Calling tool: grepTool
def get_future_imports\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py:2912:def get_future_imports(node: Node) -> Set[str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py:2911:def get_future_imports(node: Node) -> Set[str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/black.py
2905:                omit.add(id(closing_bracket))
2906:                omit.update(inner_brackets)
2907:                inner_brackets.clear()
2908:                yield omit
2909:            closing_bracket = leaf
2910:
2911:
2912:def get_future_imports(node: Node) -> Set[str]:
2913:    """Return a set of __future__ imports in the file."""
2914:    imports: Set[str] = set()
2915:
2916:    def get_imports_from_children(children: List[LN]) -> Generator[str, None, None]:
2917:        for child in children:
2918:            if isinstance(child, Leaf):
2919:                if child.type == token.NAME:
2920:                    yield child.value
2921:            elif child.type == syms.import_as_name:
2922:                orig_name = child.children[0]
2923:                assert isinstance(orig_name, Leaf), "Invalid syntax parsing imports"
2924:                assert orig_name.type == token.NAME, "Invalid syntax parsing imports"
2925:                yield orig_name.value
2926:            elif child.type == syms.import_as_names:
2927:                yield from get_imports_from_children(child.children)
2928:            else:
2929:                assert False, "Invalid syntax parsing imports"
2930:
2931:    for child in node.children:
2932:        if child.type != syms.simple_stmt:
2933:            break
2934:        first_child = child.children[0]
2935:        if isinstance(first_child, Leaf):
2936:            # Continue looking if we see a docstring; otherwise stop.
2937:            if (
2938:                len(child.children) == 2
2939:                and first_child.type == token.STRING
2940:                and child.children[1].type == token.NEWLINE
2941:            ):
2942:                continue
2943:            else:
2944:                break
2945:        elif first_child.type == syms.import_from:
2946:            module_name = first_child.children[1]
2947:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2948:                break
2949:            imports |= set(get_imports_from_children(first_child.children[3:]))
2950:        else:
2951:            break
2952:    return imports
2953:
2954:
2955:def gen_python_files_in_dir(
2956:    path: Path,
2957:    root: Path,
2958:    include: Pattern[str],
2959:    exclude: Pattern[str],
2960:    report: "Report",
2961:) -> Iterator[Path]:
2962:    """Generate all files under `path` whose paths are not excluded by the
2963:    `exclude` regex, but are included by the `include` regex.
2964:
2965:    Symbolic links pointing outside of the `root` directory are ignored.
2966:
2967:    `report` is where output about exclusions goes.
2968:    """
2969:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2970:    for child in path.iterdir():
2971:        try:
2972:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2973:        except ValueError:
2974:            if child.is_symlink():
2975:                report.path_ignored(
2976:                    child, f"is a symbolic link that points outside {root}"
2977:                )
2978:                continue
2979:
2980:            raise
2981:
2982:        if child.is_dir():
2983:            normalized_path += "/"
2984:        exclude_match = exclude.search(normalized_path)

Calling tool: grepTool
test_get_future_imports
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_get_future_imports
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/tests/test_black.py:717:    def test_get_future_imports(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/tests/test_black.py
705:        self.assertTrue(black.is_python36(node))
706:        source, expected = read_data("function")
707:        node = black.lib2to3_parse(source)
708:        self.assertTrue(black.is_python36(node))
709:        node = black.lib2to3_parse(expected)
710:        self.assertTrue(black.is_python36(node))
711:        source, expected = read_data("expression")
712:        node = black.lib2to3_parse(source)
713:        self.assertFalse(black.is_python36(node))
714:        node = black.lib2to3_parse(expected)
715:        self.assertFalse(black.is_python36(node))
716:
717:    def test_get_future_imports(self) -> None:
718:        node = black.lib2to3_parse("\n")
719:        self.assertEqual(set(), black.get_future_imports(node))
720:        node = black.lib2to3_parse("from __future__ import black\n")
721:        self.assertEqual({"black"}, black.get_future_imports(node))
722:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
723:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
724:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
725:        self.assertEqual({"parenthesized", "imports"}, black.get_future_imports(node))
726:        node = black.lib2to3_parse(
727:            "from __future__ import multiple\nfrom __future__ import imports\n"
728:        )
729:        self.assertEqual({"multiple", "imports"}, black.get_future_imports(node))
730:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
731:        self.assertEqual({"black"}, black.get_future_imports(node))
732:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
733:        self.assertEqual({"black"}, black.get_future_imports(node))
734:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
735:        self.assertEqual(set(), black.get_future_imports(node))
736:        node = black.lib2to3_parse("from some.module import black\n")
737:        self.assertEqual(set(), black.get_future_imports(node))
738:        node = black.lib2to3_parse(
739:            "from __future__ import unicode_literals as _unicode_literals"
740:        )
741:        self.assertEqual({"unicode_literals"}, black.get_future_imports(node))
742:        node = black.lib2to3_parse(
743:            "from __future__ import unicode_literals as _lol, print"
744:        )
745:        self.assertEqual({"unicode_literals", "print"}, black.get_future_imports(node))
746:
747:    def test_debug_visitor(self) -> None:
748:        source, _ = read_data("debug_visitor.py")
749:        expected, _ = read_data("debug_visitor.out")
750:        out_lines = []
751:        err_lines = []
752:
753:        def out(msg: str, **kwargs: Any) -> None:
754:            out_lines.append(msg)
755:
756:        def err(msg: str, **kwargs: Any) -> None:
757:            err_lines.append(msg)
758:
759:        with patch("black.out", out), patch("black.err", err):
760:            black.DebugVisitor.show(source)
761:        actual = "\n".join(out_lines) + "\n"
762:        log_name = ""
763:        if expected != actual:
764:            log_name = black.dump_to_file(*out_lines)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-14/good/black/env/src/black/black.py
2907:                yield omit
2908:            closing_bracket = leaf
2909:
2910:
2911:def get_future_imports(node: Node) -> Set[str]:
2912:    """Return a set of __future__ imports in the file."""
2913:    imports = set()
2914:    for child in node.children:
2915:        if child.type != syms.simple_stmt:
2916:            break
2917:        first_child = child.children[0]
2918:        if isinstance(first_child, Leaf):
2919:            # Continue looking if we see a docstring; otherwise stop.
2920:            if (
2921:                len(child.children) == 2
2922:                and first_child.type == token.STRING
2923:                and child.children[1].type == token.NEWLINE
2924:            ):
2925:                continue
2926:            else:
2927:                break
2928:        elif first_child.type == syms.import_from:
2929:            module_name = first_child.children[1]
2930:            if not isinstance(module_name, Leaf) or module_name.value != "__future__":
2931:                break
2932:            for import_from_child in first_child.children[3:]:
2933:                if isinstance(import_from_child, Leaf):
2934:                    if import_from_child.type == token.NAME:
2935:                        imports.add(import_from_child.value)
2936:                else:
2937:                    assert import_from_child.type == syms.import_as_names
2938:                    for leaf in import_from_child.children:
2939:                        if isinstance(leaf, Leaf) and leaf.type == token.NAME:
2940:                            imports.add(leaf.value)
2941:        else:
2942:            break
2943:    return imports
2944:
2945:
2946:def gen_python_files_in_dir(
2947:    path: Path,
2948:    root: Path,
2949:    include: Pattern[str],
2950:    exclude: Pattern[str],
2951:    report: "Report",
2952:) -> Iterator[Path]:
2953:    """Generate all files under `path` whose paths are not excluded by the
2954:    `exclude` regex, but are included by the `include` regex.
2955:
2956:    Symbolic links pointing outside of the `root` directory are ignored.
2957:
2958:    `report` is where output about exclusions goes.
2959:    """
2960:    assert root.is_absolute(), f"INTERNAL ERROR: `root` must be absolute but is {root}"
2961:    for child in path.iterdir():
2962:        try:
2963:            normalized_path = "/" + child.resolve().relative_to(root).as_posix()
2964:        except ValueError:
2965:            if child.is_symlink():
2966:                report.path_ignored(

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The updated get_future_imports parses import_as_name nodes to yield only the original names (child.children[0]) and recurses through import_as_names, ignoring alias names. Tests (test_get_future_imports) verify that aliases like '_unicode_literals' and 'lol' are excluded and pass with this implementation.

Todo item 14 of 14 is correct
description: 'Check that no alias names (e.g., '_unicode_literals', 'lol') are added to the returned set by get_future_imports.'


=== PHASE 2 COMPLETE ===

