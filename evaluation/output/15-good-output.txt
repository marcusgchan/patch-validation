=== PHASE 1: ANALYSIS ===

[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "(?i)test_fmtonoff2",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "fmtonoff2", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def read_data\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "normalize_fmt_off\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def container_of\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def list_comments\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "FMT_ON|FMT_OFF|STANDALONE_COMMENT",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def generate_comments\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "FormatOn|FormatOff|FormatError|UnformattedLines",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def standalone_comment_split\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
(?i)test_fmtonoff2
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_fmtonoff2
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_fmtonoff2
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py:404:    def test_fmtonoff2(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py
380:    @patch("black.dump_to_file", dump_to_stderr)
381:    def test_python2_unicode_literals(self) -> None:
382:        source, expected = read_data("python2_unicode_literals")
383:        actual = fs(source)
384:        self.assertFormatEqual(expected, actual)
385:        black.assert_stable(source, actual, line_length=ll)
386:
387:    @patch("black.dump_to_file", dump_to_stderr)
388:    def test_stub(self) -> None:
389:        mode = black.FileMode.PYI
390:        source, expected = read_data("stub.pyi")
391:        actual = fs(source, mode=mode)
392:        self.assertFormatEqual(expected, actual)
393:        black.assert_stable(source, actual, line_length=ll, mode=mode)
394:
395:    @patch("black.dump_to_file", dump_to_stderr)
396:    def test_fmtonoff(self) -> None:
397:        source, expected = read_data("fmtonoff")
398:        actual = fs(source)
399:        self.assertFormatEqual(expected, actual)
400:        black.assert_equivalent(source, actual)
401:        black.assert_stable(source, actual, line_length=ll)
402:
403:    @patch("black.dump_to_file", dump_to_stderr)
404:    def test_fmtonoff2(self) -> None:
405:        source, expected = read_data("fmtonoff2")
406:        actual = fs(source)
407:        self.assertFormatEqual(expected, actual)
408:        black.assert_equivalent(source, actual)
409:        black.assert_stable(source, actual, line_length=ll)
410:
411:    @patch("black.dump_to_file", dump_to_stderr)
412:    def test_remove_empty_parentheses_after_class(self) -> None:
413:        source, expected = read_data("class_blank_parentheses")
414:        actual = fs(source)
415:        self.assertFormatEqual(expected, actual)
416:        black.assert_equivalent(source, actual)
417:        black.assert_stable(source, actual, line_length=ll)
418:
419:    @patch("black.dump_to_file", dump_to_stderr)
420:    def test_new_line_between_class_and_code(self) -> None:
421:        source, expected = read_data("class_methods_new_line")
422:        actual = fs(source)
423:        self.assertFormatEqual(expected, actual)
424:        black.assert_equivalent(source, actual)
425:        black.assert_stable(source, actual, line_length=ll)
426:
427:    def test_report_verbose(self) -> None:
428:        report = black.Report(verbose=True)
429:        out_lines = []
430:        err_lines = []
431:
432:        def out(msg: str, **kwargs: Any) -> None:
433:            out_lines.append(msg)
434:
435:        def err(msg: str, **kwargs: Any) -> None:
436:            err_lines.append(msg)
437:
438:        with patch("black.out", out), patch("black.err", err):
439:            report.done(Path("f1"), black.Changed.NO)
440:            self.assertEqual(len(out_lines), 1)
441:            self.assertEqual(len(err_lines), 0)
442:            self.assertEqual(out_lines[-1], "f1 already well formatted, good job.")
443:            self.assertEqual(unstyle(str(report)), "1 file left unchanged.")
444:            self.assertEqual(report.return_code, 0)
445:            report.done(Path("f2"), black.Changed.YES)
446:            self.assertEqual(len(out_lines), 2)
447:            self.assertEqual(len(err_lines), 0)
448:            self.assertEqual(out_lines[-1], "reformatted f2")
449:            self.assertEqual(
450:                unstyle(str(report)), "1 file reformatted, 1 file left unchanged."
451:            )
452:            report.done(Path("f3"), black.Changed.CACHED)
453:            self.assertEqual(len(out_lines), 3)
454:            self.assertEqual(len(err_lines), 0)
455:            self.assertEqual(
456:                out_lines[-1], "f3 wasn't modified on disk since last run."
457:            )
458:            self.assertEqual(
459:                unstyle(str(report)), "1 file reformatted, 2 files left unchanged."

Calling tool: grepTool
fmtonoff2
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_fmtonoff2
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/bugsinpy_bug.info:4:test_file="tests/data/fmtonoff2.py;tests/test_black.py"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_fmtonoff2
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py:404:    def test_fmtonoff2(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py:405:        source, expected = read_data("fmtonoff2")

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/fmtonoff2.py
1:import pytest
2:
3:TmSt = 1
4:TmEx = 2
5:
6:# fmt: off
7:
8:# Test data:
9:#   Position, Volume, State, TmSt/TmEx/None, [call, [arg1...]]
10:
11:@pytest.mark.parametrize('test', [
12:
13:    # Test don't manage the volume
14:    [
15:        ('stuff', 'in')
16:    ],
17:])
18:def test_fader(test):
19:    pass
20:
21:def check_fader(test):
22:    pass
23:
24:def test_calculate_fades():
25:    calcs = [
26:        # one is zero/none
27:        (0, 4, 0, 0, 10,        0, 0, 6, 10),
28:        (None, 4, 0, 0, 10,     0, 0, 6, 10),
29:    ]
30:
31:# fmt: on

Calling tool: globTool
**/tests/data/fmtonoff2*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/fmtonoff2.py

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py:34:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/test_black.py:34:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1770:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1784:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1802:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1812:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1824:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1834:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pyflakes/test/test_other.py:1846:        async def read_data(db):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/virtualenv/create/via_global_ref/builtin/cpython/mac_os.py:235:    def read_data(file, endian, num=1):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/coverage/html.py:63:def read_data(fname):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import re
10:import sys
11:from tempfile import TemporaryDirectory
12:from typing import Any, BinaryIO, Generator, List, Tuple, Iterator
13:import unittest
14:from unittest.mock import patch, MagicMock
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:
22:ll = 88
23:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
24:fs = partial(black.format_str, line_length=ll)
25:THIS_FILE = Path(__file__)
26:THIS_DIR = THIS_FILE.parent
27:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
28:
29:
30:def dump_to_stderr(*output: str) -> str:
31:    return "\n" + "\n".join(output) + "\n"
32:
33:
34:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
35:    """read_data('test_name') -> 'input', 'output'"""
36:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
37:        name += ".py"
38:    _input: List[str] = []
39:    _output: List[str] = []
40:    base_dir = THIS_DIR / "data" if data else THIS_DIR
41:    with open(base_dir / name, "r", encoding="utf8") as test:
42:        lines = test.readlines()
43:    result = _input
44:    for line in lines:
45:        line = line.replace(EMPTY_LINE, "")
46:        if line.rstrip() == "# output":
47:            result = _output
48:            continue
49:
50:        result.append(line)
51:    if _input and not _output:
52:        # If there's no output marker, treat the entire file as already pre-formatted.
53:        _output = _input[:]
54:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
55:
56:
57:@contextmanager
58:def cache_dir(exists: bool = True) -> Iterator[Path]:
59:    with TemporaryDirectory() as workspace:
60:        cache_dir = Path(workspace)
61:        if not exists:
62:            cache_dir = cache_dir / "new"
63:        with patch("black.CACHE_DIR", cache_dir):
64:            yield cache_dir
65:
66:
67:@contextmanager
68:def event_loop(close: bool) -> Iterator[None]:
69:    policy = asyncio.get_event_loop_policy()
70:    old_loop = policy.get_event_loop()
71:    loop = policy.new_event_loop()
72:    asyncio.set_event_loop(loop)
73:    try:
74:        yield
75:
76:    finally:
77:        policy.set_event_loop(old_loop)
78:        if close:
79:            loop.close()
80:

Calling tool: grepTool
normalize_fmt_off\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:602:    normalize_fmt_off(src_node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2555:def normalize_fmt_off(node: Node) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:631:    normalize_fmt_off(src_node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2682:def normalize_fmt_off(node: Node) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
560:        f.detach()
561:
562:
563:def format_file_contents(
564:    src_contents: str,
565:    *,
566:    line_length: int,
567:    fast: bool,
568:    mode: FileMode = FileMode.AUTO_DETECT,
569:) -> FileContent:
570:    """Reformat contents a file and return new contents.
571:
572:    If `fast` is False, additionally confirm that the reformatted code is
573:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
574:    `line_length` is passed to :func:`format_str`.
575:    """
576:    if src_contents.strip() == "":
577:        raise NothingChanged
578:
579:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
580:    if src_contents == dst_contents:
581:        raise NothingChanged
582:
583:    if not fast:
584:        assert_equivalent(src_contents, dst_contents)
585:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
586:    return dst_contents
587:
588:
589:def format_str(
590:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
591:) -> FileContent:
592:    """Reformat a string and return new contents.
593:
594:    `line_length` determines how many characters per line are allowed.
595:    """
596:    src_node = lib2to3_parse(src_contents)
597:    dst_contents = ""
598:    future_imports = get_future_imports(src_node)
599:    is_pyi = bool(mode & FileMode.PYI)
600:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
601:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
602:    normalize_fmt_off(src_node)
603:    lines = LineGenerator(
604:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
605:        is_pyi=is_pyi,
606:        normalize_strings=normalize_strings,
607:    )
608:    elt = EmptyLineTracker(is_pyi=is_pyi)
609:    empty_line = Line()
610:    after = 0
611:    for current_line in lines.visit(src_node):
612:        for _ in range(after):
613:            dst_contents += str(empty_line)
614:        before, after = elt.maybe_empty_lines(current_line)
615:        for _ in range(before):
616:            dst_contents += str(empty_line)
617:        for line in split_line(current_line, line_length=line_length, py36=py36):
618:            dst_contents += str(line)
619:    return dst_contents
620:
621:
622:def decode_bytes(src: bytes) -> Tuple[FileContent, Encoding, NewLine]:
623:    """Return a tuple of (decoded_contents, encoding, newline).
624:
625:    `newline` is either CRLF or LF but `decoded_contents` is decoded with
626:    universal newlines (i.e. only contains LF).
627:    """
628:    srcbuf = io.BytesIO(src)
629:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
630:    if not lines:
631:        return "", encoding, "\n"
632:
633:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
634:    srcbuf.seek(0)
635:    with io.TextIOWrapper(srcbuf, encoding) as tiow:
636:        return tiow.read(), encoding, newline
637:
638:
639:GRAMMARS = [

Calling tool: grepTool
def container_of\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1837:def container_of(leaf: Leaf) -> LN:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1957:def container_of(leaf: Leaf) -> LN:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1800:                return SPACE
1801:
1802:            if prev and prev.type == token.DOT:
1803:                return NO
1804:
1805:    elif p.type == syms.sliceop:
1806:        return NO
1807:
1808:    return SPACE
1809:
1810:
1811:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
1812:    """Return the first leaf that precedes `node`, if any."""
1813:    while node:
1814:        res = node.prev_sibling
1815:        if res:
1816:            if isinstance(res, Leaf):
1817:                return res
1818:
1819:            try:
1820:                return list(res.leaves())[-1]
1821:
1822:            except IndexError:
1823:                return None
1824:
1825:        node = node.parent
1826:    return None
1827:
1828:
1829:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
1830:    """Return the child of `ancestor` that contains `descendant`."""
1831:    node: Optional[LN] = descendant
1832:    while node and node.parent != ancestor:
1833:        node = node.parent
1834:    return node
1835:
1836:
1837:def container_of(leaf: Leaf) -> LN:
1838:    """Return `leaf` or one of its ancestors that is the topmost container of it.
1839:
1840:    By "container" we mean a node where `leaf` is the very first child.
1841:    """
1842:    same_prefix = leaf.prefix
1843:    container: LN = leaf
1844:    while container:
1845:        parent = container.parent
1846:        if parent is None:
1847:            break
1848:
1849:        if parent.children[0].prefix != same_prefix:
1850:            break
1851:
1852:        if parent.type == syms.file_input:
1853:            break
1854:
1855:        if parent.type in SURROUNDED_BY_BRACKETS:
1856:            break
1857:
1858:        container = parent
1859:    return container
1860:
1861:
1862:def is_split_after_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1863:    """Return the priority of the `leaf` delimiter, given a line break after it.
1864:
1865:    The delimiter priorities returned here are from those delimiters that would
1866:    cause a line break after themselves.
1867:
1868:    Higher numbers are higher priority.
1869:    """
1870:    if leaf.type == token.COMMA:
1871:        return COMMA_PRIORITY
1872:
1873:    return 0
1874:
1875:
1876:def is_split_before_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1877:    """Return the priority of the `leaf` delimiter, given a line before after it.
1878:
1879:    The delimiter priorities returned here are from those delimiters that would
1880:    cause a line break before themselves.
1881:
1882:    Higher numbers are higher priority.
1883:    """
1884:    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):
1885:        # * and ** might also be MATH_OPERATORS but in this case they are not.
1886:        # Don't treat them as a delimiter.
1887:        return 0
1888:
1889:    if (
1890:        leaf.type == token.DOT
1891:        and leaf.parent
1892:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
1893:        and (previous is None or previous.type in CLOSING_BRACKETS)
1894:    ):
1895:        return DOT_PRIORITY
1896:
1897:    if (
1898:        leaf.type in MATH_OPERATORS
1899:        and leaf.parent
1900:        and leaf.parent.type not in {syms.factor, syms.star_expr}
1901:    ):
1902:        return MATH_PRIORITIES[leaf.type]
1903:
1904:    if leaf.type in COMPARATORS:
1905:        return COMPARATOR_PRIORITY
1906:
1907:    if (
1908:        leaf.type == token.STRING
1909:        and previous is not None
1910:        and previous.type == token.STRING
1911:    ):
1912:        return STRING_PRIORITY
1913:
1914:    if leaf.type != token.NAME:
1915:        return 0
1916:
1917:    if (
1918:        leaf.value == "for"
1919:        and leaf.parent

Calling tool: grepTool
def list_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2130:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't
1985:    share the line with any code.
1986:
1987:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
1989:    """
1990:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
1991:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
1992:
1993:
1994:@dataclass
1995:class ProtoComment:
1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
1997:    value: str  # content of the comment
1998:    newlines: int  # how many newlines before the comment
1999:    consumed: int  # how many characters of the original leaf's prefix did we consume
2000:
2001:
2002:@lru_cache(maxsize=4096)
2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2004:    result: List[ProtoComment] = []
2005:    if not prefix or "#" not in prefix:
2006:        return result
2007:
2008:    consumed = 0
2009:    nlines = 0
2010:    for index, line in enumerate(prefix.split("\n")):
2011:        consumed += len(line) + 1  # adding the length of the split '\n'
2012:        line = line.lstrip()
2013:        if not line:
2014:            nlines += 1
2015:        if not line.startswith("#"):
2016:            continue
2017:
2018:        if index == 0 and not is_endmarker:
2019:            comment_type = token.COMMENT  # simple trailing comment
2020:        else:
2021:            comment_type = STANDALONE_COMMENT
2022:        comment = make_comment(line)
2023:        result.append(
2024:            ProtoComment(
2025:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2026:            )
2027:        )
2028:        nlines = 0
2029:    return result
2030:
2031:
2032:def make_comment(content: str) -> str:
2033:    """Return a consistently formatted comment from the given `content` string.
2034:
2035:    All comments (except for "##", "#!", "#:") should have a single space between
2036:    the hash sign and the content.
2037:
2038:    If `content` didn't start with a hash sign, one is provided.
2039:    """
2040:    content = content.rstrip()
2041:    if not content:
2042:        return "#"
2043:
2044:    if content[0] == "#":
2045:        content = content[1:]
2046:    if content and content[0] not in " !:#":
2047:        content = " " + content
2048:    return "#" + content
2049:
2050:
2051:def split_line(
2052:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2053:) -> Iterator[Line]:
2054:    """Split a `line` into potentially many lines.
2055:
2056:    They should fit in the allotted `line_length` but might not be able to.
2057:    `inner` signifies that there were a pair of brackets somewhere around the
2058:    current `line`, possibly transitively. This means we can fallback to splitting
2059:    by delimiters if the LHS/RHS don't yield any results.
2060:
2061:    If `py36` is True, splitting may generate syntax that is only compatible
2062:    with Python 3.6 and later.
2063:    """
2064:    if line.is_comment:
2065:        yield line
2066:        return
2067:
2068:    line_str = str(line).strip("\n")
2069:    if not line.should_explode and is_line_short_enough(
2070:        line, line_length=line_length, line_str=line_str
2071:    ):
2072:        yield line
2073:        return
2074:
2075:    split_funcs: List[SplitFunc]
2076:    if line.is_def:
2077:        split_funcs = [left_hand_split]
2078:    else:
2079:
2080:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2081:            for omit in generate_trailers_to_omit(line, line_length):
2082:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2083:                if is_line_short_enough(lines[0], line_length=line_length):
2084:                    yield from lines
2085:                    return
2086:
2087:            # All splits failed, best effort split with no omits.
2088:            # This mostly happens to multiline strings that are by definition
2089:            # reported as not fitting a single line.
2090:            yield from right_hand_split(line, py36)
2091:
2092:        if line.inside_brackets:
2093:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2094:        else:
2095:            split_funcs = [rhs]
2096:    for split_func in split_funcs:
2097:        # We are accumulating lines in `result` because we might want to abort
2098:        # mission and return the original line in the end, or attempt a different
2099:        # split altogether.
2100:        result: List[Line] = []
2101:        try:
2102:            for l in split_func(line, py36):
2103:                if str(l).strip("\n") == line_str:
2104:                    raise CannotSplit("Split function returned an unchanged result")
2105:
2106:                result.extend(
2107:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2108:                )
2109:        except CannotSplit as cs:
2110:            continue
2111:
2112:        else:
2113:            yield from result
2114:            break
2115:
2116:    else:
2117:        yield line
2118:
2119:
2120:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2121:    """Split line into many lines, starting with the first matching bracket pair.
2122:
2123:    Note: this usually looks weird, only use this for function definitions.
2124:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2125:    :func:`right_hand_split` which also handles optional parentheses.
2126:    """
2127:    head = Line(depth=line.depth)
2128:    body = Line(depth=line.depth + 1, inside_brackets=True)
2129:    tail = Line(depth=line.depth)
2130:    tail_leaves: List[Leaf] = []
2131:    body_leaves: List[Leaf] = []
2132:    head_leaves: List[Leaf] = []
2133:    current_leaves = head_leaves
2134:    matching_bracket = None
2135:    for leaf in line.leaves:
2136:        if (
2137:            current_leaves is body_leaves
2138:            and leaf.type in CLOSING_BRACKETS
2139:            and leaf.opening_bracket is matching_bracket
2140:        ):
2141:            current_leaves = tail_leaves if body_leaves else head_leaves
2142:        current_leaves.append(leaf)
2143:        if current_leaves is head_leaves:
2144:            if leaf.type in OPENING_BRACKETS:
2145:                matching_bracket = leaf
2146:                current_leaves = body_leaves
2147:    # Since body is a new indent level, remove spurious leading whitespace.
2148:    if body_leaves:
2149:        normalize_prefix(body_leaves[0], inside_brackets=True)
2150:    # Build the new lines.
2151:    for result, leaves in (head, head_leaves), (body, body_leaves), (tail, tail_leaves):
2152:        for leaf in leaves:
2153:            result.append(leaf, preformatted=True)
2154:            for comment_after in line.comments_after(leaf):
2155:                result.append(comment_after, preformatted=True)
2156:    bracket_split_succeeded_or_raise(head, body, tail)
2157:    for result in (head, body, tail):
2158:        if result:
2159:            yield result
2160:
2161:
2162:def right_hand_split(
2163:    line: Line, line_length: int, py36: bool = False, omit: Collection[LeafID] = ()
2164:) -> Iterator[Line]:
2165:    """Split line into many lines, starting with the last matching bracket pair.
2166:
2167:    If the split was by optional parentheses, attempt splitting without them, too.
2168:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2169:    this split.
2170:
2171:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2172:    """
2173:    head = Line(depth=line.depth)
2174:    body = Line(depth=line.depth + 1, inside_brackets=True)
2175:    tail = Line(depth=line.depth)
2176:    tail_leaves: List[Leaf] = []
2177:    body_leaves: List[Leaf] = []
2178:    head_leaves: List[Leaf] = []
2179:    current_leaves = tail_leaves
2180:    opening_bracket = None
2181:    closing_bracket = None
2182:    for leaf in reversed(line.leaves):
2183:        if current_leaves is body_leaves:
2184:            if leaf is opening_bracket:
2185:                current_leaves = head_leaves if body_leaves else tail_leaves
2186:        current_leaves.append(leaf)
2187:        if current_leaves is tail_leaves:
2188:            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:
2189:                opening_bracket = leaf.opening_bracket
2190:                closing_bracket = leaf
2191:                current_leaves = body_leaves
2192:    tail_leaves.reverse()
2193:    body_leaves.reverse()
2194:    head_leaves.reverse()
2195:    # Since body is a new indent level, remove spurious leading whitespace.
2196:    if body_leaves:
2197:        normalize_prefix(body_leaves[0], inside_brackets=True)
2198:    if not head_leaves:
2199:        # No `head` means the split failed. Either `tail` has all content or
2200:        # the matching `opening_bracket` wasn't available on `line` anymore.
2201:        raise CannotSplit("No brackets found")
2202:
2203:    # Build the new lines.
2204:    for result, leaves in (head, head_leaves), (body, body_leaves), (tail, tail_leaves):
2205:        for leaf in leaves:
2206:            result.append(leaf, preformatted=True)
2207:            for comment_after in line.comments_after(leaf):
2208:                result.append(comment_after, preformatted=True)
2209:    assert opening_bracket and closing_bracket
2210:    body.should_explode = should_explode(body, opening_bracket)
2211:    bracket_split_succeeded_or_raise(head, body, tail)
2212:    if (
2213:        # the body shouldn't be exploded
2214:        not body.should_explode
2215:        # the opening bracket is an optional paren
2216:        and opening_bracket.type == token.LPAR
2217:        and not opening_bracket.value
2218:        # the closing bracket is an optional paren
2219:        and closing_bracket.type == token.RPAR

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2520:
2521:    check_lpar = False
2522:    for index, child in enumerate(list(node.children)):
2523:        if check_lpar:
2524:            if child.type == syms.atom:
2525:                maybe_make_parens_invisible_in_atom(child)
2526:            elif is_one_tuple(child):
2527:                # wrap child in visible parentheses
2528:                lpar = Leaf(token.LPAR, "(")
2529:                rpar = Leaf(token.RPAR, ")")
2530:                child.remove()
2531:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2532:            elif node.type == syms.import_from:
2533:                # "import from" nodes store parentheses directly as part of
2534:                # the statement
2535:                if child.type == token.LPAR:
2536:                    # make parentheses invisible
2537:                    child.value = ""  # type: ignore
2538:                    node.children[-1].value = ""  # type: ignore
2539:                elif child.type != token.STAR:
2540:                    # insert invisible parentheses
2541:                    node.insert_child(index, Leaf(token.LPAR, ""))
2542:                    node.append_child(Leaf(token.RPAR, ""))
2543:                break
2544:
2545:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2546:                # wrap child in invisible parentheses
2547:                lpar = Leaf(token.LPAR, "")
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2
2658:        and node.children[0].type == token.LPAR
2659:        and node.children[1].type == token.RPAR
2660:    )
2661:
2662:
2663:def is_one_tuple(node: LN) -> bool:
2664:    """Return True if `node` holds a tuple with one element, with or without parens."""
2665:    if node.type == syms.atom:
2666:        if len(node.children) != 3:
2667:            return False
2668:
2669:        lpar, gexp, rpar = node.children
2670:        if not (
2671:            lpar.type == token.LPAR
2672:            and gexp.type == syms.testlist_gexp
2673:            and rpar.type == token.RPAR
2674:        ):
2675:            return False
2676:
2677:        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA
2678:
2679:    return (
2680:        node.type in IMPLICIT_TUPLE
2681:        and len(node.children) == 2
2682:        and node.children[1].type == token.COMMA
2683:    )
2684:
2685:
2686:def is_yield(node: LN) -> bool:
2687:    """Return True if `node` holds a `yield` or `yield from` expression."""
2688:    if node.type == syms.yield_expr:
2689:        return True
2690:
2691:    if node.type == token.NAME and node.value == "yield":  # type: ignore
2692:        return True
2693:
2694:    if node.type != syms.atom:
2695:        return False
2696:
2697:    if len(node.children) != 3:
2698:        return False
2699:
2700:    lpar, expr, rpar = node.children
2701:    if lpar.type == token.LPAR and rpar.type == token.RPAR:
2702:        return is_yield(expr)
2703:
2704:    return False
2705:
2706:
2707:def is_vararg(leaf: Leaf, within: Set[NodeType]) -> bool:
2708:    """Return True if `leaf` is a star or double star in a vararg or kwarg.
2709:
2710:    If `within` includes VARARGS_PARENTS, this applies to function signatures.
2711:    If `within` includes UNPACKING_PARENTS, it applies to right hand-side
2712:    extended iterable unpacking (PEP 3132) and additional unpacking
2713:    generalizations (PEP 448).
2714:    """
2715:    if leaf.type not in STARS or not leaf.parent:
2716:        return False
2717:
2718:    p = leaf.parent
2719:    if p.type == syms.star_expr:
2720:        # Star expressions are also used as assignment targets in extended
2721:        # iterable unpacking (PEP 3132).  See what its parent is instead.
2722:        if not p.parent:
2723:            return False
2724:
2725:        p = p.parent
2726:
2727:    return p.type in within
2728:
2729:
2730:def is_multiline_string(leaf: Leaf) -> bool:
2731:    """Return True if `leaf` is a multiline string that actually spans many lines."""
2732:    value = leaf.value.lstrip("furbFURB")
2733:    return value[:3] in {'"""', "'''"} and "\n" in value
2734:
2735:
2736:def is_stub_suite(node: Node) -> bool:
2737:    """Return True if `node` is a suite with a stub body."""
2738:    if (
2739:        len(node.children) != 4
2740:        or node.children[0].type != token.NEWLINE
2741:        or node.children[1].type != token.INDENT
2742:        or node.children[3].type != token.DEDENT
2743:    ):
2744:        return False
2745:
2746:    return is_stub_body(node.children[2])
2747:
2748:
2749:def is_stub_body(node: LN) -> bool:
2750:    """Return True if `node` is a simple statement containing an ellipsis."""
2751:    if not isinstance(node, Node) or node.type != syms.simple_stmt:
2752:        return False
2753:
2754:    if len(node.children) != 2:
2755:        return False
2756:
2757:    child = node.children[0]
2758:    return (
2759:        child.type == syms.atom

Calling tool: grepTool
FMT_ON|FMT_OFF|STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:757:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1126:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1196:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1207:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2021:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2357:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2517:        if pc.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2570:            if comment.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2574:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2601:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2621:            if comment.value in FMT_ON:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2878:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:784:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1068:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1078:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1153:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1223:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1234:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2084:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2085:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2109:        if pc.value in FMT_ON:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2112:        if pc.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2113:            if pc.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2148:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2484:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2644:        if pc.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2704:            if comment.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2723:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2739:            if comment.value in FMT_ON:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2996:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
720:
721:            self.tree_depth -= 1
722:            out(f"{indent}/{_type}", fg="yellow", bold=False)
723:        else:
724:            _type = token.tok_name.get(node.type, str(node.type))
725:            out(f"{indent}{_type}", fg="blue", nl=False)
726:            if node.prefix:
727:                # We don't have to handle prefixes for `Node` objects since
728:                # that delegates to the first child anyway.
729:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
730:            out(f" {node.value!r}", fg="blue", bold=False)
731:
732:    @classmethod
733:    def show(cls, code: Union[str, Leaf, Node]) -> None:
734:        """Pretty-print the lib2to3 AST of a given string of `code`.
735:
736:        Convenience method for debugging.
737:        """
738:        v: DebugVisitor[None] = DebugVisitor()
739:        if isinstance(code, str):
740:            code = lib2to3_parse(code)
741:        list(v.visit(code))
742:
743:
744:KEYWORDS = set(keyword.kwlist)
745:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
746:FLOW_CONTROL = {"return", "raise", "break", "continue"}
747:STATEMENT = {
748:    syms.if_stmt,
749:    syms.while_stmt,
750:    syms.for_stmt,
751:    syms.try_stmt,
752:    syms.except_clause,
753:    syms.with_stmt,
754:    syms.funcdef,
755:    syms.classdef,
756:}
757:STANDALONE_COMMENT = 153
758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
759:LOGIC_OPERATORS = {"and", "or"}
760:COMPARATORS = {
761:    token.LESS,
762:    token.GREATER,
763:    token.EQEQUAL,
764:    token.NOTEQUAL,
765:    token.LESSEQUAL,
766:    token.GREATEREQUAL,
767:}
768:MATH_OPERATORS = {
769:    token.VBAR,
770:    token.CIRCUMFLEX,
771:    token.AMPER,
772:    token.LEFTSHIFT,
773:    token.RIGHTSHIFT,
774:    token.PLUS,
775:    token.MINUS,
776:    token.STAR,
777:    token.SLASH,
778:    token.DOUBLESLASH,
779:    token.PERCENT,
780:    token.AT,
781:    token.TILDE,
782:    token.DOUBLESTAR,
783:}
784:STARS = {token.STAR, token.DOUBLESTAR}
785:VARARGS_PARENTS = {
786:    syms.arglist,
787:    syms.argument,  # double star in arglist
788:    syms.trailer,  # single argument to call
789:    syms.typedargslist,
790:    syms.varargslist,  # lambdas
791:}
792:UNPACKING_PARENTS = {
793:    syms.atom,  # single element of a list or set literal
794:    syms.dictsetmaker,
795:    syms.listmaker,
796:    syms.testlist_gexp,
797:    syms.testlist_star_expr,
798:}
799:SURROUNDED_BY_BRACKETS = {
800:    syms.typedargslist,
801:    syms.arglist,
802:    syms.subscriptlist,
803:    syms.vfplist,
804:    syms.import_as_names,
805:    syms.yield_expr,
806:    syms.testlist_gexp,
807:    syms.testlist_star_expr,
808:    syms.listmaker,
809:    syms.dictsetmaker,
810:}
811:TEST_DESCENDANTS = {
812:    syms.test,
813:    syms.lambdef,
814:    syms.or_test,
815:    syms.and_test,
816:    syms.not_test,
817:    syms.comparison,
818:    syms.star_expr,
819:    syms.expr,
820:    syms.xor_expr,
821:    syms.and_expr,
822:    syms.shift_expr,
823:    syms.arith_expr,
824:    syms.trailer,
825:    syms.term,
826:    syms.power,
827:}
828:ASSIGNMENTS = {
829:    "=",
830:    "+=",
831:    "-=",
832:    "*=",
833:    "@=",
834:    "/=",
835:    "%=",
836:    "&=",
837:    "|=",
838:    "^=",
839:    "<<=",
840:    ">>=",
841:    "**=",
842:    "//=",
843:}
844:COMPREHENSION_PRIORITY = 20
845:COMMA_PRIORITY = 18
846:TERNARY_PRIORITY = 16
847:LOGIC_PRIORITY = 14
848:STRING_PRIORITY = 12
849:COMPARATOR_PRIORITY = 10
850:MATH_PRIORITIES = {
851:    token.VBAR: 9,
852:    token.CIRCUMFLEX: 8,
853:    token.AMPER: 7,
854:    token.LEFTSHIFT: 6,
855:    token.RIGHTSHIFT: 6,
856:    token.PLUS: 5,
857:    token.MINUS: 5,
858:    token.STAR: 4,
859:    token.SLASH: 4,
860:    token.DOUBLESLASH: 4,
861:    token.PERCENT: 4,
862:    token.AT: 4,
863:    token.TILDE: 3,
864:    token.DOUBLESTAR: 2,
865:}
866:DOT_PRIORITY = 1
867:
868:
869:@dataclass
870:class BracketTracker:
871:    """Keeps track of brackets on a line."""
872:
873:    depth: int = 0
874:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
875:    delimiters: Dict[LeafID, Priority] = Factory(dict)
876:    previous: Optional[Leaf] = None
877:    _for_loop_variable: int = 0
878:    _lambda_arguments: int = 0
879:
880:    def mark(self, leaf: Leaf) -> None:
881:        """Mark `leaf` with bracket-related metadata. Keep track of delimiters.
882:
883:        All leaves receive an int `bracket_depth` field that stores how deep
884:        within brackets a given leaf is. 0 means there are no enclosing brackets
885:        that started on this line.
886:
887:        If a leaf is itself a closing bracket, it receives an `opening_bracket`
888:        field that it forms a pair with. This is a one-directional link to
889:        avoid reference cycles.
890:
891:        If a leaf is a delimiter (a token on which Black can split the line if
892:        needed) and it's on depth 0, its `id()` is stored in the tracker's
893:        `delimiters` field.
894:        """
895:        if leaf.type == token.COMMENT:
896:            return
897:
898:        self.maybe_decrement_after_for_loop_variable(leaf)
899:        self.maybe_decrement_after_lambda_arguments(leaf)
900:        if leaf.type in CLOSING_BRACKETS:
901:            self.depth -= 1
902:            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))
903:            leaf.opening_bracket = opening_bracket
904:        leaf.bracket_depth = self.depth
905:        if self.depth == 0:
906:            delim = is_split_before_delimiter(leaf, self.previous)
907:            if delim and self.previous is not None:
908:                self.delimiters[id(self.previous)] = delim
909:            else:
910:                delim = is_split_after_delimiter(leaf, self.previous)
911:                if delim:
912:                    self.delimiters[id(leaf)] = delim
913:        if leaf.type in OPENING_BRACKETS:
914:            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf
915:            self.depth += 1
916:        self.previous = leaf
917:        self.maybe_increment_lambda_arguments(leaf)
918:        self.maybe_increment_for_loop_variable(leaf)
919:
920:    def any_open_brackets(self) -> bool:
921:        """Return True if there is an yet unmatched open bracket on the line."""
922:        return bool(self.bracket_match)
923:
924:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
925:        """Return the highest priority of a delimiter found on the line.
926:
927:        Values are consistent with what `is_split_*_delimiter()` return.
928:        Raises ValueError on no delimiters.
929:        """
930:        return max(v for k, v in self.delimiters.items() if k not in exclude)
931:
932:    def delimiter_count_with_priority(self, priority: int = 0) -> int:
933:        """Return the number of delimiters with the given `priority`.
934:
935:        If no `priority` is passed, defaults to max priority on the line.
936:        """
937:        if not self.delimiters:
938:            return 0
939:
940:        priority = priority or self.max_delimiter_priority()
941:        return sum(1 for p in self.delimiters.values() if p == priority)
942:
943:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
944:        """In a for loop, or comprehension, the variables are often unpacks.
945:
946:        To avoid splitting on the comma in this situation, increase the depth of
947:        tokens between `for` and `in`.
948:        """
949:        if leaf.type == token.NAME and leaf.value == "for":
950:            self.depth += 1
951:            self._for_loop_variable += 1
952:            return True
953:
954:        return False
955:
956:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
957:        """See `maybe_increment_for_loop_variable` above for explanation."""
958:        if self._for_loop_variable and leaf.type == token.NAME and leaf.value == "in":
959:            self.depth -= 1
960:            self._for_loop_variable -= 1
961:            return True
962:
963:        return False
964:
965:    def maybe_increment_lambda_arguments(self, leaf: Leaf) -> bool:
966:        """In a lambda expression, there might be more than one argument.
967:
968:        To avoid splitting on the comma in this situation, increase the depth of
969:        tokens between `lambda` and `:`.
970:        """
971:        if leaf.type == token.NAME and leaf.value == "lambda":
972:            self.depth += 1
973:            self._lambda_arguments += 1
974:            return True
975:
976:        return False
977:
978:    def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:
979:        """See `maybe_increment_lambda_arguments` above for explanation."""
980:        if self._lambda_arguments and leaf.type == token.COLON:
981:            self.depth -= 1
982:            self._lambda_arguments -= 1
983:            return True
984:
985:        return False
986:
987:    def get_open_lsqb(self) -> Optional[Leaf]:
988:        """Return the most recent opening square bracket (if any)."""
989:        return self.bracket_match.get((self.depth - 1, token.RSQB))
990:
991:
992:@dataclass
993:class Line:
994:    """Holds leaves and comments. Can be printed with `str(line)`."""
995:
996:    depth: int = 0
997:    leaves: List[Leaf] = Factory(list)
998:    comments: List[Tuple[Index, Leaf]] = Factory(list)
999:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1000:    inside_brackets: bool = False
1001:    should_explode: bool = False
1002:
1003:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1004:        """Add a new `leaf` to the end of the line.
1005:
1006:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1007:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1008:        Trailing commas are maybe removed, unpacked for loop variables are
1009:        demoted from being delimiters.
1010:
1011:        Inline comments are put aside.
1012:        """
1013:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1014:        if not has_value:
1015:            return
1016:
1017:        if token.COLON == leaf.type and self.is_class_paren_empty:
1018:            del self.leaves[-2:]
1019:        if self.leaves and not preformatted:
1020:            # Note: at this point leaf.prefix should be empty except for
1021:            # imports, for which we only preserve newlines.
1022:            leaf.prefix += whitespace(
1023:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1024:            )
1025:        if self.inside_brackets or not preformatted:
1026:            self.bracket_tracker.mark(leaf)
1027:            self.maybe_remove_trailing_comma(leaf)
1028:        if not self.append_comment(leaf):
1029:            self.leaves.append(leaf)
1030:
1031:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1032:        """Like :func:`append()` but disallow invalid standalone comment structure.
1033:
1034:        Raises ValueError when any `leaf` is appended after a standalone comment
1035:        or when a standalone comment is not the first leaf on the line.
1036:        """
1037:        if self.bracket_tracker.depth == 0:
1038:            if self.is_comment:
1039:                raise ValueError("cannot append to standalone comments")
1040:
1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1042:                raise ValueError(
1043:                    "cannot append standalone comments to a populated line"
1044:                )
1045:
1046:        self.append(leaf, preformatted=preformatted)
1047:
1048:    @property
1049:    def is_comment(self) -> bool:
1050:        """Is this line a standalone comment?"""
1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1052:
1053:    @property
1054:    def is_decorator(self) -> bool:
1055:        """Is this line a decorator?"""
1056:        return bool(self) and self.leaves[0].type == token.AT
1057:
1058:    @property
1059:    def is_import(self) -> bool:
1060:        """Is this an import line?"""
1061:        return bool(self) and is_import(self.leaves[0])
1062:
1063:    @property
1064:    def is_class(self) -> bool:
1065:        """Is this line a class definition?"""
1066:        return (
1067:            bool(self)
1068:            and self.leaves[0].type == token.NAME
1069:            and self.leaves[0].value == "class"
1070:        )
1071:
1072:    @property
1073:    def is_stub_class(self) -> bool:
1074:        """Is this line a class definition with a body consisting only of "..."?"""
1075:        return self.is_class and self.leaves[-3:] == [
1076:            Leaf(token.DOT, ".") for _ in range(3)
1077:        ]
1078:
1079:    @property
1080:    def is_def(self) -> bool:
1081:        """Is this a function definition? (Also returns True for async defs.)"""
1082:        try:
1083:            first_leaf = self.leaves[0]
1084:        except IndexError:
1085:            return False
1086:
1087:        try:
1088:            second_leaf: Optional[Leaf] = self.leaves[1]
1089:        except IndexError:
1090:            second_leaf = None
1091:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1092:            first_leaf.type == token.ASYNC
1093:            and second_leaf is not None
1094:            and second_leaf.type == token.NAME
1095:            and second_leaf.value == "def"
1096:        )
1097:
1098:    @property
1099:    def is_class_paren_empty(self) -> bool:
1100:        """Is this a class with no base classes but using parentheses?
1101:
1102:        Those are unnecessary and should be removed.
1103:        """
1104:        return (
1105:            bool(self)
1106:            and len(self.leaves) == 4
1107:            and self.is_class
1108:            and self.leaves[2].type == token.LPAR
1109:            and self.leaves[2].value == "("
1110:            and self.leaves[3].type == token.RPAR
1111:            and self.leaves[3].value == ")"
1112:        )
1113:
1114:    @property
1115:    def is_triple_quoted_string(self) -> bool:
1116:        """Is the line a triple quoted string?"""
1117:        return (
1118:            bool(self)
1119:            and self.leaves[0].type == token.STRING
1120:            and self.leaves[0].value.startswith(('"""', "'''"))
1121:        )
1122:
1123:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1124:        """If so, needs to be split before emitting."""
1125:        for leaf in self.leaves:
1126:            if leaf.type == STANDALONE_COMMENT:
1127:                if leaf.bracket_depth <= depth_limit:
1128:                    return True
1129:
1130:        return False
1131:
1132:    def contains_multiline_strings(self) -> bool:
1133:        for leaf in self.leaves:
1134:            if is_multiline_string(leaf):
1135:                return True
1136:
1137:        return False
1138:
1139:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1140:        """Remove trailing comma if there is one and it's safe."""
1141:        if not (
1142:            self.leaves
1143:            and self.leaves[-1].type == token.COMMA
1144:            and closing.type in CLOSING_BRACKETS
1145:        ):
1146:            return False
1147:
1148:        if closing.type == token.RBRACE:
1149:            self.remove_trailing_comma()
1150:            return True
1151:
1152:        if closing.type == token.RSQB:
1153:            comma = self.leaves[-1]
1154:            if comma.parent and comma.parent.type == syms.listmaker:
1155:                self.remove_trailing_comma()
1156:                return True
1157:
1158:        # For parens let's check if it's safe to remove the comma.
1159:        # Imports are always safe.
1160:        if self.is_import:
1161:            self.remove_trailing_comma()
1162:            return True
1163:
1164:        # Otheriwsse, if the trailing one is the only one, we might mistakenly
1165:        # change a tuple into a different type by removing the comma.
1166:        depth = closing.bracket_depth + 1
1167:        commas = 0
1168:        opening = closing.opening_bracket
1169:        for _opening_index, leaf in enumerate(self.leaves):
1170:            if leaf is opening:
1171:                break
1172:
1173:        else:
1174:            return False
1175:
1176:        for leaf in self.leaves[_opening_index + 1 :]:
1177:            if leaf is closing:
1178:                break
1179:
1180:            bracket_depth = leaf.bracket_depth
1181:            if bracket_depth == depth and leaf.type == token.COMMA:
1182:                commas += 1
1183:                if leaf.parent and leaf.parent.type == syms.arglist:
1184:                    commas += 1
1185:                    break
1186:
1187:        if commas > 1:
1188:            self.remove_trailing_comma()
1189:            return True
1190:
1191:        return False
1192:
1193:    def append_comment(self, comment: Leaf) -> bool:
1194:        """Add an inline or standalone comment to the line."""
1195:        if (
1196:            comment.type == STANDALONE_COMMENT
1197:            and self.bracket_tracker.any_open_brackets()
1198:        ):
1199:            comment.prefix = ""
1200:            return False
1201:
1202:        if comment.type != token.COMMENT:
1203:            return False
1204:
1205:        after = len(self.leaves) - 1
1206:        if after == -1:
1207:            comment.type = STANDALONE_COMMENT
1208:            comment.prefix = ""
1209:            return False
1210:
1211:        else:
1212:            self.comments.append((after, comment))
1213:            return True
1214:
1215:    def comments_after(self, leaf: Leaf, _index: int = -1) -> Iterator[Leaf]:
1216:        """Generate comments that should appear directly after `leaf`.
1217:
1218:        Provide a non-negative leaf `_index` to speed up the function.
1219:        """
1220:        if not self.comments:
1221:            return
1222:
1223:        if _index == -1:
1224:            for _index, _leaf in enumerate(self.leaves):
1225:                if leaf is _leaf:
1226:                    break
1227:
1228:            else:
1229:                return
1230:
1231:        for index, comment_after in self.comments:
1232:            if _index == index:
1233:                yield comment_after
1234:
1235:    def remove_trailing_comma(self) -> None:
1236:        """Remove the trailing comma and moves the comments attached to it."""
1237:        comma_index = len(self.leaves) - 1
1238:        for i in range(len(self.comments)):
1239:            comment_index, comment = self.comments[i]

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1500:        is_suite_like = node.parent and node.parent.type in STATEMENT
1501:        if is_suite_like:
1502:            if self.is_pyi and is_stub_body(node):
1503:                yield from self.visit_default(node)
1504:            else:
1505:                yield from self.line(+1)
1506:                yield from self.visit_default(node)
1507:                yield from self.line(-1)
1508:
1509:        else:
1510:            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):
1511:                yield from self.line()
1512:            yield from self.visit_default(node)
1513:
1514:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:
1515:        """Visit `async def`, `async for`, `async with`."""
1516:        yield from self.line()
1517:
1518:        children = iter(node.children)
1519:        for child in children:
1520:            yield from self.visit(child)
1521:
1522:            if child.type == token.ASYNC:
1523:                break
1524:
1525:        internal_stmt = next(children)
1526:        for child in internal_stmt.children:
1527:            yield from self.visit(child)
1528:
1529:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1530:        """Visit decorators."""
1531:        for child in node.children:
1532:            yield from self.line()
1533:            yield from self.visit(child)
1534:
1535:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1536:        """Remove a semicolon and put the other statement on a separate line."""
1537:        yield from self.line()
1538:
1539:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1540:        """End of file. Process outstanding comments and end with a newline."""
1541:        yield from self.visit_default(leaf)
1542:        yield from self.line()
1543:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1545:        if not self.current_line.bracket_tracker.any_open_brackets():
1546:            yield from self.line()
1547:        yield from self.visit_default(leaf)
1548:
1549:    def __attrs_post_init__(self) -> None:
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1558:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1559:        self.visit_try_stmt = partial(
1560:            v, keywords={"try", "except", "else", "finally"}, parens=
1561:        )
1562:        self.visit_except_clause = partial(v, keywords={"except"}, parens=)
1563:        self.visit_with_stmt = partial(v, keywords={"with"}, parens=)
1564:        self.visit_funcdef = partial(v, keywords={"def"}, parens=)
1565:        self.visit_classdef = partial(v, keywords={"class"}, parens=)
1566:        self.visit_expr_stmt = partial(v, keywords=, parens=ASSIGNMENTS)
1567:        self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})
1568:        self.visit_import_from = partial(v, keywords=, parens={"import"})
1569:        self.visit_async_funcdef = self.visit_async_stmt
1570:        self.visit_decorated = self.visit_decorators
1571:
1572:
1573:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
1574:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1575:OPENING_BRACKETS = set(BRACKET.keys())
1576:CLOSING_BRACKETS = set(BRACKET.values())
1577:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1579:

Calling tool: grepTool
def generate_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2088:def generate_comments(leaf: LN) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1960:
1961:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1962:        return LOGIC_PRIORITY
1963:
1964:    return 0
1965:
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't
1985:    share the line with any code.
1986:
1987:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
1989:    """
1990:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
1991:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
1992:
1993:
1994:@dataclass
1995:class ProtoComment:
1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
1997:    value: str  # content of the comment
1998:    newlines: int  # how many newlines before the comment
1999:    consumed: int  # how many characters of the original leaf's prefix did we consume

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1240:            if comment_index == comma_index:
1241:                self.comments[i] = (comma_index - 1, comment)
1242:        self.leaves.pop()
1243:
1244:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1245:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1246:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1247:        if open_lsqb is None:
1248:            return False
1249:
1250:        subscript_start = open_lsqb.next_sibling
1251:
1252:        if isinstance(subscript_start, Node):
1253:            if subscript_start.type == syms.listmaker:
1254:                return False
1255:
1256:            if subscript_start.type == syms.subscriptlist:
1257:                subscript_start = child_towards(subscript_start, leaf)
1258:        return subscript_start is not None and any(
1259:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
1260:        )
1261:
1262:    def __str__(self) -> str:
1263:        """Render the line."""
1264:        if not self:
1265:            return "\n"
1266:
1267:        indent = "    " * self.depth
1268:        leaves = iter(self.leaves)
1269:        first = next(leaves)
1270:        res = f"{first.prefix}{indent}{first.value}"
1271:        for leaf in leaves:
1272:            res += str(leaf)
1273:        for _, comment in self.comments:
1274:            res += str(comment)
1275:        return res + "\n"
1276:
1277:    def __bool__(self) -> bool:
1278:        """Return True if the line has leaves or comments."""
1279:        return bool(self.leaves or self.comments)
1280:
1281:
1282:@dataclass
1283:class EmptyLineTracker:
1284:    """Provides a stateful method that returns the number of potential extra
1285:    empty lines needed before and after the currently processed line.
1286:
1287:    Note: this tracker works on lines that haven't been split yet.  It assumes
1288:    the prefix of the first leaf consists of optional newlines.  Those newlines
1289:    are consumed by `maybe_empty_lines()` and included in the computation.
1290:    """
1291:
1292:    is_pyi: bool = False
1293:    previous_line: Optional[Line] = None
1294:    previous_after: int = 0
1295:    previous_defs: List[int] = Factory(list)
1296:
1297:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1298:        """Return the number of extra empty lines before and after the `current_line`.
1299:
1300:        This is for separating `def`, `async def` and `class` with extra empty
1301:        lines (two on module-level).
1302:        """
1303:        before, after = self._maybe_empty_lines(current_line)
1304:        before -= self.previous_after
1305:        self.previous_after = after
1306:        self.previous_line = current_line
1307:        return before, after
1308:
1309:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1310:        max_allowed = 1
1311:        if current_line.depth == 0:
1312:            max_allowed = 1 if self.is_pyi else 2
1313:        if current_line.leaves:
1314:            # Consume the first leaf's extra newlines.
1315:            first_leaf = current_line.leaves[0]
1316:            before = first_leaf.prefix.count("\n")
1317:            before = min(before, max_allowed)
1318:            first_leaf.prefix = ""
1319:        else:
1320:            before = 0
1321:        depth = current_line.depth
1322:        while self.previous_defs and self.previous_defs[-1] >= depth:
1323:            self.previous_defs.pop()
1324:            if self.is_pyi:
1325:                before = 0 if depth else 1
1326:            else:
1327:                before = 1 if depth else 2
1328:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
1329:            return self._maybe_empty_lines_for_class_or_def(current_line, before)
1330:
1331:        if (
1332:            self.previous_line
1333:            and self.previous_line.is_import
1334:            and not current_line.is_import
1335:            and depth == self.previous_line.depth
1336:        ):
1337:            return (before or 1), 0
1338:
1339:        if (
1340:            self.previous_line
1341:            and self.previous_line.is_class
1342:            and current_line.is_triple_quoted_string
1343:        ):
1344:            return before, 1
1345:
1346:        return before, 0
1347:
1348:    def _maybe_empty_lines_for_class_or_def(
1349:        self, current_line: Line, before: int
1350:    ) -> Tuple[int, int]:
1351:        if not current_line.is_decorator:
1352:            self.previous_defs.append(current_line.depth)
1353:        if self.previous_line is None:
1354:            # Don't insert empty lines before the first line in the file.
1355:            return 0, 0
1356:
1357:        if self.previous_line.is_decorator:
1358:            return 0, 0
1359:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1360:        if self.previous_line.depth < current_line.depth and (
1361:            self.previous_line.is_class or self.previous_line.is_def
1362:        ):
1363:            return 0, 0
1364:
1365:        if (
1366:            self.previous_line.is_comment
1367:            and self.previous_line.depth == current_line.depth
1368:            and before == 0
1369:        ):
1370:            return 0, 0
1371:
1372:        if self.is_pyi:
1373:            if self.previous_line.depth > current_line.depth:
1374:                newlines = 1
1375:            elif current_line.is_class or self.previous_line.is_class:
1376:                if current_line.is_stub_class and self.previous_line.is_stub_class:
1377:                    # No blank line between classes with an emty body
1378:                    newlines = 0
1379:                else:
1380:                    newlines = 1
1381:            elif current_line.is_def and not self.previous_line.is_def:
1382:                # Blank line between a block of functions and a block of non-functions
1383:                newlines = 1
1384:            else:
1385:                newlines = 0
1386:        else:
1387:            newlines = 2
1388:        if current_line.depth and newlines:
1389:            newlines -= 1
1390:        return newlines, 0
1391:
1392:
1393:@dataclass
1394:class LineGenerator(Visitor[Line]):
1395:    """Generates reformatted Line objects.  Empty lines are not emitted.
1396:
1397:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
1398:    in ways that will no longer stringify to valid Python code on the tree.
1399:    """
1400:
1401:    is_pyi: bool = False
1402:    normalize_strings: bool = True
1403:    current_line: Line = Factory(Line)
1404:    remove_u_prefix: bool = False
1405:
1406:    def line(self, indent: int = 0) -> Iterator[Line]:
1407:        """Generate a line.
1408:
1409:        If the line is empty, only emit if it makes sense.
1410:        If the line is too long, split it first and then generate.
1411:
1412:        If any lines were generated, set up a new current_line.
1413:        """
1414:        if not self.current_line:
1415:            self.current_line.depth += indent
1416:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1417:
1418:        complete_line = self.current_line
1419:        self.current_line = Line(depth=complete_line.depth + indent)
1420:        yield complete_line
1421:
1422:    def visit_default(self, node: LN) -> Iterator[Line]:
1423:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1424:        if isinstance(node, Leaf):
1425:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1426:            for comment in generate_comments(node):
1427:                if any_open_brackets:
1428:                    # any comment within brackets is subject to splitting
1429:                    self.current_line.append(comment)
1430:                elif comment.type == token.COMMENT:
1431:                    # regular trailing comment
1432:                    self.current_line.append(comment)
1433:                    yield from self.line()
1434:
1435:                else:
1436:                    # regular standalone comment
1437:                    yield from self.line()
1438:
1439:                    self.current_line.append(comment)
1440:                    yield from self.line()
1441:
1442:            normalize_prefix(node, inside_brackets=any_open_brackets)
1443:            if self.normalize_strings and node.type == token.STRING:
1444:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1445:                normalize_string_quotes(node)
1446:            if node.type not in WHITESPACE:
1447:                self.current_line.append(node)
1448:        yield from super().visit_default(node)
1449:
1450:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1451:        """Increase indentation level, maybe yield a line."""
1452:        # In blib2to3 INDENT never holds comments.
1453:        yield from self.line(+1)
1454:        yield from self.visit_default(node)
1455:
1456:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1457:        """Decrease indentation level, maybe yield a line."""
1458:        # The current line might still wait for trailing comments.  At DEDENT time
1459:        # there won't be any (they would be prefixes on the preceding NEWLINE).
1460:        # Emit the line then.
1461:        yield from self.line()
1462:
1463:        # While DEDENT has no value, its prefix may contain standalone comments
1464:        # that belong to the current indentation level.  Get 'em.
1465:        yield from self.visit_default(node)
1466:
1467:        # Finally, emit the dedent.
1468:        yield from self.line(-1)
1469:
1470:    def visit_stmt(
1471:        self, node: Node, keywords: Set[str], parens: Set[str]
1472:    ) -> Iterator[Line]:
1473:        """Visit a statement.
1474:
1475:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1476:        `def`, `with`, `class`, `assert` and assignments.
1477:
1478:        The relevant Python language `keywords` for a given statement will be
1479:        NAME leaves within it. This methods puts those on a separate line.

Calling tool: grepTool
FormatOn|FormatOff|FormatError|UnformattedLines
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_exceptions.rst:10:.. autoexception:: black.FormatError
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_exceptions.rst:12:.. autoexception:: black.FormatOn
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_exceptions.rst:14:.. autoexception:: black.FormatOff
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_classes.rst:41::class:`UnformattedLines`
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_classes.rst:44:.. autoclass:: black.UnformattedLines
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_exceptions.rst:10:.. autoexception:: black.FormatError
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_exceptions.rst:12:.. autoexception:: black.FormatOn
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_exceptions.rst:14:.. autoexception:: black.FormatOff
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_classes.rst:41::class:`UnformattedLines`
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_classes.rst:44:.. autoclass:: black.UnformattedLines
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:93:class FormatError(Exception):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:113:class FormatOn(FormatError):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:117:class FormatOff(FormatError):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1309:class UnformattedLines(Line):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1322:        except FormatOn as f_on:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1379:        if isinstance(current_line, UnformattedLines):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1509:        if isinstance(self.current_line, UnformattedLines):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1537:            except FormatOff as f_off:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1539:                yield from self.line(type=UnformattedLines)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1542:            except FormatOn as f_on:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1660:            except FormatOn as f_on:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2110:            raise FormatOn(pc.consumed)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2114:                raise FormatOff(pc.consumed)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2118:                raise FormatOff(pc.consumed)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2191:    if isinstance(line, UnformattedLines) or line.is_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:419:class UnknownCurrencyFormatError(KeyError):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:473:    UnknownCurrencyFormatError: "'unknown' is not a known currency format type"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:516:            raise UnknownCurrencyFormatError(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:634:class NumberFormatError(ValueError):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:638:        super(NumberFormatError, self).__init__(message)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:656:    NumberFormatError: '1.099,98' is not a valid number
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:661:    :raise `NumberFormatError`: if the string can not be converted to a number
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:666:        raise NumberFormatError('%r is not a valid number' % string)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:684:    NumberFormatError: '2,109,998' is not a valid decimal number
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:692:    NumberFormatError: '30.00' is not a properly formatted decimal number. Did you mean '3.000'? Or maybe '30,00'?
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:697:    NumberFormatError: '0.00' is not a properly formatted decimal number. Did you mean '0'?
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:703:    :raise NumberFormatError: if the string can not be converted to a
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:722:        raise NumberFormatError('%r is not a valid decimal number' % string)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:730:                raise NumberFormatError((
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:737:                    raise NumberFormatError((
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/babel/numbers.py:742:                    raise NumberFormatError((
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:76:from .exceptions import BufferFull, OutOfData, ExtraData, FormatError, StackError
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:116:    Raises ``FormatError`` when *packed* is not valid msgpack.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:270:    Raises ``FormatError`` when *packed* is not valid msgpack.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:540:            raise FormatError("Unknown header: 0x%x" % b)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:726:    Raises ``FormatError`` when *packed* is not valid msgpack.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/exceptions.py:18:class FormatError(ValueError, UnpackException):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2and3/mailbox.pyi:199:class FormatError(Error): ...
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2and3/ctypes/__init__.pyi:151:    def FormatError(code: int) -> str: ...

Calling tool: grepTool
def standalone_comment_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2364:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2491:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2320:
2321:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2322:    lowest_depth = sys.maxsize
2323:    trailing_comma_safe = True
2324:
2325:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2326:        """Append `leaf` to current line or to new line if appending impossible."""
2327:        nonlocal current_line
2328:        try:
2329:            current_line.append_safe(leaf, preformatted=True)
2330:        except ValueError as ve:
2331:            yield current_line
2332:
2333:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2334:            current_line.append(leaf)
2335:
2336:    for index, leaf in enumerate(line.leaves):
2337:        yield from append_to_line(leaf)
2338:
2339:        for comment_after in line.comments_after(leaf, index):
2340:            yield from append_to_line(comment_after)
2341:
2342:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2343:        if leaf.bracket_depth == lowest_depth and is_vararg(
2344:            leaf, within=VARARGS_PARENTS
2345:        ):
2346:            trailing_comma_safe = trailing_comma_safe and py36
2347:        leaf_priority = bt.delimiters.get(id(leaf))
2348:        if leaf_priority == delimiter_priority:
2349:            yield current_line
2350:
2351:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2352:    if current_line:
2353:        if (
2354:            trailing_comma_safe
2355:            and delimiter_priority == COMMA_PRIORITY
2356:            and current_line.leaves[-1].type != token.COMMA
2357:            and current_line.leaves[-1].type != STANDALONE_COMMENT
2358:        ):
2359:            current_line.append(Leaf(token.COMMA, ","))
2360:        yield current_line
2361:
2362:
2363:@dont_increase_indentation
2364:def standalone_comment_split(line: Line, py36: bool = False) -> Iterator[Line]:
2365:    """Split standalone comments from the rest of the line."""
2366:    if not line.contains_standalone_comments(0):
2367:        raise CannotSplit("Line does not have any standalone comments")
2368:
2369:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2370:
2371:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2372:        """Append `leaf` to current line or to new line if appending impossible."""
2373:        nonlocal current_line
2374:        try:
2375:            current_line.append_safe(leaf, preformatted=True)
2376:        except ValueError as ve:
2377:            yield current_line
2378:
2379:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2380:            current_line.append(leaf)
2381:
2382:    for index, leaf in enumerate(line.leaves):
2383:        yield from append_to_line(leaf)
2384:
2385:        for comment_after in line.comments_after(leaf, index):
2386:            yield from append_to_line(comment_after)
2387:
2388:    if current_line:
2389:        yield current_line
2390:
2391:
2392:def is_import(leaf: Leaf) -> bool:
2393:    """Return True if the given leaf starts an import statement."""
2394:    p = leaf.parent
2395:    t = leaf.type
2396:    v = leaf.value
2397:    return bool(
2398:        t == token.NAME
2399:        and (
2400:            (v == "import" and p and p.type == syms.import_name)
2401:            or (v == "from" and p and p.type == syms.import_from)
2402:        )
2403:    )
2404:
2405:
2406:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2407:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2408:    else.
2409:
2410:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2411:    """
2412:    if not inside_brackets:
2413:        spl = leaf.prefix.split("#")
2414:        if "\\" not in spl[0]:
2415:            nl_count = spl[-1].count("\n")
2416:            if len(spl) > 1:
2417:                nl_count -= 1
2418:            leaf.prefix = "\n" * nl_count
2419:            return
2420:
2421:    leaf.prefix = ""
2422:
2423:
2424:def normalize_string_prefix(leaf: Leaf, remove_u_prefix: bool = False) -> None:
2425:    """Make all string prefixes lowercase.
2426:
2427:    If remove_u_prefix is given, also removes any u prefix from the string.
2428:
2429:    Note: Mutates its argument.
2430:    """
2431:    match = re.match(r"^([furbFURB]*)(.*)$", leaf.value, re.DOTALL)
2432:    assert match is not None, f"failed to match string {leaf.value!r}"
2433:    orig_prefix = match.group(1)
2434:    new_prefix = orig_prefix.lower()
2435:    if remove_u_prefix:
2436:        new_prefix = new_prefix.replace("u", "")
2437:    leaf.value = f"{new_prefix}{match.group(2)}"
2438:
2439:
2440:def normalize_string_quotes(leaf: Leaf) -> None:
2441:    """Prefer double quotes but only if it doesn't cause more escaping.
2442:
2443:    Adds or removes backslashes as appropriate. Doesn't parse and fix
2444:    strings nested in f-strings (yet).
2445:
2446:    Note: Mutates its argument.
2447:    """
2448:    value = leaf.value.lstrip("furbFURB")
2449:    if value[:3] == '"""':
2450:        return
2451:
2452:    elif value[:3] == "'''":
2453:        orig_quote = "'''"
2454:        new_quote = '"""'
2455:    elif value[0] == '"':
2456:        orig_quote = '"'
2457:        new_quote = "'"
2458:    else:
2459:        orig_quote = "'"
2460:        new_quote = '"'
2461:    first_quote_pos = leaf.value.find(orig_quote)
2462:    if first_quote_pos == -1:
2463:        return  # There's an internal error
2464:
2465:    prefix = leaf.value[:first_quote_pos]
2466:    unescaped_new_quote = re.compile(rf"(([^\\]|^)(\\\\)*){new_quote}")
2467:    escaped_new_quote = re.compile(rf"([^\\]|^)\\((?:\\\\)*){new_quote}")
2468:    escaped_orig_quote = re.compile(rf"([^\\]|^)\\((?:\\\\)*){orig_quote}")
2469:    body = leaf.value[first_quote_pos + len(orig_quote) : -len(orig_quote)]
2470:    if "r" in prefix.casefold():
2471:        if unescaped_new_quote.search(body):
2472:            # There's at least one unescaped new_quote in this raw string
2473:            # so converting is impossible
2474:            return
2475:
2476:        # Do not introduce or remove backslashes in raw strings
2477:        new_body = body
2478:    else:
2479:        # remove unnecessary escapes

Calling tool: createTodo
Todo List Created
Todo List (18 items):
- [ ] Verify tests/data/fmtonoff2.py contains a # fmt: off block spanning multiple top-level defs and a list of tuples, and that tests/test_black.py::test_fmtonoff2 uses read_data("fmtonoff2") then asserts self.assertFormatEqual(source, actual) so expected equals input (no # output marker). (ID: todo-1)
- [ ] In black.py format_str(), confirm normalize_fmt_off(src_node) is called before LineGenerator is constructed and used. (ID: todo-2)
- [ ] Confirm class-based exception handling for fmt on/off is removed: no classes FormatError/FormatOn/FormatOff are defined in black.py and no references remain to them or UnformattedLines. (ID: todo-3)
- [ ] Confirm LineGenerator no longer supports UnformattedLines: method signature line(self, indent=0) has no type parameter; there is no visit_unformatted() method; and visit_default() contains no try/except for FormatOn/FormatOff. (ID: todo-4)
- [ ] Confirm generate_comments() no longer raises on FMT_ON/FMT_OFF and simply yields Leaf(pc.type, pc.value, prefix=...). (ID: todo-5)
- [ ] Check constants FMT_OFF and FMT_ON exist and include '# fmt: off', '# fmt:off', '# yapf: disable' and '# fmt: on', '# fmt:on', '# yapf: enable' respectively. (ID: todo-6)
- [ ] Validate normalize_fmt_off() loops converting pairs until none remain by calling convert_one_fmt_off_pair() in a while loop. (ID: todo-7)
- [ ] Inspect convert_one_fmt_off_pair(): it should only act on FMT_OFF comments that are standalone (pc.type == STANDALONE_COMMENT) or standalone-in-disguise (no previous leaf or previous leaf is WHITESPACE), skipping inline trailing comments. (ID: todo-8)
- [ ] Inspect convert_one_fmt_off_pair(): it must collect ignored nodes via generate_ignored_nodes(leaf), trim the consumed part of the first node's prefix, build hidden_value = '# fmt: off' + newline + concatenated ignored nodes, and trim a trailing newline if present. (ID: todo-9)
- [ ] Inspect convert_one_fmt_off_pair(): it must remove all ignored nodes from the tree and insert a new Leaf(STANDALONE_COMMENT, hidden_value) at the correct index with prefix preserved as original prefix up to previous comments plus comment.newlines newlines. (ID: todo-10)
- [ ] Inspect generate_ignored_nodes(): starting at container_of(leaf), it should yield successive containers until encountering FMT_ON in a container's prefix, then stop; it must also stop when container becomes token.ENDMARKER. (ID: todo-11)
- [ ] Inspect container_of(leaf): verify it walks up until the topmost container whose first child's prefix matches the starting prefix, and stops before syms.file_input or any node in SURROUNDED_BY_BRACKETS. (ID: todo-12)
- [ ] Verify LineGenerator.visit_STANDALONE_COMMENT yields a line boundary when not inside brackets (no open brackets) before visiting the STANDALONE_COMMENT, ensuring the comment is isolated on its own line. (ID: todo-13)
- [ ] Verify split_line() immediately yields and returns when line.is_comment is True so STANDALONE_COMMENT lines are not split or reformatted. (ID: todo-14)
- [ ] Verify ALWAYS_NO_SPACE includes STANDALONE_COMMENT to avoid inserting spaces around standalone comment leaves during formatting. (ID: todo-15)
- [ ] Verify EmptyLineTracker._maybe_empty_lines_for_class_or_def() has logic to avoid adding blank lines when previous_line.is_comment, at the same depth, and 'before' is 0; this should prevent extra lines between functions following a STANDALONE_COMMENT block. (ID: todo-16)
- [ ] Confirm that container_of() includes an early break when parent.type == syms.file_input to prevent fmt: off conversion from spanning the entire file and crossing module-level boundaries. (ID: todo-17)
- [ ] Optionally spot-check that DebugVisitor.show() accepts Union[str, Leaf, Node] and handles Node/Leaf by not reparsing, consistent with updated signature (non-critical to fmt off behavior but part of diff). (ID: todo-18)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 18
description: 'Verify tests/data/fmtonoff2.py contains a # fmt: off block spanning multiple top-level defs and a list of tuples, and that tests/test_black.py::test_fmtonoff2 uses read_data("fmtonoff2") then asserts self.assertFormatEqual(source, actual) so expected equals input (no # output marker).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "fmtonoff2", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def read_data\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests" ]
Calling tool: grepTool
fmtonoff2
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_fmtonoff2
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/bugsinpy_bug.info:4:test_file="tests/data/fmtonoff2.py;tests/test_black.py"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_fmtonoff2
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py:404:    def test_fmtonoff2(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py:405:        source, expected = read_data("fmtonoff2")

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py
380:    @patch("black.dump_to_file", dump_to_stderr)
381:    def test_python2_unicode_literals(self) -> None:
382:        source, expected = read_data("python2_unicode_literals")
383:        actual = fs(source)
384:        self.assertFormatEqual(expected, actual)
385:        black.assert_stable(source, actual, line_length=ll)
386:
387:    @patch("black.dump_to_file", dump_to_stderr)
388:    def test_stub(self) -> None:
389:        mode = black.FileMode.PYI
390:        source, expected = read_data("stub.pyi")
391:        actual = fs(source, mode=mode)
392:        self.assertFormatEqual(expected, actual)
393:        black.assert_stable(source, actual, line_length=ll, mode=mode)
394:
395:    @patch("black.dump_to_file", dump_to_stderr)
396:    def test_fmtonoff(self) -> None:
397:        source, expected = read_data("fmtonoff")
398:        actual = fs(source)
399:        self.assertFormatEqual(expected, actual)
400:        black.assert_equivalent(source, actual)
401:        black.assert_stable(source, actual, line_length=ll)
402:
403:    @patch("black.dump_to_file", dump_to_stderr)
404:    def test_fmtonoff2(self) -> None:
405:        source, expected = read_data("fmtonoff2")
406:        actual = fs(source)
407:        self.assertFormatEqual(expected, actual)
408:        black.assert_equivalent(source, actual)
409:        black.assert_stable(source, actual, line_length=ll)
410:
411:    @patch("black.dump_to_file", dump_to_stderr)
412:    def test_remove_empty_parentheses_after_class(self) -> None:
413:        source, expected = read_data("class_blank_parentheses")
414:        actual = fs(source)
415:        self.assertFormatEqual(expected, actual)
416:        black.assert_equivalent(source, actual)
417:        black.assert_stable(source, actual, line_length=ll)
418:
419:    @patch("black.dump_to_file", dump_to_stderr)
420:    def test_new_line_between_class_and_code(self) -> None:
421:        source, expected = read_data("class_methods_new_line")
422:        actual = fs(source)
423:        self.assertFormatEqual(expected, actual)
424:        black.assert_equivalent(source, actual)
425:        black.assert_stable(source, actual, line_length=ll)
426:
427:    def test_report_verbose(self) -> None:
428:        report = black.Report(verbose=True)
429:        out_lines = []
430:        err_lines = []
431:
432:        def out(msg: str, **kwargs: Any) -> None:
433:            out_lines.append(msg)
434:
435:        def err(msg: str, **kwargs: Any) -> None:
436:            err_lines.append(msg)
437:
438:        with patch("black.out", out), patch("black.err", err):
439:            report.done(Path("f1"), black.Changed.NO)
440:            self.assertEqual(len(out_lines), 1)
441:            self.assertEqual(len(err_lines), 0)
442:            self.assertEqual(out_lines[-1], "f1 already well formatted, good job.")
443:            self.assertEqual(unstyle(str(report)), "1 file left unchanged.")
444:            self.assertEqual(report.return_code, 0)
445:            report.done(Path("f2"), black.Changed.YES)
446:            self.assertEqual(len(out_lines), 2)
447:            self.assertEqual(len(err_lines), 0)
448:            self.assertEqual(out_lines[-1], "reformatted f2")
449:            self.assertEqual(
450:                unstyle(str(report)), "1 file reformatted, 1 file left unchanged."
451:            )
452:            report.done(Path("f3"), black.Changed.CACHED)
453:            self.assertEqual(len(out_lines), 3)
454:            self.assertEqual(len(err_lines), 0)
455:            self.assertEqual(
456:                out_lines[-1], "f3 wasn't modified on disk since last run."
457:            )
458:            self.assertEqual(
459:                unstyle(str(report)), "1 file reformatted, 2 files left unchanged."

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py:34:def read_data(name: str, data: bool = True) -> Tuple[str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import re
10:import sys
11:from tempfile import TemporaryDirectory
12:from typing import Any, BinaryIO, Generator, List, Tuple, Iterator
13:import unittest
14:from unittest.mock import patch, MagicMock
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:
22:ll = 88
23:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
24:fs = partial(black.format_str, line_length=ll)
25:THIS_FILE = Path(__file__)
26:THIS_DIR = THIS_FILE.parent
27:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
28:
29:
30:def dump_to_stderr(*output: str) -> str:
31:    return "\n" + "\n".join(output) + "\n"
32:
33:
34:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
35:    """read_data('test_name') -> 'input', 'output'"""
36:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
37:        name += ".py"
38:    _input: List[str] = []
39:    _output: List[str] = []
40:    base_dir = THIS_DIR / "data" if data else THIS_DIR
41:    with open(base_dir / name, "r", encoding="utf8") as test:
42:        lines = test.readlines()
43:    result = _input
44:    for line in lines:
45:        line = line.replace(EMPTY_LINE, "")
46:        if line.rstrip() == "# output":
47:            result = _output
48:            continue
49:
50:        result.append(line)
51:    if _input and not _output:
52:        # If there's no output marker, treat the entire file as already pre-formatted.
53:        _output = _input[:]
54:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
55:
56:
57:@contextmanager
58:def cache_dir(exists: bool = True) -> Iterator[Path]:
59:    with TemporaryDirectory() as workspace:
60:        cache_dir = Path(workspace)
61:        if not exists:
62:            cache_dir = cache_dir / "new"
63:        with patch("black.CACHE_DIR", cache_dir):
64:            yield cache_dir
65:
66:
67:@contextmanager
68:def event_loop(close: bool) -> Iterator[None]:
69:    policy = asyncio.get_event_loop_policy()
70:    old_loop = policy.get_event_loop()
71:    loop = policy.new_event_loop()
72:    asyncio.set_event_loop(loop)
73:    try:
74:        yield
75:
76:    finally:
77:        policy.set_event_loop(old_loop)
78:        if close:
79:            loop.close()
80:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/fmtonoff2.py
1:import pytest
2:
3:TmSt = 1
4:TmEx = 2
5:
6:# fmt: off
7:
8:# Test data:
9:#   Position, Volume, State, TmSt/TmEx/None, [call, [arg1...]]
10:
11:@pytest.mark.parametrize('test', [
12:
13:    # Test don't manage the volume
14:    [
15:        ('stuff', 'in')
16:    ],
17:])
18:def test_fader(test):
19:    pass
20:
21:def check_fader(test):
22:    pass
23:
24:def test_calculate_fades():
25:    calcs = [
26:        # one is zero/none
27:        (0, 4, 0, 0, 10,        0, 0, 6, 10),
28:        (None, 4, 0, 0, 10,     0, 0, 6, 10),
29:    ]
30:
31:# fmt: on

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: tests/data/fmtonoff2.py includes a # fmt: off block that spans multiple top-level defs and a list of tuples (lines 631). tests/test_black.py::test_fmtonoff2 calls read_data("fmtonoff2") and asserts self.assertFormatEqual(expected, actual); read_data returns expected == source when no '# output' marker is present (lines 5154), satisfying the requirement that expected equals input.


Todo item 1 of 18 is correct
description: 'Verify tests/data/fmtonoff2.py contains a # fmt: off block spanning multiple top-level defs and a list of tuples, and that tests/test_black.py::test_fmtonoff2 uses read_data("fmtonoff2") then asserts self.assertFormatEqual(source, actual) so expected equals input (no # output marker).'
Validating todo item 2 of 18
description: 'In black.py format_str(), confirm normalize_fmt_off(src_node) is called before LineGenerator is constructed and used.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_str\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "normalize_fmt_off\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
def format_str\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:618:def format_str(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:589:def format_str(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
560:        f.detach()
561:
562:
563:def format_file_contents(
564:    src_contents: str,
565:    *,
566:    line_length: int,
567:    fast: bool,
568:    mode: FileMode = FileMode.AUTO_DETECT,
569:) -> FileContent:
570:    """Reformat contents a file and return new contents.
571:
572:    If `fast` is False, additionally confirm that the reformatted code is
573:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
574:    `line_length` is passed to :func:`format_str`.
575:    """
576:    if src_contents.strip() == "":
577:        raise NothingChanged
578:
579:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
580:    if src_contents == dst_contents:
581:        raise NothingChanged
582:
583:    if not fast:
584:        assert_equivalent(src_contents, dst_contents)
585:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
586:    return dst_contents
587:
588:
589:def format_str(
590:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
591:) -> FileContent:
592:    """Reformat a string and return new contents.
593:
594:    `line_length` determines how many characters per line are allowed.
595:    """
596:    src_node = lib2to3_parse(src_contents)
597:    dst_contents = ""
598:    future_imports = get_future_imports(src_node)
599:    is_pyi = bool(mode & FileMode.PYI)
600:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
601:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
602:    normalize_fmt_off(src_node)
603:    lines = LineGenerator(
604:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
605:        is_pyi=is_pyi,
606:        normalize_strings=normalize_strings,
607:    )
608:    elt = EmptyLineTracker(is_pyi=is_pyi)
609:    empty_line = Line()
610:    after = 0
611:    for current_line in lines.visit(src_node):
612:        for _ in range(after):
613:            dst_contents += str(empty_line)
614:        before, after = elt.maybe_empty_lines(current_line)
615:        for _ in range(before):
616:            dst_contents += str(empty_line)
617:        for line in split_line(current_line, line_length=line_length, py36=py36):
618:            dst_contents += str(line)
619:    return dst_contents
620:
621:
622:def decode_bytes(src: bytes) -> Tuple[FileContent, Encoding, NewLine]:
623:    """Return a tuple of (decoded_contents, encoding, newline).
624:
625:    `newline` is either CRLF or LF but `decoded_contents` is decoded with
626:    universal newlines (i.e. only contains LF).
627:    """
628:    srcbuf = io.BytesIO(src)
629:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
630:    if not lines:
631:        return "", encoding, "\n"
632:
633:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
634:    srcbuf.seek(0)
635:    with io.TextIOWrapper(srcbuf, encoding) as tiow:
636:        return tiow.read(), encoding, newline
637:
638:
639:GRAMMARS = [
640:    pygram.python_grammar_no_print_statement_no_exec_statement,
641:    pygram.python_grammar_no_print_statement,
642:    pygram.python_grammar,
643:]
644:
645:
646:def lib2to3_parse(src_txt: str) -> Node:
647:    """Given a string with source, return the lib2to3 Node."""
648:    grammar = pygram.python_grammar_no_print_statement
649:    if src_txt[-1:] != "\n":
650:        src_txt += "\n"
651:    for grammar in GRAMMARS:
652:        drv = driver.Driver(grammar, pytree.convert)
653:        try:
654:            result = drv.parse_string(src_txt, True)
655:            break
656:
657:        except ParseError as pe:
658:            lineno, column = pe.context[1]
659:            lines = src_txt.splitlines()
660:            try:
661:                faulty_line = lines[lineno - 1]
662:            except IndexError:
663:                faulty_line = "<line number missing in source>"
664:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
665:    else:
666:        raise exc from None
667:
668:    if isinstance(result, Leaf):
669:        result = Node(syms.file_input, [result])
670:    return result
671:
672:
673:def lib2to3_unparse(node: Node) -> str:
674:    """Given a lib2to3 node, return its string representation."""
675:    code = str(node)
676:    return code
677:
678:
679:T = TypeVar("T")
680:
681:
682:class Visitor(Generic[T]):
683:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
684:
685:    def visit(self, node: LN) -> Iterator[T]:
686:        """Main method to visit `node` and its children.
687:
688:        It tries to find a `visit_*()` method for the given `node.type`, like
689:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
690:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
691:        instead.
692:
693:        Then yields objects of type `T` from the selected visitor.
694:        """
695:        if node.type < 256:
696:            name = token.tok_name[node.type]
697:        else:
698:            name = type_repr(node.type)
699:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)

Calling tool: grepTool
normalize_fmt_off\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:602:    normalize_fmt_off(src_node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2555:def normalize_fmt_off(node: Node) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:631:    normalize_fmt_off(src_node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2682:def normalize_fmt_off(node: Node) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
610:        raise NothingChanged
611:
612:    if not fast:
613:        assert_equivalent(src_contents, dst_contents)
614:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
615:    return dst_contents
616:
617:
618:def format_str(
619:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
620:) -> FileContent:
621:    """Reformat a string and return new contents.
622:
623:    `line_length` determines how many characters per line are allowed.
624:    """
625:    src_node = lib2to3_parse(src_contents)
626:    dst_contents = ""
627:    future_imports = get_future_imports(src_node)
628:    is_pyi = bool(mode & FileMode.PYI)
629:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
630:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
631:    normalize_fmt_off(src_node)
632:    lines = LineGenerator(
633:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
634:        is_pyi=is_pyi,
635:        normalize_strings=normalize_strings,
636:    )
637:    elt = EmptyLineTracker(is_pyi=is_pyi)
638:    empty_line = Line()
639:    after = 0
640:    for current_line in lines.visit(src_node):
641:        for _ in range(after):
642:            dst_contents += str(empty_line)
643:        before, after = elt.maybe_empty_lines(current_line)
644:        for _ in range(before):
645:            dst_contents += str(empty_line)
646:        for line in split_line(current_line, line_length=line_length, py36=py36):
647:            dst_contents += str(line)
648:    return dst_contents
649:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pys format_str(), normalize_fmt_off(src_node) is invoked (line ~602) before constructing LineGenerator (line ~603) and before iterating lines.visit(src_node) (line ~611). Verified by reading the actual implementation.


Todo item 2 of 18 is correct
description: 'In black.py format_str(), confirm normalize_fmt_off(src_node) is called before LineGenerator is constructed and used.'
Validating todo item 3 of 18
description: 'Confirm class-based exception handling for fmt on/off is removed: no classes FormatError/FormatOn/FormatOff are defined in black.py and no references remain to them or UnformattedLines.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "(?i)class\\s+Format(Error|On|Off)\\b|\\bFormat(Error|On|Off)\\b|\\bUnformattedLines\\b",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "(?i)Format(Error|On|Off)|UnformattedLines",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def visit_STANDALONE_COMMENT",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def generate_comments\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_fmt_off\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py" ]
Calling tool: grepTool
(?i)class\s+Format(Error|On|Off)\b|\bFormat(Error|On|Off)\b|\bUnformattedLines\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_exceptions.rst:10:.. autoexception:: black.FormatError
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_exceptions.rst:12:.. autoexception:: black.FormatOn
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_exceptions.rst:14:.. autoexception:: black.FormatOff
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_classes.rst:41::class:`UnformattedLines`
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_classes.rst:44:.. autoclass:: black.UnformattedLines
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_exceptions.rst:10:.. autoexception:: black.FormatError
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_exceptions.rst:12:.. autoexception:: black.FormatOn
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_exceptions.rst:14:.. autoexception:: black.FormatOff
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:93:class FormatError(Exception):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:113:class FormatOn(FormatError):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:117:class FormatOff(FormatError):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1309:class UnformattedLines(Line):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1322:        except FormatOn as f_on:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1379:        if isinstance(current_line, UnformattedLines):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1509:        if isinstance(self.current_line, UnformattedLines):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1537:            except FormatOff as f_off:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1539:                yield from self.line(type=UnformattedLines)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1542:            except FormatOn as f_on:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1660:            except FormatOn as f_on:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2110:            raise FormatOn(pc.consumed)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2114:                raise FormatOff(pc.consumed)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2118:                raise FormatOff(pc.consumed)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2191:    if isinstance(line, UnformattedLines) or line.is_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_classes.rst:41::class:`UnformattedLines`
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_classes.rst:44:.. autoclass:: black.UnformattedLines
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2and3/mailbox.pyi:199:class FormatError(Error): ...
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:76:from .exceptions import BufferFull, OutOfData, ExtraData, FormatError, StackError
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:116:    Raises ``FormatError`` when *packed* is not valid msgpack.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:270:    Raises ``FormatError`` when *packed* is not valid msgpack.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:540:            raise FormatError("Unknown header: 0x%x" % b)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:726:    Raises ``FormatError`` when *packed* is not valid msgpack.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/exceptions.py:18:class FormatError(ValueError, UnpackException):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2and3/ctypes/__init__.pyi:151:    def FormatError(code: int) -> str: ...

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py

Calling tool: grepTool
(?i)Format(Error|On|Off)|UnformattedLines
No files found. Call grepTool again with a more generic pattern.

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generic,
24:    Iterable,
25:    Iterator,
26:    List,
27:    Optional,
28:    Pattern,
29:    Sequence,
30:    Set,
31:    Tuple,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:import toml
41:
42:# lib2to3 fork
43:from blib2to3.pytree import Node, Leaf, type_repr
44:from blib2to3 import pygram, pytree
45:from blib2to3.pgen2 import driver, token
46:from blib2to3.pgen2.parse import ParseError
47:
48:
49:__version__ = "18.6b2"
50:DEFAULT_LINE_LENGTH = 88
51:DEFAULT_EXCLUDES = (
52:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
53:)
54:DEFAULT_INCLUDES = r"\.pyi?$"
55:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
56:
57:
58:# types
59:FileContent = str
60:Encoding = str
61:NewLine = str
62:Depth = int
63:NodeType = int
64:LeafID = int
65:Priority = int
66:Index = int
67:LN = Union[Leaf, Node]
68:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
69:Timestamp = float
70:FileSize = int
71:CacheInfo = Tuple[Timestamp, FileSize]
72:Cache = Dict[Path, CacheInfo]
73:out = partial(click.secho, bold=True, err=True)
74:err = partial(click.secho, fg="red", err=True)
75:
76:pygram.initialize(CACHE_DIR)
77:syms = pygram.python_symbols
78:
79:
80:class NothingChanged(UserWarning):
81:    """Raised by :func:`format_file` when reformatted code is the same as source."""
82:
83:
84:class CannotSplit(Exception):
85:    """A readable split that fits the allotted line length is impossible.
86:
87:    Raised by :func:`left_hand_split`, :func:`right_hand_split`, and
88:    :func:`delimiter_split`.
89:    """
90:
91:
92:class WriteBack(Enum):
93:    NO = 0
94:    YES = 1
95:    DIFF = 2
96:
97:    @classmethod
98:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
99:        if check and not diff:
100:            return cls.NO
101:
102:        return cls.DIFF if diff else cls.YES
103:
104:
105:class Changed(Enum):
106:    NO = 0
107:    CACHED = 1
108:    YES = 2
109:
110:
111:class FileMode(Flag):
112:    AUTO_DETECT = 0
113:    PYTHON36 = 1
114:    PYI = 2
115:    NO_STRING_NORMALIZATION = 4
116:
117:    @classmethod
118:    def from_configuration(
119:        cls, *, py36: bool, pyi: bool, skip_string_normalization: bool
120:    ) -> "FileMode":
121:        mode = cls.AUTO_DETECT
122:        if py36:
123:            mode |= cls.PYTHON36
124:        if pyi:
125:            mode |= cls.PYI
126:        if skip_string_normalization:
127:            mode |= cls.NO_STRING_NORMALIZATION
128:        return mode
129:
130:
131:def read_pyproject_toml(
132:    ctx: click.Context, param: click.Parameter, value: Union[str, int, bool, None]
133:) -> Optional[str]:
134:    """Inject Black configuration from "pyproject.toml" into defaults in `ctx`.
135:
136:    Returns the path to a successfully found and read configuration file, None
137:    otherwise.
138:    """
139:    assert not isinstance(value, (int, bool)), "Invalid parameter type passed"
140:    if not value:
141:        root = find_project_root(ctx.params.get("src", ()))
142:        path = root / "pyproject.toml"
143:        if path.is_file():
144:            value = str(path)
145:        else:
146:            return None
147:
148:    try:
149:        pyproject_toml = toml.load(value)
150:        config = pyproject_toml.get("tool", {}).get("black", {})
151:    except (toml.TomlDecodeError, OSError) as e:
152:        raise click.BadOptionUsage(f"Error reading configuration file: {e}", ctx)
153:
154:    if not config:
155:        return None
156:
157:    if ctx.default_map is None:
158:        ctx.default_map = {}
159:    ctx.default_map.update(  # type: ignore  # bad types in .pyi
160:        {k.replace("--", "").replace("-", "_"): v for k, v in config.items()}
161:    )
162:    return value
163:
164:
165:@click.command(context_settings=dict(help_option_names=["-h", "--help"]))
166:@click.option(
167:    "-l",
168:    "--line-length",
169:    type=int,
170:    default=DEFAULT_LINE_LENGTH,
171:    help="How many character per line to allow.",
172:    show_default=True,
173:)
174:@click.option(
175:    "--py36",
176:    is_flag=True,
177:    help=(
178:        "Allow using Python 3.6-only syntax on all input files.  This will put "
179:        "trailing commas in function signatures and calls also after *args and "
180:        "**kwargs.  [default: per-file auto-detection]"

Calling tool: grepTool
def line\(
Matched content:
1406:    def line(self, indent: int = 0) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1390:        return newlines, 0
1391:
1392:
1393:@dataclass
1394:class LineGenerator(Visitor[Line]):
1395:    """Generates reformatted Line objects.  Empty lines are not emitted.
1396:
1397:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
1398:    in ways that will no longer stringify to valid Python code on the tree.
1399:    """
1400:
1401:    is_pyi: bool = False
1402:    normalize_strings: bool = True
1403:    current_line: Line = Factory(Line)
1404:    remove_u_prefix: bool = False
1405:
1406:    def line(self, indent: int = 0) -> Iterator[Line]:
1407:        """Generate a line.
1408:
1409:        If the line is empty, only emit if it makes sense.
1410:        If the line is too long, split it first and then generate.
1411:
1412:        If any lines were generated, set up a new current_line.
1413:        """
1414:        if not self.current_line:
1415:            self.current_line.depth += indent
1416:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1417:
1418:        complete_line = self.current_line
1419:        self.current_line = Line(depth=complete_line.depth + indent)
1420:        yield complete_line
1421:
1422:    def visit_default(self, node: LN) -> Iterator[Line]:
1423:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1424:        if isinstance(node, Leaf):
1425:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1426:            for comment in generate_comments(node):
1427:                if any_open_brackets:
1428:                    # any comment within brackets is subject to splitting
1429:                    self.current_line.append(comment)
1430:                elif comment.type == token.COMMENT:
1431:                    # regular trailing comment
1432:                    self.current_line.append(comment)
1433:                    yield from self.line()
1434:
1435:                else:
1436:                    # regular standalone comment
1437:                    yield from self.line()
1438:
1439:                    self.current_line.append(comment)
1440:                    yield from self.line()
1441:
1442:            normalize_prefix(node, inside_brackets=any_open_brackets)
1443:            if self.normalize_strings and node.type == token.STRING:
1444:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1445:                normalize_string_quotes(node)
1446:            if node.type not in WHITESPACE:
1447:                self.current_line.append(node)
1448:        yield from super().visit_default(node)
1449:

Calling tool: grepTool
def visit_STANDALONE_COMMENT
Matched content:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1538:
1539:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1540:        """End of file. Process outstanding comments and end with a newline."""
1541:        yield from self.visit_default(leaf)
1542:        yield from self.line()
1543:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1545:        if not self.current_line.bracket_tracker.any_open_brackets():
1546:            yield from self.line()
1547:        yield from self.visit_default(leaf)
1548:
1549:    def __attrs_post_init__(self) -> None:
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})

Calling tool: grepTool
def generate_comments\(
Matched content:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't
1985:    share the line with any code.
1986:
1987:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
1989:    """
1990:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
1991:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
1992:
1993:
1994:@dataclass
1995:class ProtoComment:
1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
1997:    value: str  # content of the comment
1998:    newlines: int  # how many newlines before the comment
1999:    consumed: int  # how many characters of the original leaf's prefix did we consume
2000:
2001:
2002:@lru_cache(maxsize=4096)
2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2004:    result: List[ProtoComment] = []
2005:    if not prefix or "#" not in prefix:

Calling tool: grepTool
def normalize_fmt_off\(
Matched content:
2555:def normalize_fmt_off(node: Node) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:

Calling tool: grepTool
def split_line\(
Matched content:
2051:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2046:    if content and content[0] not in " !:#":
2047:        content = " " + content
2048:    return "#" + content
2049:
2050:
2051:def split_line(
2052:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2053:) -> Iterator[Line]:
2054:    """Split a `line` into potentially many lines.
2055:
2056:    They should fit in the allotted `line_length` but might not be able to.
2057:    `inner` signifies that there were a pair of brackets somewhere around the
2058:    current `line`, possibly transitively. This means we can fallback to splitting
2059:    by delimiters if the LHS/RHS don't yield any results.
2060:
2061:    If `py36` is True, splitting may generate syntax that is only compatible
2062:    with Python 3.6 and later.
2063:    """
2064:    if line.is_comment:
2065:        yield line
2066:        return
2067:
2068:    line_str = str(line).strip("\n")
2069:    if not line.should_explode and is_line_short_enough(
2070:        line, line_length=line_length, line_str=line_str
2071:    ):
2072:        yield line
2073:        return
2074:
2075:    split_funcs: List[SplitFunc]

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In the projects top-level black.py, the classes FormatError, FormatOn, FormatOff, and UnformattedLines are not defined and there are no remaining references to them. I verified by reading relevant sections (class removals and refactored methods) and confirming no occurrences via targeted searches; remaining matches are only in env/src copies and docs.


Todo item 3 of 18 is correct
description: 'Confirm class-based exception handling for fmt on/off is removed: no classes FormatError/FormatOn/FormatOff are defined in black.py and no references remain to them or UnformattedLines.'
Validating todo item 4 of 18
description: 'Confirm LineGenerator no longer supports UnformattedLines: method signature line(self, indent=0) has no type parameter; there is no visit_unformatted() method; and visit_default() contains no try/except for FormatOn/FormatOff.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class LineGenerator\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def visit_unformatted\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "Format(On|Off)", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def visit\\(self, node: LN\\)",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py"
]
Calling tool: grepTool
class LineGenerator\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1394:class LineGenerator(Visitor[Line]):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1473:class LineGenerator(Visitor[Line]):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1380:                    newlines = 1
1381:            elif current_line.is_def and not self.previous_line.is_def:
1382:                # Blank line between a block of functions and a block of non-functions
1383:                newlines = 1
1384:            else:
1385:                newlines = 0
1386:        else:
1387:            newlines = 2
1388:        if current_line.depth and newlines:
1389:            newlines -= 1
1390:        return newlines, 0
1391:
1392:
1393:@dataclass
1394:class LineGenerator(Visitor[Line]):
1395:    """Generates reformatted Line objects.  Empty lines are not emitted.
1396:
1397:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
1398:    in ways that will no longer stringify to valid Python code on the tree.
1399:    """
1400:
1401:    is_pyi: bool = False
1402:    normalize_strings: bool = True
1403:    current_line: Line = Factory(Line)
1404:    remove_u_prefix: bool = False
1405:
1406:    def line(self, indent: int = 0) -> Iterator[Line]:
1407:        """Generate a line.
1408:
1409:        If the line is empty, only emit if it makes sense.
1410:        If the line is too long, split it first and then generate.
1411:
1412:        If any lines were generated, set up a new current_line.
1413:        """
1414:        if not self.current_line:
1415:            self.current_line.depth += indent
1416:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1417:
1418:        complete_line = self.current_line
1419:        self.current_line = Line(depth=complete_line.depth + indent)
1420:        yield complete_line
1421:
1422:    def visit_default(self, node: LN) -> Iterator[Line]:
1423:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1424:        if isinstance(node, Leaf):
1425:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1426:            for comment in generate_comments(node):
1427:                if any_open_brackets:
1428:                    # any comment within brackets is subject to splitting
1429:                    self.current_line.append(comment)
1430:                elif comment.type == token.COMMENT:
1431:                    # regular trailing comment
1432:                    self.current_line.append(comment)
1433:                    yield from self.line()
1434:
1435:                else:
1436:                    # regular standalone comment
1437:                    yield from self.line()
1438:
1439:                    self.current_line.append(comment)
1440:                    yield from self.line()
1441:
1442:            normalize_prefix(node, inside_brackets=any_open_brackets)
1443:            if self.normalize_strings and node.type == token.STRING:
1444:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1445:                normalize_string_quotes(node)
1446:            if node.type not in WHITESPACE:
1447:                self.current_line.append(node)
1448:        yield from super().visit_default(node)
1449:
1450:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1451:        """Increase indentation level, maybe yield a line."""
1452:        # In blib2to3 INDENT never holds comments.
1453:        yield from self.line(+1)
1454:        yield from self.visit_default(node)
1455:
1456:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1457:        """Decrease indentation level, maybe yield a line."""
1458:        # The current line might still wait for trailing comments.  At DEDENT time
1459:        # there won't be any (they would be prefixes on the preceding NEWLINE).
1460:        # Emit the line then.
1461:        yield from self.line()
1462:
1463:        # While DEDENT has no value, its prefix may contain standalone comments
1464:        # that belong to the current indentation level.  Get 'em.
1465:        yield from self.visit_default(node)
1466:
1467:        # Finally, emit the dedent.
1468:        yield from self.line(-1)
1469:
1470:    def visit_stmt(
1471:        self, node: Node, keywords: Set[str], parens: Set[str]
1472:    ) -> Iterator[Line]:
1473:        """Visit a statement.
1474:
1475:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1476:        `def`, `with`, `class`, `assert` and assignments.
1477:
1478:        The relevant Python language `keywords` for a given statement will be
1479:        NAME leaves within it. This methods puts those on a separate line.
1480:
1481:        `parens` holds a set of string leaf values immediately after which
1482:        invisible parens should be put.
1483:        """
1484:        normalize_invisible_parens(node, parens_after=parens)
1485:        for child in node.children:
1486:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1487:                yield from self.line()
1488:
1489:            yield from self.visit(child)
1490:
1491:    def visit_suite(self, node: Node) -> Iterator[Line]:
1492:        """Visit a suite."""
1493:        if self.is_pyi and is_stub_suite(node):
1494:            yield from self.visit(node.children[2])
1495:        else:
1496:            yield from self.visit_default(node)
1497:
1498:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1499:        """Visit a statement without nested statements."""

Calling tool: grepTool
def visit_unformatted\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
Format(On|Off)
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
def visit\(self, node: LN\)
Matched content:
685:    def visit(self, node: LN) -> Iterator[T]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
650:        src_txt += "\n"
651:    for grammar in GRAMMARS:
652:        drv = driver.Driver(grammar, pytree.convert)
653:        try:
654:            result = drv.parse_string(src_txt, True)
655:            break
656:
657:        except ParseError as pe:
658:            lineno, column = pe.context[1]
659:            lines = src_txt.splitlines()
660:            try:
661:                faulty_line = lines[lineno - 1]
662:            except IndexError:
663:                faulty_line = "<line number missing in source>"
664:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
665:    else:
666:        raise exc from None
667:
668:    if isinstance(result, Leaf):
669:        result = Node(syms.file_input, [result])
670:    return result
671:
672:
673:def lib2to3_unparse(node: Node) -> str:
674:    """Given a lib2to3 node, return its string representation."""
675:    code = str(node)
676:    return code
677:
678:
679:T = TypeVar("T")
680:
681:
682:class Visitor(Generic[T]):
683:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
684:
685:    def visit(self, node: LN) -> Iterator[T]:
686:        """Main method to visit `node` and its children.
687:
688:        It tries to find a `visit_*()` method for the given `node.type`, like
689:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
690:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
691:        instead.
692:
693:        Then yields objects of type `T` from the selected visitor.
694:        """
695:        if node.type < 256:
696:            name = token.tok_name[node.type]
697:        else:
698:            name = type_repr(node.type)
699:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
700:
701:    def visit_default(self, node: LN) -> Iterator[T]:
702:        """Default `visit_*()` implementation. Recurses to children of `node`."""
703:        if isinstance(node, Node):
704:            for child in node.children:
705:                yield from self.visit(child)
706:
707:
708:@dataclass
709:class DebugVisitor(Visitor[T]):
710:    tree_depth: int = 0
711:
712:    def visit_default(self, node: LN) -> Iterator[T]:
713:        indent = " " * (2 * self.tree_depth)
714:        if isinstance(node, Node):
715:            _type = type_repr(node.type)
716:            out(f"{indent}{_type}", fg="yellow")
717:            self.tree_depth += 1
718:            for child in node.children:
719:                yield from self.visit(child)
720:
721:            self.tree_depth -= 1
722:            out(f"{indent}/{_type}", fg="yellow", bold=False)
723:        else:
724:            _type = token.tok_name.get(node.type, str(node.type))
725:            out(f"{indent}{_type}", fg="blue", nl=False)
726:            if node.prefix:
727:                # We don't have to handle prefixes for `Node` objects since
728:                # that delegates to the first child anyway.
729:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, LineGenerator.line now has signature line(self, indent=0) without a type parameter; there is no def visit_unformatted() present; and LineGenerator.visit_default() iterates comments without any try/except for FormatOn/FormatOff. Verified via grep and reading lines 1406-1448.


Todo item 4 of 18 is correct
description: 'Confirm LineGenerator no longer supports UnformattedLines: method signature line(self, indent=0) has no type parameter; there is no visit_unformatted() method; and visit_default() contains no try/except for FormatOn/FormatOff.'
Validating todo item 5 of 18
description: 'Confirm generate_comments() no longer raises on FMT_ON/FMT_OFF and simply yields Leaf(pc.type, pc.value, prefix=...).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def generate_comments\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class FormatOn", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py" ]
Calling tool: grepTool
def generate_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2088:def generate_comments(leaf: LN) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1960:
1961:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1962:        return LOGIC_PRIORITY
1963:
1964:    return 0
1965:
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't
1985:    share the line with any code.
1986:
1987:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
1989:    """
1990:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
1991:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
1992:
1993:
1994:@dataclass
1995:class ProtoComment:
1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
1997:    value: str  # content of the comment
1998:    newlines: int  # how many newlines before the comment
1999:    consumed: int  # how many characters of the original leaf's prefix did we consume
2000:
2001:
2002:@lru_cache(maxsize=4096)
2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2004:    result: List[ProtoComment] = []
2005:    if not prefix or "#" not in prefix:
2006:        return result
2007:
2008:    consumed = 0
2009:    nlines = 0
2010:    for index, line in enumerate(prefix.split("\n")):
2011:        consumed += len(line) + 1  # adding the length of the split '\n'
2012:        line = line.lstrip()
2013:        if not line:
2014:            nlines += 1
2015:        if not line.startswith("#"):
2016:            continue
2017:
2018:        if index == 0 and not is_endmarker:
2019:            comment_type = token.COMMENT  # simple trailing comment
2020:        else:
2021:            comment_type = STANDALONE_COMMENT
2022:        comment = make_comment(line)
2023:        result.append(
2024:            ProtoComment(
2025:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2026:            )
2027:        )
2028:        nlines = 0
2029:    return result
2030:
2031:
2032:def make_comment(content: str) -> str:
2033:    """Return a consistently formatted comment from the given `content` string.
2034:
2035:    All comments (except for "##", "#!", "#:") should have a single space between
2036:    the hash sign and the content.
2037:
2038:    If `content` didn't start with a hash sign, one is provided.
2039:    """

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
2080:
2081:    return 0
2082:
2083:
2084:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2085:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2086:
2087:
2088:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2089:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2090:
2091:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2092:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2093:    move because it does away with modifying the grammar to include all the
2094:    possible places in which comments can be placed.
2095:
2096:    The sad consequence for us though is that comments don't "belong" anywhere.
2097:    This is why this function generates simple parentless Leaf objects for
2098:    comments.  We simply don't know what the correct parent should be.
2099:
2100:    No matter though, we can live without this.  We really only need to
2101:    differentiate between inline and standalone comments.  The latter don't
2102:    share the line with any code.
2103:
2104:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
2106:    """
2107:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2108:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2109:        if pc.value in FMT_ON:
2110:            raise FormatOn(pc.consumed)
2111:
2112:        if pc.value in FMT_OFF:
2113:            if pc.type == STANDALONE_COMMENT:
2114:                raise FormatOff(pc.consumed)
2115:
2116:            prev = preceding_leaf(leaf)
2117:            if not prev or prev.type in WHITESPACE:  # standalone comment in disguise
2118:                raise FormatOff(pc.consumed)
2119:
2120:
2121:@dataclass
2122:class ProtoComment:
2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
2124:    value: str  # content of the comment
2125:    newlines: int  # how many newlines before the comment
2126:    consumed: int  # how many characters of the original leaf's prefix did we consume
2127:
2128:
2129:@lru_cache(maxsize=4096)
2130:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2131:    result: List[ProtoComment] = []
2132:    if not prefix or "#" not in prefix:
2133:        return result
2134:
2135:    consumed = 0
2136:    nlines = 0
2137:    for index, line in enumerate(prefix.split("\n")):
2138:        consumed += len(line) + 1  # adding the length of the split '\n'
2139:        line = line.lstrip()
2140:        if not line:
2141:            nlines += 1
2142:        if not line.startswith("#"):
2143:            continue
2144:
2145:        if index == 0 and not is_endmarker:
2146:            comment_type = token.COMMENT  # simple trailing comment
2147:        else:
2148:            comment_type = STANDALONE_COMMENT
2149:        comment = make_comment(line)
2150:        result.append(
2151:            ProtoComment(
2152:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2153:            )
2154:        )
2155:        nlines = 0
2156:    return result
2157:
2158:
2159:def make_comment(content: str) -> str:

Calling tool: grepTool
class FormatOn
No files found. Call grepTool again with a more generic pattern.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In the modified black.py, generate_comments() simply iterates list_comments and yields Leaf(pc.type, pc.value, prefix="\n" * pc.newlines) without raising on FMT_ON/FMT_OFF (see lines ~1990-1992). The prior exception-raising block was removed in this file as per the diff.


Todo item 5 of 18 is correct
description: 'Confirm generate_comments() no longer raises on FMT_ON/FMT_OFF and simply yields Leaf(pc.type, pc.value, prefix=...).'
Validating todo item 6 of 18
description: 'Check constants FMT_OFF and FMT_ON exist and include '# fmt: off', '# fmt:off', '# yapf: disable' and '# fmt: on', '# fmt:on', '# yapf: enable' respectively.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "FMT_OFF|FMT_ON", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
Calling tool: grepTool
FMT_OFF|FMT_ON
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2517:        if pc.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2570:            if comment.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2621:            if comment.value in FMT_ON:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2084:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2085:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2109:        if pc.value in FMT_ON:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2112:        if pc.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2644:        if pc.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2704:            if comment.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2739:            if comment.value in FMT_ON:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1955:            and previous.type == token.NAME
1956:            and previous.value == "is"
1957:        )
1958:    ):
1959:        return COMPARATOR_PRIORITY
1960:
1961:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1962:        return LOGIC_PRIORITY
1963:
1964:    return 0
1965:
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Found constants in black.py at lines 1967-1968: FMT_OFF = {'# fmt: off', '# fmt:off', '# yapf: disable'} and FMT_ON = {'# fmt: on', '# fmt:on', '# yapf: enable'}, matching the requirement.


Todo item 6 of 18 is correct
description: 'Check constants FMT_OFF and FMT_ON exist and include '# fmt: off', '# fmt:off', '# yapf: disable' and '# fmt: on', '# fmt:on', '# yapf: enable' respectively.'
Validating todo item 7 of 18
description: 'Validate normalize_fmt_off() loops converting pairs until none remain by calling convert_one_fmt_off_pair() in a while loop.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_fmt_off\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def convert_one_fmt_off_pair\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
def normalize_fmt_off\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2555:def normalize_fmt_off(node: Node) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2682:def normalize_fmt_off(node: Node) -> None:

Calling tool: grepTool
def convert_one_fmt_off_pair\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2562:def convert_one_fmt_off_pair(node: Node) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2538:                    node.children[-1].value = ""  # type: ignore
2539:                elif child.type != token.STAR:
2540:                    # insert invisible parentheses
2541:                    node.insert_child(index, Leaf(token.LPAR, ""))
2542:                    node.append_child(Leaf(token.RPAR, ""))
2543:                break
2544:
2545:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2546:                # wrap child in invisible parentheses
2547:                lpar = Leaf(token.LPAR, "")
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
2668:                    node.insert_child(index, Leaf(token.LPAR, ""))
2669:                    node.append_child(Leaf(token.RPAR, ""))
2670:                break
2671:
2672:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2673:                # wrap child in invisible parentheses
2674:                lpar = Leaf(token.LPAR, "")
2675:                rpar = Leaf(token.RPAR, "")
2676:                index = child.remove() or 0
2677:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2678:
2679:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2680:
2681:
2682:def normalize_fmt_off(node: Node) -> None:
2683:    """Allow `# fmt: off`/`# fmt: on` within bracket pairs.
2684:
2685:    Ignores `# fmt: off` and `# fmt: on` outside of brackets.
2686:
2687:    Raises :exc:`SyntaxError` if no matching `# fmt: on` is found for a `# fmt: off`
2688:    given inside brackets.
2689:    """
2690:    try_again = True
2691:    while try_again:
2692:        try_again = hide_fmt_off(node)
2693:
2694:
2695:def hide_fmt_off(node: Node) -> bool:
2696:    bt = BracketTracker()
2697:    for leaf in node.leaves():
2698:        bt.mark(leaf)
2699:        if bt.depth == 0:
2700:            continue
2701:
2702:        previous_consumed = 0
2703:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2704:            if comment.value in FMT_OFF:
2705:                ignored_nodes = list(generate_ignored_nodes(leaf))
2706:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2707:                parent = first.parent

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, normalize_fmt_off() sets try_again = True and loops while try_again, assigning the result of convert_one_fmt_off_pair(node) each iteration (lines 25552559). convert_one_fmt_off_pair(node) returns True when a pair is converted and False otherwise (lines 25622610), ensuring the loop continues until no pairs remain.


Todo item 7 of 18 is correct
description: 'Validate normalize_fmt_off() loops converting pairs until none remain by calling convert_one_fmt_off_pair() in a while loop.'
Validating todo item 8 of 18
description: 'Inspect convert_one_fmt_off_pair(): it should only act on FMT_OFF comments that are standalone (pc.type == STANDALONE_COMMENT) or standalone-in-disguise (no previous leaf or previous leaf is WHITESPACE), skipping inline trailing comments.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def convert_one_fmt_off_pair\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "STANDALONE_COMMENT",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "WHITESPACE\\s*=", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
Calling tool: grepTool
def convert_one_fmt_off_pair\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2562:def convert_one_fmt_off_pair(node: Node) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2538:                    node.children[-1].value = ""  # type: ignore
2539:                elif child.type != token.STAR:
2540:                    # insert invisible parentheses
2541:                    node.insert_child(index, Leaf(token.LPAR, ""))
2542:                    node.append_child(Leaf(token.RPAR, ""))
2543:                break
2544:
2545:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2546:                # wrap child in invisible parentheses
2547:                lpar = Leaf(token.LPAR, "")
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2
2658:        and node.children[0].type == token.LPAR
2659:        and node.children[1].type == token.RPAR
2660:    )
2661:
2662:
2663:def is_one_tuple(node: LN) -> bool:
2664:    """Return True if `node` holds a tuple with one element, with or without parens."""
2665:    if node.type == syms.atom:
2666:        if len(node.children) != 3:
2667:            return False

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:757:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1126:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1196:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1207:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2021:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2357:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2574:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2601:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2878:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:784:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1068:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1078:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1153:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1223:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1234:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2113:            if pc.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2148:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2484:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2723:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2996:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: grepTool
WHITESPACE\s*=
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:745:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:772:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/flake8/defaults.py:22:WHITESPACE = frozenset(" \t")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/jinja2/lexer.py:85:TOKEN_WHITESPACE = intern("whitespace")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pygments/lexers/usd.py:28:_WHITESPACE = r"([ \t]+)"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pygments/lexers/usd.py:45:                _TYPE, _BASE_ATTRIBUTE, _WHITESPACE=_WHITESPACE),
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pygments/lexers/usd.py:50:                _TYPE, _BASE_ATTRIBUTE, _WHITESPACE=_WHITESPACE),
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pygments/lexers/usd.py:55:                _TYPE, _BASE_ATTRIBUTE, _WHITESPACE=_WHITESPACE),
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pygments/lexers/usd.py:60:                _TYPE, _BASE_ATTRIBUTE, _WHITESPACE=_WHITESPACE),
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pycodestyle.py:124:WHITESPACE = frozenset(' \t')
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/highlighter.py:111:    JSON_WHITESPACE = {" ", "\n", "\r", "\t"}

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pys convert_one_fmt_off_pair(), it checks FMT_OFF comments and proceeds only if the comment is a STANDALONE_COMMENT or, if not, when the preceding leaf is absent or WHITESPACE; otherwise it continues (skips). This matches the requirement to skip inline trailing comments.


Todo item 8 of 18 is correct
description: 'Inspect convert_one_fmt_off_pair(): it should only act on FMT_OFF comments that are standalone (pc.type == STANDALONE_COMMENT) or standalone-in-disguise (no previous leaf or previous leaf is WHITESPACE), skipping inline trailing comments.'
Validating todo item 9 of 18
description: 'Inspect convert_one_fmt_off_pair(): it must collect ignored nodes via generate_ignored_nodes(leaf), trim the consumed part of the first node's prefix, build hidden_value = '# fmt: off' + newline + concatenated ignored nodes, and trim a trailing newline if present.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def convert_one_fmt_off_pair\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
def convert_one_fmt_off_pair\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2562:def convert_one_fmt_off_pair(node: Node) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2520:
2521:    check_lpar = False
2522:    for index, child in enumerate(list(node.children)):
2523:        if check_lpar:
2524:            if child.type == syms.atom:
2525:                maybe_make_parens_invisible_in_atom(child)
2526:            elif is_one_tuple(child):
2527:                # wrap child in visible parentheses
2528:                lpar = Leaf(token.LPAR, "(")
2529:                rpar = Leaf(token.RPAR, ")")
2530:                child.remove()
2531:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2532:            elif node.type == syms.import_from:
2533:                # "import from" nodes store parentheses directly as part of
2534:                # the statement
2535:                if child.type == token.LPAR:
2536:                    # make parentheses invisible
2537:                    child.value = ""  # type: ignore
2538:                    node.children[-1].value = ""  # type: ignore
2539:                elif child.type != token.STAR:
2540:                    # insert invisible parentheses
2541:                    node.insert_child(index, Leaf(token.LPAR, ""))
2542:                    node.append_child(Leaf(token.RPAR, ""))
2543:                break
2544:
2545:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2546:                # wrap child in invisible parentheses
2547:                lpar = Leaf(token.LPAR, "")
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2
2658:        and node.children[0].type == token.LPAR
2659:        and node.children[1].type == token.RPAR
2660:    )
2661:
2662:
2663:def is_one_tuple(node: LN) -> bool:
2664:    """Return True if `node` holds a tuple with one element, with or without parens."""
2665:    if node.type == syms.atom:
2666:        if len(node.children) != 3:
2667:            return False
2668:
2669:        lpar, gexp, rpar = node.children
2670:        if not (
2671:            lpar.type == token.LPAR
2672:            and gexp.type == syms.testlist_gexp
2673:            and rpar.type == token.RPAR
2674:        ):
2675:            return False
2676:
2677:        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA
2678:
2679:    return (

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In convert_one_fmt_off_pair(), it gathers ignored nodes via generate_ignored_nodes(leaf) (lines 2579-2580), trims the consumed part of the first nodes prefix (line 2583), builds hidden_value as comment.value + "\n" + concatenated ignored nodes (lines 2584-2586), and trims a trailing newline if present (lines 2587-2590).


Todo item 9 of 18 is correct
description: 'Inspect convert_one_fmt_off_pair(): it must collect ignored nodes via generate_ignored_nodes(leaf), trim the consumed part of the first node's prefix, build hidden_value = '# fmt: off' + newline + concatenated ignored nodes, and trim a trailing newline if present.'
Validating todo item 10 of 18
description: 'Inspect convert_one_fmt_off_pair(): it must remove all ignored nodes from the tree and insert a new Leaf(STANDALONE_COMMENT, hidden_value) at the correct index with prefix preserved as original prefix up to previous comments plus comment.newlines newlines.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def convert_one_fmt_off_pair\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "STANDALONE_COMMENT",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
def convert_one_fmt_off_pair\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2562:def convert_one_fmt_off_pair(node: Node) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2520:
2521:    check_lpar = False
2522:    for index, child in enumerate(list(node.children)):
2523:        if check_lpar:
2524:            if child.type == syms.atom:
2525:                maybe_make_parens_invisible_in_atom(child)
2526:            elif is_one_tuple(child):
2527:                # wrap child in visible parentheses
2528:                lpar = Leaf(token.LPAR, "(")
2529:                rpar = Leaf(token.RPAR, ")")
2530:                child.remove()
2531:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2532:            elif node.type == syms.import_from:
2533:                # "import from" nodes store parentheses directly as part of
2534:                # the statement
2535:                if child.type == token.LPAR:
2536:                    # make parentheses invisible
2537:                    child.value = ""  # type: ignore
2538:                    node.children[-1].value = ""  # type: ignore
2539:                elif child.type != token.STAR:
2540:                    # insert invisible parentheses
2541:                    node.insert_child(index, Leaf(token.LPAR, ""))
2542:                    node.append_child(Leaf(token.RPAR, ""))
2543:                break
2544:
2545:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2546:                # wrap child in invisible parentheses
2547:                lpar = Leaf(token.LPAR, "")
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2
2658:        and node.children[0].type == token.LPAR
2659:        and node.children[1].type == token.RPAR
2660:    )
2661:
2662:
2663:def is_one_tuple(node: LN) -> bool:
2664:    """Return True if `node` holds a tuple with one element, with or without parens."""
2665:    if node.type == syms.atom:
2666:        if len(node.children) != 3:
2667:            return False
2668:
2669:        lpar, gexp, rpar = node.children
2670:        if not (
2671:            lpar.type == token.LPAR
2672:            and gexp.type == syms.testlist_gexp
2673:            and rpar.type == token.RPAR
2674:        ):
2675:            return False
2676:
2677:        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA
2678:
2679:    return (
2680:        node.type in IMPLICIT_TUPLE
2681:        and len(node.children) == 2
2682:        and node.children[1].type == token.COMMA
2683:    )
2684:
2685:
2686:def is_yield(node: LN) -> bool:
2687:    """Return True if `node` holds a `yield` or `yield from` expression."""
2688:    if node.type == syms.yield_expr:
2689:        return True
2690:
2691:    if node.type == token.NAME and node.value == "yield":  # type: ignore
2692:        return True
2693:
2694:    if node.type != syms.atom:
2695:        return False
2696:
2697:    if len(node.children) != 3:
2698:        return False
2699:

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:757:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1126:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1196:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1207:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2021:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2357:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2574:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2601:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2878:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:784:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1068:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1078:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1153:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1223:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1234:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2113:            if pc.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2148:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2484:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2723:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2996:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py lines 2562-2606, convert_one_fmt_off_pair() gathers ignored_nodes, removes each via remove(), tracks first_idx, and inserts a new Leaf(STANDALONE_COMMENT, hidden_value) at that index with prefix set to prefix[:previous_consumed] + "\n" * comment.newlines, preserving prefix up to previous comments plus newlines.


Todo item 10 of 18 is correct
description: 'Inspect convert_one_fmt_off_pair(): it must remove all ignored nodes from the tree and insert a new Leaf(STANDALONE_COMMENT, hidden_value) at the correct index with prefix preserved as original prefix up to previous comments plus comment.newlines newlines.'
Validating todo item 11 of 18
description: 'Inspect generate_ignored_nodes(): starting at container_of(leaf), it should yield successive containers until encountering FMT_ON in a container's prefix, then stop; it must also stop when container becomes token.ENDMARKER.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def generate_ignored_nodes\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "FMT_ON\\s*=|def list_comments\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def container_of\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
def generate_ignored_nodes\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2735:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2
2658:        and node.children[0].type == token.LPAR
2659:        and node.children[1].type == token.RPAR
2660:    )
2661:
2662:
2663:def is_one_tuple(node: LN) -> bool:
2664:    """Return True if `node` holds a tuple with one element, with or without parens."""
2665:    if node.type == syms.atom:
2666:        if len(node.children) != 3:
2667:            return False
2668:
2669:        lpar, gexp, rpar = node.children
2670:        if not (
2671:            lpar.type == token.LPAR
2672:            and gexp.type == syms.testlist_gexp
2673:            and rpar.type == token.RPAR
2674:        ):
2675:            return False
2676:
2677:        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA
2678:
2679:    return (
2680:        node.type in IMPLICIT_TUPLE
2681:        and len(node.children) == 2
2682:        and node.children[1].type == token.COMMA
2683:    )
2684:
2685:
2686:def is_yield(node: LN) -> bool:
2687:    """Return True if `node` holds a `yield` or `yield from` expression."""
2688:    if node.type == syms.yield_expr:
2689:        return True
2690:
2691:    if node.type == token.NAME and node.value == "yield":  # type: ignore
2692:        return True
2693:
2694:    if node.type != syms.atom:
2695:        return False
2696:
2697:    if len(node.children) != 3:
2698:        return False
2699:
2700:    lpar, expr, rpar = node.children
2701:    if lpar.type == token.LPAR and rpar.type == token.RPAR:
2702:        return is_yield(expr)
2703:
2704:    return False
2705:
2706:
2707:def is_vararg(leaf: Leaf, within: Set[NodeType]) -> bool:

Calling tool: grepTool
FMT_ON\s*=|def list_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2085:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2130:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1956:            and previous.value == "is"
1957:        )
1958:    ):
1959:        return COMPARATOR_PRIORITY
1960:
1961:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1962:        return LOGIC_PRIORITY
1963:
1964:    return 0
1965:
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't
1985:    share the line with any code.
1986:
1987:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
1989:    """
1990:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
1991:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
1992:
1993:
1994:@dataclass
1995:class ProtoComment:
1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
1997:    value: str  # content of the comment
1998:    newlines: int  # how many newlines before the comment
1999:    consumed: int  # how many characters of the original leaf's prefix did we consume
2000:
2001:
2002:@lru_cache(maxsize=4096)
2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2004:    result: List[ProtoComment] = []
2005:    if not prefix or "#" not in prefix:
2006:        return result
2007:
2008:    consumed = 0
2009:    nlines = 0
2010:    for index, line in enumerate(prefix.split("\n")):
2011:        consumed += len(line) + 1  # adding the length of the split '\n'
2012:        line = line.lstrip()
2013:        if not line:
2014:            nlines += 1
2015:        if not line.startswith("#"):
2016:            continue
2017:
2018:        if index == 0 and not is_endmarker:
2019:            comment_type = token.COMMENT  # simple trailing comment
2020:        else:
2021:            comment_type = STANDALONE_COMMENT
2022:        comment = make_comment(line)
2023:        result.append(
2024:            ProtoComment(
2025:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2026:            )
2027:        )
2028:        nlines = 0
2029:    return result
2030:
2031:
2032:def make_comment(content: str) -> str:
2033:    """Return a consistently formatted comment from the given `content` string.
2034:
2035:    All comments (except for "##", "#!", "#:") should have a single space between

Calling tool: grepTool
def container_of\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1837:def container_of(leaf: Leaf) -> LN:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1957:def container_of(leaf: Leaf) -> LN:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1828:
1829:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
1830:    """Return the child of `ancestor` that contains `descendant`."""
1831:    node: Optional[LN] = descendant
1832:    while node and node.parent != ancestor:
1833:        node = node.parent
1834:    return node
1835:
1836:
1837:def container_of(leaf: Leaf) -> LN:
1838:    """Return `leaf` or one of its ancestors that is the topmost container of it.
1839:
1840:    By "container" we mean a node where `leaf` is the very first child.
1841:    """
1842:    same_prefix = leaf.prefix
1843:    container: LN = leaf
1844:    while container:
1845:        parent = container.parent
1846:        if parent is None:
1847:            break
1848:
1849:        if parent.children[0].prefix != same_prefix:
1850:            break
1851:
1852:        if parent.type == syms.file_input:
1853:            break
1854:
1855:        if parent.type in SURROUNDED_BY_BRACKETS:
1856:            break
1857:
1858:        container = parent
1859:    return container
1860:
1861:
1862:def is_split_after_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1863:    """Return the priority of the `leaf` delimiter, given a line break after it.
1864:
1865:    The delimiter priorities returned here are from those delimiters that would
1866:    cause a line break after themselves.
1867:
1868:    Higher numbers are higher priority.
1869:    """
1870:    if leaf.type == token.COMMA:
1871:        return COMMA_PRIORITY
1872:
1873:    return 0
1874:
1875:
1876:def is_split_before_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1877:    """Return the priority of the `leaf` delimiter, given a line before after it.
1878:
1879:    The delimiter priorities returned here are from those delimiters that would
1880:    cause a line break before themselves.
1881:
1882:    Higher numbers are higher priority.
1883:    """
1884:    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):
1885:        # * and ** might also be MATH_OPERATORS but in this case they are not.
1886:        # Don't treat them as a delimiter.
1887:        return 0
1888:
1889:    if (
1890:        leaf.type == token.DOT
1891:        and leaf.parent
1892:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
1893:        and (previous is None or previous.type in CLOSING_BRACKETS)
1894:    ):
1895:        return DOT_PRIORITY
1896:
1897:    if (
1898:        leaf.type in MATH_OPERATORS
1899:        and leaf.parent
1900:        and leaf.parent.type not in {syms.factor, syms.star_expr}
1901:    ):
1902:        return MATH_PRIORITIES[leaf.type]
1903:
1904:    if leaf.type in COMPARATORS:
1905:        return COMPARATOR_PRIORITY
1906:
1907:    if (

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: generate_ignored_nodes starts from container_of(leaf) and iterates container.next_sibling, yielding each container until it finds FMT_ON in a containers prefix (then returns) and the loop condition also stops when container is token.ENDMARKER.


Todo item 11 of 18 is correct
description: 'Inspect generate_ignored_nodes(): starting at container_of(leaf), it should yield successive containers until encountering FMT_ON in a container's prefix, then stop; it must also stop when container becomes token.ENDMARKER.'
Validating todo item 12 of 18
description: 'Inspect container_of(leaf): verify it walks up until the topmost container whose first child's prefix matches the starting prefix, and stops before syms.file_input or any node in SURROUNDED_BY_BRACKETS.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def container_of\\(leaf: Leaf\\)",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
def container_of\(leaf: Leaf\)
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1837:def container_of(leaf: Leaf) -> LN:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1957:def container_of(leaf: Leaf) -> LN:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1800:                return SPACE
1801:
1802:            if prev and prev.type == token.DOT:
1803:                return NO
1804:
1805:    elif p.type == syms.sliceop:
1806:        return NO
1807:
1808:    return SPACE
1809:
1810:
1811:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
1812:    """Return the first leaf that precedes `node`, if any."""
1813:    while node:
1814:        res = node.prev_sibling
1815:        if res:
1816:            if isinstance(res, Leaf):
1817:                return res
1818:
1819:            try:
1820:                return list(res.leaves())[-1]
1821:
1822:            except IndexError:
1823:                return None
1824:
1825:        node = node.parent
1826:    return None
1827:
1828:
1829:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
1830:    """Return the child of `ancestor` that contains `descendant`."""
1831:    node: Optional[LN] = descendant
1832:    while node and node.parent != ancestor:
1833:        node = node.parent
1834:    return node
1835:
1836:
1837:def container_of(leaf: Leaf) -> LN:
1838:    """Return `leaf` or one of its ancestors that is the topmost container of it.
1839:
1840:    By "container" we mean a node where `leaf` is the very first child.
1841:    """
1842:    same_prefix = leaf.prefix
1843:    container: LN = leaf
1844:    while container:
1845:        parent = container.parent
1846:        if parent is None:
1847:            break
1848:
1849:        if parent.children[0].prefix != same_prefix:
1850:            break
1851:
1852:        if parent.type == syms.file_input:
1853:            break
1854:
1855:        if parent.type in SURROUNDED_BY_BRACKETS:
1856:            break
1857:
1858:        container = parent
1859:    return container
1860:
1861:
1862:def is_split_after_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1863:    """Return the priority of the `leaf` delimiter, given a line break after it.
1864:
1865:    The delimiter priorities returned here are from those delimiters that would
1866:    cause a line break after themselves.
1867:
1868:    Higher numbers are higher priority.
1869:    """
1870:    if leaf.type == token.COMMA:
1871:        return COMMA_PRIORITY
1872:
1873:    return 0
1874:
1875:
1876:def is_split_before_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1877:    """Return the priority of the `leaf` delimiter, given a line before after it.
1878:
1879:    The delimiter priorities returned here are from those delimiters that would
1880:    cause a line break before themselves.
1881:
1882:    Higher numbers are higher priority.
1883:    """
1884:    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):
1885:        # * and ** might also be MATH_OPERATORS but in this case they are not.
1886:        # Don't treat them as a delimiter.
1887:        return 0
1888:
1889:    if (
1890:        leaf.type == token.DOT
1891:        and leaf.parent
1892:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
1893:        and (previous is None or previous.type in CLOSING_BRACKETS)
1894:    ):
1895:        return DOT_PRIORITY
1896:
1897:    if (
1898:        leaf.type in MATH_OPERATORS
1899:        and leaf.parent
1900:        and leaf.parent.type not in {syms.factor, syms.star_expr}
1901:    ):
1902:        return MATH_PRIORITIES[leaf.type]
1903:
1904:    if leaf.type in COMPARATORS:
1905:        return COMPARATOR_PRIORITY
1906:
1907:    if (
1908:        leaf.type == token.STRING
1909:        and previous is not None
1910:        and previous.type == token.STRING
1911:    ):
1912:        return STRING_PRIORITY
1913:
1914:    if leaf.type != token.NAME:
1915:        return 0
1916:
1917:    if (
1918:        leaf.value == "for"
1919:        and leaf.parent
1920:        and leaf.parent.type in {syms.comp_for, syms.old_comp_for}
1921:    ):
1922:        return COMPREHENSION_PRIORITY
1923:
1924:    if (
1925:        leaf.value == "if"
1926:        and leaf.parent
1927:        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
1928:    ):
1929:        return COMPREHENSION_PRIORITY

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
1920:                return SPACE
1921:
1922:            if prev and prev.type == token.DOT:
1923:                return NO
1924:
1925:    elif p.type == syms.sliceop:
1926:        return NO
1927:
1928:    return SPACE
1929:
1930:
1931:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
1932:    """Return the first leaf that precedes `node`, if any."""
1933:    while node:
1934:        res = node.prev_sibling
1935:        if res:
1936:            if isinstance(res, Leaf):
1937:                return res
1938:
1939:            try:
1940:                return list(res.leaves())[-1]
1941:
1942:            except IndexError:
1943:                return None
1944:
1945:        node = node.parent
1946:    return None
1947:
1948:
1949:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
1950:    """Return the child of `ancestor` that contains `descendant`."""
1951:    node: Optional[LN] = descendant
1952:    while node and node.parent != ancestor:
1953:        node = node.parent
1954:    return node
1955:
1956:
1957:def container_of(leaf: Leaf) -> LN:
1958:    """Return `leaf` or one of its ancestors that is the topmost container of it.
1959:
1960:    By "container" we mean a node where `leaf` is the very first child.
1961:    """
1962:    same_prefix = leaf.prefix
1963:    container: LN = leaf
1964:    while container:
1965:        parent = container.parent
1966:        if parent is None:
1967:            break
1968:
1969:        if parent.children[0].prefix != same_prefix:
1970:            break
1971:
1972:        if parent.type in SURROUNDED_BY_BRACKETS:
1973:            break
1974:
1975:        container = parent
1976:    return container
1977:
1978:
1979:def is_split_after_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1980:    """Return the priority of the `leaf` delimiter, given a line break after it.
1981:
1982:    The delimiter priorities returned here are from those delimiters that would
1983:    cause a line break after themselves.
1984:
1985:    Higher numbers are higher priority.
1986:    """
1987:    if leaf.type == token.COMMA:
1988:        return COMMA_PRIORITY
1989:
1990:    return 0
1991:
1992:
1993:def is_split_before_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1994:    """Return the priority of the `leaf` delimiter, given a line before after it.
1995:
1996:    The delimiter priorities returned here are from those delimiters that would
1997:    cause a line break before themselves.
1998:
1999:    Higher numbers are higher priority.
2000:    """
2001:    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):
2002:        # * and ** might also be MATH_OPERATORS but in this case they are not.
2003:        # Don't treat them as a delimiter.
2004:        return 0
2005:
2006:    if (
2007:        leaf.type == token.DOT
2008:        and leaf.parent
2009:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
2010:        and (previous is None or previous.type in CLOSING_BRACKETS)
2011:    ):
2012:        return DOT_PRIORITY
2013:
2014:    if (
2015:        leaf.type in MATH_OPERATORS
2016:        and leaf.parent
2017:        and leaf.parent.type not in {syms.factor, syms.star_expr}
2018:    ):
2019:        return MATH_PRIORITIES[leaf.type]
2020:
2021:    if leaf.type in COMPARATORS:
2022:        return COMPARATOR_PRIORITY
2023:
2024:    if (
2025:        leaf.type == token.STRING
2026:        and previous is not None
2027:        and previous.type == token.STRING
2028:    ):
2029:        return STRING_PRIORITY
2030:
2031:    if leaf.type != token.NAME:
2032:        return 0
2033:
2034:    if (
2035:        leaf.value == "for"
2036:        and leaf.parent
2037:        and leaf.parent.type in {syms.comp_for, syms.old_comp_for}
2038:    ):
2039:        return COMPREHENSION_PRIORITY
2040:
2041:    if (
2042:        leaf.value == "if"
2043:        and leaf.parent
2044:        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
2045:    ):
2046:        return COMPREHENSION_PRIORITY
2047:
2048:    if leaf.value in {"if", "else"} and leaf.parent and leaf.parent.type == syms.test:
2049:        return TERNARY_PRIORITY

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py at lines 1837-1859, container_of walks up ancestors while the parents first child prefix matches the original prefix, and breaks when encountering syms.file_input or any type in SURROUNDED_BY_BRACKETS. This matches the specified behavior.


Todo item 12 of 18 is correct
description: 'Inspect container_of(leaf): verify it walks up until the topmost container whose first child's prefix matches the starting prefix, and stops before syms.file_input or any node in SURROUNDED_BY_BRACKETS.'
Validating todo item 13 of 18
description: 'Verify LineGenerator.visit_STANDALONE_COMMENT yields a line boundary when not inside brackets (no open brackets) before visiting the STANDALONE_COMMENT, ensuring the comment is isolated on its own line.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def visit_STANDALONE_COMMENT\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class Line\\b", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "STANDALONE_COMMENT",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def visit_NEWLINE\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "visit_\\w*NEWLINE", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "yield from self\\.line\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
def visit_STANDALONE_COMMENT\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1528:
1529:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1530:        """Visit decorators."""
1531:        for child in node.children:
1532:            yield from self.line()
1533:            yield from self.visit(child)
1534:
1535:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1536:        """Remove a semicolon and put the other statement on a separate line."""
1537:        yield from self.line()
1538:
1539:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1540:        """End of file. Process outstanding comments and end with a newline."""
1541:        yield from self.visit_default(leaf)
1542:        yield from self.line()
1543:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1545:        if not self.current_line.bracket_tracker.any_open_brackets():
1546:            yield from self.line()
1547:        yield from self.visit_default(leaf)
1548:
1549:    def __attrs_post_init__(self) -> None:
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1558:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1559:        self.visit_try_stmt = partial(
1560:            v, keywords={"try", "except", "else", "finally"}, parens=
1561:        )
1562:        self.visit_except_clause = partial(v, keywords={"except"}, parens=)
1563:        self.visit_with_stmt = partial(v, keywords={"with"}, parens=)
1564:        self.visit_funcdef = partial(v, keywords={"def"}, parens=)
1565:        self.visit_classdef = partial(v, keywords={"class"}, parens=)
1566:        self.visit_expr_stmt = partial(v, keywords=, parens=ASSIGNMENTS)
1567:        self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})

Calling tool: grepTool
class Line\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:993:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1020:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/docutils/parsers/rst/states.py:2913:class Line(SpecializedText):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/tabulate.pyi:8:class Line(NamedTuple):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/werkzeug/debug/tbtools.pyi:16:class Line:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
990:
991:
992:@dataclass
993:class Line:
994:    """Holds leaves and comments. Can be printed with `str(line)`."""
995:
996:    depth: int = 0
997:    leaves: List[Leaf] = Factory(list)
998:    comments: List[Tuple[Index, Leaf]] = Factory(list)
999:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1000:    inside_brackets: bool = False
1001:    should_explode: bool = False
1002:
1003:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1004:        """Add a new `leaf` to the end of the line.
1005:
1006:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1007:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1008:        Trailing commas are maybe removed, unpacked for loop variables are
1009:        demoted from being delimiters.
1010:
1011:        Inline comments are put aside.
1012:        """
1013:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1014:        if not has_value:
1015:            return
1016:
1017:        if token.COLON == leaf.type and self.is_class_paren_empty:
1018:            del self.leaves[-2:]
1019:        if self.leaves and not preformatted:
1020:            # Note: at this point leaf.prefix should be empty except for
1021:            # imports, for which we only preserve newlines.
1022:            leaf.prefix += whitespace(
1023:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1024:            )
1025:        if self.inside_brackets or not preformatted:
1026:            self.bracket_tracker.mark(leaf)
1027:            self.maybe_remove_trailing_comma(leaf)
1028:        if not self.append_comment(leaf):
1029:            self.leaves.append(leaf)
1030:
1031:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1032:        """Like :func:`append()` but disallow invalid standalone comment structure.
1033:
1034:        Raises ValueError when any `leaf` is appended after a standalone comment
1035:        or when a standalone comment is not the first leaf on the line.
1036:        """
1037:        if self.bracket_tracker.depth == 0:
1038:            if self.is_comment:
1039:                raise ValueError("cannot append to standalone comments")
1040:
1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1042:                raise ValueError(
1043:                    "cannot append standalone comments to a populated line"
1044:                )
1045:
1046:        self.append(leaf, preformatted=preformatted)
1047:
1048:    @property
1049:    def is_comment(self) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1048:    @property
1049:    def is_comment(self) -> bool:
1050:        """Is this line a standalone comment?"""
1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1052:
1053:    @property
1054:    def is_decorator(self) -> bool:
1055:        """Is this line a decorator?"""
1056:        return bool(self) and self.leaves[0].type == token.AT
1057:
1058:    @property
1059:    def is_import(self) -> bool:
1060:        """Is this an import line?"""
1061:        return bool(self) and is_import(self.leaves[0])
1062:
1063:    @property
1064:    def is_class(self) -> bool:
1065:        """Is this line a class definition?"""
1066:        return (
1067:            bool(self)
1068:            and self.leaves[0].type == token.NAME
1069:            and self.leaves[0].value == "class"
1070:        )
1071:
1072:    @property
1073:    def is_stub_class(self) -> bool:
1074:        """Is this line a class definition with a body consisting only of "..."?"""
1075:        return self.is_class and self.leaves[-3:] == [
1076:            Leaf(token.DOT, ".") for _ in range(3)
1077:        ]
1078:
1079:    @property
1080:    def is_def(self) -> bool:
1081:        """Is this a function definition? (Also returns True for async defs.)"""
1082:        try:
1083:            first_leaf = self.leaves[0]
1084:        except IndexError:
1085:            return False
1086:
1087:        try:
1088:            second_leaf: Optional[Leaf] = self.leaves[1]
1089:        except IndexError:
1090:            second_leaf = None
1091:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1092:            first_leaf.type == token.ASYNC
1093:            and second_leaf is not None
1094:            and second_leaf.type == token.NAME
1095:            and second_leaf.value == "def"
1096:        )
1097:
1098:    @property
1099:    def is_class_paren_empty(self) -> bool:
1100:        """Is this a class with no base classes but using parentheses?
1101:
1102:        Those are unnecessary and should be removed.
1103:        """
1104:        return (
1105:            bool(self)
1106:            and len(self.leaves) == 4
1107:            and self.is_class
1108:            and self.leaves[2].type == token.LPAR
1109:            and self.leaves[2].value == "("
1110:            and self.leaves[3].type == token.RPAR
1111:            and self.leaves[3].value == ")"
1112:        )
1113:
1114:    @property
1115:    def is_triple_quoted_string(self) -> bool:
1116:        """Is the line a triple quoted string?"""
1117:        return (
1118:            bool(self)
1119:            and self.leaves[0].type == token.STRING
1120:            and self.leaves[0].value.startswith(('"""', "'''"))
1121:        )
1122:
1123:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1124:        """If so, needs to be split before emitting."""
1125:        for leaf in self.leaves:
1126:            if leaf.type == STANDALONE_COMMENT:
1127:                if leaf.bracket_depth <= depth_limit:

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2051:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2178:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2050:
2051:def split_line(
2052:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2053:) -> Iterator[Line]:
2054:    """Split a `line` into potentially many lines.
2055:
2056:    They should fit in the allotted `line_length` but might not be able to.
2057:    `inner` signifies that there were a pair of brackets somewhere around the
2058:    current `line`, possibly transitively. This means we can fallback to splitting
2059:    by delimiters if the LHS/RHS don't yield any results.
2060:
2061:    If `py36` is True, splitting may generate syntax that is only compatible
2062:    with Python 3.6 and later.
2063:    """
2064:    if line.is_comment:
2065:        yield line
2066:        return
2067:
2068:    line_str = str(line).strip("\n")
2069:    if not line.should_explode and is_line_short_enough(
2070:        line, line_length=line_length, line_str=line_str
2071:    ):
2072:        yield line
2073:        return
2074:
2075:    split_funcs: List[SplitFunc]
2076:    if line.is_def:
2077:        split_funcs = [left_hand_split]
2078:    else:
2079:
2080:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2081:            for omit in generate_trailers_to_omit(line, line_length):
2082:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2083:                if is_line_short_enough(lines[0], line_length=line_length):
2084:                    yield from lines
2085:                    return
2086:
2087:            # All splits failed, best effort split with no omits.
2088:            # This mostly happens to multiline strings that are by definition
2089:            # reported as not fitting a single line.

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:757:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1126:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1196:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1207:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2021:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2357:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2574:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2601:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2878:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:784:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1068:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1078:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1153:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1223:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1234:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2113:            if pc.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2148:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2484:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2723:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2996:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1118:            bool(self)
1119:            and self.leaves[0].type == token.STRING
1120:            and self.leaves[0].value.startswith(('"""', "'''"))
1121:        )
1122:
1123:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1124:        """If so, needs to be split before emitting."""
1125:        for leaf in self.leaves:
1126:            if leaf.type == STANDALONE_COMMENT:
1127:                if leaf.bracket_depth <= depth_limit:
1128:                    return True
1129:
1130:        return False
1131:
1132:    def contains_multiline_strings(self) -> bool:
1133:        for leaf in self.leaves:
1134:            if is_multiline_string(leaf):
1135:                return True
1136:
1137:        return False
1138:
1139:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1140:        """Remove trailing comma if there is one and it's safe."""
1141:        if not (
1142:            self.leaves
1143:            and self.leaves[-1].type == token.COMMA
1144:            and closing.type in CLOSING_BRACKETS
1145:        ):
1146:            return False
1147:
1148:        if closing.type == token.RBRACE:
1149:            self.remove_trailing_comma()
1150:            return True
1151:
1152:        if closing.type == token.RSQB:
1153:            comma = self.leaves[-1]
1154:            if comma.parent and comma.parent.type == syms.listmaker:
1155:                self.remove_trailing_comma()
1156:                return True
1157:
1158:        # For parens let's check if it's safe to remove the comma.
1159:        # Imports are always safe.
1160:        if self.is_import:
1161:            self.remove_trailing_comma()
1162:            return True
1163:
1164:        # Otheriwsse, if the trailing one is the only one, we might mistakenly
1165:        # change a tuple into a different type by removing the comma.
1166:        depth = closing.bracket_depth + 1
1167:        commas = 0
1168:        opening = closing.opening_bracket
1169:        for _opening_index, leaf in enumerate(self.leaves):
1170:            if leaf is opening:
1171:                break
1172:
1173:        else:
1174:            return False
1175:
1176:        for leaf in self.leaves[_opening_index + 1 :]:
1177:            if leaf is closing:
1178:                break
1179:
1180:            bracket_depth = leaf.bracket_depth
1181:            if bracket_depth == depth and leaf.type == token.COMMA:
1182:                commas += 1
1183:                if leaf.parent and leaf.parent.type == syms.arglist:
1184:                    commas += 1
1185:                    break
1186:
1187:        if commas > 1:
1188:            self.remove_trailing_comma()
1189:            return True
1190:
1191:        return False
1192:
1193:    def append_comment(self, comment: Leaf) -> bool:
1194:        """Add an inline or standalone comment to the line."""
1195:        if (
1196:            comment.type == STANDALONE_COMMENT
1197:            and self.bracket_tracker.any_open_brackets()
1198:        ):
1199:            comment.prefix = ""
1200:            return False
1201:
1202:        if comment.type != token.COMMENT:
1203:            return False
1204:
1205:        after = len(self.leaves) - 1
1206:        if after == -1:
1207:            comment.type = STANDALONE_COMMENT
1208:            comment.prefix = ""
1209:            return False
1210:
1211:        else:
1212:            self.comments.append((after, comment))
1213:            return True
1214:
1215:    def comments_after(self, leaf: Leaf, _index: int = -1) -> Iterator[Leaf]:
1216:        """Generate comments that should appear directly after `leaf`.
1217:

Calling tool: grepTool
def visit_NEWLINE\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
visit_\w*NEWLINE
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
yield from self\.line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1433:                    yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1437:                    yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1440:                    yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1453:        yield from self.line(+1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1461:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1468:        yield from self.line(-1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1487:                yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1505:                yield from self.line(+1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1507:                yield from self.line(-1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1511:                yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1516:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1532:            yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1537:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1542:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1546:            yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1528:                        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1532:                        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1535:                        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1539:                yield from self.line(type=UnformattedLines)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1560:        yield from self.line(+1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1568:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1575:        yield from self.line(-1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1594:                yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1612:                yield from self.line(+1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1614:                yield from self.line(-1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1618:                yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1623:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1639:            yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1644:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1649:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1662:                yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1667:                yield from self.line()

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1418:        complete_line = self.current_line
1419:        self.current_line = Line(depth=complete_line.depth + indent)
1420:        yield complete_line
1421:
1422:    def visit_default(self, node: LN) -> Iterator[Line]:
1423:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1424:        if isinstance(node, Leaf):
1425:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1426:            for comment in generate_comments(node):
1427:                if any_open_brackets:
1428:                    # any comment within brackets is subject to splitting
1429:                    self.current_line.append(comment)
1430:                elif comment.type == token.COMMENT:
1431:                    # regular trailing comment
1432:                    self.current_line.append(comment)
1433:                    yield from self.line()
1434:
1435:                else:
1436:                    # regular standalone comment
1437:                    yield from self.line()
1438:
1439:                    self.current_line.append(comment)
1440:                    yield from self.line()
1441:
1442:            normalize_prefix(node, inside_brackets=any_open_brackets)
1443:            if self.normalize_strings and node.type == token.STRING:
1444:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1445:                normalize_string_quotes(node)
1446:            if node.type not in WHITESPACE:
1447:                self.current_line.append(node)
1448:        yield from super().visit_default(node)
1449:
1450:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1451:        """Increase indentation level, maybe yield a line."""
1452:        # In blib2to3 INDENT never holds comments.
1453:        yield from self.line(+1)
1454:        yield from self.visit_default(node)
1455:
1456:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1457:        """Decrease indentation level, maybe yield a line."""
1458:        # The current line might still wait for trailing comments.  At DEDENT time
1459:        # there won't be any (they would be prefixes on the preceding NEWLINE).
1460:        # Emit the line then.
1461:        yield from self.line()
1462:
1463:        # While DEDENT has no value, its prefix may contain standalone comments
1464:        # that belong to the current indentation level.  Get 'em.
1465:        yield from self.visit_default(node)
1466:
1467:        # Finally, emit the dedent.
1468:        yield from self.line(-1)
1469:
1470:    def visit_stmt(
1471:        self, node: Node, keywords: Set[str], parens: Set[str]
1472:    ) -> Iterator[Line]:
1473:        """Visit a statement.
1474:
1475:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1476:        `def`, `with`, `class`, `assert` and assignments.
1477:
1478:        The relevant Python language `keywords` for a given statement will be
1479:        NAME leaves within it. This methods puts those on a separate line.
1480:
1481:        `parens` holds a set of string leaf values immediately after which
1482:        invisible parens should be put.
1483:        """
1484:        normalize_invisible_parens(node, parens_after=parens)
1485:        for child in node.children:
1486:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1487:                yield from self.line()
1488:
1489:            yield from self.visit(child)
1490:
1491:    def visit_suite(self, node: Node) -> Iterator[Line]:
1492:        """Visit a suite."""
1493:        if self.is_pyi and is_stub_suite(node):
1494:            yield from self.visit(node.children[2])
1495:        else:
1496:            yield from self.visit_default(node)
1497:
1498:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1499:        """Visit a statement without nested statements."""
1500:        is_suite_like = node.parent and node.parent.type in STATEMENT
1501:        if is_suite_like:
1502:            if self.is_pyi and is_stub_body(node):
1503:                yield from self.visit_default(node)
1504:            else:
1505:                yield from self.line(+1)
1506:                yield from self.visit_default(node)
1507:                yield from self.line(-1)
1508:
1509:        else:
1510:            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):
1511:                yield from self.line()
1512:            yield from self.visit_default(node)
1513:
1514:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:
1515:        """Visit `async def`, `async for`, `async with`."""
1516:        yield from self.line()
1517:
1518:        children = iter(node.children)
1519:        for child in children:
1520:            yield from self.visit(child)
1521:
1522:            if child.type == token.ASYNC:
1523:                break
1524:
1525:        internal_stmt = next(children)
1526:        for child in internal_stmt.children:
1527:            yield from self.visit(child)
1528:
1529:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1530:        """Visit decorators."""
1531:        for child in node.children:
1532:            yield from self.line()
1533:            yield from self.visit(child)
1534:
1535:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1536:        """Remove a semicolon and put the other statement on a separate line."""
1537:        yield from self.line()
1538:
1539:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1540:        """End of file. Process outstanding comments and end with a newline."""
1541:        yield from self.visit_default(leaf)
1542:        yield from self.line()
1543:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1545:        if not self.current_line.bracket_tracker.any_open_brackets():
1546:            yield from self.line()
1547:        yield from self.visit_default(leaf)
1548:
1549:    def __attrs_post_init__(self) -> None:
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, LineGenerator.visit_STANDALONE_COMMENT checks bracket_tracker.any_open_brackets() and, when there are no open brackets, calls `yield from self.line()` before delegating to visit_default. This ensures a line boundary is created prior to the standalone comment, isolating it on its own line.


Todo item 13 of 18 is correct
description: 'Verify LineGenerator.visit_STANDALONE_COMMENT yields a line boundary when not inside brackets (no open brackets) before visiting the STANDALONE_COMMENT, ensuring the comment is isolated on its own line.'
Validating todo item 14 of 18
description: 'Verify split_line() immediately yields and returns when line.is_comment is True so STANDALONE_COMMENT lines are not split or reformatted.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/{{FOLDER_PATH}}" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def split_line\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
Calling tool: grepTool
def split_line\(
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2051:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2178:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2025:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2026:            )
2027:        )
2028:        nlines = 0
2029:    return result
2030:
2031:
2032:def make_comment(content: str) -> str:
2033:    """Return a consistently formatted comment from the given `content` string.
2034:
2035:    All comments (except for "##", "#!", "#:") should have a single space between
2036:    the hash sign and the content.
2037:
2038:    If `content` didn't start with a hash sign, one is provided.
2039:    """
2040:    content = content.rstrip()
2041:    if not content:
2042:        return "#"
2043:
2044:    if content[0] == "#":
2045:        content = content[1:]
2046:    if content and content[0] not in " !:#":
2047:        content = " " + content
2048:    return "#" + content
2049:
2050:
2051:def split_line(
2052:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2053:) -> Iterator[Line]:
2054:    """Split a `line` into potentially many lines.
2055:
2056:    They should fit in the allotted `line_length` but might not be able to.
2057:    `inner` signifies that there were a pair of brackets somewhere around the
2058:    current `line`, possibly transitively. This means we can fallback to splitting
2059:    by delimiters if the LHS/RHS don't yield any results.
2060:
2061:    If `py36` is True, splitting may generate syntax that is only compatible
2062:    with Python 3.6 and later.
2063:    """
2064:    if line.is_comment:
2065:        yield line
2066:        return
2067:
2068:    line_str = str(line).strip("\n")
2069:    if not line.should_explode and is_line_short_enough(
2070:        line, line_length=line_length, line_str=line_str
2071:    ):
2072:        yield line
2073:        return
2074:
2075:    split_funcs: List[SplitFunc]
2076:    if line.is_def:
2077:        split_funcs = [left_hand_split]
2078:    else:
2079:
2080:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2081:            for omit in generate_trailers_to_omit(line, line_length):
2082:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2083:                if is_line_short_enough(lines[0], line_length=line_length):
2084:                    yield from lines
2085:                    return
2086:
2087:            # All splits failed, best effort split with no omits.
2088:            # This mostly happens to multiline strings that are by definition
2089:            # reported as not fitting a single line.
2090:            yield from right_hand_split(line, py36)
2091:
2092:        if line.inside_brackets:
2093:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2094:        else:
2095:            split_funcs = [rhs]
2096:    for split_func in split_funcs:
2097:        # We are accumulating lines in `result` because we might want to abort
2098:        # mission and return the original line in the end, or attempt a different
2099:        # split altogether.
2100:        result: List[Line] = []
2101:        try:
2102:            for l in split_func(line, py36):
2103:                if str(l).strip("\n") == line_str:
2104:                    raise CannotSplit("Split function returned an unchanged result")
2105:
2106:                result.extend(
2107:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2108:                )
2109:        except CannotSplit as cs:
2110:            continue
2111:
2112:        else:
2113:            yield from result
2114:            break
2115:
2116:    else:
2117:        yield line
2118:
2119:
2120:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2121:    """Split line into many lines, starting with the first matching bracket pair.
2122:
2123:    Note: this usually looks weird, only use this for function definitions.
2124:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2125:    :func:`right_hand_split` which also handles optional parentheses.
2126:    """
2127:    head = Line(depth=line.depth)
2128:    body = Line(depth=line.depth + 1, inside_brackets=True)
2129:    tail = Line(depth=line.depth)
2130:    tail_leaves: List[Leaf] = []
2131:    body_leaves: List[Leaf] = []
2132:    head_leaves: List[Leaf] = []
2133:    current_leaves = head_leaves
2134:    matching_bracket = None
2135:    for leaf in line.leaves:
2136:        if (
2137:            current_leaves is body_leaves
2138:            and leaf.type in CLOSING_BRACKETS
2139:            and leaf.opening_bracket is matching_bracket
2140:        ):
2141:            current_leaves = tail_leaves if body_leaves else head_leaves
2142:        current_leaves.append(leaf)
2143:        if current_leaves is head_leaves:
2144:            if leaf.type in OPENING_BRACKETS:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, split_line() checks `if line.is_comment:` and immediately `yield line` and `return` (lines ~2064-2067), ensuring comment-only lines (including STANDALONE_COMMENT) are not split or reformatted.


Todo item 14 of 18 is correct
description: 'Verify split_line() immediately yields and returns when line.is_comment is True so STANDALONE_COMMENT lines are not split or reformatted.'
Validating todo item 15 of 18
description: 'Verify ALWAYS_NO_SPACE includes STANDALONE_COMMENT to avoid inserting spaces around standalone comment leaves during formatting.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "ALWAYS_NO_SPACE", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "STANDALONE_COMMENT",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
ALWAYS_NO_SPACE
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/empty_lines.py:14:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/empty_lines.py:67:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/empty_lines.py:111:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/empty_lines.py:162:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1713:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1593:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/data/empty_lines.py:14:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/data/empty_lines.py:67:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/data/empty_lines.py:111:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/data/empty_lines.py:162:    if t in ALWAYS_NO_SPACE:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1558:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1559:        self.visit_try_stmt = partial(
1560:            v, keywords={"try", "except", "else", "finally"}, parens=
1561:        )
1562:        self.visit_except_clause = partial(v, keywords={"except"}, parens=)
1563:        self.visit_with_stmt = partial(v, keywords={"with"}, parens=)
1564:        self.visit_funcdef = partial(v, keywords={"def"}, parens=)
1565:        self.visit_classdef = partial(v, keywords={"class"}, parens=)
1566:        self.visit_expr_stmt = partial(v, keywords=, parens=ASSIGNMENTS)
1567:        self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})
1568:        self.visit_import_from = partial(v, keywords=, parens={"import"})
1569:        self.visit_async_funcdef = self.visit_async_stmt
1570:        self.visit_decorated = self.visit_decorators
1571:
1572:
1573:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
1574:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1575:OPENING_BRACKETS = set(BRACKET.keys())
1576:CLOSING_BRACKETS = set(BRACKET.values())
1577:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1579:
1580:
1581:def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa C901
1582:    """Return whitespace prefix if needed for the given `leaf`.
1583:
1584:    `complex_subscript` signals whether the given leaf is part of a subscription
1585:    which has non-trivial arguments, like arithmetic expressions or function calls.
1586:    """
1587:    NO = ""
1588:    SPACE = " "
1589:    DOUBLESPACE = "  "
1590:    t = leaf.type
1591:    p = leaf.parent
1592:    v = leaf.value
1593:    if t in ALWAYS_NO_SPACE:
1594:        return NO
1595:
1596:    if t == token.COMMENT:
1597:        return DOUBLESPACE
1598:
1599:    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"
1600:    if t == token.COLON and p.type not in {
1601:        syms.subscript,
1602:        syms.subscriptlist,
1603:        syms.sliceop,
1604:    }:
1605:        return NO
1606:
1607:    prev = leaf.prev_sibling
1608:    if not prev:
1609:        prevp = preceding_leaf(p)
1610:        if not prevp or prevp.type in OPENING_BRACKETS:
1611:            return NO
1612:
1613:        if t == token.COLON:
1614:            if prevp.type == token.COLON:
1615:                return NO
1616:
1617:            elif prevp.type != token.COMMA and not complex_subscript:
1618:                return NO
1619:
1620:            return SPACE
1621:
1622:        if prevp.type == token.EQUAL:
1623:            if prevp.parent:
1624:                if prevp.parent.type in {
1625:                    syms.arglist,
1626:                    syms.argument,
1627:                    syms.parameters,
1628:                    syms.varargslist,
1629:                }:

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:757:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1126:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1196:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1207:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2021:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2357:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2574:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2601:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2878:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:784:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1068:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1078:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1153:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1223:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1234:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2113:            if pc.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2148:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2484:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2723:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2996:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
730:            out(f" {node.value!r}", fg="blue", bold=False)
731:
732:    @classmethod
733:    def show(cls, code: Union[str, Leaf, Node]) -> None:
734:        """Pretty-print the lib2to3 AST of a given string of `code`.
735:
736:        Convenience method for debugging.
737:        """
738:        v: DebugVisitor[None] = DebugVisitor()
739:        if isinstance(code, str):
740:            code = lib2to3_parse(code)
741:        list(v.visit(code))
742:
743:
744:KEYWORDS = set(keyword.kwlist)
745:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
746:FLOW_CONTROL = {"return", "raise", "break", "continue"}
747:STATEMENT = {
748:    syms.if_stmt,
749:    syms.while_stmt,
750:    syms.for_stmt,
751:    syms.try_stmt,
752:    syms.except_clause,
753:    syms.with_stmt,
754:    syms.funcdef,
755:    syms.classdef,
756:}
757:STANDALONE_COMMENT = 153
758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
759:LOGIC_OPERATORS = {"and", "or"}
760:COMPARATORS = {
761:    token.LESS,
762:    token.GREATER,
763:    token.EQEQUAL,
764:    token.NOTEQUAL,
765:    token.LESSEQUAL,
766:    token.GREATEREQUAL,
767:}
768:MATH_OPERATORS = {
769:    token.VBAR,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1960:
1961:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1962:        return LOGIC_PRIORITY
1963:
1964:    return 0
1965:
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't
1985:    share the line with any code.
1986:
1987:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
1989:    """
1990:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
1991:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
1992:
1993:
1994:@dataclass
1995:class ProtoComment:
1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
1997:    value: str  # content of the comment
1998:    newlines: int  # how many newlines before the comment
1999:    consumed: int  # how many characters of the original leaf's prefix did we consume
2000:
2001:
2002:@lru_cache(maxsize=4096)
2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2004:    result: List[ProtoComment] = []
2005:    if not prefix or "#" not in prefix:
2006:        return result
2007:
2008:    consumed = 0
2009:    nlines = 0
2010:    for index, line in enumerate(prefix.split("\n")):
2011:        consumed += len(line) + 1  # adding the length of the split '\n'
2012:        line = line.lstrip()
2013:        if not line:
2014:            nlines += 1
2015:        if not line.startswith("#"):
2016:            continue
2017:
2018:        if index == 0 and not is_endmarker:
2019:            comment_type = token.COMMENT  # simple trailing comment
2020:        else:
2021:            comment_type = STANDALONE_COMMENT
2022:        comment = make_comment(line)
2023:        result.append(
2024:            ProtoComment(
2025:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2026:            )
2027:        )
2028:        nlines = 0
2029:    return result
2030:
2031:
2032:def make_comment(content: str) -> str:
2033:    """Return a consistently formatted comment from the given `content` string.
2034:
2035:    All comments (except for "##", "#!", "#:") should have a single space between
2036:    the hash sign and the content.
2037:
2038:    If `content` didn't start with a hash sign, one is provided.
2039:    """

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, ALWAYS_NO_SPACE is defined as CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT} (see around line 1578). The whitespace() function checks `if t in ALWAYS_NO_SPACE: return ""` (lines ~1591-1594), ensuring no spaces are inserted around STANDALONE_COMMENT leaves. This satisfies the requirement.


Todo item 15 of 18 is correct
description: 'Verify ALWAYS_NO_SPACE includes STANDALONE_COMMENT to avoid inserting spaces around standalone comment leaves during formatting.'
Validating todo item 16 of 18
description: 'Verify EmptyLineTracker._maybe_empty_lines_for_class_or_def() has logic to avoid adding blank lines when previous_line.is_comment, at the same depth, and 'before' is 0; this should prevent extra lines between functions following a STANDALONE_COMMENT block.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class EmptyLineTracker",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def is_comment|@property\\s+def is_comment|is_comment\\b",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py"
]
Calling tool: grepTool
class EmptyLineTracker
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1359:class EmptyLineTracker:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1283:class EmptyLineTracker:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1260:        )
1261:
1262:    def __str__(self) -> str:
1263:        """Render the line."""
1264:        if not self:
1265:            return "\n"
1266:
1267:        indent = "    " * self.depth
1268:        leaves = iter(self.leaves)
1269:        first = next(leaves)
1270:        res = f"{first.prefix}{indent}{first.value}"
1271:        for leaf in leaves:
1272:            res += str(leaf)
1273:        for _, comment in self.comments:
1274:            res += str(comment)
1275:        return res + "\n"
1276:
1277:    def __bool__(self) -> bool:
1278:        """Return True if the line has leaves or comments."""
1279:        return bool(self.leaves or self.comments)
1280:
1281:
1282:@dataclass
1283:class EmptyLineTracker:
1284:    """Provides a stateful method that returns the number of potential extra
1285:    empty lines needed before and after the currently processed line.
1286:
1287:    Note: this tracker works on lines that haven't been split yet.  It assumes
1288:    the prefix of the first leaf consists of optional newlines.  Those newlines
1289:    are consumed by `maybe_empty_lines()` and included in the computation.
1290:    """
1291:
1292:    is_pyi: bool = False
1293:    previous_line: Optional[Line] = None
1294:    previous_after: int = 0
1295:    previous_defs: List[int] = Factory(list)
1296:
1297:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1298:        """Return the number of extra empty lines before and after the `current_line`.
1299:
1300:        This is for separating `def`, `async def` and `class` with extra empty
1301:        lines (two on module-level).
1302:        """
1303:        before, after = self._maybe_empty_lines(current_line)
1304:        before -= self.previous_after
1305:        self.previous_after = after
1306:        self.previous_line = current_line
1307:        return before, after
1308:
1309:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1310:        max_allowed = 1
1311:        if current_line.depth == 0:
1312:            max_allowed = 1 if self.is_pyi else 2
1313:        if current_line.leaves:
1314:            # Consume the first leaf's extra newlines.
1315:            first_leaf = current_line.leaves[0]
1316:            before = first_leaf.prefix.count("\n")
1317:            before = min(before, max_allowed)
1318:            first_leaf.prefix = ""
1319:        else:
1320:            before = 0
1321:        depth = current_line.depth
1322:        while self.previous_defs and self.previous_defs[-1] >= depth:
1323:            self.previous_defs.pop()
1324:            if self.is_pyi:
1325:                before = 0 if depth else 1
1326:            else:
1327:                before = 1 if depth else 2
1328:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
1329:            return self._maybe_empty_lines_for_class_or_def(current_line, before)
1330:
1331:        if (
1332:            self.previous_line
1333:            and self.previous_line.is_import
1334:            and not current_line.is_import
1335:            and depth == self.previous_line.depth
1336:        ):
1337:            return (before or 1), 0
1338:
1339:        if (
1340:            self.previous_line
1341:            and self.previous_line.is_class
1342:            and current_line.is_triple_quoted_string
1343:        ):
1344:            return before, 1
1345:
1346:        return before, 0
1347:
1348:    def _maybe_empty_lines_for_class_or_def(
1349:        self, current_line: Line, before: int
1350:    ) -> Tuple[int, int]:
1351:        if not current_line.is_decorator:
1352:            self.previous_defs.append(current_line.depth)
1353:        if self.previous_line is None:
1354:            # Don't insert empty lines before the first line in the file.
1355:            return 0, 0
1356:
1357:        if self.previous_line.is_decorator:
1358:            return 0, 0
1359:
1360:        if self.previous_line.depth < current_line.depth and (
1361:            self.previous_line.is_class or self.previous_line.is_def
1362:        ):
1363:            return 0, 0
1364:
1365:        if (
1366:            self.previous_line.is_comment
1367:            and self.previous_line.depth == current_line.depth
1368:            and before == 0
1369:        ):
1370:            return 0, 0
1371:
1372:        if self.is_pyi:
1373:            if self.previous_line.depth > current_line.depth:
1374:                newlines = 1
1375:            elif current_line.is_class or self.previous_line.is_class:
1376:                if current_line.is_stub_class and self.previous_line.is_stub_class:
1377:                    # No blank line between classes with an emty body
1378:                    newlines = 0
1379:                else:
1380:                    newlines = 1
1381:            elif current_line.is_def and not self.previous_line.is_def:
1382:                # Blank line between a block of functions and a block of non-functions
1383:                newlines = 1
1384:            else:
1385:                newlines = 0
1386:        else:
1387:            newlines = 2
1388:        if current_line.depth and newlines:
1389:            newlines -= 1
1390:        return newlines, 0
1391:
1392:
1393:@dataclass
1394:class LineGenerator(Visitor[Line]):
1395:    """Generates reformatted Line objects.  Empty lines are not emitted.
1396:
1397:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
1398:    in ways that will no longer stringify to valid Python code on the tree.
1399:    """
1400:
1401:    is_pyi: bool = False
1402:    normalize_strings: bool = True
1403:    current_line: Line = Factory(Line)
1404:    remove_u_prefix: bool = False
1405:
1406:    def line(self, indent: int = 0) -> Iterator[Line]:
1407:        """Generate a line.
1408:
1409:        If the line is empty, only emit if it makes sense.
1410:        If the line is too long, split it first and then generate.
1411:
1412:        If any lines were generated, set up a new current_line.
1413:        """
1414:        if not self.current_line:
1415:            self.current_line.depth += indent
1416:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1417:
1418:        complete_line = self.current_line
1419:        self.current_line = Line(depth=complete_line.depth + indent)
1420:        yield complete_line
1421:
1422:    def visit_default(self, node: LN) -> Iterator[Line]:
1423:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1424:        if isinstance(node, Leaf):
1425:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1426:            for comment in generate_comments(node):
1427:                if any_open_brackets:
1428:                    # any comment within brackets is subject to splitting
1429:                    self.current_line.append(comment)
1430:                elif comment.type == token.COMMENT:
1431:                    # regular trailing comment
1432:                    self.current_line.append(comment)
1433:                    yield from self.line()
1434:
1435:                else:
1436:                    # regular standalone comment
1437:                    yield from self.line()
1438:
1439:                    self.current_line.append(comment)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1440:                    yield from self.line()
1441:
1442:            normalize_prefix(node, inside_brackets=any_open_brackets)
1443:            if self.normalize_strings and node.type == token.STRING:
1444:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1445:                normalize_string_quotes(node)
1446:            if node.type not in WHITESPACE:
1447:                self.current_line.append(node)
1448:        yield from super().visit_default(node)
1449:
1450:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1451:        """Increase indentation level, maybe yield a line."""
1452:        # In blib2to3 INDENT never holds comments.
1453:        yield from self.line(+1)
1454:        yield from self.visit_default(node)
1455:
1456:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1457:        """Decrease indentation level, maybe yield a line."""
1458:        # The current line might still wait for trailing comments.  At DEDENT time
1459:        # there won't be any (they would be prefixes on the preceding NEWLINE).
1460:        # Emit the line then.
1461:        yield from self.line()
1462:
1463:        # While DEDENT has no value, its prefix may contain standalone comments
1464:        # that belong to the current indentation level.  Get 'em.
1465:        yield from self.visit_default(node)
1466:
1467:        # Finally, emit the dedent.
1468:        yield from self.line(-1)
1469:
1470:    def visit_stmt(
1471:        self, node: Node, keywords: Set[str], parens: Set[str]
1472:    ) -> Iterator[Line]:
1473:        """Visit a statement.
1474:
1475:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1476:        `def`, `with`, `class`, `assert` and assignments.
1477:
1478:        The relevant Python language `keywords` for a given statement will be
1479:        NAME leaves within it. This methods puts those on a separate line.
1480:
1481:        `parens` holds a set of string leaf values immediately after which
1482:        invisible parens should be put.
1483:        """
1484:        normalize_invisible_parens(node, parens_after=parens)
1485:        for child in node.children:
1486:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1487:                yield from self.line()
1488:
1489:            yield from self.visit(child)
1490:
1491:    def visit_suite(self, node: Node) -> Iterator[Line]:
1492:        """Visit a suite."""
1493:        if self.is_pyi and is_stub_suite(node):
1494:            yield from self.visit(node.children[2])
1495:        else:
1496:            yield from self.visit_default(node)
1497:
1498:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1499:        """Visit a statement without nested statements."""
1500:        is_suite_like = node.parent and node.parent.type in STATEMENT
1501:        if is_suite_like:
1502:            if self.is_pyi and is_stub_body(node):
1503:                yield from self.visit_default(node)
1504:            else:
1505:                yield from self.line(+1)
1506:                yield from self.visit_default(node)
1507:                yield from self.line(-1)
1508:
1509:        else:
1510:            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):
1511:                yield from self.line()
1512:            yield from self.visit_default(node)
1513:
1514:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:
1515:        """Visit `async def`, `async for`, `async with`."""
1516:        yield from self.line()
1517:
1518:        children = iter(node.children)
1519:        for child in children:
1520:            yield from self.visit(child)
1521:
1522:            if child.type == token.ASYNC:
1523:                break
1524:
1525:        internal_stmt = next(children)
1526:        for child in internal_stmt.children:
1527:            yield from self.visit(child)
1528:
1529:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1530:        """Visit decorators."""
1531:        for child in node.children:
1532:            yield from self.line()
1533:            yield from self.visit(child)
1534:
1535:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1536:        """Remove a semicolon and put the other statement on a separate line."""
1537:        yield from self.line()
1538:
1539:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1540:        """End of file. Process outstanding comments and end with a newline."""
1541:        yield from self.visit_default(leaf)
1542:        yield from self.line()
1543:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1545:        if not self.current_line.bracket_tracker.any_open_brackets():
1546:            yield from self.line()
1547:        yield from self.visit_default(leaf)
1548:
1549:    def __attrs_post_init__(self) -> None:
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1558:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1559:        self.visit_try_stmt = partial(

Calling tool: grepTool
def is_comment|@property\s+def is_comment|is_comment\b
Matched content:
1038:            if self.is_comment:
1049:    def is_comment(self) -> bool:
1366:            self.previous_line.is_comment
2064:    if line.is_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1000:    inside_brackets: bool = False
1001:    should_explode: bool = False
1002:
1003:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1004:        """Add a new `leaf` to the end of the line.
1005:
1006:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1007:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1008:        Trailing commas are maybe removed, unpacked for loop variables are
1009:        demoted from being delimiters.
1010:
1011:        Inline comments are put aside.
1012:        """
1013:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1014:        if not has_value:
1015:            return
1016:
1017:        if token.COLON == leaf.type and self.is_class_paren_empty:
1018:            del self.leaves[-2:]
1019:        if self.leaves and not preformatted:
1020:            # Note: at this point leaf.prefix should be empty except for
1021:            # imports, for which we only preserve newlines.
1022:            leaf.prefix += whitespace(
1023:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1024:            )
1025:        if self.inside_brackets or not preformatted:
1026:            self.bracket_tracker.mark(leaf)
1027:            self.maybe_remove_trailing_comma(leaf)
1028:        if not self.append_comment(leaf):
1029:            self.leaves.append(leaf)
1030:
1031:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1032:        """Like :func:`append()` but disallow invalid standalone comment structure.
1033:
1034:        Raises ValueError when any `leaf` is appended after a standalone comment
1035:        or when a standalone comment is not the first leaf on the line.
1036:        """
1037:        if self.bracket_tracker.depth == 0:
1038:            if self.is_comment:
1039:                raise ValueError("cannot append to standalone comments")
1040:
1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1042:                raise ValueError(
1043:                    "cannot append standalone comments to a populated line"
1044:                )
1045:
1046:        self.append(leaf, preformatted=preformatted)
1047:
1048:    @property
1049:    def is_comment(self) -> bool:
1050:        """Is this line a standalone comment?"""
1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1052:
1053:    @property
1054:    def is_decorator(self) -> bool:
1055:        """Is this line a decorator?"""
1056:        return bool(self) and self.leaves[0].type == token.AT
1057:
1058:    @property
1059:    def is_import(self) -> bool:
1060:        """Is this an import line?"""
1061:        return bool(self) and is_import(self.leaves[0])
1062:
1063:    @property
1064:    def is_class(self) -> bool:
1065:        """Is this line a class definition?"""
1066:        return (
1067:            bool(self)
1068:            and self.leaves[0].type == token.NAME
1069:            and self.leaves[0].value == "class"
1070:        )
1071:
1072:    @property
1073:    def is_stub_class(self) -> bool:
1074:        """Is this line a class definition with a body consisting only of "..."?"""
1075:        return self.is_class and self.leaves[-3:] == [
1076:            Leaf(token.DOT, ".") for _ in range(3)
1077:        ]
1078:
1079:    @property

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, EmptyLineTracker._maybe_empty_lines_for_class_or_def() contains a condition (lines ~1365-1371) that returns (0, 0) when the previous line is a standalone comment at the same depth and before == 0, satisfying the requirement to avoid extra blank lines between functions after a STANDALONE_COMMENT block.


Todo item 16 of 18 is correct
description: 'Verify EmptyLineTracker._maybe_empty_lines_for_class_or_def() has logic to avoid adding blank lines when previous_line.is_comment, at the same depth, and 'before' is 0; this should prevent extra lines between functions following a STANDALONE_COMMENT block.'
Validating todo item 17 of 18
description: 'Confirm that container_of() includes an early break when parent.type == syms.file_input to prevent fmt: off conversion from spanning the entire file and crossing module-level boundaries.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def container_of\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
def container_of\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1837:def container_of(leaf: Leaf) -> LN:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1957:def container_of(leaf: Leaf) -> LN:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1820:                return list(res.leaves())[-1]
1821:
1822:            except IndexError:
1823:                return None
1824:
1825:        node = node.parent
1826:    return None
1827:
1828:
1829:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
1830:    """Return the child of `ancestor` that contains `descendant`."""
1831:    node: Optional[LN] = descendant
1832:    while node and node.parent != ancestor:
1833:        node = node.parent
1834:    return node
1835:
1836:
1837:def container_of(leaf: Leaf) -> LN:
1838:    """Return `leaf` or one of its ancestors that is the topmost container of it.
1839:
1840:    By "container" we mean a node where `leaf` is the very first child.
1841:    """
1842:    same_prefix = leaf.prefix
1843:    container: LN = leaf
1844:    while container:
1845:        parent = container.parent
1846:        if parent is None:
1847:            break
1848:
1849:        if parent.children[0].prefix != same_prefix:
1850:            break
1851:
1852:        if parent.type == syms.file_input:
1853:            break
1854:
1855:        if parent.type in SURROUNDED_BY_BRACKETS:
1856:            break
1857:
1858:        container = parent
1859:    return container
1860:
1861:
1862:def is_split_after_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1863:    """Return the priority of the `leaf` delimiter, given a line break after it.
1864:
1865:    The delimiter priorities returned here are from those delimiters that would
1866:    cause a line break after themselves.
1867:
1868:    Higher numbers are higher priority.
1869:    """
1870:    if leaf.type == token.COMMA:
1871:        return COMMA_PRIORITY
1872:
1873:    return 0
1874:
1875:
1876:def is_split_before_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1877:    """Return the priority of the `leaf` delimiter, given a line before after it.
1878:
1879:    The delimiter priorities returned here are from those delimiters that would
1880:    cause a line break before themselves.
1881:
1882:    Higher numbers are higher priority.
1883:    """
1884:    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):
1885:        # * and ** might also be MATH_OPERATORS but in this case they are not.
1886:        # Don't treat them as a delimiter.
1887:        return 0
1888:
1889:    if (
1890:        leaf.type == token.DOT
1891:        and leaf.parent
1892:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
1893:        and (previous is None or previous.type in CLOSING_BRACKETS)
1894:    ):
1895:        return DOT_PRIORITY
1896:
1897:    if (
1898:        leaf.type in MATH_OPERATORS
1899:        and leaf.parent

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py, function container_of() includes an early break for parent.type == syms.file_input (lines ~1852-1854), ensuring fmt: off conversion does not cross the module-level boundary.


Todo item 17 of 18 is correct
description: 'Confirm that container_of() includes an early break when parent.type == syms.file_input to prevent fmt: off conversion from spanning the entire file and crossing module-level boundaries.'
Validating todo item 18 of 18
description: 'Optionally spot-check that DebugVisitor.show() accepts Union[str, Leaf, Node] and handles Node/Leaf by not reparsing, consistent with updated signature (non-critical to fmt off behavior but part of diff).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class DebugVisitor",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "LN\\s*=\\s*Union\\[", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def lib2to3_parse\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black"
]
Calling tool: grepTool
class DebugVisitor
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:709:class DebugVisitor(Visitor[T]):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:738:class DebugVisitor(Visitor[T]):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/debug_visitor.py:2:class DebugVisitor(Visitor[T]):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/data/debug_visitor.py:2:class DebugVisitor(Visitor[T]):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
700:
701:    def visit_default(self, node: LN) -> Iterator[T]:
702:        """Default `visit_*()` implementation. Recurses to children of `node`."""
703:        if isinstance(node, Node):
704:            for child in node.children:
705:                yield from self.visit(child)
706:
707:
708:@dataclass
709:class DebugVisitor(Visitor[T]):
710:    tree_depth: int = 0
711:
712:    def visit_default(self, node: LN) -> Iterator[T]:
713:        indent = " " * (2 * self.tree_depth)
714:        if isinstance(node, Node):
715:            _type = type_repr(node.type)
716:            out(f"{indent}{_type}", fg="yellow")
717:            self.tree_depth += 1
718:            for child in node.children:
719:                yield from self.visit(child)
720:
721:            self.tree_depth -= 1
722:            out(f"{indent}/{_type}", fg="yellow", bold=False)
723:        else:
724:            _type = token.tok_name.get(node.type, str(node.type))
725:            out(f"{indent}{_type}", fg="blue", nl=False)
726:            if node.prefix:
727:                # We don't have to handle prefixes for `Node` objects since
728:                # that delegates to the first child anyway.
729:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
730:            out(f" {node.value!r}", fg="blue", bold=False)
731:
732:    @classmethod
733:    def show(cls, code: Union[str, Leaf, Node]) -> None:
734:        """Pretty-print the lib2to3 AST of a given string of `code`.
735:
736:        Convenience method for debugging.
737:        """
738:        v: DebugVisitor[None] = DebugVisitor()
739:        if isinstance(code, str):
740:            code = lib2to3_parse(code)
741:        list(v.visit(code))
742:
743:
744:KEYWORDS = set(keyword.kwlist)
745:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
746:FLOW_CONTROL = {"return", "raise", "break", "continue"}
747:STATEMENT = {
748:    syms.if_stmt,
749:    syms.while_stmt,
750:    syms.for_stmt,
751:    syms.try_stmt,
752:    syms.except_clause,
753:    syms.with_stmt,
754:    syms.funcdef,
755:    syms.classdef,
756:}
757:STANDALONE_COMMENT = 153
758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
759:LOGIC_OPERATORS = {"and", "or"}
760:COMPARATORS = {
761:    token.LESS,
762:    token.GREATER,
763:    token.EQEQUAL,
764:    token.NOTEQUAL,
765:    token.LESSEQUAL,
766:    token.GREATEREQUAL,
767:}
768:MATH_OPERATORS = {
769:    token.VBAR,
770:    token.CIRCUMFLEX,
771:    token.AMPER,
772:    token.LEFTSHIFT,
773:    token.RIGHTSHIFT,
774:    token.PLUS,
775:    token.MINUS,
776:    token.STAR,
777:    token.SLASH,
778:    token.DOUBLESLASH,
779:    token.PERCENT,

Calling tool: grepTool
LN\s*=\s*Union\[
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:67:LN = Union[Leaf, Node]
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:68:LN = Union[Leaf, Node]

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generic,
24:    Iterable,
25:    Iterator,
26:    List,
27:    Optional,
28:    Pattern,
29:    Sequence,
30:    Set,
31:    Tuple,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:import toml
41:
42:# lib2to3 fork
43:from blib2to3.pytree import Node, Leaf, type_repr
44:from blib2to3 import pygram, pytree
45:from blib2to3.pgen2 import driver, token
46:from blib2to3.pgen2.parse import ParseError
47:
48:
49:__version__ = "18.6b2"
50:DEFAULT_LINE_LENGTH = 88
51:DEFAULT_EXCLUDES = (
52:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
53:)
54:DEFAULT_INCLUDES = r"\.pyi?$"
55:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
56:
57:
58:# types
59:FileContent = str
60:Encoding = str
61:NewLine = str
62:Depth = int
63:NodeType = int
64:LeafID = int
65:Priority = int
66:Index = int
67:LN = Union[Leaf, Node]
68:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
69:Timestamp = float
70:FileSize = int
71:CacheInfo = Tuple[Timestamp, FileSize]
72:Cache = Dict[Path, CacheInfo]
73:out = partial(click.secho, bold=True, err=True)
74:err = partial(click.secho, fg="red", err=True)
75:
76:pygram.initialize(CACHE_DIR)
77:syms = pygram.python_symbols
78:
79:
80:class NothingChanged(UserWarning):
81:    """Raised by :func:`format_file` when reformatted code is the same as source."""
82:
83:
84:class CannotSplit(Exception):
85:    """A readable split that fits the allotted line length is impossible.
86:
87:    Raised by :func:`left_hand_split`, :func:`right_hand_split`, and
88:    :func:`delimiter_split`.
89:    """
90:
91:
92:class WriteBack(Enum):
93:    NO = 0
94:    YES = 1
95:    DIFF = 2
96:
97:    @classmethod
98:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
99:        if check and not diff:
100:            return cls.NO
101:
102:        return cls.DIFF if diff else cls.YES
103:
104:
105:class Changed(Enum):
106:    NO = 0
107:    CACHED = 1
108:    YES = 2
109:
110:
111:class FileMode(Flag):
112:    AUTO_DETECT = 0
113:    PYTHON36 = 1
114:    PYI = 2
115:    NO_STRING_NORMALIZATION = 4
116:
117:    @classmethod
118:    def from_configuration(
119:        cls, *, py36: bool, pyi: bool, skip_string_normalization: bool
120:    ) -> "FileMode":

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
730:    def visit_default(self, node: LN) -> Iterator[T]:
731:        """Default `visit_*()` implementation. Recurses to children of `node`."""
732:        if isinstance(node, Node):
733:            for child in node.children:
734:                yield from self.visit(child)
735:
736:
737:@dataclass
738:class DebugVisitor(Visitor[T]):
739:    tree_depth: int = 0
740:
741:    def visit_default(self, node: LN) -> Iterator[T]:
742:        indent = " " * (2 * self.tree_depth)
743:        if isinstance(node, Node):
744:            _type = type_repr(node.type)
745:            out(f"{indent}{_type}", fg="yellow")
746:            self.tree_depth += 1
747:            for child in node.children:
748:                yield from self.visit(child)
749:
750:            self.tree_depth -= 1
751:            out(f"{indent}/{_type}", fg="yellow", bold=False)
752:        else:
753:            _type = token.tok_name.get(node.type, str(node.type))
754:            out(f"{indent}{_type}", fg="blue", nl=False)
755:            if node.prefix:
756:                # We don't have to handle prefixes for `Node` objects since
757:                # that delegates to the first child anyway.
758:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
759:            out(f" {node.value!r}", fg="blue", bold=False)
760:
761:    @classmethod
762:    def show(cls, code: str) -> None:
763:        """Pretty-print the lib2to3 AST of a given string of `code`.
764:
765:        Convenience method for debugging.
766:        """
767:        v: DebugVisitor[None] = DebugVisitor()
768:        list(v.visit(lib2to3_parse(code)))
769:
770:
771:KEYWORDS = set(keyword.kwlist)
772:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
773:FLOW_CONTROL = {"return", "raise", "break", "continue"}
774:STATEMENT = {
775:    syms.if_stmt,
776:    syms.while_stmt,
777:    syms.for_stmt,
778:    syms.try_stmt,
779:    syms.except_clause,
780:    syms.with_stmt,
781:    syms.funcdef,
782:    syms.classdef,
783:}
784:STANDALONE_COMMENT = 153
785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
786:LOGIC_OPERATORS = {"and", "or"}
787:COMPARATORS = {
788:    token.LESS,
789:    token.GREATER,
790:    token.EQEQUAL,
791:    token.NOTEQUAL,
792:    token.LESSEQUAL,
793:    token.GREATEREQUAL,
794:}
795:MATH_OPERATORS = {
796:    token.VBAR,
797:    token.CIRCUMFLEX,
798:    token.AMPER,
799:    token.LEFTSHIFT,
800:    token.RIGHTSHIFT,
801:    token.PLUS,
802:    token.MINUS,
803:    token.STAR,
804:    token.SLASH,
805:    token.DOUBLESLASH,
806:    token.PERCENT,
807:    token.AT,
808:    token.TILDE,
809:    token.DOUBLESTAR,

Calling tool: grepTool
def lib2to3_parse\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:646:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:675:def lib2to3_parse(src_txt: str) -> Node:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
640:    pygram.python_grammar_no_print_statement_no_exec_statement,
641:    pygram.python_grammar_no_print_statement,
642:    pygram.python_grammar,
643:]
644:
645:
646:def lib2to3_parse(src_txt: str) -> Node:
647:    """Given a string with source, return the lib2to3 Node."""
648:    grammar = pygram.python_grammar_no_print_statement
649:    if src_txt[-1:] != "\n":
650:        src_txt += "\n"
651:    for grammar in GRAMMARS:
652:        drv = driver.Driver(grammar, pytree.convert)
653:        try:
654:            result = drv.parse_string(src_txt, True)
655:            break
656:
657:        except ParseError as pe:
658:            lineno, column = pe.context[1]
659:            lines = src_txt.splitlines()

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py, DebugVisitor.show signature is updated to Union[str, Leaf, Node] and only calls lib2to3_parse if code is str; for Node/Leaf it passes directly to visit(), thus avoiding reparsing.


Todo item 18 of 18 is correct
description: 'Optionally spot-check that DebugVisitor.show() accepts Union[str, Leaf, Node] and handles Node/Leaf by not reparsing, consistent with updated signature (non-critical to fmt off behavior but part of diff).'
Validating todo item 1 of 18
description: 'Verify tests/data/fmtonoff2.py contains a # fmt: off block spanning multiple top-level defs and a list of tuples, and that tests/test_black.py::test_fmtonoff2 uses read_data("fmtonoff2") then asserts self.assertFormatEqual(source, actual) so expected equals input (no # output marker).'

Calling tool: grepTool
fmtonoff2
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_fmtonoff2
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/bugsinpy_bug.info:4:test_file="tests/data/fmtonoff2.py;tests/test_black.py"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_fmtonoff2
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py:404:    def test_fmtonoff2(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py:405:        source, expected = read_data("fmtonoff2")

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py
380:    @patch("black.dump_to_file", dump_to_stderr)
381:    def test_python2_unicode_literals(self) -> None:
382:        source, expected = read_data("python2_unicode_literals")
383:        actual = fs(source)
384:        self.assertFormatEqual(expected, actual)
385:        black.assert_stable(source, actual, line_length=ll)
386:
387:    @patch("black.dump_to_file", dump_to_stderr)
388:    def test_stub(self) -> None:
389:        mode = black.FileMode.PYI
390:        source, expected = read_data("stub.pyi")
391:        actual = fs(source, mode=mode)
392:        self.assertFormatEqual(expected, actual)
393:        black.assert_stable(source, actual, line_length=ll, mode=mode)
394:
395:    @patch("black.dump_to_file", dump_to_stderr)
396:    def test_fmtonoff(self) -> None:
397:        source, expected = read_data("fmtonoff")
398:        actual = fs(source)
399:        self.assertFormatEqual(expected, actual)
400:        black.assert_equivalent(source, actual)
401:        black.assert_stable(source, actual, line_length=ll)
402:
403:    @patch("black.dump_to_file", dump_to_stderr)
404:    def test_fmtonoff2(self) -> None:
405:        source, expected = read_data("fmtonoff2")
406:        actual = fs(source)
407:        self.assertFormatEqual(expected, actual)
408:        black.assert_equivalent(source, actual)
409:        black.assert_stable(source, actual, line_length=ll)
410:
411:    @patch("black.dump_to_file", dump_to_stderr)
412:    def test_remove_empty_parentheses_after_class(self) -> None:
413:        source, expected = read_data("class_blank_parentheses")
414:        actual = fs(source)
415:        self.assertFormatEqual(expected, actual)
416:        black.assert_equivalent(source, actual)
417:        black.assert_stable(source, actual, line_length=ll)
418:
419:    @patch("black.dump_to_file", dump_to_stderr)
420:    def test_new_line_between_class_and_code(self) -> None:
421:        source, expected = read_data("class_methods_new_line")
422:        actual = fs(source)
423:        self.assertFormatEqual(expected, actual)
424:        black.assert_equivalent(source, actual)
425:        black.assert_stable(source, actual, line_length=ll)
426:
427:    def test_report_verbose(self) -> None:
428:        report = black.Report(verbose=True)
429:        out_lines = []
430:        err_lines = []
431:
432:        def out(msg: str, **kwargs: Any) -> None:
433:            out_lines.append(msg)
434:
435:        def err(msg: str, **kwargs: Any) -> None:
436:            err_lines.append(msg)
437:
438:        with patch("black.out", out), patch("black.err", err):
439:            report.done(Path("f1"), black.Changed.NO)
440:            self.assertEqual(len(out_lines), 1)
441:            self.assertEqual(len(err_lines), 0)
442:            self.assertEqual(out_lines[-1], "f1 already well formatted, good job.")
443:            self.assertEqual(unstyle(str(report)), "1 file left unchanged.")
444:            self.assertEqual(report.return_code, 0)
445:            report.done(Path("f2"), black.Changed.YES)
446:            self.assertEqual(len(out_lines), 2)
447:            self.assertEqual(len(err_lines), 0)
448:            self.assertEqual(out_lines[-1], "reformatted f2")
449:            self.assertEqual(
450:                unstyle(str(report)), "1 file reformatted, 1 file left unchanged."
451:            )
452:            report.done(Path("f3"), black.Changed.CACHED)
453:            self.assertEqual(len(out_lines), 3)
454:            self.assertEqual(len(err_lines), 0)
455:            self.assertEqual(
456:                out_lines[-1], "f3 wasn't modified on disk since last run."
457:            )
458:            self.assertEqual(
459:                unstyle(str(report)), "1 file reformatted, 2 files left unchanged."

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py:34:def read_data(name: str, data: bool = True) -> Tuple[str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import re
10:import sys
11:from tempfile import TemporaryDirectory
12:from typing import Any, BinaryIO, Generator, List, Tuple, Iterator
13:import unittest
14:from unittest.mock import patch, MagicMock
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:
22:ll = 88
23:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
24:fs = partial(black.format_str, line_length=ll)
25:THIS_FILE = Path(__file__)
26:THIS_DIR = THIS_FILE.parent
27:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
28:
29:
30:def dump_to_stderr(*output: str) -> str:
31:    return "\n" + "\n".join(output) + "\n"
32:
33:
34:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
35:    """read_data('test_name') -> 'input', 'output'"""
36:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
37:        name += ".py"
38:    _input: List[str] = []
39:    _output: List[str] = []
40:    base_dir = THIS_DIR / "data" if data else THIS_DIR
41:    with open(base_dir / name, "r", encoding="utf8") as test:
42:        lines = test.readlines()
43:    result = _input
44:    for line in lines:
45:        line = line.replace(EMPTY_LINE, "")
46:        if line.rstrip() == "# output":
47:            result = _output
48:            continue
49:
50:        result.append(line)
51:    if _input and not _output:
52:        # If there's no output marker, treat the entire file as already pre-formatted.
53:        _output = _input[:]
54:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
55:
56:
57:@contextmanager
58:def cache_dir(exists: bool = True) -> Iterator[Path]:
59:    with TemporaryDirectory() as workspace:
60:        cache_dir = Path(workspace)
61:        if not exists:
62:            cache_dir = cache_dir / "new"
63:        with patch("black.CACHE_DIR", cache_dir):
64:            yield cache_dir
65:
66:
67:@contextmanager
68:def event_loop(close: bool) -> Iterator[None]:
69:    policy = asyncio.get_event_loop_policy()
70:    old_loop = policy.get_event_loop()
71:    loop = policy.new_event_loop()
72:    asyncio.set_event_loop(loop)
73:    try:
74:        yield
75:
76:    finally:
77:        policy.set_event_loop(old_loop)
78:        if close:
79:            loop.close()
80:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/fmtonoff2.py
1:import pytest
2:
3:TmSt = 1
4:TmEx = 2
5:
6:# fmt: off
7:
8:# Test data:
9:#   Position, Volume, State, TmSt/TmEx/None, [call, [arg1...]]
10:
11:@pytest.mark.parametrize('test', [
12:
13:    # Test don't manage the volume
14:    [
15:        ('stuff', 'in')
16:    ],
17:])
18:def test_fader(test):
19:    pass
20:
21:def check_fader(test):
22:    pass
23:
24:def test_calculate_fades():
25:    calcs = [
26:        # one is zero/none
27:        (0, 4, 0, 0, 10,        0, 0, 6, 10),
28:        (None, 4, 0, 0, 10,     0, 0, 6, 10),
29:    ]
30:
31:# fmt: on

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: tests/data/fmtonoff2.py includes a # fmt: off block that spans multiple top-level defs and a list of tuples (lines 631). tests/test_black.py::test_fmtonoff2 calls read_data("fmtonoff2") and asserts self.assertFormatEqual(expected, actual); read_data returns expected == source when no '# output' marker is present (lines 5154), satisfying the requirement that expected equals input.

Todo item 1 of 18 is correct
description: 'Verify tests/data/fmtonoff2.py contains a # fmt: off block spanning multiple top-level defs and a list of tuples, and that tests/test_black.py::test_fmtonoff2 uses read_data("fmtonoff2") then asserts self.assertFormatEqual(source, actual) so expected equals input (no # output marker).'

Validating todo item 2 of 18
description: 'In black.py format_str(), confirm normalize_fmt_off(src_node) is called before LineGenerator is constructed and used.'

Calling tool: grepTool
def format_str\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:618:def format_str(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:589:def format_str(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
560:        f.detach()
561:
562:
563:def format_file_contents(
564:    src_contents: str,
565:    *,
566:    line_length: int,
567:    fast: bool,
568:    mode: FileMode = FileMode.AUTO_DETECT,
569:) -> FileContent:
570:    """Reformat contents a file and return new contents.
571:
572:    If `fast` is False, additionally confirm that the reformatted code is
573:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
574:    `line_length` is passed to :func:`format_str`.
575:    """
576:    if src_contents.strip() == "":
577:        raise NothingChanged
578:
579:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
580:    if src_contents == dst_contents:
581:        raise NothingChanged
582:
583:    if not fast:
584:        assert_equivalent(src_contents, dst_contents)
585:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
586:    return dst_contents
587:
588:
589:def format_str(
590:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
591:) -> FileContent:
592:    """Reformat a string and return new contents.
593:
594:    `line_length` determines how many characters per line are allowed.
595:    """
596:    src_node = lib2to3_parse(src_contents)
597:    dst_contents = ""
598:    future_imports = get_future_imports(src_node)
599:    is_pyi = bool(mode & FileMode.PYI)
600:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
601:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
602:    normalize_fmt_off(src_node)
603:    lines = LineGenerator(
604:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
605:        is_pyi=is_pyi,
606:        normalize_strings=normalize_strings,
607:    )
608:    elt = EmptyLineTracker(is_pyi=is_pyi)
609:    empty_line = Line()
610:    after = 0
611:    for current_line in lines.visit(src_node):
612:        for _ in range(after):
613:            dst_contents += str(empty_line)
614:        before, after = elt.maybe_empty_lines(current_line)
615:        for _ in range(before):
616:            dst_contents += str(empty_line)
617:        for line in split_line(current_line, line_length=line_length, py36=py36):
618:            dst_contents += str(line)
619:    return dst_contents
620:
621:
622:def decode_bytes(src: bytes) -> Tuple[FileContent, Encoding, NewLine]:
623:    """Return a tuple of (decoded_contents, encoding, newline).
624:
625:    `newline` is either CRLF or LF but `decoded_contents` is decoded with
626:    universal newlines (i.e. only contains LF).
627:    """
628:    srcbuf = io.BytesIO(src)
629:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
630:    if not lines:
631:        return "", encoding, "\n"
632:
633:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
634:    srcbuf.seek(0)
635:    with io.TextIOWrapper(srcbuf, encoding) as tiow:
636:        return tiow.read(), encoding, newline
637:
638:
639:GRAMMARS = [
640:    pygram.python_grammar_no_print_statement_no_exec_statement,
641:    pygram.python_grammar_no_print_statement,
642:    pygram.python_grammar,
643:]
644:
645:
646:def lib2to3_parse(src_txt: str) -> Node:
647:    """Given a string with source, return the lib2to3 Node."""
648:    grammar = pygram.python_grammar_no_print_statement
649:    if src_txt[-1:] != "\n":
650:        src_txt += "\n"
651:    for grammar in GRAMMARS:
652:        drv = driver.Driver(grammar, pytree.convert)
653:        try:
654:            result = drv.parse_string(src_txt, True)
655:            break
656:
657:        except ParseError as pe:
658:            lineno, column = pe.context[1]
659:            lines = src_txt.splitlines()
660:            try:
661:                faulty_line = lines[lineno - 1]
662:            except IndexError:
663:                faulty_line = "<line number missing in source>"
664:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
665:    else:
666:        raise exc from None
667:
668:    if isinstance(result, Leaf):
669:        result = Node(syms.file_input, [result])
670:    return result
671:
672:
673:def lib2to3_unparse(node: Node) -> str:
674:    """Given a lib2to3 node, return its string representation."""
675:    code = str(node)
676:    return code
677:
678:
679:T = TypeVar("T")
680:
681:
682:class Visitor(Generic[T]):
683:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
684:
685:    def visit(self, node: LN) -> Iterator[T]:
686:        """Main method to visit `node` and its children.
687:
688:        It tries to find a `visit_*()` method for the given `node.type`, like
689:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
690:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
691:        instead.
692:
693:        Then yields objects of type `T` from the selected visitor.
694:        """
695:        if node.type < 256:
696:            name = token.tok_name[node.type]
697:        else:
698:            name = type_repr(node.type)
699:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)

Calling tool: grepTool
normalize_fmt_off\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:602:    normalize_fmt_off(src_node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2555:def normalize_fmt_off(node: Node) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:631:    normalize_fmt_off(src_node)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2682:def normalize_fmt_off(node: Node) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
610:        raise NothingChanged
611:
612:    if not fast:
613:        assert_equivalent(src_contents, dst_contents)
614:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
615:    return dst_contents
616:
617:
618:def format_str(
619:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
620:) -> FileContent:
621:    """Reformat a string and return new contents.
622:
623:    `line_length` determines how many characters per line are allowed.
624:    """
625:    src_node = lib2to3_parse(src_contents)
626:    dst_contents = ""
627:    future_imports = get_future_imports(src_node)
628:    is_pyi = bool(mode & FileMode.PYI)
629:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
630:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
631:    normalize_fmt_off(src_node)
632:    lines = LineGenerator(
633:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
634:        is_pyi=is_pyi,
635:        normalize_strings=normalize_strings,
636:    )
637:    elt = EmptyLineTracker(is_pyi=is_pyi)
638:    empty_line = Line()
639:    after = 0
640:    for current_line in lines.visit(src_node):
641:        for _ in range(after):
642:            dst_contents += str(empty_line)
643:        before, after = elt.maybe_empty_lines(current_line)
644:        for _ in range(before):
645:            dst_contents += str(empty_line)
646:        for line in split_line(current_line, line_length=line_length, py36=py36):
647:            dst_contents += str(line)
648:    return dst_contents
649:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pys format_str(), normalize_fmt_off(src_node) is invoked (line ~602) before constructing LineGenerator (line ~603) and before iterating lines.visit(src_node) (line ~611). Verified by reading the actual implementation.

Todo item 2 of 18 is correct
description: 'In black.py format_str(), confirm normalize_fmt_off(src_node) is called before LineGenerator is constructed and used.'

Validating todo item 3 of 18
description: 'Confirm class-based exception handling for fmt on/off is removed: no classes FormatError/FormatOn/FormatOff are defined in black.py and no references remain to them or UnformattedLines.'

Calling tool: grepTool
(?i)class\s+Format(Error|On|Off)\b|\bFormat(Error|On|Off)\b|\bUnformattedLines\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_exceptions.rst:10:.. autoexception:: black.FormatError
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_exceptions.rst:12:.. autoexception:: black.FormatOn
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_exceptions.rst:14:.. autoexception:: black.FormatOff
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_classes.rst:41::class:`UnformattedLines`
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/docs/reference/reference_classes.rst:44:.. autoclass:: black.UnformattedLines
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_exceptions.rst:10:.. autoexception:: black.FormatError
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_exceptions.rst:12:.. autoexception:: black.FormatOn
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_exceptions.rst:14:.. autoexception:: black.FormatOff
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:93:class FormatError(Exception):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:113:class FormatOn(FormatError):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:117:class FormatOff(FormatError):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1309:class UnformattedLines(Line):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1322:        except FormatOn as f_on:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1379:        if isinstance(current_line, UnformattedLines):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1509:        if isinstance(self.current_line, UnformattedLines):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1537:            except FormatOff as f_off:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1539:                yield from self.line(type=UnformattedLines)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1542:            except FormatOn as f_on:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1660:            except FormatOn as f_on:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2110:            raise FormatOn(pc.consumed)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2114:                raise FormatOff(pc.consumed)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2118:                raise FormatOff(pc.consumed)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2191:    if isinstance(line, UnformattedLines) or line.is_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_classes.rst:41::class:`UnformattedLines`
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/docs/reference/reference_classes.rst:44:.. autoclass:: black.UnformattedLines
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2and3/mailbox.pyi:199:class FormatError(Error): ...
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:76:from .exceptions import BufferFull, OutOfData, ExtraData, FormatError, StackError
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:116:    Raises ``FormatError`` when *packed* is not valid msgpack.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:270:    Raises ``FormatError`` when *packed* is not valid msgpack.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:540:            raise FormatError("Unknown header: 0x%x" % b)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/fallback.py:726:    Raises ``FormatError`` when *packed* is not valid msgpack.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/msgpack/exceptions.py:18:class FormatError(ValueError, UnpackException):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2and3/ctypes/__init__.pyi:151:    def FormatError(code: int) -> str: ...

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py

Calling tool: grepTool
(?i)Format(Error|On|Off)|UnformattedLines
No files found. Call grepTool again with a more generic pattern.

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generic,
24:    Iterable,
25:    Iterator,
26:    List,
27:    Optional,
28:    Pattern,
29:    Sequence,
30:    Set,
31:    Tuple,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:import toml
41:
42:# lib2to3 fork
43:from blib2to3.pytree import Node, Leaf, type_repr
44:from blib2to3 import pygram, pytree
45:from blib2to3.pgen2 import driver, token
46:from blib2to3.pgen2.parse import ParseError
47:
48:
49:__version__ = "18.6b2"
50:DEFAULT_LINE_LENGTH = 88
51:DEFAULT_EXCLUDES = (
52:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
53:)
54:DEFAULT_INCLUDES = r"\.pyi?$"
55:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
56:
57:
58:# types
59:FileContent = str
60:Encoding = str
61:NewLine = str
62:Depth = int
63:NodeType = int
64:LeafID = int
65:Priority = int
66:Index = int
67:LN = Union[Leaf, Node]
68:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
69:Timestamp = float
70:FileSize = int
71:CacheInfo = Tuple[Timestamp, FileSize]
72:Cache = Dict[Path, CacheInfo]
73:out = partial(click.secho, bold=True, err=True)
74:err = partial(click.secho, fg="red", err=True)
75:
76:pygram.initialize(CACHE_DIR)
77:syms = pygram.python_symbols
78:
79:
80:class NothingChanged(UserWarning):
81:    """Raised by :func:`format_file` when reformatted code is the same as source."""
82:
83:
84:class CannotSplit(Exception):
85:    """A readable split that fits the allotted line length is impossible.
86:
87:    Raised by :func:`left_hand_split`, :func:`right_hand_split`, and
88:    :func:`delimiter_split`.
89:    """
90:
91:
92:class WriteBack(Enum):
93:    NO = 0
94:    YES = 1
95:    DIFF = 2
96:
97:    @classmethod
98:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
99:        if check and not diff:
100:            return cls.NO
101:
102:        return cls.DIFF if diff else cls.YES
103:
104:
105:class Changed(Enum):
106:    NO = 0
107:    CACHED = 1
108:    YES = 2
109:
110:
111:class FileMode(Flag):
112:    AUTO_DETECT = 0
113:    PYTHON36 = 1
114:    PYI = 2
115:    NO_STRING_NORMALIZATION = 4
116:
117:    @classmethod
118:    def from_configuration(
119:        cls, *, py36: bool, pyi: bool, skip_string_normalization: bool
120:    ) -> "FileMode":
121:        mode = cls.AUTO_DETECT
122:        if py36:
123:            mode |= cls.PYTHON36
124:        if pyi:
125:            mode |= cls.PYI
126:        if skip_string_normalization:
127:            mode |= cls.NO_STRING_NORMALIZATION
128:        return mode
129:
130:
131:def read_pyproject_toml(
132:    ctx: click.Context, param: click.Parameter, value: Union[str, int, bool, None]
133:) -> Optional[str]:
134:    """Inject Black configuration from "pyproject.toml" into defaults in `ctx`.
135:
136:    Returns the path to a successfully found and read configuration file, None
137:    otherwise.
138:    """
139:    assert not isinstance(value, (int, bool)), "Invalid parameter type passed"
140:    if not value:
141:        root = find_project_root(ctx.params.get("src", ()))
142:        path = root / "pyproject.toml"
143:        if path.is_file():
144:            value = str(path)
145:        else:
146:            return None
147:
148:    try:
149:        pyproject_toml = toml.load(value)
150:        config = pyproject_toml.get("tool", {}).get("black", {})
151:    except (toml.TomlDecodeError, OSError) as e:
152:        raise click.BadOptionUsage(f"Error reading configuration file: {e}", ctx)
153:
154:    if not config:
155:        return None
156:
157:    if ctx.default_map is None:
158:        ctx.default_map = {}
159:    ctx.default_map.update(  # type: ignore  # bad types in .pyi
160:        {k.replace("--", "").replace("-", "_"): v for k, v in config.items()}
161:    )
162:    return value
163:
164:
165:@click.command(context_settings=dict(help_option_names=["-h", "--help"]))
166:@click.option(
167:    "-l",
168:    "--line-length",
169:    type=int,
170:    default=DEFAULT_LINE_LENGTH,
171:    help="How many character per line to allow.",
172:    show_default=True,
173:)
174:@click.option(
175:    "--py36",
176:    is_flag=True,
177:    help=(
178:        "Allow using Python 3.6-only syntax on all input files.  This will put "
179:        "trailing commas in function signatures and calls also after *args and "
180:        "**kwargs.  [default: per-file auto-detection]"

Calling tool: grepTool
def line\(
Matched content:
1406:    def line(self, indent: int = 0) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1390:        return newlines, 0
1391:
1392:
1393:@dataclass
1394:class LineGenerator(Visitor[Line]):
1395:    """Generates reformatted Line objects.  Empty lines are not emitted.
1396:
1397:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
1398:    in ways that will no longer stringify to valid Python code on the tree.
1399:    """
1400:
1401:    is_pyi: bool = False
1402:    normalize_strings: bool = True
1403:    current_line: Line = Factory(Line)
1404:    remove_u_prefix: bool = False
1405:
1406:    def line(self, indent: int = 0) -> Iterator[Line]:
1407:        """Generate a line.
1408:
1409:        If the line is empty, only emit if it makes sense.
1410:        If the line is too long, split it first and then generate.
1411:
1412:        If any lines were generated, set up a new current_line.
1413:        """
1414:        if not self.current_line:
1415:            self.current_line.depth += indent
1416:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1417:
1418:        complete_line = self.current_line
1419:        self.current_line = Line(depth=complete_line.depth + indent)
1420:        yield complete_line
1421:
1422:    def visit_default(self, node: LN) -> Iterator[Line]:
1423:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1424:        if isinstance(node, Leaf):
1425:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1426:            for comment in generate_comments(node):
1427:                if any_open_brackets:
1428:                    # any comment within brackets is subject to splitting
1429:                    self.current_line.append(comment)
1430:                elif comment.type == token.COMMENT:
1431:                    # regular trailing comment
1432:                    self.current_line.append(comment)
1433:                    yield from self.line()
1434:
1435:                else:
1436:                    # regular standalone comment
1437:                    yield from self.line()
1438:
1439:                    self.current_line.append(comment)
1440:                    yield from self.line()
1441:
1442:            normalize_prefix(node, inside_brackets=any_open_brackets)
1443:            if self.normalize_strings and node.type == token.STRING:
1444:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1445:                normalize_string_quotes(node)
1446:            if node.type not in WHITESPACE:
1447:                self.current_line.append(node)
1448:        yield from super().visit_default(node)
1449:

Calling tool: grepTool
def visit_STANDALONE_COMMENT
Matched content:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1538:
1539:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1540:        """End of file. Process outstanding comments and end with a newline."""
1541:        yield from self.visit_default(leaf)
1542:        yield from self.line()
1543:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1545:        if not self.current_line.bracket_tracker.any_open_brackets():
1546:            yield from self.line()
1547:        yield from self.visit_default(leaf)
1548:
1549:    def __attrs_post_init__(self) -> None:
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})

Calling tool: grepTool
def generate_comments\(
Matched content:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't
1985:    share the line with any code.
1986:
1987:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
1989:    """
1990:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
1991:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
1992:
1993:
1994:@dataclass
1995:class ProtoComment:
1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
1997:    value: str  # content of the comment
1998:    newlines: int  # how many newlines before the comment
1999:    consumed: int  # how many characters of the original leaf's prefix did we consume
2000:
2001:
2002:@lru_cache(maxsize=4096)
2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2004:    result: List[ProtoComment] = []
2005:    if not prefix or "#" not in prefix:

Calling tool: grepTool
def normalize_fmt_off\(
Matched content:
2555:def normalize_fmt_off(node: Node) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:

Calling tool: grepTool
def split_line\(
Matched content:
2051:def split_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2046:    if content and content[0] not in " !:#":
2047:        content = " " + content
2048:    return "#" + content
2049:
2050:
2051:def split_line(
2052:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2053:) -> Iterator[Line]:
2054:    """Split a `line` into potentially many lines.
2055:
2056:    They should fit in the allotted `line_length` but might not be able to.
2057:    `inner` signifies that there were a pair of brackets somewhere around the
2058:    current `line`, possibly transitively. This means we can fallback to splitting
2059:    by delimiters if the LHS/RHS don't yield any results.
2060:
2061:    If `py36` is True, splitting may generate syntax that is only compatible
2062:    with Python 3.6 and later.
2063:    """
2064:    if line.is_comment:
2065:        yield line
2066:        return
2067:
2068:    line_str = str(line).strip("\n")
2069:    if not line.should_explode and is_line_short_enough(
2070:        line, line_length=line_length, line_str=line_str
2071:    ):
2072:        yield line
2073:        return
2074:
2075:    split_funcs: List[SplitFunc]

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In the projects top-level black.py, the classes FormatError, FormatOn, FormatOff, and UnformattedLines are not defined and there are no remaining references to them. I verified by reading relevant sections (class removals and refactored methods) and confirming no occurrences via targeted searches; remaining matches are only in env/src copies and docs.

Todo item 3 of 18 is correct
description: 'Confirm class-based exception handling for fmt on/off is removed: no classes FormatError/FormatOn/FormatOff are defined in black.py and no references remain to them or UnformattedLines.'

Validating todo item 4 of 18
description: 'Confirm LineGenerator no longer supports UnformattedLines: method signature line(self, indent=0) has no type parameter; there is no visit_unformatted() method; and visit_default() contains no try/except for FormatOn/FormatOff.'

Calling tool: grepTool
class LineGenerator\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1394:class LineGenerator(Visitor[Line]):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1473:class LineGenerator(Visitor[Line]):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1380:                    newlines = 1
1381:            elif current_line.is_def and not self.previous_line.is_def:
1382:                # Blank line between a block of functions and a block of non-functions
1383:                newlines = 1
1384:            else:
1385:                newlines = 0
1386:        else:
1387:            newlines = 2
1388:        if current_line.depth and newlines:
1389:            newlines -= 1
1390:        return newlines, 0
1391:
1392:
1393:@dataclass
1394:class LineGenerator(Visitor[Line]):
1395:    """Generates reformatted Line objects.  Empty lines are not emitted.
1396:
1397:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
1398:    in ways that will no longer stringify to valid Python code on the tree.
1399:    """
1400:
1401:    is_pyi: bool = False
1402:    normalize_strings: bool = True
1403:    current_line: Line = Factory(Line)
1404:    remove_u_prefix: bool = False
1405:
1406:    def line(self, indent: int = 0) -> Iterator[Line]:
1407:        """Generate a line.
1408:
1409:        If the line is empty, only emit if it makes sense.
1410:        If the line is too long, split it first and then generate.
1411:
1412:        If any lines were generated, set up a new current_line.
1413:        """
1414:        if not self.current_line:
1415:            self.current_line.depth += indent
1416:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1417:
1418:        complete_line = self.current_line
1419:        self.current_line = Line(depth=complete_line.depth + indent)
1420:        yield complete_line
1421:
1422:    def visit_default(self, node: LN) -> Iterator[Line]:
1423:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1424:        if isinstance(node, Leaf):
1425:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1426:            for comment in generate_comments(node):
1427:                if any_open_brackets:
1428:                    # any comment within brackets is subject to splitting
1429:                    self.current_line.append(comment)
1430:                elif comment.type == token.COMMENT:
1431:                    # regular trailing comment
1432:                    self.current_line.append(comment)
1433:                    yield from self.line()
1434:
1435:                else:
1436:                    # regular standalone comment
1437:                    yield from self.line()
1438:
1439:                    self.current_line.append(comment)
1440:                    yield from self.line()
1441:
1442:            normalize_prefix(node, inside_brackets=any_open_brackets)
1443:            if self.normalize_strings and node.type == token.STRING:
1444:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1445:                normalize_string_quotes(node)
1446:            if node.type not in WHITESPACE:
1447:                self.current_line.append(node)
1448:        yield from super().visit_default(node)
1449:
1450:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1451:        """Increase indentation level, maybe yield a line."""
1452:        # In blib2to3 INDENT never holds comments.
1453:        yield from self.line(+1)
1454:        yield from self.visit_default(node)
1455:
1456:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1457:        """Decrease indentation level, maybe yield a line."""
1458:        # The current line might still wait for trailing comments.  At DEDENT time
1459:        # there won't be any (they would be prefixes on the preceding NEWLINE).
1460:        # Emit the line then.
1461:        yield from self.line()
1462:
1463:        # While DEDENT has no value, its prefix may contain standalone comments
1464:        # that belong to the current indentation level.  Get 'em.
1465:        yield from self.visit_default(node)
1466:
1467:        # Finally, emit the dedent.
1468:        yield from self.line(-1)
1469:
1470:    def visit_stmt(
1471:        self, node: Node, keywords: Set[str], parens: Set[str]
1472:    ) -> Iterator[Line]:
1473:        """Visit a statement.
1474:
1475:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1476:        `def`, `with`, `class`, `assert` and assignments.
1477:
1478:        The relevant Python language `keywords` for a given statement will be
1479:        NAME leaves within it. This methods puts those on a separate line.
1480:
1481:        `parens` holds a set of string leaf values immediately after which
1482:        invisible parens should be put.
1483:        """
1484:        normalize_invisible_parens(node, parens_after=parens)
1485:        for child in node.children:
1486:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1487:                yield from self.line()
1488:
1489:            yield from self.visit(child)
1490:
1491:    def visit_suite(self, node: Node) -> Iterator[Line]:
1492:        """Visit a suite."""
1493:        if self.is_pyi and is_stub_suite(node):
1494:            yield from self.visit(node.children[2])
1495:        else:
1496:            yield from self.visit_default(node)
1497:
1498:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1499:        """Visit a statement without nested statements."""

Calling tool: grepTool
def visit_unformatted\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
Format(On|Off)
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
def visit\(self, node: LN\)
Matched content:
685:    def visit(self, node: LN) -> Iterator[T]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
650:        src_txt += "\n"
651:    for grammar in GRAMMARS:
652:        drv = driver.Driver(grammar, pytree.convert)
653:        try:
654:            result = drv.parse_string(src_txt, True)
655:            break
656:
657:        except ParseError as pe:
658:            lineno, column = pe.context[1]
659:            lines = src_txt.splitlines()
660:            try:
661:                faulty_line = lines[lineno - 1]
662:            except IndexError:
663:                faulty_line = "<line number missing in source>"
664:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
665:    else:
666:        raise exc from None
667:
668:    if isinstance(result, Leaf):
669:        result = Node(syms.file_input, [result])
670:    return result
671:
672:
673:def lib2to3_unparse(node: Node) -> str:
674:    """Given a lib2to3 node, return its string representation."""
675:    code = str(node)
676:    return code
677:
678:
679:T = TypeVar("T")
680:
681:
682:class Visitor(Generic[T]):
683:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
684:
685:    def visit(self, node: LN) -> Iterator[T]:
686:        """Main method to visit `node` and its children.
687:
688:        It tries to find a `visit_*()` method for the given `node.type`, like
689:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
690:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
691:        instead.
692:
693:        Then yields objects of type `T` from the selected visitor.
694:        """
695:        if node.type < 256:
696:            name = token.tok_name[node.type]
697:        else:
698:            name = type_repr(node.type)
699:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
700:
701:    def visit_default(self, node: LN) -> Iterator[T]:
702:        """Default `visit_*()` implementation. Recurses to children of `node`."""
703:        if isinstance(node, Node):
704:            for child in node.children:
705:                yield from self.visit(child)
706:
707:
708:@dataclass
709:class DebugVisitor(Visitor[T]):
710:    tree_depth: int = 0
711:
712:    def visit_default(self, node: LN) -> Iterator[T]:
713:        indent = " " * (2 * self.tree_depth)
714:        if isinstance(node, Node):
715:            _type = type_repr(node.type)
716:            out(f"{indent}{_type}", fg="yellow")
717:            self.tree_depth += 1
718:            for child in node.children:
719:                yield from self.visit(child)
720:
721:            self.tree_depth -= 1
722:            out(f"{indent}/{_type}", fg="yellow", bold=False)
723:        else:
724:            _type = token.tok_name.get(node.type, str(node.type))
725:            out(f"{indent}{_type}", fg="blue", nl=False)
726:            if node.prefix:
727:                # We don't have to handle prefixes for `Node` objects since
728:                # that delegates to the first child anyway.
729:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, LineGenerator.line now has signature line(self, indent=0) without a type parameter; there is no def visit_unformatted() present; and LineGenerator.visit_default() iterates comments without any try/except for FormatOn/FormatOff. Verified via grep and reading lines 1406-1448.

Todo item 4 of 18 is correct
description: 'Confirm LineGenerator no longer supports UnformattedLines: method signature line(self, indent=0) has no type parameter; there is no visit_unformatted() method; and visit_default() contains no try/except for FormatOn/FormatOff.'

Validating todo item 5 of 18
description: 'Confirm generate_comments() no longer raises on FMT_ON/FMT_OFF and simply yields Leaf(pc.type, pc.value, prefix=...).'

Calling tool: grepTool
def generate_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2088:def generate_comments(leaf: LN) -> Iterator[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1960:
1961:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1962:        return LOGIC_PRIORITY
1963:
1964:    return 0
1965:
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't
1985:    share the line with any code.
1986:
1987:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
1989:    """
1990:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
1991:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
1992:
1993:
1994:@dataclass
1995:class ProtoComment:
1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
1997:    value: str  # content of the comment
1998:    newlines: int  # how many newlines before the comment
1999:    consumed: int  # how many characters of the original leaf's prefix did we consume
2000:
2001:
2002:@lru_cache(maxsize=4096)
2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2004:    result: List[ProtoComment] = []
2005:    if not prefix or "#" not in prefix:
2006:        return result
2007:
2008:    consumed = 0
2009:    nlines = 0
2010:    for index, line in enumerate(prefix.split("\n")):
2011:        consumed += len(line) + 1  # adding the length of the split '\n'
2012:        line = line.lstrip()
2013:        if not line:
2014:            nlines += 1
2015:        if not line.startswith("#"):
2016:            continue
2017:
2018:        if index == 0 and not is_endmarker:
2019:            comment_type = token.COMMENT  # simple trailing comment
2020:        else:
2021:            comment_type = STANDALONE_COMMENT
2022:        comment = make_comment(line)
2023:        result.append(
2024:            ProtoComment(
2025:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2026:            )
2027:        )
2028:        nlines = 0
2029:    return result
2030:
2031:
2032:def make_comment(content: str) -> str:
2033:    """Return a consistently formatted comment from the given `content` string.
2034:
2035:    All comments (except for "##", "#!", "#:") should have a single space between
2036:    the hash sign and the content.
2037:
2038:    If `content` didn't start with a hash sign, one is provided.
2039:    """

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
2080:
2081:    return 0
2082:
2083:
2084:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2085:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2086:
2087:
2088:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2089:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2090:
2091:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2092:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2093:    move because it does away with modifying the grammar to include all the
2094:    possible places in which comments can be placed.
2095:
2096:    The sad consequence for us though is that comments don't "belong" anywhere.
2097:    This is why this function generates simple parentless Leaf objects for
2098:    comments.  We simply don't know what the correct parent should be.
2099:
2100:    No matter though, we can live without this.  We really only need to
2101:    differentiate between inline and standalone comments.  The latter don't
2102:    share the line with any code.
2103:
2104:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
2106:    """
2107:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2108:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2109:        if pc.value in FMT_ON:
2110:            raise FormatOn(pc.consumed)
2111:
2112:        if pc.value in FMT_OFF:
2113:            if pc.type == STANDALONE_COMMENT:
2114:                raise FormatOff(pc.consumed)
2115:
2116:            prev = preceding_leaf(leaf)
2117:            if not prev or prev.type in WHITESPACE:  # standalone comment in disguise
2118:                raise FormatOff(pc.consumed)
2119:
2120:
2121:@dataclass
2122:class ProtoComment:
2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
2124:    value: str  # content of the comment
2125:    newlines: int  # how many newlines before the comment
2126:    consumed: int  # how many characters of the original leaf's prefix did we consume
2127:
2128:
2129:@lru_cache(maxsize=4096)
2130:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2131:    result: List[ProtoComment] = []
2132:    if not prefix or "#" not in prefix:
2133:        return result
2134:
2135:    consumed = 0
2136:    nlines = 0
2137:    for index, line in enumerate(prefix.split("\n")):
2138:        consumed += len(line) + 1  # adding the length of the split '\n'
2139:        line = line.lstrip()
2140:        if not line:
2141:            nlines += 1
2142:        if not line.startswith("#"):
2143:            continue
2144:
2145:        if index == 0 and not is_endmarker:
2146:            comment_type = token.COMMENT  # simple trailing comment
2147:        else:
2148:            comment_type = STANDALONE_COMMENT
2149:        comment = make_comment(line)
2150:        result.append(
2151:            ProtoComment(
2152:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2153:            )
2154:        )
2155:        nlines = 0
2156:    return result
2157:
2158:
2159:def make_comment(content: str) -> str:

Calling tool: grepTool
class FormatOn
No files found. Call grepTool again with a more generic pattern.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In the modified black.py, generate_comments() simply iterates list_comments and yields Leaf(pc.type, pc.value, prefix="\n" * pc.newlines) without raising on FMT_ON/FMT_OFF (see lines ~1990-1992). The prior exception-raising block was removed in this file as per the diff.

Todo item 5 of 18 is correct
description: 'Confirm generate_comments() no longer raises on FMT_ON/FMT_OFF and simply yields Leaf(pc.type, pc.value, prefix=...).'

Validating todo item 6 of 18
description: 'Check constants FMT_OFF and FMT_ON exist and include '# fmt: off', '# fmt:off', '# yapf: disable' and '# fmt: on', '# fmt:on', '# yapf: enable' respectively.'

Calling tool: grepTool
FMT_OFF|FMT_ON
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2517:        if pc.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2570:            if comment.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2621:            if comment.value in FMT_ON:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2084:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2085:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2109:        if pc.value in FMT_ON:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2112:        if pc.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2644:        if pc.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2704:            if comment.value in FMT_OFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2739:            if comment.value in FMT_ON:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1955:            and previous.type == token.NAME
1956:            and previous.value == "is"
1957:        )
1958:    ):
1959:        return COMPARATOR_PRIORITY
1960:
1961:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1962:        return LOGIC_PRIORITY
1963:
1964:    return 0
1965:
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Found constants in black.py at lines 1967-1968: FMT_OFF = {'# fmt: off', '# fmt:off', '# yapf: disable'} and FMT_ON = {'# fmt: on', '# fmt:on', '# yapf: enable'}, matching the requirement.

Todo item 6 of 18 is correct
description: 'Check constants FMT_OFF and FMT_ON exist and include '# fmt: off', '# fmt:off', '# yapf: disable' and '# fmt: on', '# fmt:on', '# yapf: enable' respectively.'

Validating todo item 7 of 18
description: 'Validate normalize_fmt_off() loops converting pairs until none remain by calling convert_one_fmt_off_pair() in a while loop.'

Calling tool: grepTool
def normalize_fmt_off\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2555:def normalize_fmt_off(node: Node) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2682:def normalize_fmt_off(node: Node) -> None:

Calling tool: grepTool
def convert_one_fmt_off_pair\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2562:def convert_one_fmt_off_pair(node: Node) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2538:                    node.children[-1].value = ""  # type: ignore
2539:                elif child.type != token.STAR:
2540:                    # insert invisible parentheses
2541:                    node.insert_child(index, Leaf(token.LPAR, ""))
2542:                    node.append_child(Leaf(token.RPAR, ""))
2543:                break
2544:
2545:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2546:                # wrap child in invisible parentheses
2547:                lpar = Leaf(token.LPAR, "")
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
2668:                    node.insert_child(index, Leaf(token.LPAR, ""))
2669:                    node.append_child(Leaf(token.RPAR, ""))
2670:                break
2671:
2672:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2673:                # wrap child in invisible parentheses
2674:                lpar = Leaf(token.LPAR, "")
2675:                rpar = Leaf(token.RPAR, "")
2676:                index = child.remove() or 0
2677:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2678:
2679:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2680:
2681:
2682:def normalize_fmt_off(node: Node) -> None:
2683:    """Allow `# fmt: off`/`# fmt: on` within bracket pairs.
2684:
2685:    Ignores `# fmt: off` and `# fmt: on` outside of brackets.
2686:
2687:    Raises :exc:`SyntaxError` if no matching `# fmt: on` is found for a `# fmt: off`
2688:    given inside brackets.
2689:    """
2690:    try_again = True
2691:    while try_again:
2692:        try_again = hide_fmt_off(node)
2693:
2694:
2695:def hide_fmt_off(node: Node) -> bool:
2696:    bt = BracketTracker()
2697:    for leaf in node.leaves():
2698:        bt.mark(leaf)
2699:        if bt.depth == 0:
2700:            continue
2701:
2702:        previous_consumed = 0
2703:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2704:            if comment.value in FMT_OFF:
2705:                ignored_nodes = list(generate_ignored_nodes(leaf))
2706:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2707:                parent = first.parent

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, normalize_fmt_off() sets try_again = True and loops while try_again, assigning the result of convert_one_fmt_off_pair(node) each iteration (lines 25552559). convert_one_fmt_off_pair(node) returns True when a pair is converted and False otherwise (lines 25622610), ensuring the loop continues until no pairs remain.

Todo item 7 of 18 is correct
description: 'Validate normalize_fmt_off() loops converting pairs until none remain by calling convert_one_fmt_off_pair() in a while loop.'

Validating todo item 8 of 18
description: 'Inspect convert_one_fmt_off_pair(): it should only act on FMT_OFF comments that are standalone (pc.type == STANDALONE_COMMENT) or standalone-in-disguise (no previous leaf or previous leaf is WHITESPACE), skipping inline trailing comments.'

Calling tool: grepTool
def convert_one_fmt_off_pair\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2562:def convert_one_fmt_off_pair(node: Node) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2538:                    node.children[-1].value = ""  # type: ignore
2539:                elif child.type != token.STAR:
2540:                    # insert invisible parentheses
2541:                    node.insert_child(index, Leaf(token.LPAR, ""))
2542:                    node.append_child(Leaf(token.RPAR, ""))
2543:                break
2544:
2545:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2546:                # wrap child in invisible parentheses
2547:                lpar = Leaf(token.LPAR, "")
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2
2658:        and node.children[0].type == token.LPAR
2659:        and node.children[1].type == token.RPAR
2660:    )
2661:
2662:
2663:def is_one_tuple(node: LN) -> bool:
2664:    """Return True if `node` holds a tuple with one element, with or without parens."""
2665:    if node.type == syms.atom:
2666:        if len(node.children) != 3:
2667:            return False

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:757:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1126:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1196:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1207:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2021:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2357:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2574:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2601:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2878:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:784:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1068:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1078:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1153:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1223:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1234:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2113:            if pc.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2148:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2484:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2723:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2996:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: grepTool
WHITESPACE\s*=
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:745:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:772:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/flake8/defaults.py:22:WHITESPACE = frozenset(" \t")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/jinja2/lexer.py:85:TOKEN_WHITESPACE = intern("whitespace")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pygments/lexers/usd.py:28:_WHITESPACE = r"([ \t]+)"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pygments/lexers/usd.py:45:                _TYPE, _BASE_ATTRIBUTE, _WHITESPACE=_WHITESPACE),
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pygments/lexers/usd.py:50:                _TYPE, _BASE_ATTRIBUTE, _WHITESPACE=_WHITESPACE),
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pygments/lexers/usd.py:55:                _TYPE, _BASE_ATTRIBUTE, _WHITESPACE=_WHITESPACE),
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pygments/lexers/usd.py:60:                _TYPE, _BASE_ATTRIBUTE, _WHITESPACE=_WHITESPACE),
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pycodestyle.py:124:WHITESPACE = frozenset(' \t')
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/pip/_vendor/rich/highlighter.py:111:    JSON_WHITESPACE = {" ", "\n", "\r", "\t"}

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.pys convert_one_fmt_off_pair(), it checks FMT_OFF comments and proceeds only if the comment is a STANDALONE_COMMENT or, if not, when the preceding leaf is absent or WHITESPACE; otherwise it continues (skips). This matches the requirement to skip inline trailing comments.

Todo item 8 of 18 is correct
description: 'Inspect convert_one_fmt_off_pair(): it should only act on FMT_OFF comments that are standalone (pc.type == STANDALONE_COMMENT) or standalone-in-disguise (no previous leaf or previous leaf is WHITESPACE), skipping inline trailing comments.'

Validating todo item 9 of 18
description: 'Inspect convert_one_fmt_off_pair(): it must collect ignored nodes via generate_ignored_nodes(leaf), trim the consumed part of the first node's prefix, build hidden_value = '# fmt: off' + newline + concatenated ignored nodes, and trim a trailing newline if present.'

Calling tool: grepTool
def convert_one_fmt_off_pair\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2562:def convert_one_fmt_off_pair(node: Node) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2520:
2521:    check_lpar = False
2522:    for index, child in enumerate(list(node.children)):
2523:        if check_lpar:
2524:            if child.type == syms.atom:
2525:                maybe_make_parens_invisible_in_atom(child)
2526:            elif is_one_tuple(child):
2527:                # wrap child in visible parentheses
2528:                lpar = Leaf(token.LPAR, "(")
2529:                rpar = Leaf(token.RPAR, ")")
2530:                child.remove()
2531:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2532:            elif node.type == syms.import_from:
2533:                # "import from" nodes store parentheses directly as part of
2534:                # the statement
2535:                if child.type == token.LPAR:
2536:                    # make parentheses invisible
2537:                    child.value = ""  # type: ignore
2538:                    node.children[-1].value = ""  # type: ignore
2539:                elif child.type != token.STAR:
2540:                    # insert invisible parentheses
2541:                    node.insert_child(index, Leaf(token.LPAR, ""))
2542:                    node.append_child(Leaf(token.RPAR, ""))
2543:                break
2544:
2545:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2546:                # wrap child in invisible parentheses
2547:                lpar = Leaf(token.LPAR, "")
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2
2658:        and node.children[0].type == token.LPAR
2659:        and node.children[1].type == token.RPAR
2660:    )
2661:
2662:
2663:def is_one_tuple(node: LN) -> bool:
2664:    """Return True if `node` holds a tuple with one element, with or without parens."""
2665:    if node.type == syms.atom:
2666:        if len(node.children) != 3:
2667:            return False
2668:
2669:        lpar, gexp, rpar = node.children
2670:        if not (
2671:            lpar.type == token.LPAR
2672:            and gexp.type == syms.testlist_gexp
2673:            and rpar.type == token.RPAR
2674:        ):
2675:            return False
2676:
2677:        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA
2678:
2679:    return (

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In convert_one_fmt_off_pair(), it gathers ignored nodes via generate_ignored_nodes(leaf) (lines 2579-2580), trims the consumed part of the first nodes prefix (line 2583), builds hidden_value as comment.value + "\n" + concatenated ignored nodes (lines 2584-2586), and trims a trailing newline if present (lines 2587-2590).

Todo item 9 of 18 is correct
description: 'Inspect convert_one_fmt_off_pair(): it must collect ignored nodes via generate_ignored_nodes(leaf), trim the consumed part of the first node's prefix, build hidden_value = '# fmt: off' + newline + concatenated ignored nodes, and trim a trailing newline if present.'

Validating todo item 10 of 18
description: 'Inspect convert_one_fmt_off_pair(): it must remove all ignored nodes from the tree and insert a new Leaf(STANDALONE_COMMENT, hidden_value) at the correct index with prefix preserved as original prefix up to previous comments plus comment.newlines newlines.'

Calling tool: grepTool
def convert_one_fmt_off_pair\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2562:def convert_one_fmt_off_pair(node: Node) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2520:
2521:    check_lpar = False
2522:    for index, child in enumerate(list(node.children)):
2523:        if check_lpar:
2524:            if child.type == syms.atom:
2525:                maybe_make_parens_invisible_in_atom(child)
2526:            elif is_one_tuple(child):
2527:                # wrap child in visible parentheses
2528:                lpar = Leaf(token.LPAR, "(")
2529:                rpar = Leaf(token.RPAR, ")")
2530:                child.remove()
2531:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2532:            elif node.type == syms.import_from:
2533:                # "import from" nodes store parentheses directly as part of
2534:                # the statement
2535:                if child.type == token.LPAR:
2536:                    # make parentheses invisible
2537:                    child.value = ""  # type: ignore
2538:                    node.children[-1].value = ""  # type: ignore
2539:                elif child.type != token.STAR:
2540:                    # insert invisible parentheses
2541:                    node.insert_child(index, Leaf(token.LPAR, ""))
2542:                    node.append_child(Leaf(token.RPAR, ""))
2543:                break
2544:
2545:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2546:                # wrap child in invisible parentheses
2547:                lpar = Leaf(token.LPAR, "")
2548:                rpar = Leaf(token.RPAR, "")
2549:                index = child.remove() or 0
2550:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2551:
2552:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2553:
2554:
2555:def normalize_fmt_off(node: Node) -> None:
2556:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2557:    try_again = True
2558:    while try_again:
2559:        try_again = convert_one_fmt_off_pair(node)
2560:
2561:
2562:def convert_one_fmt_off_pair(node: Node) -> bool:
2563:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2564:
2565:    Returns True if a pair was converted.
2566:    """
2567:    for leaf in node.leaves():
2568:        previous_consumed = 0
2569:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2570:            if comment.value in FMT_OFF:
2571:                # We only want standalone comments. If there's no previous leaf or
2572:                # the previous leaf is indentation, it's a standalone comment in
2573:                # disguise.
2574:                if comment.type != STANDALONE_COMMENT:
2575:                    prev = preceding_leaf(leaf)
2576:                    if prev and prev.type not in WHITESPACE:
2577:                        continue
2578:
2579:                ignored_nodes = list(generate_ignored_nodes(leaf))
2580:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2581:                parent = first.parent
2582:                prefix = first.prefix
2583:                first.prefix = prefix[comment.consumed :]
2584:                hidden_value = (
2585:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2586:                )
2587:                if hidden_value.endswith("\n"):
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2
2658:        and node.children[0].type == token.LPAR
2659:        and node.children[1].type == token.RPAR
2660:    )
2661:
2662:
2663:def is_one_tuple(node: LN) -> bool:
2664:    """Return True if `node` holds a tuple with one element, with or without parens."""
2665:    if node.type == syms.atom:
2666:        if len(node.children) != 3:
2667:            return False
2668:
2669:        lpar, gexp, rpar = node.children
2670:        if not (
2671:            lpar.type == token.LPAR
2672:            and gexp.type == syms.testlist_gexp
2673:            and rpar.type == token.RPAR
2674:        ):
2675:            return False
2676:
2677:        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA
2678:
2679:    return (
2680:        node.type in IMPLICIT_TUPLE
2681:        and len(node.children) == 2
2682:        and node.children[1].type == token.COMMA
2683:    )
2684:
2685:
2686:def is_yield(node: LN) -> bool:
2687:    """Return True if `node` holds a `yield` or `yield from` expression."""
2688:    if node.type == syms.yield_expr:
2689:        return True
2690:
2691:    if node.type == token.NAME and node.value == "yield":  # type: ignore
2692:        return True
2693:
2694:    if node.type != syms.atom:
2695:        return False
2696:
2697:    if len(node.children) != 3:
2698:        return False
2699:

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:757:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1126:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1196:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1207:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2021:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2357:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2574:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2601:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2878:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:784:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1068:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1078:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1153:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1223:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1234:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2113:            if pc.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2148:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2484:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2723:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2996:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py lines 2562-2606, convert_one_fmt_off_pair() gathers ignored_nodes, removes each via remove(), tracks first_idx, and inserts a new Leaf(STANDALONE_COMMENT, hidden_value) at that index with prefix set to prefix[:previous_consumed] + "\n" * comment.newlines, preserving prefix up to previous comments plus newlines.

Todo item 10 of 18 is correct
description: 'Inspect convert_one_fmt_off_pair(): it must remove all ignored nodes from the tree and insert a new Leaf(STANDALONE_COMMENT, hidden_value) at the correct index with prefix preserved as original prefix up to previous comments plus comment.newlines newlines.'

Validating todo item 11 of 18
description: 'Inspect generate_ignored_nodes(): starting at container_of(leaf), it should yield successive containers until encountering FMT_ON in a container's prefix, then stop; it must also stop when container becomes token.ENDMARKER.'

Calling tool: grepTool
def generate_ignored_nodes\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2735:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2588:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2589:                    # leaf (possibly followed by a DEDENT).
2590:                    hidden_value = hidden_value[:-1]
2591:                first_idx = None
2592:                for ignored in ignored_nodes:
2593:                    index = ignored.remove()
2594:                    if first_idx is None:
2595:                        first_idx = index
2596:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2597:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2598:                parent.insert_child(
2599:                    first_idx,
2600:                    Leaf(
2601:                        STANDALONE_COMMENT,
2602:                        hidden_value,
2603:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2604:                    ),
2605:                )
2606:                return True
2607:
2608:            previous_consumed += comment.consumed
2609:
2610:    return False
2611:
2612:
2613:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2614:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2615:
2616:    Stops at the end of the block.
2617:    """
2618:    container: Optional[LN] = container_of(leaf)
2619:    while container is not None and container.type != token.ENDMARKER:
2620:        for comment in list_comments(container.prefix, is_endmarker=False):
2621:            if comment.value in FMT_ON:
2622:                return
2623:
2624:        yield container
2625:
2626:        container = container.next_sibling
2627:
2628:
2629:def maybe_make_parens_invisible_in_atom(node: LN) -> bool:
2630:    """If it's safe, make the parens in the atom `node` invisible, recursively."""
2631:    if (
2632:        node.type != syms.atom
2633:        or is_empty_tuple(node)
2634:        or is_one_tuple(node)
2635:        or is_yield(node)
2636:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2637:    ):
2638:        return False
2639:
2640:    first = node.children[0]
2641:    last = node.children[-1]
2642:    if first.type == token.LPAR and last.type == token.RPAR:
2643:        # make parentheses invisible
2644:        first.value = ""  # type: ignore
2645:        last.value = ""  # type: ignore
2646:        if len(node.children) > 1:
2647:            maybe_make_parens_invisible_in_atom(node.children[1])
2648:        return True
2649:
2650:    return False
2651:
2652:
2653:def is_empty_tuple(node: LN) -> bool:
2654:    """Return True if `node` holds an empty tuple."""
2655:    return (
2656:        node.type == syms.atom
2657:        and len(node.children) == 2
2658:        and node.children[0].type == token.LPAR
2659:        and node.children[1].type == token.RPAR
2660:    )
2661:
2662:
2663:def is_one_tuple(node: LN) -> bool:
2664:    """Return True if `node` holds a tuple with one element, with or without parens."""
2665:    if node.type == syms.atom:
2666:        if len(node.children) != 3:
2667:            return False
2668:
2669:        lpar, gexp, rpar = node.children
2670:        if not (
2671:            lpar.type == token.LPAR
2672:            and gexp.type == syms.testlist_gexp
2673:            and rpar.type == token.RPAR
2674:        ):
2675:            return False
2676:
2677:        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA
2678:
2679:    return (
2680:        node.type in IMPLICIT_TUPLE
2681:        and len(node.children) == 2
2682:        and node.children[1].type == token.COMMA
2683:    )
2684:
2685:
2686:def is_yield(node: LN) -> bool:
2687:    """Return True if `node` holds a `yield` or `yield from` expression."""
2688:    if node.type == syms.yield_expr:
2689:        return True
2690:
2691:    if node.type == token.NAME and node.value == "yield":  # type: ignore
2692:        return True
2693:
2694:    if node.type != syms.atom:
2695:        return False
2696:
2697:    if len(node.children) != 3:
2698:        return False
2699:
2700:    lpar, expr, rpar = node.children
2701:    if lpar.type == token.LPAR and rpar.type == token.RPAR:
2702:        return is_yield(expr)
2703:
2704:    return False
2705:
2706:
2707:def is_vararg(leaf: Leaf, within: Set[NodeType]) -> bool:

Calling tool: grepTool
FMT_ON\s*=|def list_comments\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2085:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2130:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1956:            and previous.value == "is"
1957:        )
1958:    ):
1959:        return COMPARATOR_PRIORITY
1960:
1961:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1962:        return LOGIC_PRIORITY
1963:
1964:    return 0
1965:
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't
1985:    share the line with any code.
1986:
1987:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
1989:    """
1990:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
1991:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
1992:
1993:
1994:@dataclass
1995:class ProtoComment:
1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
1997:    value: str  # content of the comment
1998:    newlines: int  # how many newlines before the comment
1999:    consumed: int  # how many characters of the original leaf's prefix did we consume
2000:
2001:
2002:@lru_cache(maxsize=4096)
2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2004:    result: List[ProtoComment] = []
2005:    if not prefix or "#" not in prefix:
2006:        return result
2007:
2008:    consumed = 0
2009:    nlines = 0
2010:    for index, line in enumerate(prefix.split("\n")):
2011:        consumed += len(line) + 1  # adding the length of the split '\n'
2012:        line = line.lstrip()
2013:        if not line:
2014:            nlines += 1
2015:        if not line.startswith("#"):
2016:            continue
2017:
2018:        if index == 0 and not is_endmarker:
2019:            comment_type = token.COMMENT  # simple trailing comment
2020:        else:
2021:            comment_type = STANDALONE_COMMENT
2022:        comment = make_comment(line)
2023:        result.append(
2024:            ProtoComment(
2025:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2026:            )
2027:        )
2028:        nlines = 0
2029:    return result
2030:
2031:
2032:def make_comment(content: str) -> str:
2033:    """Return a consistently formatted comment from the given `content` string.
2034:
2035:    All comments (except for "##", "#!", "#:") should have a single space between

Calling tool: grepTool
def container_of\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1837:def container_of(leaf: Leaf) -> LN:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1957:def container_of(leaf: Leaf) -> LN:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1828:
1829:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
1830:    """Return the child of `ancestor` that contains `descendant`."""
1831:    node: Optional[LN] = descendant
1832:    while node and node.parent != ancestor:
1833:        node = node.parent
1834:    return node
1835:
1836:
1837:def container_of(leaf: Leaf) -> LN:
1838:    """Return `leaf` or one of its ancestors that is the topmost container of it.
1839:
1840:    By "container" we mean a node where `leaf` is the very first child.
1841:    """
1842:    same_prefix = leaf.prefix
1843:    container: LN = leaf
1844:    while container:
1845:        parent = container.parent
1846:        if parent is None:
1847:            break
1848:
1849:        if parent.children[0].prefix != same_prefix:
1850:            break
1851:
1852:        if parent.type == syms.file_input:
1853:            break
1854:
1855:        if parent.type in SURROUNDED_BY_BRACKETS:
1856:            break
1857:
1858:        container = parent
1859:    return container
1860:
1861:
1862:def is_split_after_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1863:    """Return the priority of the `leaf` delimiter, given a line break after it.
1864:
1865:    The delimiter priorities returned here are from those delimiters that would
1866:    cause a line break after themselves.
1867:
1868:    Higher numbers are higher priority.
1869:    """
1870:    if leaf.type == token.COMMA:
1871:        return COMMA_PRIORITY
1872:
1873:    return 0
1874:
1875:
1876:def is_split_before_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1877:    """Return the priority of the `leaf` delimiter, given a line before after it.
1878:
1879:    The delimiter priorities returned here are from those delimiters that would
1880:    cause a line break before themselves.
1881:
1882:    Higher numbers are higher priority.
1883:    """
1884:    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):
1885:        # * and ** might also be MATH_OPERATORS but in this case they are not.
1886:        # Don't treat them as a delimiter.
1887:        return 0
1888:
1889:    if (
1890:        leaf.type == token.DOT
1891:        and leaf.parent
1892:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
1893:        and (previous is None or previous.type in CLOSING_BRACKETS)
1894:    ):
1895:        return DOT_PRIORITY
1896:
1897:    if (
1898:        leaf.type in MATH_OPERATORS
1899:        and leaf.parent
1900:        and leaf.parent.type not in {syms.factor, syms.star_expr}
1901:    ):
1902:        return MATH_PRIORITIES[leaf.type]
1903:
1904:    if leaf.type in COMPARATORS:
1905:        return COMPARATOR_PRIORITY
1906:
1907:    if (

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: generate_ignored_nodes starts from container_of(leaf) and iterates container.next_sibling, yielding each container until it finds FMT_ON in a containers prefix (then returns) and the loop condition also stops when container is token.ENDMARKER.

Todo item 11 of 18 is correct
description: 'Inspect generate_ignored_nodes(): starting at container_of(leaf), it should yield successive containers until encountering FMT_ON in a container's prefix, then stop; it must also stop when container becomes token.ENDMARKER.'

Validating todo item 12 of 18
description: 'Inspect container_of(leaf): verify it walks up until the topmost container whose first child's prefix matches the starting prefix, and stops before syms.file_input or any node in SURROUNDED_BY_BRACKETS.'

Calling tool: grepTool
def container_of\(leaf: Leaf\)
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1837:def container_of(leaf: Leaf) -> LN:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1957:def container_of(leaf: Leaf) -> LN:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1800:                return SPACE
1801:
1802:            if prev and prev.type == token.DOT:
1803:                return NO
1804:
1805:    elif p.type == syms.sliceop:
1806:        return NO
1807:
1808:    return SPACE
1809:
1810:
1811:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
1812:    """Return the first leaf that precedes `node`, if any."""
1813:    while node:
1814:        res = node.prev_sibling
1815:        if res:
1816:            if isinstance(res, Leaf):
1817:                return res
1818:
1819:            try:
1820:                return list(res.leaves())[-1]
1821:
1822:            except IndexError:
1823:                return None
1824:
1825:        node = node.parent
1826:    return None
1827:
1828:
1829:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
1830:    """Return the child of `ancestor` that contains `descendant`."""
1831:    node: Optional[LN] = descendant
1832:    while node and node.parent != ancestor:
1833:        node = node.parent
1834:    return node
1835:
1836:
1837:def container_of(leaf: Leaf) -> LN:
1838:    """Return `leaf` or one of its ancestors that is the topmost container of it.
1839:
1840:    By "container" we mean a node where `leaf` is the very first child.
1841:    """
1842:    same_prefix = leaf.prefix
1843:    container: LN = leaf
1844:    while container:
1845:        parent = container.parent
1846:        if parent is None:
1847:            break
1848:
1849:        if parent.children[0].prefix != same_prefix:
1850:            break
1851:
1852:        if parent.type == syms.file_input:
1853:            break
1854:
1855:        if parent.type in SURROUNDED_BY_BRACKETS:
1856:            break
1857:
1858:        container = parent
1859:    return container
1860:
1861:
1862:def is_split_after_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1863:    """Return the priority of the `leaf` delimiter, given a line break after it.
1864:
1865:    The delimiter priorities returned here are from those delimiters that would
1866:    cause a line break after themselves.
1867:
1868:    Higher numbers are higher priority.
1869:    """
1870:    if leaf.type == token.COMMA:
1871:        return COMMA_PRIORITY
1872:
1873:    return 0
1874:
1875:
1876:def is_split_before_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1877:    """Return the priority of the `leaf` delimiter, given a line before after it.
1878:
1879:    The delimiter priorities returned here are from those delimiters that would
1880:    cause a line break before themselves.
1881:
1882:    Higher numbers are higher priority.
1883:    """
1884:    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):
1885:        # * and ** might also be MATH_OPERATORS but in this case they are not.
1886:        # Don't treat them as a delimiter.
1887:        return 0
1888:
1889:    if (
1890:        leaf.type == token.DOT
1891:        and leaf.parent
1892:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
1893:        and (previous is None or previous.type in CLOSING_BRACKETS)
1894:    ):
1895:        return DOT_PRIORITY
1896:
1897:    if (
1898:        leaf.type in MATH_OPERATORS
1899:        and leaf.parent
1900:        and leaf.parent.type not in {syms.factor, syms.star_expr}
1901:    ):
1902:        return MATH_PRIORITIES[leaf.type]
1903:
1904:    if leaf.type in COMPARATORS:
1905:        return COMPARATOR_PRIORITY
1906:
1907:    if (
1908:        leaf.type == token.STRING
1909:        and previous is not None
1910:        and previous.type == token.STRING
1911:    ):
1912:        return STRING_PRIORITY
1913:
1914:    if leaf.type != token.NAME:
1915:        return 0
1916:
1917:    if (
1918:        leaf.value == "for"
1919:        and leaf.parent
1920:        and leaf.parent.type in {syms.comp_for, syms.old_comp_for}
1921:    ):
1922:        return COMPREHENSION_PRIORITY
1923:
1924:    if (
1925:        leaf.value == "if"
1926:        and leaf.parent
1927:        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
1928:    ):
1929:        return COMPREHENSION_PRIORITY

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
1920:                return SPACE
1921:
1922:            if prev and prev.type == token.DOT:
1923:                return NO
1924:
1925:    elif p.type == syms.sliceop:
1926:        return NO
1927:
1928:    return SPACE
1929:
1930:
1931:def preceding_leaf(node: Optional[LN]) -> Optional[Leaf]:
1932:    """Return the first leaf that precedes `node`, if any."""
1933:    while node:
1934:        res = node.prev_sibling
1935:        if res:
1936:            if isinstance(res, Leaf):
1937:                return res
1938:
1939:            try:
1940:                return list(res.leaves())[-1]
1941:
1942:            except IndexError:
1943:                return None
1944:
1945:        node = node.parent
1946:    return None
1947:
1948:
1949:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
1950:    """Return the child of `ancestor` that contains `descendant`."""
1951:    node: Optional[LN] = descendant
1952:    while node and node.parent != ancestor:
1953:        node = node.parent
1954:    return node
1955:
1956:
1957:def container_of(leaf: Leaf) -> LN:
1958:    """Return `leaf` or one of its ancestors that is the topmost container of it.
1959:
1960:    By "container" we mean a node where `leaf` is the very first child.
1961:    """
1962:    same_prefix = leaf.prefix
1963:    container: LN = leaf
1964:    while container:
1965:        parent = container.parent
1966:        if parent is None:
1967:            break
1968:
1969:        if parent.children[0].prefix != same_prefix:
1970:            break
1971:
1972:        if parent.type in SURROUNDED_BY_BRACKETS:
1973:            break
1974:
1975:        container = parent
1976:    return container
1977:
1978:
1979:def is_split_after_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1980:    """Return the priority of the `leaf` delimiter, given a line break after it.
1981:
1982:    The delimiter priorities returned here are from those delimiters that would
1983:    cause a line break after themselves.
1984:
1985:    Higher numbers are higher priority.
1986:    """
1987:    if leaf.type == token.COMMA:
1988:        return COMMA_PRIORITY
1989:
1990:    return 0
1991:
1992:
1993:def is_split_before_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1994:    """Return the priority of the `leaf` delimiter, given a line before after it.
1995:
1996:    The delimiter priorities returned here are from those delimiters that would
1997:    cause a line break before themselves.
1998:
1999:    Higher numbers are higher priority.
2000:    """
2001:    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):
2002:        # * and ** might also be MATH_OPERATORS but in this case they are not.
2003:        # Don't treat them as a delimiter.
2004:        return 0
2005:
2006:    if (
2007:        leaf.type == token.DOT
2008:        and leaf.parent
2009:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
2010:        and (previous is None or previous.type in CLOSING_BRACKETS)
2011:    ):
2012:        return DOT_PRIORITY
2013:
2014:    if (
2015:        leaf.type in MATH_OPERATORS
2016:        and leaf.parent
2017:        and leaf.parent.type not in {syms.factor, syms.star_expr}
2018:    ):
2019:        return MATH_PRIORITIES[leaf.type]
2020:
2021:    if leaf.type in COMPARATORS:
2022:        return COMPARATOR_PRIORITY
2023:
2024:    if (
2025:        leaf.type == token.STRING
2026:        and previous is not None
2027:        and previous.type == token.STRING
2028:    ):
2029:        return STRING_PRIORITY
2030:
2031:    if leaf.type != token.NAME:
2032:        return 0
2033:
2034:    if (
2035:        leaf.value == "for"
2036:        and leaf.parent
2037:        and leaf.parent.type in {syms.comp_for, syms.old_comp_for}
2038:    ):
2039:        return COMPREHENSION_PRIORITY
2040:
2041:    if (
2042:        leaf.value == "if"
2043:        and leaf.parent
2044:        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
2045:    ):
2046:        return COMPREHENSION_PRIORITY
2047:
2048:    if leaf.value in {"if", "else"} and leaf.parent and leaf.parent.type == syms.test:
2049:        return TERNARY_PRIORITY

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py at lines 1837-1859, container_of walks up ancestors while the parents first child prefix matches the original prefix, and breaks when encountering syms.file_input or any type in SURROUNDED_BY_BRACKETS. This matches the specified behavior.

Todo item 12 of 18 is correct
description: 'Inspect container_of(leaf): verify it walks up until the topmost container whose first child's prefix matches the starting prefix, and stops before syms.file_input or any node in SURROUNDED_BY_BRACKETS.'

Validating todo item 13 of 18
description: 'Verify LineGenerator.visit_STANDALONE_COMMENT yields a line boundary when not inside brackets (no open brackets) before visiting the STANDALONE_COMMENT, ensuring the comment is isolated on its own line.'

Calling tool: grepTool
def visit_STANDALONE_COMMENT\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1528:
1529:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1530:        """Visit decorators."""
1531:        for child in node.children:
1532:            yield from self.line()
1533:            yield from self.visit(child)
1534:
1535:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1536:        """Remove a semicolon and put the other statement on a separate line."""
1537:        yield from self.line()
1538:
1539:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1540:        """End of file. Process outstanding comments and end with a newline."""
1541:        yield from self.visit_default(leaf)
1542:        yield from self.line()
1543:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1545:        if not self.current_line.bracket_tracker.any_open_brackets():
1546:            yield from self.line()
1547:        yield from self.visit_default(leaf)
1548:
1549:    def __attrs_post_init__(self) -> None:
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1558:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1559:        self.visit_try_stmt = partial(
1560:            v, keywords={"try", "except", "else", "finally"}, parens=
1561:        )
1562:        self.visit_except_clause = partial(v, keywords={"except"}, parens=)
1563:        self.visit_with_stmt = partial(v, keywords={"with"}, parens=)
1564:        self.visit_funcdef = partial(v, keywords={"def"}, parens=)
1565:        self.visit_classdef = partial(v, keywords={"class"}, parens=)
1566:        self.visit_expr_stmt = partial(v, keywords=, parens=ASSIGNMENTS)
1567:        self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})

Calling tool: grepTool
class Line\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:993:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1020:class Line:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/docutils/parsers/rst/states.py:2913:class Line(SpecializedText):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/tabulate.pyi:8:class Line(NamedTuple):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/mypy/typeshed/third_party/2and3/werkzeug/debug/tbtools.pyi:16:class Line:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
990:
991:
992:@dataclass
993:class Line:
994:    """Holds leaves and comments. Can be printed with `str(line)`."""
995:
996:    depth: int = 0
997:    leaves: List[Leaf] = Factory(list)
998:    comments: List[Tuple[Index, Leaf]] = Factory(list)
999:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1000:    inside_brackets: bool = False
1001:    should_explode: bool = False
1002:
1003:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1004:        """Add a new `leaf` to the end of the line.
1005:
1006:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1007:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1008:        Trailing commas are maybe removed, unpacked for loop variables are
1009:        demoted from being delimiters.
1010:
1011:        Inline comments are put aside.
1012:        """
1013:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1014:        if not has_value:
1015:            return
1016:
1017:        if token.COLON == leaf.type and self.is_class_paren_empty:
1018:            del self.leaves[-2:]
1019:        if self.leaves and not preformatted:
1020:            # Note: at this point leaf.prefix should be empty except for
1021:            # imports, for which we only preserve newlines.
1022:            leaf.prefix += whitespace(
1023:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1024:            )
1025:        if self.inside_brackets or not preformatted:
1026:            self.bracket_tracker.mark(leaf)
1027:            self.maybe_remove_trailing_comma(leaf)
1028:        if not self.append_comment(leaf):
1029:            self.leaves.append(leaf)
1030:
1031:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1032:        """Like :func:`append()` but disallow invalid standalone comment structure.
1033:
1034:        Raises ValueError when any `leaf` is appended after a standalone comment
1035:        or when a standalone comment is not the first leaf on the line.
1036:        """
1037:        if self.bracket_tracker.depth == 0:
1038:            if self.is_comment:
1039:                raise ValueError("cannot append to standalone comments")
1040:
1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1042:                raise ValueError(
1043:                    "cannot append standalone comments to a populated line"
1044:                )
1045:
1046:        self.append(leaf, preformatted=preformatted)
1047:
1048:    @property
1049:    def is_comment(self) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1048:    @property
1049:    def is_comment(self) -> bool:
1050:        """Is this line a standalone comment?"""
1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1052:
1053:    @property
1054:    def is_decorator(self) -> bool:
1055:        """Is this line a decorator?"""
1056:        return bool(self) and self.leaves[0].type == token.AT
1057:
1058:    @property
1059:    def is_import(self) -> bool:
1060:        """Is this an import line?"""
1061:        return bool(self) and is_import(self.leaves[0])
1062:
1063:    @property
1064:    def is_class(self) -> bool:
1065:        """Is this line a class definition?"""
1066:        return (
1067:            bool(self)
1068:            and self.leaves[0].type == token.NAME
1069:            and self.leaves[0].value == "class"
1070:        )
1071:
1072:    @property
1073:    def is_stub_class(self) -> bool:
1074:        """Is this line a class definition with a body consisting only of "..."?"""
1075:        return self.is_class and self.leaves[-3:] == [
1076:            Leaf(token.DOT, ".") for _ in range(3)
1077:        ]
1078:
1079:    @property
1080:    def is_def(self) -> bool:
1081:        """Is this a function definition? (Also returns True for async defs.)"""
1082:        try:
1083:            first_leaf = self.leaves[0]
1084:        except IndexError:
1085:            return False
1086:
1087:        try:
1088:            second_leaf: Optional[Leaf] = self.leaves[1]
1089:        except IndexError:
1090:            second_leaf = None
1091:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1092:            first_leaf.type == token.ASYNC
1093:            and second_leaf is not None
1094:            and second_leaf.type == token.NAME
1095:            and second_leaf.value == "def"
1096:        )
1097:
1098:    @property
1099:    def is_class_paren_empty(self) -> bool:
1100:        """Is this a class with no base classes but using parentheses?
1101:
1102:        Those are unnecessary and should be removed.
1103:        """
1104:        return (
1105:            bool(self)
1106:            and len(self.leaves) == 4
1107:            and self.is_class
1108:            and self.leaves[2].type == token.LPAR
1109:            and self.leaves[2].value == "("
1110:            and self.leaves[3].type == token.RPAR
1111:            and self.leaves[3].value == ")"
1112:        )
1113:
1114:    @property
1115:    def is_triple_quoted_string(self) -> bool:
1116:        """Is the line a triple quoted string?"""
1117:        return (
1118:            bool(self)
1119:            and self.leaves[0].type == token.STRING
1120:            and self.leaves[0].value.startswith(('"""', "'''"))
1121:        )
1122:
1123:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1124:        """If so, needs to be split before emitting."""
1125:        for leaf in self.leaves:
1126:            if leaf.type == STANDALONE_COMMENT:
1127:                if leaf.bracket_depth <= depth_limit:

Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2051:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2178:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2050:
2051:def split_line(
2052:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2053:) -> Iterator[Line]:
2054:    """Split a `line` into potentially many lines.
2055:
2056:    They should fit in the allotted `line_length` but might not be able to.
2057:    `inner` signifies that there were a pair of brackets somewhere around the
2058:    current `line`, possibly transitively. This means we can fallback to splitting
2059:    by delimiters if the LHS/RHS don't yield any results.
2060:
2061:    If `py36` is True, splitting may generate syntax that is only compatible
2062:    with Python 3.6 and later.
2063:    """
2064:    if line.is_comment:
2065:        yield line
2066:        return
2067:
2068:    line_str = str(line).strip("\n")
2069:    if not line.should_explode and is_line_short_enough(
2070:        line, line_length=line_length, line_str=line_str
2071:    ):
2072:        yield line
2073:        return
2074:
2075:    split_funcs: List[SplitFunc]
2076:    if line.is_def:
2077:        split_funcs = [left_hand_split]
2078:    else:
2079:
2080:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2081:            for omit in generate_trailers_to_omit(line, line_length):
2082:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2083:                if is_line_short_enough(lines[0], line_length=line_length):
2084:                    yield from lines
2085:                    return
2086:
2087:            # All splits failed, best effort split with no omits.
2088:            # This mostly happens to multiline strings that are by definition
2089:            # reported as not fitting a single line.

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:757:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1126:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1196:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1207:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2021:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2357:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2574:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2601:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2878:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:784:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1068:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1078:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1153:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1223:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1234:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2113:            if pc.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2148:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2484:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2723:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2996:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1118:            bool(self)
1119:            and self.leaves[0].type == token.STRING
1120:            and self.leaves[0].value.startswith(('"""', "'''"))
1121:        )
1122:
1123:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1124:        """If so, needs to be split before emitting."""
1125:        for leaf in self.leaves:
1126:            if leaf.type == STANDALONE_COMMENT:
1127:                if leaf.bracket_depth <= depth_limit:
1128:                    return True
1129:
1130:        return False
1131:
1132:    def contains_multiline_strings(self) -> bool:
1133:        for leaf in self.leaves:
1134:            if is_multiline_string(leaf):
1135:                return True
1136:
1137:        return False
1138:
1139:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1140:        """Remove trailing comma if there is one and it's safe."""
1141:        if not (
1142:            self.leaves
1143:            and self.leaves[-1].type == token.COMMA
1144:            and closing.type in CLOSING_BRACKETS
1145:        ):
1146:            return False
1147:
1148:        if closing.type == token.RBRACE:
1149:            self.remove_trailing_comma()
1150:            return True
1151:
1152:        if closing.type == token.RSQB:
1153:            comma = self.leaves[-1]
1154:            if comma.parent and comma.parent.type == syms.listmaker:
1155:                self.remove_trailing_comma()
1156:                return True
1157:
1158:        # For parens let's check if it's safe to remove the comma.
1159:        # Imports are always safe.
1160:        if self.is_import:
1161:            self.remove_trailing_comma()
1162:            return True
1163:
1164:        # Otheriwsse, if the trailing one is the only one, we might mistakenly
1165:        # change a tuple into a different type by removing the comma.
1166:        depth = closing.bracket_depth + 1
1167:        commas = 0
1168:        opening = closing.opening_bracket
1169:        for _opening_index, leaf in enumerate(self.leaves):
1170:            if leaf is opening:
1171:                break
1172:
1173:        else:
1174:            return False
1175:
1176:        for leaf in self.leaves[_opening_index + 1 :]:
1177:            if leaf is closing:
1178:                break
1179:
1180:            bracket_depth = leaf.bracket_depth
1181:            if bracket_depth == depth and leaf.type == token.COMMA:
1182:                commas += 1
1183:                if leaf.parent and leaf.parent.type == syms.arglist:
1184:                    commas += 1
1185:                    break
1186:
1187:        if commas > 1:
1188:            self.remove_trailing_comma()
1189:            return True
1190:
1191:        return False
1192:
1193:    def append_comment(self, comment: Leaf) -> bool:
1194:        """Add an inline or standalone comment to the line."""
1195:        if (
1196:            comment.type == STANDALONE_COMMENT
1197:            and self.bracket_tracker.any_open_brackets()
1198:        ):
1199:            comment.prefix = ""
1200:            return False
1201:
1202:        if comment.type != token.COMMENT:
1203:            return False
1204:
1205:        after = len(self.leaves) - 1
1206:        if after == -1:
1207:            comment.type = STANDALONE_COMMENT
1208:            comment.prefix = ""
1209:            return False
1210:
1211:        else:
1212:            self.comments.append((after, comment))
1213:            return True
1214:
1215:    def comments_after(self, leaf: Leaf, _index: int = -1) -> Iterator[Leaf]:
1216:        """Generate comments that should appear directly after `leaf`.
1217:

Calling tool: grepTool
def visit_NEWLINE\(
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
visit_\w*NEWLINE
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
yield from self\.line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1433:                    yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1437:                    yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1440:                    yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1453:        yield from self.line(+1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1461:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1468:        yield from self.line(-1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1487:                yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1505:                yield from self.line(+1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1507:                yield from self.line(-1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1511:                yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1516:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1532:            yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1537:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1542:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1546:            yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1528:                        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1532:                        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1535:                        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1539:                yield from self.line(type=UnformattedLines)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1560:        yield from self.line(+1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1568:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1575:        yield from self.line(-1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1594:                yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1612:                yield from self.line(+1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1614:                yield from self.line(-1)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1618:                yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1623:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1639:            yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1644:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1649:        yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1662:                yield from self.line()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1667:                yield from self.line()

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1418:        complete_line = self.current_line
1419:        self.current_line = Line(depth=complete_line.depth + indent)
1420:        yield complete_line
1421:
1422:    def visit_default(self, node: LN) -> Iterator[Line]:
1423:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1424:        if isinstance(node, Leaf):
1425:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1426:            for comment in generate_comments(node):
1427:                if any_open_brackets:
1428:                    # any comment within brackets is subject to splitting
1429:                    self.current_line.append(comment)
1430:                elif comment.type == token.COMMENT:
1431:                    # regular trailing comment
1432:                    self.current_line.append(comment)
1433:                    yield from self.line()
1434:
1435:                else:
1436:                    # regular standalone comment
1437:                    yield from self.line()
1438:
1439:                    self.current_line.append(comment)
1440:                    yield from self.line()
1441:
1442:            normalize_prefix(node, inside_brackets=any_open_brackets)
1443:            if self.normalize_strings and node.type == token.STRING:
1444:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1445:                normalize_string_quotes(node)
1446:            if node.type not in WHITESPACE:
1447:                self.current_line.append(node)
1448:        yield from super().visit_default(node)
1449:
1450:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1451:        """Increase indentation level, maybe yield a line."""
1452:        # In blib2to3 INDENT never holds comments.
1453:        yield from self.line(+1)
1454:        yield from self.visit_default(node)
1455:
1456:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1457:        """Decrease indentation level, maybe yield a line."""
1458:        # The current line might still wait for trailing comments.  At DEDENT time
1459:        # there won't be any (they would be prefixes on the preceding NEWLINE).
1460:        # Emit the line then.
1461:        yield from self.line()
1462:
1463:        # While DEDENT has no value, its prefix may contain standalone comments
1464:        # that belong to the current indentation level.  Get 'em.
1465:        yield from self.visit_default(node)
1466:
1467:        # Finally, emit the dedent.
1468:        yield from self.line(-1)
1469:
1470:    def visit_stmt(
1471:        self, node: Node, keywords: Set[str], parens: Set[str]
1472:    ) -> Iterator[Line]:
1473:        """Visit a statement.
1474:
1475:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1476:        `def`, `with`, `class`, `assert` and assignments.
1477:
1478:        The relevant Python language `keywords` for a given statement will be
1479:        NAME leaves within it. This methods puts those on a separate line.
1480:
1481:        `parens` holds a set of string leaf values immediately after which
1482:        invisible parens should be put.
1483:        """
1484:        normalize_invisible_parens(node, parens_after=parens)
1485:        for child in node.children:
1486:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1487:                yield from self.line()
1488:
1489:            yield from self.visit(child)
1490:
1491:    def visit_suite(self, node: Node) -> Iterator[Line]:
1492:        """Visit a suite."""
1493:        if self.is_pyi and is_stub_suite(node):
1494:            yield from self.visit(node.children[2])
1495:        else:
1496:            yield from self.visit_default(node)
1497:
1498:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1499:        """Visit a statement without nested statements."""
1500:        is_suite_like = node.parent and node.parent.type in STATEMENT
1501:        if is_suite_like:
1502:            if self.is_pyi and is_stub_body(node):
1503:                yield from self.visit_default(node)
1504:            else:
1505:                yield from self.line(+1)
1506:                yield from self.visit_default(node)
1507:                yield from self.line(-1)
1508:
1509:        else:
1510:            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):
1511:                yield from self.line()
1512:            yield from self.visit_default(node)
1513:
1514:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:
1515:        """Visit `async def`, `async for`, `async with`."""
1516:        yield from self.line()
1517:
1518:        children = iter(node.children)
1519:        for child in children:
1520:            yield from self.visit(child)
1521:
1522:            if child.type == token.ASYNC:
1523:                break
1524:
1525:        internal_stmt = next(children)
1526:        for child in internal_stmt.children:
1527:            yield from self.visit(child)
1528:
1529:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1530:        """Visit decorators."""
1531:        for child in node.children:
1532:            yield from self.line()
1533:            yield from self.visit(child)
1534:
1535:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1536:        """Remove a semicolon and put the other statement on a separate line."""
1537:        yield from self.line()
1538:
1539:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1540:        """End of file. Process outstanding comments and end with a newline."""
1541:        yield from self.visit_default(leaf)
1542:        yield from self.line()
1543:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1545:        if not self.current_line.bracket_tracker.any_open_brackets():
1546:            yield from self.line()
1547:        yield from self.visit_default(leaf)
1548:
1549:    def __attrs_post_init__(self) -> None:
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, LineGenerator.visit_STANDALONE_COMMENT checks bracket_tracker.any_open_brackets() and, when there are no open brackets, calls `yield from self.line()` before delegating to visit_default. This ensures a line boundary is created prior to the standalone comment, isolating it on its own line.

Todo item 13 of 18 is correct
description: 'Verify LineGenerator.visit_STANDALONE_COMMENT yields a line boundary when not inside brackets (no open brackets) before visiting the STANDALONE_COMMENT, ensuring the comment is isolated on its own line.'

Validating todo item 14 of 18
description: 'Verify split_line() immediately yields and returns when line.is_comment is True so STANDALONE_COMMENT lines are not split or reformatted.'

Calling tool: grepTool
def split_line\(
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
def split_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2051:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2178:def split_line(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/lib/python3.8/site-packages/flake8/processor.py:224:    def split_line(self, token):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
2025:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2026:            )
2027:        )
2028:        nlines = 0
2029:    return result
2030:
2031:
2032:def make_comment(content: str) -> str:
2033:    """Return a consistently formatted comment from the given `content` string.
2034:
2035:    All comments (except for "##", "#!", "#:") should have a single space between
2036:    the hash sign and the content.
2037:
2038:    If `content` didn't start with a hash sign, one is provided.
2039:    """
2040:    content = content.rstrip()
2041:    if not content:
2042:        return "#"
2043:
2044:    if content[0] == "#":
2045:        content = content[1:]
2046:    if content and content[0] not in " !:#":
2047:        content = " " + content
2048:    return "#" + content
2049:
2050:
2051:def split_line(
2052:    line: Line, line_length: int, inner: bool = False, py36: bool = False
2053:) -> Iterator[Line]:
2054:    """Split a `line` into potentially many lines.
2055:
2056:    They should fit in the allotted `line_length` but might not be able to.
2057:    `inner` signifies that there were a pair of brackets somewhere around the
2058:    current `line`, possibly transitively. This means we can fallback to splitting
2059:    by delimiters if the LHS/RHS don't yield any results.
2060:
2061:    If `py36` is True, splitting may generate syntax that is only compatible
2062:    with Python 3.6 and later.
2063:    """
2064:    if line.is_comment:
2065:        yield line
2066:        return
2067:
2068:    line_str = str(line).strip("\n")
2069:    if not line.should_explode and is_line_short_enough(
2070:        line, line_length=line_length, line_str=line_str
2071:    ):
2072:        yield line
2073:        return
2074:
2075:    split_funcs: List[SplitFunc]
2076:    if line.is_def:
2077:        split_funcs = [left_hand_split]
2078:    else:
2079:
2080:        def rhs(line: Line, py36: bool = False) -> Iterator[Line]:
2081:            for omit in generate_trailers_to_omit(line, line_length):
2082:                lines = list(right_hand_split(line, line_length, py36, omit=omit))
2083:                if is_line_short_enough(lines[0], line_length=line_length):
2084:                    yield from lines
2085:                    return
2086:
2087:            # All splits failed, best effort split with no omits.
2088:            # This mostly happens to multiline strings that are by definition
2089:            # reported as not fitting a single line.
2090:            yield from right_hand_split(line, py36)
2091:
2092:        if line.inside_brackets:
2093:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2094:        else:
2095:            split_funcs = [rhs]
2096:    for split_func in split_funcs:
2097:        # We are accumulating lines in `result` because we might want to abort
2098:        # mission and return the original line in the end, or attempt a different
2099:        # split altogether.
2100:        result: List[Line] = []
2101:        try:
2102:            for l in split_func(line, py36):
2103:                if str(l).strip("\n") == line_str:
2104:                    raise CannotSplit("Split function returned an unchanged result")
2105:
2106:                result.extend(
2107:                    split_line(l, line_length=line_length, inner=True, py36=py36)
2108:                )
2109:        except CannotSplit as cs:
2110:            continue
2111:
2112:        else:
2113:            yield from result
2114:            break
2115:
2116:    else:
2117:        yield line
2118:
2119:
2120:def left_hand_split(line: Line, py36: bool = False) -> Iterator[Line]:
2121:    """Split line into many lines, starting with the first matching bracket pair.
2122:
2123:    Note: this usually looks weird, only use this for function definitions.
2124:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2125:    :func:`right_hand_split` which also handles optional parentheses.
2126:    """
2127:    head = Line(depth=line.depth)
2128:    body = Line(depth=line.depth + 1, inside_brackets=True)
2129:    tail = Line(depth=line.depth)
2130:    tail_leaves: List[Leaf] = []
2131:    body_leaves: List[Leaf] = []
2132:    head_leaves: List[Leaf] = []
2133:    current_leaves = head_leaves
2134:    matching_bracket = None
2135:    for leaf in line.leaves:
2136:        if (
2137:            current_leaves is body_leaves
2138:            and leaf.type in CLOSING_BRACKETS
2139:            and leaf.opening_bracket is matching_bracket
2140:        ):
2141:            current_leaves = tail_leaves if body_leaves else head_leaves
2142:        current_leaves.append(leaf)
2143:        if current_leaves is head_leaves:
2144:            if leaf.type in OPENING_BRACKETS:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, split_line() checks `if line.is_comment:` and immediately `yield line` and `return` (lines ~2064-2067), ensuring comment-only lines (including STANDALONE_COMMENT) are not split or reformatted.

Todo item 14 of 18 is correct
description: 'Verify split_line() immediately yields and returns when line.is_comment is True so STANDALONE_COMMENT lines are not split or reformatted.'

Validating todo item 15 of 18
description: 'Verify ALWAYS_NO_SPACE includes STANDALONE_COMMENT to avoid inserting spaces around standalone comment leaves during formatting.'

Calling tool: grepTool
ALWAYS_NO_SPACE
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/empty_lines.py:14:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/empty_lines.py:67:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/empty_lines.py:111:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/empty_lines.py:162:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1713:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1593:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/data/empty_lines.py:14:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/data/empty_lines.py:67:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/data/empty_lines.py:111:    if t in ALWAYS_NO_SPACE:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/data/empty_lines.py:162:    if t in ALWAYS_NO_SPACE:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1558:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1559:        self.visit_try_stmt = partial(
1560:            v, keywords={"try", "except", "else", "finally"}, parens=
1561:        )
1562:        self.visit_except_clause = partial(v, keywords={"except"}, parens=)
1563:        self.visit_with_stmt = partial(v, keywords={"with"}, parens=)
1564:        self.visit_funcdef = partial(v, keywords={"def"}, parens=)
1565:        self.visit_classdef = partial(v, keywords={"class"}, parens=)
1566:        self.visit_expr_stmt = partial(v, keywords=, parens=ASSIGNMENTS)
1567:        self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})
1568:        self.visit_import_from = partial(v, keywords=, parens={"import"})
1569:        self.visit_async_funcdef = self.visit_async_stmt
1570:        self.visit_decorated = self.visit_decorators
1571:
1572:
1573:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
1574:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1575:OPENING_BRACKETS = set(BRACKET.keys())
1576:CLOSING_BRACKETS = set(BRACKET.values())
1577:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1579:
1580:
1581:def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa C901
1582:    """Return whitespace prefix if needed for the given `leaf`.
1583:
1584:    `complex_subscript` signals whether the given leaf is part of a subscription
1585:    which has non-trivial arguments, like arithmetic expressions or function calls.
1586:    """
1587:    NO = ""
1588:    SPACE = " "
1589:    DOUBLESPACE = "  "
1590:    t = leaf.type
1591:    p = leaf.parent
1592:    v = leaf.value
1593:    if t in ALWAYS_NO_SPACE:
1594:        return NO
1595:
1596:    if t == token.COMMENT:
1597:        return DOUBLESPACE
1598:
1599:    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"
1600:    if t == token.COLON and p.type not in {
1601:        syms.subscript,
1602:        syms.subscriptlist,
1603:        syms.sliceop,
1604:    }:
1605:        return NO
1606:
1607:    prev = leaf.prev_sibling
1608:    if not prev:
1609:        prevp = preceding_leaf(p)
1610:        if not prevp or prevp.type in OPENING_BRACKETS:
1611:            return NO
1612:
1613:        if t == token.COLON:
1614:            if prevp.type == token.COLON:
1615:                return NO
1616:
1617:            elif prevp.type != token.COMMA and not complex_subscript:
1618:                return NO
1619:
1620:            return SPACE
1621:
1622:        if prevp.type == token.EQUAL:
1623:            if prevp.parent:
1624:                if prevp.parent.type in {
1625:                    syms.arglist,
1626:                    syms.argument,
1627:                    syms.parameters,
1628:                    syms.varargslist,
1629:                }:

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:757:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1126:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1196:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1207:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1578:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2021:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2357:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2574:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2601:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:2878:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:784:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1068:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1078:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1153:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1223:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1234:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1698:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2105:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2113:            if pc.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2123:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2148:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2484:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2723:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:2996:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
730:            out(f" {node.value!r}", fg="blue", bold=False)
731:
732:    @classmethod
733:    def show(cls, code: Union[str, Leaf, Node]) -> None:
734:        """Pretty-print the lib2to3 AST of a given string of `code`.
735:
736:        Convenience method for debugging.
737:        """
738:        v: DebugVisitor[None] = DebugVisitor()
739:        if isinstance(code, str):
740:            code = lib2to3_parse(code)
741:        list(v.visit(code))
742:
743:
744:KEYWORDS = set(keyword.kwlist)
745:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
746:FLOW_CONTROL = {"return", "raise", "break", "continue"}
747:STATEMENT = {
748:    syms.if_stmt,
749:    syms.while_stmt,
750:    syms.for_stmt,
751:    syms.try_stmt,
752:    syms.except_clause,
753:    syms.with_stmt,
754:    syms.funcdef,
755:    syms.classdef,
756:}
757:STANDALONE_COMMENT = 153
758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
759:LOGIC_OPERATORS = {"and", "or"}
760:COMPARATORS = {
761:    token.LESS,
762:    token.GREATER,
763:    token.EQEQUAL,
764:    token.NOTEQUAL,
765:    token.LESSEQUAL,
766:    token.GREATEREQUAL,
767:}
768:MATH_OPERATORS = {
769:    token.VBAR,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1960:
1961:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
1962:        return LOGIC_PRIORITY
1963:
1964:    return 0
1965:
1966:
1967:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
1968:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
1969:
1970:
1971:def generate_comments(leaf: LN) -> Iterator[Leaf]:
1972:    """Clean the prefix of the `leaf` and generate comments from it, if any.
1973:
1974:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
1975:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
1976:    move because it does away with modifying the grammar to include all the
1977:    possible places in which comments can be placed.
1978:
1979:    The sad consequence for us though is that comments don't "belong" anywhere.
1980:    This is why this function generates simple parentless Leaf objects for
1981:    comments.  We simply don't know what the correct parent should be.
1982:
1983:    No matter though, we can live without this.  We really only need to
1984:    differentiate between inline and standalone comments.  The latter don't
1985:    share the line with any code.
1986:
1987:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
1988:    are emitted with a fake STANDALONE_COMMENT token identifier.
1989:    """
1990:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
1991:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
1992:
1993:
1994:@dataclass
1995:class ProtoComment:
1996:    type: int  # token.COMMENT or STANDALONE_COMMENT
1997:    value: str  # content of the comment
1998:    newlines: int  # how many newlines before the comment
1999:    consumed: int  # how many characters of the original leaf's prefix did we consume
2000:
2001:
2002:@lru_cache(maxsize=4096)
2003:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2004:    result: List[ProtoComment] = []
2005:    if not prefix or "#" not in prefix:
2006:        return result
2007:
2008:    consumed = 0
2009:    nlines = 0
2010:    for index, line in enumerate(prefix.split("\n")):
2011:        consumed += len(line) + 1  # adding the length of the split '\n'
2012:        line = line.lstrip()
2013:        if not line:
2014:            nlines += 1
2015:        if not line.startswith("#"):
2016:            continue
2017:
2018:        if index == 0 and not is_endmarker:
2019:            comment_type = token.COMMENT  # simple trailing comment
2020:        else:
2021:            comment_type = STANDALONE_COMMENT
2022:        comment = make_comment(line)
2023:        result.append(
2024:            ProtoComment(
2025:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2026:            )
2027:        )
2028:        nlines = 0
2029:    return result
2030:
2031:
2032:def make_comment(content: str) -> str:
2033:    """Return a consistently formatted comment from the given `content` string.
2034:
2035:    All comments (except for "##", "#!", "#:") should have a single space between
2036:    the hash sign and the content.
2037:
2038:    If `content` didn't start with a hash sign, one is provided.
2039:    """

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, ALWAYS_NO_SPACE is defined as CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT} (see around line 1578). The whitespace() function checks `if t in ALWAYS_NO_SPACE: return ""` (lines ~1591-1594), ensuring no spaces are inserted around STANDALONE_COMMENT leaves. This satisfies the requirement.

Todo item 15 of 18 is correct
description: 'Verify ALWAYS_NO_SPACE includes STANDALONE_COMMENT to avoid inserting spaces around standalone comment leaves during formatting.'

Validating todo item 16 of 18
description: 'Verify EmptyLineTracker._maybe_empty_lines_for_class_or_def() has logic to avoid adding blank lines when previous_line.is_comment, at the same depth, and 'before' is 0; this should prevent extra lines between functions following a STANDALONE_COMMENT block.'

Calling tool: grepTool
class EmptyLineTracker
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1359:class EmptyLineTracker:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1283:class EmptyLineTracker:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1260:        )
1261:
1262:    def __str__(self) -> str:
1263:        """Render the line."""
1264:        if not self:
1265:            return "\n"
1266:
1267:        indent = "    " * self.depth
1268:        leaves = iter(self.leaves)
1269:        first = next(leaves)
1270:        res = f"{first.prefix}{indent}{first.value}"
1271:        for leaf in leaves:
1272:            res += str(leaf)
1273:        for _, comment in self.comments:
1274:            res += str(comment)
1275:        return res + "\n"
1276:
1277:    def __bool__(self) -> bool:
1278:        """Return True if the line has leaves or comments."""
1279:        return bool(self.leaves or self.comments)
1280:
1281:
1282:@dataclass
1283:class EmptyLineTracker:
1284:    """Provides a stateful method that returns the number of potential extra
1285:    empty lines needed before and after the currently processed line.
1286:
1287:    Note: this tracker works on lines that haven't been split yet.  It assumes
1288:    the prefix of the first leaf consists of optional newlines.  Those newlines
1289:    are consumed by `maybe_empty_lines()` and included in the computation.
1290:    """
1291:
1292:    is_pyi: bool = False
1293:    previous_line: Optional[Line] = None
1294:    previous_after: int = 0
1295:    previous_defs: List[int] = Factory(list)
1296:
1297:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1298:        """Return the number of extra empty lines before and after the `current_line`.
1299:
1300:        This is for separating `def`, `async def` and `class` with extra empty
1301:        lines (two on module-level).
1302:        """
1303:        before, after = self._maybe_empty_lines(current_line)
1304:        before -= self.previous_after
1305:        self.previous_after = after
1306:        self.previous_line = current_line
1307:        return before, after
1308:
1309:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1310:        max_allowed = 1
1311:        if current_line.depth == 0:
1312:            max_allowed = 1 if self.is_pyi else 2
1313:        if current_line.leaves:
1314:            # Consume the first leaf's extra newlines.
1315:            first_leaf = current_line.leaves[0]
1316:            before = first_leaf.prefix.count("\n")
1317:            before = min(before, max_allowed)
1318:            first_leaf.prefix = ""
1319:        else:
1320:            before = 0
1321:        depth = current_line.depth
1322:        while self.previous_defs and self.previous_defs[-1] >= depth:
1323:            self.previous_defs.pop()
1324:            if self.is_pyi:
1325:                before = 0 if depth else 1
1326:            else:
1327:                before = 1 if depth else 2
1328:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
1329:            return self._maybe_empty_lines_for_class_or_def(current_line, before)
1330:
1331:        if (
1332:            self.previous_line
1333:            and self.previous_line.is_import
1334:            and not current_line.is_import
1335:            and depth == self.previous_line.depth
1336:        ):
1337:            return (before or 1), 0
1338:
1339:        if (
1340:            self.previous_line
1341:            and self.previous_line.is_class
1342:            and current_line.is_triple_quoted_string
1343:        ):
1344:            return before, 1
1345:
1346:        return before, 0
1347:
1348:    def _maybe_empty_lines_for_class_or_def(
1349:        self, current_line: Line, before: int
1350:    ) -> Tuple[int, int]:
1351:        if not current_line.is_decorator:
1352:            self.previous_defs.append(current_line.depth)
1353:        if self.previous_line is None:
1354:            # Don't insert empty lines before the first line in the file.
1355:            return 0, 0
1356:
1357:        if self.previous_line.is_decorator:
1358:            return 0, 0
1359:
1360:        if self.previous_line.depth < current_line.depth and (
1361:            self.previous_line.is_class or self.previous_line.is_def
1362:        ):
1363:            return 0, 0
1364:
1365:        if (
1366:            self.previous_line.is_comment
1367:            and self.previous_line.depth == current_line.depth
1368:            and before == 0
1369:        ):
1370:            return 0, 0
1371:
1372:        if self.is_pyi:
1373:            if self.previous_line.depth > current_line.depth:
1374:                newlines = 1
1375:            elif current_line.is_class or self.previous_line.is_class:
1376:                if current_line.is_stub_class and self.previous_line.is_stub_class:
1377:                    # No blank line between classes with an emty body
1378:                    newlines = 0
1379:                else:
1380:                    newlines = 1
1381:            elif current_line.is_def and not self.previous_line.is_def:
1382:                # Blank line between a block of functions and a block of non-functions
1383:                newlines = 1
1384:            else:
1385:                newlines = 0
1386:        else:
1387:            newlines = 2
1388:        if current_line.depth and newlines:
1389:            newlines -= 1
1390:        return newlines, 0
1391:
1392:
1393:@dataclass
1394:class LineGenerator(Visitor[Line]):
1395:    """Generates reformatted Line objects.  Empty lines are not emitted.
1396:
1397:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
1398:    in ways that will no longer stringify to valid Python code on the tree.
1399:    """
1400:
1401:    is_pyi: bool = False
1402:    normalize_strings: bool = True
1403:    current_line: Line = Factory(Line)
1404:    remove_u_prefix: bool = False
1405:
1406:    def line(self, indent: int = 0) -> Iterator[Line]:
1407:        """Generate a line.
1408:
1409:        If the line is empty, only emit if it makes sense.
1410:        If the line is too long, split it first and then generate.
1411:
1412:        If any lines were generated, set up a new current_line.
1413:        """
1414:        if not self.current_line:
1415:            self.current_line.depth += indent
1416:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1417:
1418:        complete_line = self.current_line
1419:        self.current_line = Line(depth=complete_line.depth + indent)
1420:        yield complete_line
1421:
1422:    def visit_default(self, node: LN) -> Iterator[Line]:
1423:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1424:        if isinstance(node, Leaf):
1425:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1426:            for comment in generate_comments(node):
1427:                if any_open_brackets:
1428:                    # any comment within brackets is subject to splitting
1429:                    self.current_line.append(comment)
1430:                elif comment.type == token.COMMENT:
1431:                    # regular trailing comment
1432:                    self.current_line.append(comment)
1433:                    yield from self.line()
1434:
1435:                else:
1436:                    # regular standalone comment
1437:                    yield from self.line()
1438:
1439:                    self.current_line.append(comment)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1440:                    yield from self.line()
1441:
1442:            normalize_prefix(node, inside_brackets=any_open_brackets)
1443:            if self.normalize_strings and node.type == token.STRING:
1444:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1445:                normalize_string_quotes(node)
1446:            if node.type not in WHITESPACE:
1447:                self.current_line.append(node)
1448:        yield from super().visit_default(node)
1449:
1450:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1451:        """Increase indentation level, maybe yield a line."""
1452:        # In blib2to3 INDENT never holds comments.
1453:        yield from self.line(+1)
1454:        yield from self.visit_default(node)
1455:
1456:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1457:        """Decrease indentation level, maybe yield a line."""
1458:        # The current line might still wait for trailing comments.  At DEDENT time
1459:        # there won't be any (they would be prefixes on the preceding NEWLINE).
1460:        # Emit the line then.
1461:        yield from self.line()
1462:
1463:        # While DEDENT has no value, its prefix may contain standalone comments
1464:        # that belong to the current indentation level.  Get 'em.
1465:        yield from self.visit_default(node)
1466:
1467:        # Finally, emit the dedent.
1468:        yield from self.line(-1)
1469:
1470:    def visit_stmt(
1471:        self, node: Node, keywords: Set[str], parens: Set[str]
1472:    ) -> Iterator[Line]:
1473:        """Visit a statement.
1474:
1475:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1476:        `def`, `with`, `class`, `assert` and assignments.
1477:
1478:        The relevant Python language `keywords` for a given statement will be
1479:        NAME leaves within it. This methods puts those on a separate line.
1480:
1481:        `parens` holds a set of string leaf values immediately after which
1482:        invisible parens should be put.
1483:        """
1484:        normalize_invisible_parens(node, parens_after=parens)
1485:        for child in node.children:
1486:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1487:                yield from self.line()
1488:
1489:            yield from self.visit(child)
1490:
1491:    def visit_suite(self, node: Node) -> Iterator[Line]:
1492:        """Visit a suite."""
1493:        if self.is_pyi and is_stub_suite(node):
1494:            yield from self.visit(node.children[2])
1495:        else:
1496:            yield from self.visit_default(node)
1497:
1498:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1499:        """Visit a statement without nested statements."""
1500:        is_suite_like = node.parent and node.parent.type in STATEMENT
1501:        if is_suite_like:
1502:            if self.is_pyi and is_stub_body(node):
1503:                yield from self.visit_default(node)
1504:            else:
1505:                yield from self.line(+1)
1506:                yield from self.visit_default(node)
1507:                yield from self.line(-1)
1508:
1509:        else:
1510:            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):
1511:                yield from self.line()
1512:            yield from self.visit_default(node)
1513:
1514:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:
1515:        """Visit `async def`, `async for`, `async with`."""
1516:        yield from self.line()
1517:
1518:        children = iter(node.children)
1519:        for child in children:
1520:            yield from self.visit(child)
1521:
1522:            if child.type == token.ASYNC:
1523:                break
1524:
1525:        internal_stmt = next(children)
1526:        for child in internal_stmt.children:
1527:            yield from self.visit(child)
1528:
1529:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1530:        """Visit decorators."""
1531:        for child in node.children:
1532:            yield from self.line()
1533:            yield from self.visit(child)
1534:
1535:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1536:        """Remove a semicolon and put the other statement on a separate line."""
1537:        yield from self.line()
1538:
1539:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1540:        """End of file. Process outstanding comments and end with a newline."""
1541:        yield from self.visit_default(leaf)
1542:        yield from self.line()
1543:
1544:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1545:        if not self.current_line.bracket_tracker.any_open_brackets():
1546:            yield from self.line()
1547:        yield from self.visit_default(leaf)
1548:
1549:    def __attrs_post_init__(self) -> None:
1550:        """You are in a twisty little maze of passages."""
1551:        v = self.visit_stmt
1552:        : Set[str] = set()
1553:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1554:        self.visit_if_stmt = partial(
1555:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1556:        )
1557:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1558:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1559:        self.visit_try_stmt = partial(

Calling tool: grepTool
def is_comment|@property\s+def is_comment|is_comment\b
Matched content:
1038:            if self.is_comment:
1049:    def is_comment(self) -> bool:
1366:            self.previous_line.is_comment
2064:    if line.is_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1000:    inside_brackets: bool = False
1001:    should_explode: bool = False
1002:
1003:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1004:        """Add a new `leaf` to the end of the line.
1005:
1006:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1007:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1008:        Trailing commas are maybe removed, unpacked for loop variables are
1009:        demoted from being delimiters.
1010:
1011:        Inline comments are put aside.
1012:        """
1013:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1014:        if not has_value:
1015:            return
1016:
1017:        if token.COLON == leaf.type and self.is_class_paren_empty:
1018:            del self.leaves[-2:]
1019:        if self.leaves and not preformatted:
1020:            # Note: at this point leaf.prefix should be empty except for
1021:            # imports, for which we only preserve newlines.
1022:            leaf.prefix += whitespace(
1023:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1024:            )
1025:        if self.inside_brackets or not preformatted:
1026:            self.bracket_tracker.mark(leaf)
1027:            self.maybe_remove_trailing_comma(leaf)
1028:        if not self.append_comment(leaf):
1029:            self.leaves.append(leaf)
1030:
1031:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1032:        """Like :func:`append()` but disallow invalid standalone comment structure.
1033:
1034:        Raises ValueError when any `leaf` is appended after a standalone comment
1035:        or when a standalone comment is not the first leaf on the line.
1036:        """
1037:        if self.bracket_tracker.depth == 0:
1038:            if self.is_comment:
1039:                raise ValueError("cannot append to standalone comments")
1040:
1041:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1042:                raise ValueError(
1043:                    "cannot append standalone comments to a populated line"
1044:                )
1045:
1046:        self.append(leaf, preformatted=preformatted)
1047:
1048:    @property
1049:    def is_comment(self) -> bool:
1050:        """Is this line a standalone comment?"""
1051:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1052:
1053:    @property
1054:    def is_decorator(self) -> bool:
1055:        """Is this line a decorator?"""
1056:        return bool(self) and self.leaves[0].type == token.AT
1057:
1058:    @property
1059:    def is_import(self) -> bool:
1060:        """Is this an import line?"""
1061:        return bool(self) and is_import(self.leaves[0])
1062:
1063:    @property
1064:    def is_class(self) -> bool:
1065:        """Is this line a class definition?"""
1066:        return (
1067:            bool(self)
1068:            and self.leaves[0].type == token.NAME
1069:            and self.leaves[0].value == "class"
1070:        )
1071:
1072:    @property
1073:    def is_stub_class(self) -> bool:
1074:        """Is this line a class definition with a body consisting only of "..."?"""
1075:        return self.is_class and self.leaves[-3:] == [
1076:            Leaf(token.DOT, ".") for _ in range(3)
1077:        ]
1078:
1079:    @property

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, EmptyLineTracker._maybe_empty_lines_for_class_or_def() contains a condition (lines ~1365-1371) that returns (0, 0) when the previous line is a standalone comment at the same depth and before == 0, satisfying the requirement to avoid extra blank lines between functions after a STANDALONE_COMMENT block.

Todo item 16 of 18 is correct
description: 'Verify EmptyLineTracker._maybe_empty_lines_for_class_or_def() has logic to avoid adding blank lines when previous_line.is_comment, at the same depth, and 'before' is 0; this should prevent extra lines between functions following a STANDALONE_COMMENT block.'

Validating todo item 17 of 18
description: 'Confirm that container_of() includes an early break when parent.type == syms.file_input to prevent fmt: off conversion from spanning the entire file and crossing module-level boundaries.'

Calling tool: grepTool
def container_of\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:1837:def container_of(leaf: Leaf) -> LN:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:1957:def container_of(leaf: Leaf) -> LN:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1820:                return list(res.leaves())[-1]
1821:
1822:            except IndexError:
1823:                return None
1824:
1825:        node = node.parent
1826:    return None
1827:
1828:
1829:def child_towards(ancestor: Node, descendant: LN) -> Optional[LN]:
1830:    """Return the child of `ancestor` that contains `descendant`."""
1831:    node: Optional[LN] = descendant
1832:    while node and node.parent != ancestor:
1833:        node = node.parent
1834:    return node
1835:
1836:
1837:def container_of(leaf: Leaf) -> LN:
1838:    """Return `leaf` or one of its ancestors that is the topmost container of it.
1839:
1840:    By "container" we mean a node where `leaf` is the very first child.
1841:    """
1842:    same_prefix = leaf.prefix
1843:    container: LN = leaf
1844:    while container:
1845:        parent = container.parent
1846:        if parent is None:
1847:            break
1848:
1849:        if parent.children[0].prefix != same_prefix:
1850:            break
1851:
1852:        if parent.type == syms.file_input:
1853:            break
1854:
1855:        if parent.type in SURROUNDED_BY_BRACKETS:
1856:            break
1857:
1858:        container = parent
1859:    return container
1860:
1861:
1862:def is_split_after_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1863:    """Return the priority of the `leaf` delimiter, given a line break after it.
1864:
1865:    The delimiter priorities returned here are from those delimiters that would
1866:    cause a line break after themselves.
1867:
1868:    Higher numbers are higher priority.
1869:    """
1870:    if leaf.type == token.COMMA:
1871:        return COMMA_PRIORITY
1872:
1873:    return 0
1874:
1875:
1876:def is_split_before_delimiter(leaf: Leaf, previous: Leaf = None) -> int:
1877:    """Return the priority of the `leaf` delimiter, given a line before after it.
1878:
1879:    The delimiter priorities returned here are from those delimiters that would
1880:    cause a line break before themselves.
1881:
1882:    Higher numbers are higher priority.
1883:    """
1884:    if is_vararg(leaf, within=VARARGS_PARENTS | UNPACKING_PARENTS):
1885:        # * and ** might also be MATH_OPERATORS but in this case they are not.
1886:        # Don't treat them as a delimiter.
1887:        return 0
1888:
1889:    if (
1890:        leaf.type == token.DOT
1891:        and leaf.parent
1892:        and leaf.parent.type not in {syms.import_from, syms.dotted_name}
1893:        and (previous is None or previous.type in CLOSING_BRACKETS)
1894:    ):
1895:        return DOT_PRIORITY
1896:
1897:    if (
1898:        leaf.type in MATH_OPERATORS
1899:        and leaf.parent

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py, function container_of() includes an early break for parent.type == syms.file_input (lines ~1852-1854), ensuring fmt: off conversion does not cross the module-level boundary.

Todo item 17 of 18 is correct
description: 'Confirm that container_of() includes an early break when parent.type == syms.file_input to prevent fmt: off conversion from spanning the entire file and crossing module-level boundaries.'

Validating todo item 18 of 18
description: 'Optionally spot-check that DebugVisitor.show() accepts Union[str, Leaf, Node] and handles Node/Leaf by not reparsing, consistent with updated signature (non-critical to fmt off behavior but part of diff).'

Calling tool: grepTool
class DebugVisitor
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:709:class DebugVisitor(Visitor[T]):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:738:class DebugVisitor(Visitor[T]):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/tests/data/debug_visitor.py:2:class DebugVisitor(Visitor[T]):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/tests/data/debug_visitor.py:2:class DebugVisitor(Visitor[T]):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
700:
701:    def visit_default(self, node: LN) -> Iterator[T]:
702:        """Default `visit_*()` implementation. Recurses to children of `node`."""
703:        if isinstance(node, Node):
704:            for child in node.children:
705:                yield from self.visit(child)
706:
707:
708:@dataclass
709:class DebugVisitor(Visitor[T]):
710:    tree_depth: int = 0
711:
712:    def visit_default(self, node: LN) -> Iterator[T]:
713:        indent = " " * (2 * self.tree_depth)
714:        if isinstance(node, Node):
715:            _type = type_repr(node.type)
716:            out(f"{indent}{_type}", fg="yellow")
717:            self.tree_depth += 1
718:            for child in node.children:
719:                yield from self.visit(child)
720:
721:            self.tree_depth -= 1
722:            out(f"{indent}/{_type}", fg="yellow", bold=False)
723:        else:
724:            _type = token.tok_name.get(node.type, str(node.type))
725:            out(f"{indent}{_type}", fg="blue", nl=False)
726:            if node.prefix:
727:                # We don't have to handle prefixes for `Node` objects since
728:                # that delegates to the first child anyway.
729:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
730:            out(f" {node.value!r}", fg="blue", bold=False)
731:
732:    @classmethod
733:    def show(cls, code: Union[str, Leaf, Node]) -> None:
734:        """Pretty-print the lib2to3 AST of a given string of `code`.
735:
736:        Convenience method for debugging.
737:        """
738:        v: DebugVisitor[None] = DebugVisitor()
739:        if isinstance(code, str):
740:            code = lib2to3_parse(code)
741:        list(v.visit(code))
742:
743:
744:KEYWORDS = set(keyword.kwlist)
745:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
746:FLOW_CONTROL = {"return", "raise", "break", "continue"}
747:STATEMENT = {
748:    syms.if_stmt,
749:    syms.while_stmt,
750:    syms.for_stmt,
751:    syms.try_stmt,
752:    syms.except_clause,
753:    syms.with_stmt,
754:    syms.funcdef,
755:    syms.classdef,
756:}
757:STANDALONE_COMMENT = 153
758:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
759:LOGIC_OPERATORS = {"and", "or"}
760:COMPARATORS = {
761:    token.LESS,
762:    token.GREATER,
763:    token.EQEQUAL,
764:    token.NOTEQUAL,
765:    token.LESSEQUAL,
766:    token.GREATEREQUAL,
767:}
768:MATH_OPERATORS = {
769:    token.VBAR,
770:    token.CIRCUMFLEX,
771:    token.AMPER,
772:    token.LEFTSHIFT,
773:    token.RIGHTSHIFT,
774:    token.PLUS,
775:    token.MINUS,
776:    token.STAR,
777:    token.SLASH,
778:    token.DOUBLESLASH,
779:    token.PERCENT,

Calling tool: grepTool
LN\s*=\s*Union\[
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:67:LN = Union[Leaf, Node]
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:68:LN = Union[Leaf, Node]

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum, Flag
6:from functools import lru_cache, partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tokenize
18:from typing import (
19:    Any,
20:    Callable,
21:    Collection,
22:    Dict,
23:    Generic,
24:    Iterable,
25:    Iterator,
26:    List,
27:    Optional,
28:    Pattern,
29:    Sequence,
30:    Set,
31:    Tuple,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:import toml
41:
42:# lib2to3 fork
43:from blib2to3.pytree import Node, Leaf, type_repr
44:from blib2to3 import pygram, pytree
45:from blib2to3.pgen2 import driver, token
46:from blib2to3.pgen2.parse import ParseError
47:
48:
49:__version__ = "18.6b2"
50:DEFAULT_LINE_LENGTH = 88
51:DEFAULT_EXCLUDES = (
52:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
53:)
54:DEFAULT_INCLUDES = r"\.pyi?$"
55:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
56:
57:
58:# types
59:FileContent = str
60:Encoding = str
61:NewLine = str
62:Depth = int
63:NodeType = int
64:LeafID = int
65:Priority = int
66:Index = int
67:LN = Union[Leaf, Node]
68:SplitFunc = Callable[["Line", bool], Iterator["Line"]]
69:Timestamp = float
70:FileSize = int
71:CacheInfo = Tuple[Timestamp, FileSize]
72:Cache = Dict[Path, CacheInfo]
73:out = partial(click.secho, bold=True, err=True)
74:err = partial(click.secho, fg="red", err=True)
75:
76:pygram.initialize(CACHE_DIR)
77:syms = pygram.python_symbols
78:
79:
80:class NothingChanged(UserWarning):
81:    """Raised by :func:`format_file` when reformatted code is the same as source."""
82:
83:
84:class CannotSplit(Exception):
85:    """A readable split that fits the allotted line length is impossible.
86:
87:    Raised by :func:`left_hand_split`, :func:`right_hand_split`, and
88:    :func:`delimiter_split`.
89:    """
90:
91:
92:class WriteBack(Enum):
93:    NO = 0
94:    YES = 1
95:    DIFF = 2
96:
97:    @classmethod
98:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
99:        if check and not diff:
100:            return cls.NO
101:
102:        return cls.DIFF if diff else cls.YES
103:
104:
105:class Changed(Enum):
106:    NO = 0
107:    CACHED = 1
108:    YES = 2
109:
110:
111:class FileMode(Flag):
112:    AUTO_DETECT = 0
113:    PYTHON36 = 1
114:    PYI = 2
115:    NO_STRING_NORMALIZATION = 4
116:
117:    @classmethod
118:    def from_configuration(
119:        cls, *, py36: bool, pyi: bool, skip_string_normalization: bool
120:    ) -> "FileMode":

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py
730:    def visit_default(self, node: LN) -> Iterator[T]:
731:        """Default `visit_*()` implementation. Recurses to children of `node`."""
732:        if isinstance(node, Node):
733:            for child in node.children:
734:                yield from self.visit(child)
735:
736:
737:@dataclass
738:class DebugVisitor(Visitor[T]):
739:    tree_depth: int = 0
740:
741:    def visit_default(self, node: LN) -> Iterator[T]:
742:        indent = " " * (2 * self.tree_depth)
743:        if isinstance(node, Node):
744:            _type = type_repr(node.type)
745:            out(f"{indent}{_type}", fg="yellow")
746:            self.tree_depth += 1
747:            for child in node.children:
748:                yield from self.visit(child)
749:
750:            self.tree_depth -= 1
751:            out(f"{indent}/{_type}", fg="yellow", bold=False)
752:        else:
753:            _type = token.tok_name.get(node.type, str(node.type))
754:            out(f"{indent}{_type}", fg="blue", nl=False)
755:            if node.prefix:
756:                # We don't have to handle prefixes for `Node` objects since
757:                # that delegates to the first child anyway.
758:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
759:            out(f" {node.value!r}", fg="blue", bold=False)
760:
761:    @classmethod
762:    def show(cls, code: str) -> None:
763:        """Pretty-print the lib2to3 AST of a given string of `code`.
764:
765:        Convenience method for debugging.
766:        """
767:        v: DebugVisitor[None] = DebugVisitor()
768:        list(v.visit(lib2to3_parse(code)))
769:
770:
771:KEYWORDS = set(keyword.kwlist)
772:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
773:FLOW_CONTROL = {"return", "raise", "break", "continue"}
774:STATEMENT = {
775:    syms.if_stmt,
776:    syms.while_stmt,
777:    syms.for_stmt,
778:    syms.try_stmt,
779:    syms.except_clause,
780:    syms.with_stmt,
781:    syms.funcdef,
782:    syms.classdef,
783:}
784:STANDALONE_COMMENT = 153
785:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
786:LOGIC_OPERATORS = {"and", "or"}
787:COMPARATORS = {
788:    token.LESS,
789:    token.GREATER,
790:    token.EQEQUAL,
791:    token.NOTEQUAL,
792:    token.LESSEQUAL,
793:    token.GREATEREQUAL,
794:}
795:MATH_OPERATORS = {
796:    token.VBAR,
797:    token.CIRCUMFLEX,
798:    token.AMPER,
799:    token.LEFTSHIFT,
800:    token.RIGHTSHIFT,
801:    token.PLUS,
802:    token.MINUS,
803:    token.STAR,
804:    token.SLASH,
805:    token.DOUBLESLASH,
806:    token.PERCENT,
807:    token.AT,
808:    token.TILDE,
809:    token.DOUBLESTAR,

Calling tool: grepTool
def lib2to3_parse\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py:646:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/env/src/black/black.py:675:def lib2to3_parse(src_txt: str) -> Node:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-15/good/black/black.py
640:    pygram.python_grammar_no_print_statement_no_exec_statement,
641:    pygram.python_grammar_no_print_statement,
642:    pygram.python_grammar,
643:]
644:
645:
646:def lib2to3_parse(src_txt: str) -> Node:
647:    """Given a string with source, return the lib2to3 Node."""
648:    grammar = pygram.python_grammar_no_print_statement
649:    if src_txt[-1:] != "\n":
650:        src_txt += "\n"
651:    for grammar in GRAMMARS:
652:        drv = driver.Driver(grammar, pytree.convert)
653:        try:
654:            result = drv.parse_string(src_txt, True)
655:            break
656:
657:        except ParseError as pe:
658:            lineno, column = pe.context[1]
659:            lines = src_txt.splitlines()

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py, DebugVisitor.show signature is updated to Union[str, Leaf, Node] and only calls lib2to3_parse if code is str; for Node/Leaf it passes directly to visit(), thus avoiding reparsing.

Todo item 18 of 18 is correct
description: 'Optionally spot-check that DebugVisitor.show() accepts Union[str, Leaf, Node] and handles Node/Leaf by not reparsing, consistent with updated signature (non-critical to fmt off behavior but part of diff).'


=== PHASE 2 COMPLETE ===

