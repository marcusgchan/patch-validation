=== PHASE 1: ANALYSIS ===

[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_preserves_line_endings",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_file_in_place\\(|def prepare_input\\(|def format_stdin_to_stdout\\(|def lib2to3_parse\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_file_in_place\\(|def prepare_input\\(|def format_stdin_to_stdout\\(|def lib2to3_parse\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "^import io$", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "\\bff\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "from typing import .*Tuple",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "from typing import",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py"
]
Calling tool: grepTool
test_preserves_line_endings
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:1113:    def test_preserves_line_endings(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py
1100:        this_abs = THIS_DIR.resolve()
1101:        sources.extend(
1102:            black.gen_python_files_in_dir(
1103:                path, this_abs, re.compile(black.DEFAULT_INCLUDES), empty, report
1104:            )
1105:        )
1106:        self.assertEqual(sorted(expected), sorted(sources))
1107:
1108:    def test_invalid_include_exclude(self) -> None:
1109:        for option in ["--include", "--exclude"]:
1110:            result = CliRunner().invoke(black.main, ["-", option, "**()(!!*)"])
1111:            self.assertEqual(result.exit_code, 2)
1112:
1113:    def test_preserves_line_endings(self) -> None:
1114:        with TemporaryDirectory() as workspace:
1115:            test_file = Path(workspace) / "test.py"
1116:            for nl in ["\n", "\r\n"]:
1117:                contents = nl.join(["def f(  ):", "    pass"])
1118:                test_file.write_bytes(contents.encode())
1119:                ff(test_file, write_back=black.WriteBack.YES)
1120:                updated_contents: bytes = test_file.read_bytes()
1121:                self.assertIn(nl.encode(), updated_contents)  # type: ignore
1122:                if nl == "\n":
1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore
1124:
1125:
1126:if __name__ == "__main__":
1127:    unittest.main()

Calling tool: grepTool
def format_file_in_place\(|def prepare_input\(|def format_stdin_to_stdout\(|def lib2to3_parse\(
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/bad/black: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/bad/black: No such file or directory (os error 2)


Calling tool: grepTool
def format_file_in_place\(|def prepare_input\(|def format_stdin_to_stdout\(|def lib2to3_parse\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:494:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:589:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:503:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:625:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:494:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:589:def lib2to3_parse(src_txt: str) -> Node:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
430:        pending: Iterable[asyncio.Task] = tasks.keys()
431:        try:
432:            loop.add_signal_handler(signal.SIGINT, cancel, pending)
433:            loop.add_signal_handler(signal.SIGTERM, cancel, pending)
434:        except NotImplementedError:
435:            # There are no good alternatives for these on Windows
436:            pass
437:        while pending:
438:            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
439:            for task in done:
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """
580:    src_node = lib2to3_parse(src_contents)
581:    dst_contents = ""
582:    future_imports = get_future_imports(src_node)
583:    is_pyi = bool(mode & FileMode.PYI)
584:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
585:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
586:    lines = LineGenerator(
587:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
588:        is_pyi=is_pyi,
589:        normalize_strings=normalize_strings,
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`

Calling tool: grepTool
^import io$
Matched content:
7:import io

Calling tool: grepTool
\bff\(
Matched content:
109:        self.assertFalse(ff(THIS_FILE))
118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
163:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
193:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
210:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.DIFF))
1119:                ff(test_file, write_back=black.WriteBack.YES)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import sys
10:from tempfile import TemporaryDirectory
11:from typing import Any, List, Tuple, Iterator
12:import unittest
13:from unittest.mock import patch
14:import re
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:ll = 88
22:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
23:fs = partial(black.format_str, line_length=ll)
24:THIS_FILE = Path(__file__)
25:THIS_DIR = THIS_FILE.parent
26:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
27:
28:
29:def dump_to_stderr(*output: str) -> str:
30:    return "\n" + "\n".join(output) + "\n"
31:
32:
33:def read_data(name: str) -> Tuple[str, str]:
34:    """read_data('test_name') -> 'input', 'output'"""
35:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
36:        name += ".py"
37:    _input: List[str] = []
38:    _output: List[str] = []
39:    with open(THIS_DIR / name, "r", encoding="utf8") as test:
40:        lines = test.readlines()
41:    result = _input
42:    for line in lines:
43:        line = line.replace(EMPTY_LINE, "")
44:        if line.rstrip() == "# output":
45:            result = _output
46:            continue
47:
48:        result.append(line)
49:    if _input and not _output:
50:        # If there's no output marker, treat the entire file as already pre-formatted.
51:        _output = _input[:]
52:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
53:
54:
55:@contextmanager
56:def cache_dir(exists: bool = True) -> Iterator[Path]:
57:    with TemporaryDirectory() as workspace:
58:        cache_dir = Path(workspace)
59:        if not exists:
60:            cache_dir = cache_dir / "new"
61:        with patch("black.CACHE_DIR", cache_dir):
62:            yield cache_dir
63:
64:
65:@contextmanager
66:def event_loop(close: bool) -> Iterator[None]:
67:    policy = asyncio.get_event_loop_policy()
68:    old_loop = policy.get_event_loop()
69:    loop = policy.new_event_loop()
70:    asyncio.set_event_loop(loop)
71:    try:
72:        yield
73:
74:    finally:
75:        policy.set_event_loop(old_loop)
76:        if close:
77:            loop.close()
78:
79:
80:class BlackTestCase(unittest.TestCase):
81:    maxDiff = None
82:
83:    def assertFormatEqual(self, expected: str, actual: str) -> None:
84:        if actual != expected and not os.environ.get("SKIP_AST_PRINT"):
85:            bdv: black.DebugVisitor[Any]
86:            black.out("Expected tree:", fg="green")
87:            try:
88:                exp_node = black.lib2to3_parse(expected)
89:                bdv = black.DebugVisitor()
90:                list(bdv.visit(exp_node))
91:            except Exception as ve:
92:                black.err(str(ve))
93:            black.out("Actual tree:", fg="red")
94:            try:
95:                exp_node = black.lib2to3_parse(actual)
96:                bdv = black.DebugVisitor()
97:                list(bdv.visit(exp_node))
98:            except Exception as ve:
99:                black.err(str(ve))
100:        self.assertEqual(expected, actual)
101:
102:    @patch("black.dump_to_file", dump_to_stderr)
103:    def test_self(self) -> None:
104:        source, expected = read_data("test_black")
105:        actual = fs(source)
106:        self.assertFormatEqual(expected, actual)
107:        black.assert_equivalent(source, actual)
108:        black.assert_stable(source, actual, line_length=ll)
109:        self.assertFalse(ff(THIS_FILE))
110:
111:    @patch("black.dump_to_file", dump_to_stderr)
112:    def test_black(self) -> None:
113:        source, expected = read_data("../black")
114:        actual = fs(source)
115:        self.assertFormatEqual(expected, actual)
116:        black.assert_equivalent(source, actual)
117:        black.assert_stable(source, actual, line_length=ll)
118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
119:
120:    def test_piping(self) -> None:
121:        source, expected = read_data("../black")
122:        hold_stdin, hold_stdout = sys.stdin, sys.stdout
123:        try:
124:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
125:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
126:            sys.stdin.buffer.name = "<stdin>"  # type: ignore
127:            black.format_stdin_to_stdout(
128:                line_length=ll, fast=True, write_back=black.WriteBack.YES
129:            )
130:            sys.stdout.seek(0)
131:            actual = sys.stdout.read()
132:        finally:
133:            sys.stdin, sys.stdout = hold_stdin, hold_stdout
134:        self.assertFormatEqual(expected, actual)
135:        black.assert_equivalent(source, actual)
136:        black.assert_stable(source, actual, line_length=ll)
137:
138:    def test_piping_diff(self) -> None:
139:        source, _ = read_data("expression.py")
140:        expected, _ = read_data("expression.diff")
141:        hold_stdin, hold_stdout = sys.stdin, sys.stdout
142:        try:
143:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
144:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
145:            sys.stdin.buffer.name = "<stdin>"  # type: ignore
146:            black.format_stdin_to_stdout(
147:                line_length=ll, fast=True, write_back=black.WriteBack.DIFF
148:            )
149:            sys.stdout.seek(0)
150:            actual = sys.stdout.read()
151:        finally:
152:            sys.stdin, sys.stdout = hold_stdin, hold_stdout
153:        actual = actual.rstrip() + "\n"  # the diff output has a trailing space
154:        self.assertEqual(expected, actual)
155:
156:    @patch("black.dump_to_file", dump_to_stderr)
157:    def test_setup(self) -> None:
158:        source, expected = read_data("../setup")
159:        actual = fs(source)
160:        self.assertFormatEqual(expected, actual)
161:        black.assert_equivalent(source, actual)
162:        black.assert_stable(source, actual, line_length=ll)
163:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
164:
165:    @patch("black.dump_to_file", dump_to_stderr)
166:    def test_function(self) -> None:
167:        source, expected = read_data("function")
168:        actual = fs(source)
169:        self.assertFormatEqual(expected, actual)
170:        black.assert_equivalent(source, actual)
171:        black.assert_stable(source, actual, line_length=ll)
172:
173:    @patch("black.dump_to_file", dump_to_stderr)
174:    def test_function2(self) -> None:
175:        source, expected = read_data("function2")
176:        actual = fs(source)
177:        self.assertFormatEqual(expected, actual)
178:        black.assert_equivalent(source, actual)
179:        black.assert_stable(source, actual, line_length=ll)
180:
181:    @patch("black.dump_to_file", dump_to_stderr)
182:    def test_expression(self) -> None:
183:        source, expected = read_data("expression")
184:        actual = fs(source)
185:        self.assertFormatEqual(expected, actual)
186:        black.assert_equivalent(source, actual)
187:        black.assert_stable(source, actual, line_length=ll)
188:
189:    def test_expression_ff(self) -> None:
190:        source, expected = read_data("expression")
191:        tmp_file = Path(black.dump_to_file(source))
192:        try:
193:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
194:            with open(tmp_file, encoding="utf8") as f:
195:                actual = f.read()
196:        finally:
197:            os.unlink(tmp_file)
198:        self.assertFormatEqual(expected, actual)
199:        with patch("black.dump_to_file", dump_to_stderr):
200:            black.assert_equivalent(source, actual)
201:            black.assert_stable(source, actual, line_length=ll)
202:
203:    def test_expression_diff(self) -> None:
204:        source, _ = read_data("expression.py")
205:        expected, _ = read_data("expression.diff")
206:        tmp_file = Path(black.dump_to_file(source))
207:        hold_stdout = sys.stdout
208:        try:
209:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
210:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.DIFF))
211:            sys.stdout.seek(0)
212:            actual = sys.stdout.read()
213:            actual = actual.replace(str(tmp_file), "<stdin>")
214:        finally:
215:            sys.stdout = hold_stdout
216:            os.unlink(tmp_file)
217:        actual = actual.rstrip() + "\n"  # the diff output has a trailing space
218:        if expected != actual:
219:            dump = black.dump_to_file(actual)
220:            msg = (
221:                f"Expected diff isn't equal to the actual. If you made changes "
222:                f"to expression.py and this is an anticipated difference, "
223:                f"overwrite tests/expression.diff with {dump}"
224:            )
225:            self.assertEqual(expected, actual, msg)
226:
227:    @patch("black.dump_to_file", dump_to_stderr)
228:    def test_fstring(self) -> None:
229:        source, expected = read_data("fstring")
230:        actual = fs(source)
231:        self.assertFormatEqual(expected, actual)
232:        black.assert_equivalent(source, actual)
233:        black.assert_stable(source, actual, line_length=ll)
234:
235:    @patch("black.dump_to_file", dump_to_stderr)
236:    def test_string_quotes(self) -> None:
237:        source, expected = read_data("string_quotes")
238:        actual = fs(source)
239:        self.assertFormatEqual(expected, actual)
240:        black.assert_equivalent(source, actual)

Calling tool: grepTool
from typing import .*Tuple
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
from typing import
Matched content:
17:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
1:import asyncio
2:import pickle
3:from asyncio.base_events import BaseEventLoop
4:from concurrent.futures import Executor, ProcessPoolExecutor
5:from enum import Enum, Flag
6:from functools import partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import re
14:import tokenize
15:import signal
16:import sys
17:from typing import (
18:    Any,
19:    Callable,
20:    Collection,
21:    Dict,
22:    Generic,
23:    Iterable,
24:    Iterator,
25:    List,
26:    Optional,
27:    Pattern,
28:    Sequence,
29:    Set,
30:    Tuple,
31:    Type,
32:    TypeVar,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original
440:                if task.cancelled():
441:                    cancelled.append(task)
442:                elif task.exception():
443:                    report.failed(src, str(task.exception()))
444:                else:
445:                    formatted.append(src)
446:                    report.done(src, Changed.YES if task.result() else Changed.NO)
447:    if cancelled:
448:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
449:    if write_back == WriteBack.YES and formatted:
450:        write_cache(cache, formatted, line_length, mode)
451:
452:
453:def format_file_in_place(
454:    src: Path,
455:    line_length: int,
456:    fast: bool,
457:    write_back: WriteBack = WriteBack.NO,
458:    mode: FileMode = FileMode.AUTO_DETECT,
459:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
460:) -> bool:
461:    """Format file under `src` path. Return True if changed.
462:
463:    If `write_back` is True, write reformatted code back to stdout.
464:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
465:    """
466:    if src.suffix == ".pyi":
467:        mode |= FileMode.PYI
468:    with tokenize.open(src) as src_buffer:
469:        src_contents = src_buffer.read()
470:    try:
471:        dst_contents = format_file_contents(
472:            src_contents, line_length=line_length, fast=fast, mode=mode
473:        )
474:    except NothingChanged:
475:        return False
476:
477:    if write_back == write_back.YES:
478:        with open(src, "w", encoding=src_buffer.encoding) as f:
479:            f.write(dst_contents)
480:    elif write_back == write_back.DIFF:
481:        src_name = f"{src}  (original)"
482:        dst_name = f"{src}  (formatted)"
483:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
484:        if lock:
485:            lock.acquire()
486:        try:
487:            sys.stdout.write(diff_contents)
488:        finally:
489:            if lock:
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)

Calling tool: createTodo
Todo List Created
Todo List (14 items):
- [ ] Verify black.py imports io to support new TextIOWrapper and BytesIO usage. (ID: todo-1)
- [ ] Confirm new helper function prepare_input(src: bytes) exists in black.py with signature Tuple[str, str, str] and returns (newline, encoding, decoded_contents). (ID: todo-2)
- [ ] Check prepare_input uses tokenize.detect_encoding on a BytesIO of the source to determine encoding and inspects lines[0][-2:] to detect CRLF (sets '\r\n') vs LF (sets '\n'). (ID: todo-3)
- [ ] Ensure prepare_input resets the BytesIO position to 0 after detect_encoding and decodes using io.TextIOWrapper without a newline argument so that universal newlines produce only '\n' in decoded_contents. (ID: todo-4)
- [ ] In format_file_in_place, verify that the file is opened in binary mode ('rb') and passed through prepare_input to obtain newline and encoding before formatting. (ID: todo-5)
- [ ] In format_file_in_place with WriteBack.YES, check that the file is opened for writing with open(src, 'w', encoding=encoding, newline=newline) to preserve original line endings on write-back. (ID: todo-6)
- [ ] In format_file_in_place with WriteBack.DIFF, confirm stdout writing is done via an io.TextIOWrapper over sys.stdout.buffer using the detected encoding and newline, with write_through=True, and that f.detach() is called afterward (and that the lock around writing is preserved). (ID: todo-7)
- [ ] In format_stdin_to_stdout, verify it reads from sys.stdin.buffer.read(), passes bytes to prepare_input, and uses the returned newline and encoding. (ID: todo-8)
- [ ] In format_stdin_to_stdout, confirm both WriteBack.YES and WriteBack.DIFF paths write via an io.TextIOWrapper over sys.stdout.buffer with the detected encoding and newline, call f.write(...), and then f.detach(). (ID: todo-9)
- [ ] Verify lib2to3_parse unconditionally appends a single '\n' when the input doesn't end with a newline, removing the previous CRLF detection logic, which is now unnecessary due to universal newline decoding. (ID: todo-10)
- [ ] Ensure all code paths that pass source text to lib2to3_parse (e.g., format_str via format_file_contents) supply text that has been decoded through prepare_input so only LF newlines are present in-memory. (ID: todo-11)
- [ ] Confirm there are no remaining write-back code paths that open files for writing without specifying newline=..., which could reintroduce platform-dependent line ending conversions when formatting in place. (ID: todo-12)
- [ ] Check the test tests/test_black.py::BlackTestCase.test_preserves_line_endings writes files with both '\n' and '\r\n', calls format_file_in_place with WriteBack.YES, and asserts that the updated file bytes contain the original newline sequence; additionally for '\n' it asserts absence of '\r\n'. (ID: todo-13)
- [ ] Verify that tests that exercise piping (test_piping and test_piping_diff) still interact correctly with the updated format_stdin_to_stdout implementation that uses sys.stdin.buffer and wraps sys.stdout.buffer, i.e., mocks in tests provide .buffer and are consistent with this usage (TextIOWrapper over BytesIO in tests). (ID: todo-14)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 14
description: 'Verify black.py imports io to support new TextIOWrapper and BytesIO usage.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "^import io$", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "TextIOWrapper|BytesIO",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/"
]
Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py

Calling tool: grepTool
^import io$
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/driver.py:20:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:7:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/driver.py:20:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/identify/identify.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/setuptools_scm/utils.py:11:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/toml/decoder.py:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/click/_compat.py:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/click/_winconsole.py:11:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/resources.py:10:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/util.py:10:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/readme_renderer/rst.py:16:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/readme_renderer/integration/distutils.py:17:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pycparser/__init__.py:13:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/wheel.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/cryptography/hazmat/primitives/serialization/pkcs7.py:11:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/installed.py:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/develop.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/sdist.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/toml.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/pkg_resources/__init__.py:22:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/urllib3/packages/backports/makefile.py:9:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/urllib3/contrib/appengine.py:43:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/urllib3/response.py:3:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/flake8/utils.py:5:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/distlib/resources.py:10:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/distlib/util.py:10:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/urllib3/util/ssltransport.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/requests/utils.py:11:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/rich/__main__.py:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/rich/progress.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/rich/file_proxy.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_internal/utils/misc.py:8:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_internal/network/session.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/rich/console.py:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/cachecontrol/serialize.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/requests/utils.py:13:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/entrypoints.py:8:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/coverage/tomlconfig.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/urllib3/packages/backports/makefile.py:9:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/urllib3/response.py:4:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/urllib3/contrib/appengine.py:42:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/mypy/stubdoc.py:7:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/mypy/dmypy_server.py:9:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/coverage/annotate.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/yaml/__init__.py:18:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/nodeenv.py:14:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2/fcntl.pyi:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/twine/package.py:18:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/mypy/util.py:9:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/zipp/__init__.py:10:import io

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
1:import asyncio
2:import pickle
3:from asyncio.base_events import BaseEventLoop
4:from concurrent.futures import Executor, ProcessPoolExecutor
5:from enum import Enum, Flag
6:from functools import partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import re
14:import tokenize
15:import signal
16:import sys
17:from typing import (
18:    Any,
19:    Callable,
20:    Collection,
21:    Dict,
22:    Generic,
23:    Iterable,
24:    Iterator,
25:    List,
26:    Optional,
27:    Pattern,
28:    Sequence,
29:    Set,
30:    Tuple,
31:    Type,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:

Calling tool: grepTool
TextIOWrapper|BytesIO
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:489:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:526:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:537:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:611:    srcbuf = io.BytesIO(src)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:6:from io import BytesIO, TextIOWrapper
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:124:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:125:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:143:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:144:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:209:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/bleach/_vendor/html5lib/_inputstream.py:18:    from io import BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/bleach/_vendor/html5lib/_inputstream.py:20:    BytesIO = StringIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/bleach/_vendor/html5lib/_inputstream.py:448:            stream = BytesIO(source)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/_compat.py:18:    from io import BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/_compat.py:20:    BytesIO = StringIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/babel/_compat.py:21:    from io import StringIO, BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/babel/_compat.py:45:    from cStringIO import StringIO as BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/tests/test_commandline.py:17:            buf = io.BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/tests/test_commandline.py:54:            buf = io.BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/__init__.py:65:from .payload import BytesIOPayload as BytesIOPayload
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/__init__.py:179:    'BytesIOPayload',
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/payload.py:41:           'IOBasePayload', 'BytesIOPayload', 'BufferedReaderPayload',
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/payload.py:227:                          "io.BytesIO object instead", ResourceWarning,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/payload.py:356:class BytesIOPayload(IOBasePayload):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/payload.py:374:            # io.BufferedReader(io.BytesIO(b'data'))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/payload.py:448:PAYLOAD_REGISTRY.register(BytesIOPayload, io.BytesIO)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/scripts.py:7:from io import BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/scripts.py:242:            stream = BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/locators.py:9:from io import BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/locators.py:596:        'gzip': lambda b: gzip.GzipFile(fileobj=BytesIO(d)).read(),
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/resources.py:254:        return io.BytesIO(self.get_bytes(resource))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/util.py:1254:    """zip a directory tree into a BytesIO object"""
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/util.py:1255:    result = io.BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/_backport/tarfile.py:834:    # XXX TextIOWrapper uses the read1() method.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/compat.py:67:    from io import TextIOWrapper as file_type
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/bccache.py:19:from ._compat import BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/bccache.py:85:        self.load_bytecode(BytesIO(string))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/bccache.py:89:        out = BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/cffi/verifier.py:23:    class NativeIO(io.BytesIO):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/_compat.py:22:    from io import BytesIO, StringIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/_compat.py:55:    from cStringIO import StringIO as BytesIO, StringIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/_compat.py:57:    NativeStringIO = BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/cffi/recompiler.py:1416:    class NativeIO(io.BytesIO):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/cryptography/hazmat/primitives/serialization/pkcs7.py:350:    fp = io.BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/flake8/utils.py:198:    fd = io.BytesIO(stdin_value)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/flake8/utils.py:212:            stdin_value = io.BytesIO(sys.stdin.read())
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/cachecontrol/serialize.py:36:            response._fp = io.BytesIO(body)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/cachecontrol/serialize.py:129:                body = io.BytesIO(body_raw)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/cachecontrol/serialize.py:139:            body = io.BytesIO(body_raw.encode("utf8"))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import sys
10:from tempfile import TemporaryDirectory
11:from typing import Any, List, Tuple, Iterator
12:import unittest
13:from unittest.mock import patch
14:import re
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:ll = 88
22:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
23:fs = partial(black.format_str, line_length=ll)
24:THIS_FILE = Path(__file__)
25:THIS_DIR = THIS_FILE.parent
26:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
27:
28:
29:def dump_to_stderr(*output: str) -> str:
30:    return "\n" + "\n".join(output) + "\n"
31:
32:
33:def read_data(name: str) -> Tuple[str, str]:
34:    """read_data('test_name') -> 'input', 'output'"""
35:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
36:        name += ".py"
37:    _input: List[str] = []
38:    _output: List[str] = []
39:    with open(THIS_DIR / name, "r", encoding="utf8") as test:
40:        lines = test.readlines()

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Confirmed black.py includes `import io` at line 7, matching the diff. The file uses io.TextIOWrapper and io.BytesIO later (lines ~489, 526, 537, 611, 615), so the import supports the new usage.


Todo item 1 of 14 is correct
description: 'Verify black.py imports io to support new TextIOWrapper and BytesIO usage.'
Validating todo item 2 of 14
description: 'Confirm new helper function prepare_input(src: bytes) exists in black.py with signature Tuple[str, str, str] and returns (newline, encoding, decoded_contents).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def prepare_input\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "from typing import.*Tuple",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "Tuple\\[", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "from typing import",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py"
]
Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None

Calling tool: grepTool
from typing import.*Tuple
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
Tuple\[
Matched content:
69:CacheInfo = Tuple[Timestamp, FileSize]
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
837:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
961:    comments: List[Tuple[Index, Leaf]] = Factory(list)
1299:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1314:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
3139:def enumerate_reversed(sequence: Sequence[T]) -> Iterator[Tuple[Index, T]]:
3149:) -> Iterator[Tuple[Index, Leaf, int]]:
3155:        Callable[[Sequence[Leaf]], Iterator[Tuple[Index, Leaf]]],
3308:) -> Tuple[List[Path], List[Path]]:

Calling tool: grepTool
from typing import
Matched content:
17:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
1:import asyncio
2:import pickle
3:from asyncio.base_events import BaseEventLoop
4:from concurrent.futures import Executor, ProcessPoolExecutor
5:from enum import Enum, Flag
6:from functools import partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import re
14:import tokenize
15:import signal
16:import sys
17:from typing import (
18:    Any,
19:    Callable,
20:    Collection,
21:    Dict,
22:    Generic,
23:    Iterable,
24:    Iterator,
25:    List,
26:    Optional,
27:    Pattern,
28:    Sequence,
29:    Set,
30:    Tuple,
31:    Type,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:
41:# lib2to3 fork
42:from blib2to3.pytree import Node, Leaf, type_repr
43:from blib2to3 import pygram, pytree
44:from blib2to3.pgen2 import driver, token
45:from blib2to3.pgen2.parse import ParseError
46:
47:
48:__version__ = "18.5b1"
49:DEFAULT_LINE_LENGTH = 88
50:DEFAULT_EXCLUDES = (
51:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
52:)
53:DEFAULT_INCLUDES = r"\.pyi?$"
54:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
55:
56:
57:# types
58:FileContent = str
59:Encoding = str
60:Depth = int

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Function prepare_input is present in black.py at line ~605 with signature Tuple[str, str, str] and returns a tuple (newline, encoding, decoded_contents) as shown by the return statement.


Todo item 2 of 14 is correct
description: 'Confirm new helper function prepare_input(src: bytes) exists in black.py with signature Tuple[str, str, str] and returns (newline, encoding, decoded_contents).'
Validating todo item 3 of 14
description: 'Check prepare_input uses tokenize.detect_encoding on a BytesIO of the source to determine encoding and inspects lines[0][-2:] to detect CRLF (sets '\r\n') vs LF (sets '\n').'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def prepare_input\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
670:        instead.
671:
672:        Then yields objects of type `T` from the selected visitor.
673:        """
674:        if node.type < 256:
675:            name = token.tok_name[node.type]
676:        else:
677:            name = type_repr(node.type)
678:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
679:
680:    def visit_default(self, node: LN) -> Iterator[T]:
681:        """Default `visit_*()` implementation. Recurses to children of `node`."""

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, prepare_input creates a BytesIO from the source, calls tokenize.detect_encoding(srcbuf.readline) to get encoding and lines, and sets newline to '\r\n' if lines[0][-2:] equals b'\r\n' otherwise '\n'. This matches the requirement exactly.


Todo item 3 of 14 is correct
description: 'Check prepare_input uses tokenize.detect_encoding on a BytesIO of the source to determine encoding and inspects lines[0][-2:] to detect CRLF (sets '\r\n') vs LF (sets '\n').'
Validating todo item 4 of 14
description: 'Ensure prepare_input resets the BytesIO position to 0 after detect_encoding and decodes using io.TextIOWrapper without a newline argument so that universal newlines produce only '\n' in decoded_contents.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def prepare_input\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_file_in_place\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: prepare_input seeks the BytesIO back to 0 after tokenize.detect_encoding and decodes via io.TextIOWrapper(srcbuf, encoding) without a newline argument, enabling universal newline translation to produce only '\n' in decoded contents.


Todo item 4 of 14 is correct
description: 'Ensure prepare_input resets the BytesIO position to 0 after detect_encoding and decodes using io.TextIOWrapper without a newline argument so that universal newlines produce only '\n' in decoded_contents.'
Validating todo item 5 of 14
description: 'In format_file_in_place, verify that the file is opened in binary mode ('rb') and passed through prepare_input to obtain newline and encoding before formatting.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_file_in_place\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def prepare_input\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "^import io$", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py" ]
Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:

Calling tool: grepTool
^import io$
Matched content:
7:import io

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, format_file_in_place opens the file in binary mode (open(src, "rb")) and immediately passes the bytes to prepare_input to obtain newline and encoding (lines 470-471) before formatting. This satisfies the requirement.


Todo item 5 of 14 is correct
description: 'In format_file_in_place, verify that the file is opened in binary mode ('rb') and passed through prepare_input to obtain newline and encoding before formatting.'
Validating todo item 6 of 14
description: 'In format_file_in_place with WriteBack.YES, check that the file is opened for writing with open(src, 'w', encoding=encoding, newline=newline) to preserve original line endings on write-back.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_file_in_place\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "write_back == write_back\\.YES",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class WriteBack\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def prepare_input\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
440:                if task.cancelled():
441:                    cancelled.append(task)
442:                elif task.exception():
443:                    report.failed(src, str(task.exception()))
444:                else:
445:                    formatted.append(src)
446:                    report.done(src, Changed.YES if task.result() else Changed.NO)
447:    if cancelled:
448:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
449:    if write_back == WriteBack.YES and formatted:
450:        write_cache(cache, formatted, line_length, mode)
451:
452:
453:def format_file_in_place(
454:    src: Path,
455:    line_length: int,
456:    fast: bool,
457:    write_back: WriteBack = WriteBack.NO,
458:    mode: FileMode = FileMode.AUTO_DETECT,
459:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
460:) -> bool:
461:    """Format file under `src` path. Return True if changed.
462:
463:    If `write_back` is True, write reformatted code back to stdout.
464:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
465:    """
466:    if src.suffix == ".pyi":
467:        mode |= FileMode.PYI
468:    with tokenize.open(src) as src_buffer:
469:        src_contents = src_buffer.read()
470:    try:
471:        dst_contents = format_file_contents(
472:            src_contents, line_length=line_length, fast=fast, mode=mode
473:        )
474:    except NothingChanged:
475:        return False
476:
477:    if write_back == write_back.YES:
478:        with open(src, "w", encoding=src_buffer.encoding) as f:
479:            f.write(dst_contents)
480:    elif write_back == write_back.DIFF:
481:        src_name = f"{src}  (original)"
482:        dst_name = f"{src}  (formatted)"
483:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
484:        if lock:
485:            lock.acquire()
486:        try:
487:            sys.stdout.write(diff_contents)
488:        finally:
489:            if lock:
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)

Calling tool: grepTool
write_back == write_back\.YES
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:477:    if write_back == write_back.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:479:    if write_back == write_back.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:477:    if write_back == write_back.YES:

Calling tool: grepTool
class WriteBack\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:117:class WriteBack(Enum):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:118:class WriteBack(Enum):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:117:class WriteBack(Enum):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
110:class FormatOn(FormatError):
111:    """Found a comment like `# fmt: on` in the file."""
112:
113:
114:class FormatOff(FormatError):
115:    """Found a comment like `# fmt: off` in the file."""
116:
117:
118:class WriteBack(Enum):
119:    NO = 0
120:    YES = 1
121:    DIFF = 2
122:
123:    @classmethod
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
125:        if check and not diff:
126:            return cls.NO
127:
128:        return cls.DIFF if diff else cls.YES
129:

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py, within format_file_in_place, the YES write-back branch opens the file with open(src, "w", encoding=encoding, newline=newline) (lines 479-481), using values obtained from prepare_input. This preserves original line endings on write-back as required.


Todo item 6 of 14 is correct
description: 'In format_file_in_place with WriteBack.YES, check that the file is opened for writing with open(src, 'w', encoding=encoding, newline=newline) to preserve original line endings on write-back.'
Validating todo item 7 of 14
description: 'In format_file_in_place with WriteBack.DIFF, confirm stdout writing is done via an io.TextIOWrapper over sys.stdout.buffer using the detected encoding and newline, with write_through=True, and that f.detach() is called afterward (and that the lock around writing is preserved).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_file_in_place\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
430:        pending: Iterable[asyncio.Task] = tasks.keys()
431:        try:
432:            loop.add_signal_handler(signal.SIGINT, cancel, pending)
433:            loop.add_signal_handler(signal.SIGTERM, cancel, pending)
434:        except NotImplementedError:
435:            # There are no good alternatives for these on Windows
436:            pass
437:        while pending:
438:            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
439:            for task in done:
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In format_file_in_places WriteBack.DIFF branch (black.py:486-499), output is written using io.TextIOWrapper(sys.stdout.buffer, encoding=encoding, newline=newline, write_through=True), then f.detach() is called. The write is wrapped in a lock acquire/try/finally with lock.release(), preserving the lock behavior.


Todo item 7 of 14 is correct
description: 'In format_file_in_place with WriteBack.DIFF, confirm stdout writing is done via an io.TextIOWrapper over sys.stdout.buffer using the detected encoding and newline, with write_through=True, and that f.detach() is called afterward (and that the lock around writing is preserved).'
Validating todo item 8 of 14
description: 'In format_stdin_to_stdout, verify it reads from sys.stdin.buffer.read(), passes bytes to prepare_input, and uses the returned newline and encoding.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_stdin_to_stdout\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def prepare_input\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
Calling tool: grepTool
def format_stdin_to_stdout\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:494:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:503:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:494:def format_stdin_to_stdout(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, format_stdin_to_stdout reads from sys.stdin.buffer.read(), passes those bytes to prepare_input, and uses the returned newline and encoding when writing via a TextIOWrapper in both YES and DIFF branches (lines ~515-544).


Todo item 8 of 14 is correct
description: 'In format_stdin_to_stdout, verify it reads from sys.stdin.buffer.read(), passes bytes to prepare_input, and uses the returned newline and encoding.'
Validating todo item 9 of 14
description: 'In format_stdin_to_stdout, confirm both WriteBack.YES and WriteBack.DIFF paths write via an io.TextIOWrapper over sys.stdout.buffer with the detected encoding and newline, call f.write(...), and then f.detach().'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_stdin_to_stdout\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def prepare_input\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
Calling tool: grepTool
def format_stdin_to_stdout\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:494:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:503:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:494:def format_stdin_to_stdout(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """
580:    src_node = lib2to3_parse(src_contents)
581:    dst_contents = ""
582:    future_imports = get_future_imports(src_node)
583:    is_pyi = bool(mode & FileMode.PYI)
584:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
585:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
586:    lines = LineGenerator(
587:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
588:        is_pyi=is_pyi,
589:        normalize_strings=normalize_strings,
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In format_stdin_to_stdout, both WriteBack.YES and WriteBack.DIFF branches wrap sys.stdout.buffer in io.TextIOWrapper using the detected encoding and newline from prepare_input, perform f.write(...) of the respective content, and then call f.detach(). Verified at lines 525-544 in black.py.


Todo item 9 of 14 is correct
description: 'In format_stdin_to_stdout, confirm both WriteBack.YES and WriteBack.DIFF paths write via an io.TextIOWrapper over sys.stdout.buffer with the detected encoding and newline, call f.write(...), and then f.detach().'
Validating todo item 10 of 14
description: 'Verify lib2to3_parse unconditionally appends a single '\n' when the input doesn't end with a newline, removing the previous CRLF detection logic, which is now unnecessary due to universal newline decoding.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def lib2to3_parse\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "\\r\\n", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py" ]
Calling tool: grepTool
def lib2to3_parse\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:589:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:625:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:589:def lib2to3_parse(src_txt: str) -> Node:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:

Calling tool: grepTool
\r\n
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: the literal "\n" is not allowed in a regex

Consider enabling multiline mode with the --multiline flag (or -U for short).
When multiline mode is enabled, new line characters can be matched.


Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
580:
581:
582:GRAMMARS = [
583:    pygram.python_grammar_no_print_statement_no_exec_statement,
584:    pygram.python_grammar_no_print_statement,
585:    pygram.python_grammar,
586:]
587:
588:
589:def lib2to3_parse(src_txt: str) -> Node:
590:    """Given a string with source, return the lib2to3 Node."""
591:    grammar = pygram.python_grammar_no_print_statement
592:    if src_txt[-1] != "\n":
593:        nl = "\r\n" if "\r\n" in src_txt[:1024] else "\n"
594:        src_txt += nl
595:    for grammar in GRAMMARS:
596:        drv = driver.Driver(grammar, pytree.convert)
597:        try:
598:            result = drv.parse_string(src_txt, True)
599:            break
600:
601:        except ParseError as pe:
602:            lineno, column = pe.context[1]
603:            lines = src_txt.splitlines()
604:            try:
605:                faulty_line = lines[lineno - 1]
606:            except IndexError:
607:                faulty_line = "<line number missing in source>"
608:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
609:    else:
610:        raise exc from None
611:
612:    if isinstance(result, Leaf):
613:        result = Node(syms.file_input, [result])
614:    return result
615:
616:
617:def lib2to3_unparse(node: Node) -> str:
618:    """Given a lib2to3 node, return its string representation."""
619:    code = str(node)
620:    return code
621:
622:
623:T = TypeVar("T")
624:
625:
626:class Visitor(Generic[T]):
627:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
628:
629:    def visit(self, node: LN) -> Iterator[T]:
630:        """Main method to visit `node` and its children.
631:
632:        It tries to find a `visit_*()` method for the given `node.type`, like
633:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
634:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
635:        instead.
636:
637:        Then yields objects of type `T` from the selected visitor.
638:        """
639:        if node.type < 256:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original
580:
581:
582:GRAMMARS = [
583:    pygram.python_grammar_no_print_statement_no_exec_statement,
584:    pygram.python_grammar_no_print_statement,
585:    pygram.python_grammar,
586:]
587:
588:
589:def lib2to3_parse(src_txt: str) -> Node:
590:    """Given a string with source, return the lib2to3 Node."""
591:    grammar = pygram.python_grammar_no_print_statement
592:    if src_txt[-1] != "\n":
593:        nl = "\r\n" if "\r\n" in src_txt[:1024] else "\n"
594:        src_txt += nl
595:    for grammar in GRAMMARS:
596:        drv = driver.Driver(grammar, pytree.convert)
597:        try:
598:            result = drv.parse_string(src_txt, True)
599:            break
600:
601:        except ParseError as pe:
602:            lineno, column = pe.context[1]
603:            lines = src_txt.splitlines()
604:            try:
605:                faulty_line = lines[lineno - 1]
606:            except IndexError:
607:                faulty_line = "<line number missing in source>"
608:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
609:    else:
610:        raise exc from None
611:
612:    if isinstance(result, Leaf):
613:        result = Node(syms.file_input, [result])
614:    return result
615:
616:
617:def lib2to3_unparse(node: Node) -> str:
618:    """Given a lib2to3 node, return its string representation."""
619:    code = str(node)
620:    return code
621:
622:
623:T = TypeVar("T")
624:
625:
626:class Visitor(Generic[T]):
627:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
628:
629:    def visit(self, node: LN) -> Iterator[T]:
630:        """Main method to visit `node` and its children.
631:
632:        It tries to find a `visit_*()` method for the given `node.type`, like
633:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
634:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
635:        instead.
636:
637:        Then yields objects of type `T` from the selected visitor.
638:        """
639:        if node.type < 256:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py at lines 625-631, lib2to3_parse now appends a single "\n" when the input doesnt end with a newline. The previous CRLF detection logic was removed. This aligns with universal newline decoding handled earlier by prepare_input.


Todo item 10 of 14 is correct
description: 'Verify lib2to3_parse unconditionally appends a single '\n' when the input doesn't end with a newline, removing the previous CRLF detection logic, which is now unnecessary due to universal newline decoding.'
Validating todo item 11 of 14
description: 'Ensure all code paths that pass source text to lib2to3_parse (e.g., format_str via format_file_contents) supply text that has been decoded through prepare_input so only LF newlines are present in-memory.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_file_in_place\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "lib2to3_parse\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "format_file_contents\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "format_str\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "sys\\.stdin|open\\(|tokenize\\.open\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py"
]
Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
430:        pending: Iterable[asyncio.Task] = tasks.keys()
431:        try:
432:            loop.add_signal_handler(signal.SIGINT, cancel, pending)
433:            loop.add_signal_handler(signal.SIGTERM, cancel, pending)
434:        except NotImplementedError:
435:            # There are no good alternatives for these on Windows
436:            pass
437:        while pending:
438:            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
439:            for task in done:
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """
580:    src_node = lib2to3_parse(src_contents)
581:    dst_contents = ""
582:    future_imports = get_future_imports(src_node)
583:    is_pyi = bool(mode & FileMode.PYI)
584:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
585:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
586:    lines = LineGenerator(
587:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
588:        is_pyi=is_pyi,
589:        normalize_strings=normalize_strings,
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
670:        instead.
671:
672:        Then yields objects of type `T` from the selected visitor.
673:        """
674:        if node.type < 256:
675:            name = token.tok_name[node.type]
676:        else:
677:            name = type_repr(node.type)
678:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
679:
680:    def visit_default(self, node: LN) -> Iterator[T]:
681:        """Default `visit_*()` implementation. Recurses to children of `node`."""
682:        if isinstance(node, Node):
683:            for child in node.children:
684:                yield from self.visit(child)
685:
686:
687:@dataclass
688:class DebugVisitor(Visitor[T]):
689:    tree_depth: int = 0

Calling tool: grepTool
lib2to3_parse\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:557:    src_node = lib2to3_parse(src_contents)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:589:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:683:        list(v.visit(lib2to3_parse(code)))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:580:    src_node = lib2to3_parse(src_contents)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:625:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:718:        list(v.visit(lib2to3_parse(code)))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:88:                exp_node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:95:                exp_node = black.lib2to3_parse(actual)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:656:        node = black.lib2to3_parse("def f(*, arg): ...\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:658:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:660:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:663:        node = black.lib2to3_parse(source)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:665:        node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:668:        node = black.lib2to3_parse(source)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:670:        node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:674:        node = black.lib2to3_parse("\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:676:        node = black.lib2to3_parse("from __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:678:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:680:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:682:        node = black.lib2to3_parse(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:686:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:688:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:690:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:692:        node = black.lib2to3_parse("from some.module import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:739:        n = black.lib2to3_parse("\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:557:    src_node = lib2to3_parse(src_contents)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:589:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:683:        list(v.visit(lib2to3_parse(code)))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/debug_visitor.py:32:        list(v.visit(lib2to3_parse(code)))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:88:                exp_node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:95:                exp_node = black.lib2to3_parse(actual)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:654:        node = black.lib2to3_parse("def f(*, arg): ...\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:656:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:658:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:661:        node = black.lib2to3_parse(source)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:663:        node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:666:        node = black.lib2to3_parse(source)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:668:        node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:672:        node = black.lib2to3_parse("\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:674:        node = black.lib2to3_parse("from __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:676:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:678:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:680:        node = black.lib2to3_parse(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:684:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:686:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:688:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:690:        node = black.lib2to3_parse("from some.module import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:737:        n = black.lib2to3_parse("\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/debug_visitor.py:32:        list(v.visit(lib2to3_parse(code)))

Calling tool: grepTool
format_file_contents\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:471:        dst_contents = format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:524:def format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/plugin/black.vim:99:    new_buffer_str = black.format_file_contents(buffer_str, line_length=line_length, fast=fast)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:473:        dst_contents = format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:547:def format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:719:    def test_format_file_contents(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:722:            black.format_file_contents(empty, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:725:            black.format_file_contents(just_nl, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:728:            black.format_file_contents(same, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:731:        actual = black.format_file_contents(different, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:735:            black.format_file_contents(invalid, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:471:        dst_contents = format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:524:def format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/plugin/black.vim:99:    new_buffer_str = black.format_file_contents(buffer_str, line_length=line_length, fast=fast)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:717:    def test_format_file_contents(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:720:            black.format_file_contents(empty, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:723:            black.format_file_contents(just_nl, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:726:            black.format_file_contents(same, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:729:        actual = black.format_file_contents(different, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:733:            black.format_file_contents(invalid, line_length=ll, fast=False)

Calling tool: grepTool
format_str\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:550:def format_str(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:3027:    newdst = format_str(dst, line_length=line_length, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:573:def format_str(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:3062:    newdst = format_str(dst, line_length=line_length, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:550:def format_str(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:3027:    newdst = format_str(dst, line_length=line_length, mode=mode)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
3000:
3001:    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:
3002:        """Simple visitor generating strings to compare ASTs by content."""
3003:        yield f"{'  ' * depth}{node.__class__.__name__}("
3004:
3005:        for field in sorted(node._fields):
3006:            try:
3007:                value = getattr(node, field)
3008:            except AttributeError:
3009:                continue
3010:
3011:            yield f"{'  ' * (depth+1)}{field}="
3012:
3013:            if isinstance(value, list):
3014:                for item in value:
3015:                    if isinstance(item, ast.AST):
3016:                        yield from _v(item, depth + 2)
3017:
3018:            elif isinstance(value, ast.AST):
3019:                yield from _v(value, depth + 2)
3020:
3021:            else:
3022:                yield f"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}"
3023:
3024:        yield f"{'  ' * depth})  # /{node.__class__.__name__}"
3025:
3026:    try:
3027:        src_ast = ast.parse(src)
3028:    except Exception as exc:
3029:        major, minor = sys.version_info[:2]
3030:        raise AssertionError(
3031:            f"cannot use --safe with this file; failed to parse source file "
3032:            f"with Python {major}.{minor}'s builtin AST. Re-run with --fast "
3033:            f"or stop using deprecated Python 2 syntax. AST error message: {exc}"
3034:        )
3035:
3036:    try:
3037:        dst_ast = ast.parse(dst)
3038:    except Exception as exc:
3039:        log = dump_to_file("".join(traceback.format_tb(exc.__traceback__)), dst)
3040:        raise AssertionError(
3041:            f"INTERNAL ERROR: Black produced invalid code: {exc}. "
3042:            f"Please report a bug on https://github.com/ambv/black/issues.  "
3043:            f"This invalid output might be helpful: {log}"
3044:        ) from None
3045:
3046:    src_ast_str = "\n".join(_v(src_ast))
3047:    dst_ast_str = "\n".join(_v(dst_ast))
3048:    if src_ast_str != dst_ast_str:
3049:        log = dump_to_file(diff(src_ast_str, dst_ast_str, "src", "dst"))
3050:        raise AssertionError(
3051:            f"INTERNAL ERROR: Black produced code that is not equivalent to "
3052:            f"the source.  "
3053:            f"Please report a bug on https://github.com/ambv/black/issues.  "
3054:            f"This diff might be helpful: {log}"
3055:        ) from None
3056:
3057:
3058:def assert_stable(
3059:    src: str, dst: str, line_length: int, mode: FileMode = FileMode.AUTO_DETECT
3060:) -> None:
3061:    """Raise AssertionError if `dst` reformats differently the second time."""
3062:    newdst = format_str(dst, line_length=line_length, mode=mode)
3063:    if dst != newdst:
3064:        log = dump_to_file(
3065:            diff(src, dst, "source", "first pass"),
3066:            diff(dst, newdst, "first pass", "second pass"),
3067:        )
3068:        raise AssertionError(
3069:            f"INTERNAL ERROR: Black produced different code on the second pass "
3070:            f"of the formatter.  "
3071:            f"Please report a bug on https://github.com/ambv/black/issues.  "
3072:            f"This diff might be helpful: {log}"
3073:        ) from None
3074:
3075:
3076:def dump_to_file(*output: str) -> str:
3077:    """Dump `output` to a temporary file. Return path to the file."""
3078:    import tempfile
3079:
3080:    with tempfile.NamedTemporaryFile(
3081:        mode="w", prefix="blk_", suffix=".log", delete=False, encoding="utf8"
3082:    ) as f:
3083:        for lines in output:
3084:            f.write(lines)
3085:            if lines and lines[-1] != "\n":
3086:                f.write("\n")
3087:    return f.name
3088:
3089:
3090:def diff(a: str, b: str, a_name: str, b_name: str) -> str:
3091:    """Return a unified diff string between strings `a` and `b`."""
3092:    import difflib
3093:
3094:    a_lines = [line + "\n" for line in a.split("\n")]
3095:    b_lines = [line + "\n" for line in b.split("\n")]
3096:    return "".join(
3097:        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)
3098:    )
3099:
3100:
3101:def cancel(tasks: Iterable[asyncio.Task]) -> None:
3102:    """asyncio signal handler that cancels all `tasks` and reports to stderr."""
3103:    err("Aborted!")
3104:    for task in tasks:
3105:        task.cancel()
3106:
3107:
3108:def shutdown(loop: BaseEventLoop) -> None:
3109:    """Cancel all pending tasks on `loop`, wait for them, and close the loop."""
3110:    try:
3111:        # This part is borrowed from asyncio/runners.py in Python 3.7b2.
3112:        to_cancel = [task for task in asyncio.Task.all_tasks(loop) if not task.done()]
3113:        if not to_cancel:
3114:            return
3115:
3116:        for task in to_cancel:
3117:            task.cancel()
3118:        loop.run_until_complete(
3119:            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
430:        try:
431:            loop.add_signal_handler(signal.SIGINT, cancel, pending)
432:            loop.add_signal_handler(signal.SIGTERM, cancel, pending)
433:        except NotImplementedError:
434:            # There are no good alternatives for these on Windows
435:            pass
436:        while pending:
437:            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
438:            for task in done:
439:                src = tasks.pop(task)
440:                if task.cancelled():
441:                    cancelled.append(task)
442:                elif task.exception():
443:                    report.failed(src, str(task.exception()))
444:                else:
445:                    formatted.append(src)
446:                    report.done(src, Changed.YES if task.result() else Changed.NO)
447:    if cancelled:
448:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
449:    if write_back == WriteBack.YES and formatted:
450:        write_cache(cache, formatted, line_length, mode)
451:
452:
453:def format_file_in_place(
454:    src: Path,
455:    line_length: int,
456:    fast: bool,
457:    write_back: WriteBack = WriteBack.NO,
458:    mode: FileMode = FileMode.AUTO_DETECT,
459:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
460:) -> bool:
461:    """Format file under `src` path. Return True if changed.
462:
463:    If `write_back` is True, write reformatted code back to stdout.
464:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
465:    """
466:    if src.suffix == ".pyi":
467:        mode |= FileMode.PYI
468:    with tokenize.open(src) as src_buffer:
469:        src_contents = src_buffer.read()
470:    try:
471:        dst_contents = format_file_contents(
472:            src_contents, line_length=line_length, fast=fast, mode=mode
473:        )
474:    except NothingChanged:
475:        return False
476:
477:    if write_back == write_back.YES:
478:        with open(src, "w", encoding=src_buffer.encoding) as f:
479:            f.write(dst_contents)
480:    elif write_back == write_back.DIFF:
481:        src_name = f"{src}  (original)"
482:        dst_name = f"{src}  (formatted)"
483:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
484:        if lock:
485:            lock.acquire()
486:        try:
487:            sys.stdout.write(diff_contents)
488:        finally:
489:            if lock:
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)
560:    is_pyi = bool(mode & FileMode.PYI)
561:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
562:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
563:    lines = LineGenerator(
564:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
565:        is_pyi=is_pyi,
566:        normalize_strings=normalize_strings,
567:    )
568:    elt = EmptyLineTracker(is_pyi=is_pyi)
569:    empty_line = Line()
570:    after = 0
571:    for current_line in lines.visit(src_node):
572:        for _ in range(after):
573:            dst_contents += str(empty_line)
574:        before, after = elt.maybe_empty_lines(current_line)
575:        for _ in range(before):
576:            dst_contents += str(empty_line)
577:        for line in split_line(current_line, line_length=line_length, py36=py36):
578:            dst_contents += str(line)
579:    return dst_contents
580:
581:
582:GRAMMARS = [
583:    pygram.python_grammar_no_print_statement_no_exec_statement,
584:    pygram.python_grammar_no_print_statement,
585:    pygram.python_grammar,
586:]
587:
588:
589:def lib2to3_parse(src_txt: str) -> Node:
590:    """Given a string with source, return the lib2to3 Node."""
591:    grammar = pygram.python_grammar_no_print_statement
592:    if src_txt[-1] != "\n":
593:        nl = "\r\n" if "\r\n" in src_txt[:1024] else "\n"
594:        src_txt += nl
595:    for grammar in GRAMMARS:
596:        drv = driver.Driver(grammar, pytree.convert)
597:        try:
598:            result = drv.parse_string(src_txt, True)
599:            break
600:
601:        except ParseError as pe:
602:            lineno, column = pe.context[1]
603:            lines = src_txt.splitlines()
604:            try:
605:                faulty_line = lines[lineno - 1]
606:            except IndexError:
607:                faulty_line = "<line number missing in source>"
608:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
609:    else:
610:        raise exc from None
611:
612:    if isinstance(result, Leaf):
613:        result = Node(syms.file_input, [result])
614:    return result
615:
616:
617:def lib2to3_unparse(node: Node) -> str:
618:    """Given a lib2to3 node, return its string representation."""
619:    code = str(node)
620:    return code
621:
622:
623:T = TypeVar("T")
624:
625:
626:class Visitor(Generic[T]):
627:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
628:
629:    def visit(self, node: LN) -> Iterator[T]:
630:        """Main method to visit `node` and its children.
631:
632:        It tries to find a `visit_*()` method for the given `node.type`, like
633:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
634:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
635:        instead.
636:
637:        Then yields objects of type `T` from the selected visitor.
638:        """
639:        if node.type < 256:
640:            name = token.tok_name[node.type]
641:        else:
642:            name = type_repr(node.type)
643:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
644:
645:    def visit_default(self, node: LN) -> Iterator[T]:
646:        """Default `visit_*()` implementation. Recurses to children of `node`."""
647:        if isinstance(node, Node):
648:            for child in node.children:
649:                yield from self.visit(child)
650:
651:
652:@dataclass
653:class DebugVisitor(Visitor[T]):
654:    tree_depth: int = 0
655:
656:    def visit_default(self, node: LN) -> Iterator[T]:
657:        indent = " " * (2 * self.tree_depth)
658:        if isinstance(node, Node):
659:            _type = type_repr(node.type)
660:            out(f"{indent}{_type}", fg="yellow")
661:            self.tree_depth += 1
662:            for child in node.children:
663:                yield from self.visit(child)
664:
665:            self.tree_depth -= 1
666:            out(f"{indent}/{_type}", fg="yellow", bold=False)
667:        else:
668:            _type = token.tok_name.get(node.type, str(node.type))
669:            out(f"{indent}{_type}", fg="blue", nl=False)
670:            if node.prefix:
671:                # We don't have to handle prefixes for `Node` objects since
672:                # that delegates to the first child anyway.
673:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
674:            out(f" {node.value!r}", fg="blue", bold=False)
675:
676:    @classmethod
677:    def show(cls, code: str) -> None:
678:        """Pretty-print the lib2to3 AST of a given string of `code`.
679:
680:        Convenience method for debugging.
681:        """
682:        v: DebugVisitor[None] = DebugVisitor()
683:        list(v.visit(lib2to3_parse(code)))
684:
685:
686:KEYWORDS = set(keyword.kwlist)
687:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
688:FLOW_CONTROL = {"return", "raise", "break", "continue"}
689:STATEMENT = {

Calling tool: grepTool
sys\.stdin|open\(|tokenize\.open\(
Matched content:
470:    with open(src, "rb") as buf:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
3291:    with cache_file.open("rb") as fobj:
3333:        with cache_file.open("wb") as fobj:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, both input paths that lead to lib2to3_parse (format_file_in_place and format_stdin_to_stdout via format_file_contentsformat_str) now decode with prepare_input, which uses TextIOWrapper with universal newlines ensuring only LF in-memory. lib2to3_parse was simplified to always append \n, relying on LF-only input. No other production code paths call lib2to3_parse with raw text.


Todo item 11 of 14 is correct
description: 'Ensure all code paths that pass source text to lib2to3_parse (e.g., format_str via format_file_contents) supply text that has been decoded through prepare_input so only LF newlines are present in-memory.'
Validating todo item 12 of 14
description: 'Confirm there are no remaining write-back code paths that open files for writing without specifying newline=..., which could reintroduce platform-dependent line ending conversions when formatting in place.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "open\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "\\.open\\(\"w\"\\)", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "write_back\\s*==\\s*WriteBack\\.YES",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def write_cache\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py"
]
Calling tool: grepTool
open\(
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:468:    with tokenize.open(src) as src_buffer:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:478:        with open(src, "w", encoding=src_buffer.encoding) as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:3256:    with cache_file.open("rb") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:3298:        with cache_file.open("wb") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/tokenize.py:344:        readline = open(myfile).next    # Example of alternate readline
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/tokenize.py:566:    if len(sys.argv) > 1: tokenize(open(sys.argv[1]).readline)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/driver.py:114:        with io.open(filename, "r", encoding=encoding) as stream:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/pgen.py:15:            stream = open(filename)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/grammar.py:89:        with open(filename, "wb") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/grammar.py:94:        with open(filename, "rb") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/setup.py:15:    with open(readme_md, encoding="utf8") as ld_file:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/setup.py:22:    with open(black_py, "r", encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/conv.py:62:            f = open(filename)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/conv.py:113:            f = open(filename)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:470:    with open(src, "rb") as buf:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:480:        with open(src, "w", encoding=encoding, newline=newline) as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:3291:    with cache_file.open("rb") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:3333:        with cache_file.open("wb") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/docs/conf.py:30:    with open(str(black_py), "r", encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/docs/conf.py:38:    with open(str(template), "r", encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/docs/conf.py:40:    with open(str(target), "w", encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/docs/conf.py:63:    with open(str(readme), "r", encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/docs/conf.py:73:                output = open(str(output_path), "w", encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/tokenize.py:344:        readline = open(myfile).next    # Example of alternate readline
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/tokenize.py:566:    if len(sys.argv) > 1: tokenize(open(sys.argv[1]).readline)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/driver.py:114:        with io.open(filename, "r", encoding=encoding) as stream:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/conv.py:62:            f = open(filename)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/conv.py:113:            f = open(filename)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/comments5.py:20:with open(some_temp_file) as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/comments5.py:24:    with open(some_other_file) as w:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/grammar.py:89:        with open(filename, "wb") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/grammar.py:94:        with open(filename, "rb") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/comments5.py:20:with open(some_temp_file) as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/comments5.py:24:    with open(some_other_file) as w:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:39:    with open(THIS_DIR / name, "r", encoding="utf8") as test:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:192:            with open(tmp_file, encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:766:            with cache_file.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:770:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:781:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:786:            with src.open("r") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:796:            with one.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:799:            with two.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:804:            with one.open("r") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:806:            with two.open("r") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:816:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:876:            with failing.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:879:            with clean.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:945:            with open(path, "w") as fh:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:949:            with open(path, "r") as fh:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:969:                with open(path, "w") as fh:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: grepTool
\.open\("w"\)
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:768:            with cache_file.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:772:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:783:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:798:            with one.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:801:            with two.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:818:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:878:            with failing.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:881:            with clean.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:766:            with cache_file.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:770:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:781:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:796:            with one.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:799:            with two.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:816:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:876:            with failing.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:879:            with clean.open("w") as fobj:

Calling tool: grepTool
write_back\s*==\s*WriteBack\.YES
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:377:            if write_back == WriteBack.YES and changed is not Changed.NO:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:449:    if write_back == WriteBack.YES and formatted:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:516:        if write_back == WriteBack.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:378:            if write_back == WriteBack.YES and changed is not Changed.NO:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:450:    if write_back == WriteBack.YES and formatted:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:525:        if write_back == WriteBack.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:377:            if write_back == WriteBack.YES and changed is not Changed.NO:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:449:    if write_back == WriteBack.YES and formatted:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:516:        if write_back == WriteBack.YES:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
340:
341:
342:def reformat_one(
343:    src: Path,
344:    line_length: int,
345:    fast: bool,
346:    write_back: WriteBack,
347:    mode: FileMode,
348:    report: "Report",
349:) -> None:
350:    """Reformat a single file under `src` without spawning child processes.
351:
352:    If `quiet` is True, non-error messages are not output. `line_length`,
353:    `write_back`, `fast` and `pyi` options are passed to
354:    :func:`format_file_in_place` or :func:`format_stdin_to_stdout`.
355:    """
356:    try:
357:        changed = Changed.NO
358:        if not src.is_file() and str(src) == "-":
359:            if format_stdin_to_stdout(
360:                line_length=line_length, fast=fast, write_back=write_back, mode=mode
361:            ):
362:                changed = Changed.YES
363:        else:
364:            cache: Cache = {}
365:            if write_back != WriteBack.DIFF:
366:                cache = read_cache(line_length, mode)
367:                res_src = src.resolve()
368:                if res_src in cache and cache[res_src] == get_cache_info(res_src):
369:                    changed = Changed.CACHED
370:            if changed is not Changed.CACHED and format_file_in_place(
371:                src,
372:                line_length=line_length,
373:                fast=fast,
374:                write_back=write_back,
375:                mode=mode,
376:            ):
377:                changed = Changed.YES
378:            if write_back == WriteBack.YES and changed is not Changed.NO:
379:                write_cache(cache, [src], line_length, mode)
380:        report.done(src, changed)
381:    except Exception as exc:
382:        report.failed(src, str(exc))
383:
384:
385:async def schedule_formatting(
386:    sources: List[Path],
387:    line_length: int,
388:    fast: bool,
389:    write_back: WriteBack,
390:    mode: FileMode,
391:    report: "Report",
392:    loop: BaseEventLoop,
393:    executor: Executor,
394:) -> None:
395:    """Run formatting of `sources` in parallel using the provided `executor`.
396:
397:    (Use ProcessPoolExecutors for actual parallelism.)
398:
399:    `line_length`, `write_back`, `fast`, and `pyi` options are passed to
400:    :func:`format_file_in_place`.
401:    """
402:    cache: Cache = {}
403:    if write_back != WriteBack.DIFF:
404:        cache = read_cache(line_length, mode)
405:        sources, cached = filter_cached(cache, sources)
406:        for src in cached:
407:            report.done(src, Changed.CACHED)
408:    cancelled = []
409:    formatted = []
410:    if sources:
411:        lock = None
412:        if write_back == WriteBack.DIFF:
413:            # For diff output, we need locks to ensure we don't interleave output
414:            # from different processes.
415:            manager = Manager()
416:            lock = manager.Lock()
417:        tasks = {
418:            loop.run_in_executor(
419:                executor,
420:                format_file_in_place,
421:                src,
422:                line_length,
423:                fast,
424:                write_back,
425:                mode,
426:                lock,
427:            ): src
428:            for src in sorted(sources)
429:        }
430:        pending: Iterable[asyncio.Task] = tasks.keys()
431:        try:
432:            loop.add_signal_handler(signal.SIGINT, cancel, pending)
433:            loop.add_signal_handler(signal.SIGTERM, cancel, pending)
434:        except NotImplementedError:
435:            # There are no good alternatives for these on Windows
436:            pass
437:        while pending:
438:            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
439:            for task in done:
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
440:                if task.cancelled():
441:                    cancelled.append(task)
442:                elif task.exception():
443:                    report.failed(src, str(task.exception()))
444:                else:
445:                    formatted.append(src)
446:                    report.done(src, Changed.YES if task.result() else Changed.NO)
447:    if cancelled:
448:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
449:    if write_back == WriteBack.YES and formatted:
450:        write_cache(cache, formatted, line_length, mode)
451:
452:
453:def format_file_in_place(
454:    src: Path,
455:    line_length: int,
456:    fast: bool,
457:    write_back: WriteBack = WriteBack.NO,
458:    mode: FileMode = FileMode.AUTO_DETECT,
459:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
460:) -> bool:
461:    """Format file under `src` path. Return True if changed.
462:
463:    If `write_back` is True, write reformatted code back to stdout.
464:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
465:    """
466:    if src.suffix == ".pyi":
467:        mode |= FileMode.PYI
468:    with tokenize.open(src) as src_buffer:
469:        src_contents = src_buffer.read()
470:    try:
471:        dst_contents = format_file_contents(
472:            src_contents, line_length=line_length, fast=fast, mode=mode
473:        )
474:    except NothingChanged:
475:        return False
476:
477:    if write_back == write_back.YES:
478:        with open(src, "w", encoding=src_buffer.encoding) as f:
479:            f.write(dst_contents)
480:    elif write_back == write_back.DIFF:
481:        src_name = f"{src}  (original)"
482:        dst_name = f"{src}  (formatted)"
483:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
484:        if lock:
485:            lock.acquire()
486:        try:
487:            sys.stdout.write(diff_contents)
488:        finally:
489:            if lock:
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)

Calling tool: grepTool
def write_cache\(
Matched content:
3324:def write_cache(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
3280:
3281:
3282:def read_cache(line_length: int, mode: FileMode) -> Cache:
3283:    """Read the cache if it exists and is well formed.
3284:
3285:    If it is not well formed, the call to write_cache later should resolve the issue.
3286:    """
3287:    cache_file = get_cache_file(line_length, mode)
3288:    if not cache_file.exists():
3289:        return {}
3290:
3291:    with cache_file.open("rb") as fobj:
3292:        try:
3293:            cache: Cache = pickle.load(fobj)
3294:        except pickle.UnpicklingError:
3295:            return {}
3296:
3297:    return cache
3298:
3299:
3300:def get_cache_info(path: Path) -> CacheInfo:
3301:    """Return the information used to check if a file is already formatted or not."""
3302:    stat = path.stat()
3303:    return stat.st_mtime, stat.st_size
3304:
3305:
3306:def filter_cached(
3307:    cache: Cache, sources: Iterable[Path]
3308:) -> Tuple[List[Path], List[Path]]:
3309:    """Split a list of paths into two.
3310:
3311:    The first list contains paths of files that modified on disk or are not in the
3312:    cache. The other list contains paths to non-modified files.
3313:    """
3314:    todo, done = [], []
3315:    for src in sources:
3316:        src = src.resolve()
3317:        if cache.get(src) != get_cache_info(src):
3318:            todo.append(src)
3319:        else:
3320:            done.append(src)
3321:    return todo, done
3322:
3323:
3324:def write_cache(
3325:    cache: Cache, sources: List[Path], line_length: int, mode: FileMode
3326:) -> None:
3327:    """Update the cache file."""
3328:    cache_file = get_cache_file(line_length, mode)
3329:    try:
3330:        if not CACHE_DIR.exists():
3331:            CACHE_DIR.mkdir(parents=True)
3332:        new_cache = {**cache, **{src.resolve(): get_cache_info(src) for src in sources}}
3333:        with cache_file.open("wb") as fobj:
3334:            pickle.dump(new_cache, fobj, protocol=pickle.HIGHEST_PROTOCOL)
3335:    except OSError:
3336:        pass
3337:
3338:
3339:if __name__ == "__main__":
3340:    main()

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Searched the modified code for file write-back paths and verified the only in-place write uses open(src, "w", encoding=encoding, newline=newline) in black.py:480. No other in-place write paths without newline were found; other writes are either to stdout or binary cache files.


Todo item 12 of 14 is correct
description: 'Confirm there are no remaining write-back code paths that open files for writing without specifying newline=..., which could reintroduce platform-dependent line ending conversions when formatting in place.'
Validating todo item 13 of 14
description: 'Check the test tests/test_black.py::BlackTestCase.test_preserves_line_endings writes files with both '\n' and '\r\n', calls format_file_in_place with WriteBack.YES, and asserts that the updated file bytes contain the original newline sequence; additionally for '\n' it asserts absence of '\r\n'.'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_preserves_line_endings\\b",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "\\bff\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_file_in_place\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def prepare_input\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class WriteBack\\b",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "== write_back\\.YES|== write_back\\.DIFF|== write_back",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def format_stdin_to_stdout\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original"
]
Calling tool: grepTool
test_preserves_line_endings\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:1113:    def test_preserves_line_endings(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py
1088:        path = THIS_DIR / "include_exclude_tests"
1089:        report = black.Report()
1090:        empty = re.compile(r"")
1091:        sources: List[Path] = []
1092:        expected = [
1093:            Path(path / "b/dont_exclude/a.py"),
1094:            Path(path / "b/dont_exclude/a.pyi"),
1095:            Path(path / "b/exclude/a.py"),
1096:            Path(path / "b/exclude/a.pyi"),
1097:            Path(path / "b/.definitely_exclude/a.py"),
1098:            Path(path / "b/.definitely_exclude/a.pyi"),
1099:        ]
1100:        this_abs = THIS_DIR.resolve()
1101:        sources.extend(
1102:            black.gen_python_files_in_dir(
1103:                path, this_abs, re.compile(black.DEFAULT_INCLUDES), empty, report
1104:            )
1105:        )
1106:        self.assertEqual(sorted(expected), sorted(sources))
1107:
1108:    def test_invalid_include_exclude(self) -> None:
1109:        for option in ["--include", "--exclude"]:
1110:            result = CliRunner().invoke(black.main, ["-", option, "**()(!!*)"])
1111:            self.assertEqual(result.exit_code, 2)
1112:
1113:    def test_preserves_line_endings(self) -> None:
1114:        with TemporaryDirectory() as workspace:
1115:            test_file = Path(workspace) / "test.py"
1116:            for nl in ["\n", "\r\n"]:
1117:                contents = nl.join(["def f(  ):", "    pass"])
1118:                test_file.write_bytes(contents.encode())
1119:                ff(test_file, write_back=black.WriteBack.YES)
1120:                updated_contents: bytes = test_file.read_bytes()
1121:                self.assertIn(nl.encode(), updated_contents)  # type: ignore
1122:                if nl == "\n":
1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore
1124:
1125:
1126:if __name__ == "__main__":
1127:    unittest.main()

Calling tool: grepTool
\bff\(
Matched content:
109:        self.assertFalse(ff(THIS_FILE))
118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
163:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
193:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
210:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.DIFF))
1119:                ff(test_file, write_back=black.WriteBack.YES)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import sys
10:from tempfile import TemporaryDirectory
11:from typing import Any, List, Tuple, Iterator
12:import unittest
13:from unittest.mock import patch
14:import re
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:ll = 88
22:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
23:fs = partial(black.format_str, line_length=ll)
24:THIS_FILE = Path(__file__)
25:THIS_DIR = THIS_FILE.parent
26:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
27:
28:
29:def dump_to_stderr(*output: str) -> str:
30:    return "\n" + "\n".join(output) + "\n"
31:
32:
33:def read_data(name: str) -> Tuple[str, str]:
34:    """read_data('test_name') -> 'input', 'output'"""
35:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
36:        name += ".py"
37:    _input: List[str] = []
38:    _output: List[str] = []
39:    with open(THIS_DIR / name, "r", encoding="utf8") as test:
40:        lines = test.readlines()
41:    result = _input
42:    for line in lines:
43:        line = line.replace(EMPTY_LINE, "")
44:        if line.rstrip() == "# output":
45:            result = _output
46:            continue
47:
48:        result.append(line)
49:    if _input and not _output:
50:        # If there's no output marker, treat the entire file as already pre-formatted.
51:        _output = _input[:]
52:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
53:
54:
55:@contextmanager
56:def cache_dir(exists: bool = True) -> Iterator[Path]:
57:    with TemporaryDirectory() as workspace:
58:        cache_dir = Path(workspace)
59:        if not exists:
60:            cache_dir = cache_dir / "new"
61:        with patch("black.CACHE_DIR", cache_dir):
62:            yield cache_dir
63:
64:
65:@contextmanager
66:def event_loop(close: bool) -> Iterator[None]:
67:    policy = asyncio.get_event_loop_policy()
68:    old_loop = policy.get_event_loop()
69:    loop = policy.new_event_loop()
70:    asyncio.set_event_loop(loop)
71:    try:
72:        yield
73:
74:    finally:
75:        policy.set_event_loop(old_loop)
76:        if close:
77:            loop.close()
78:
79:
80:class BlackTestCase(unittest.TestCase):
81:    maxDiff = None
82:
83:    def assertFormatEqual(self, expected: str, actual: str) -> None:
84:        if actual != expected and not os.environ.get("SKIP_AST_PRINT"):
85:            bdv: black.DebugVisitor[Any]
86:            black.out("Expected tree:", fg="green")
87:            try:
88:                exp_node = black.lib2to3_parse(expected)
89:                bdv = black.DebugVisitor()
90:                list(bdv.visit(exp_node))
91:            except Exception as ve:
92:                black.err(str(ve))
93:            black.out("Actual tree:", fg="red")
94:            try:
95:                exp_node = black.lib2to3_parse(actual)
96:                bdv = black.DebugVisitor()
97:                list(bdv.visit(exp_node))
98:            except Exception as ve:
99:                black.err(str(ve))
100:        self.assertEqual(expected, actual)
101:
102:    @patch("black.dump_to_file", dump_to_stderr)
103:    def test_self(self) -> None:
104:        source, expected = read_data("test_black")
105:        actual = fs(source)
106:        self.assertFormatEqual(expected, actual)
107:        black.assert_equivalent(source, actual)
108:        black.assert_stable(source, actual, line_length=ll)
109:        self.assertFalse(ff(THIS_FILE))
110:
111:    @patch("black.dump_to_file", dump_to_stderr)
112:    def test_black(self) -> None:
113:        source, expected = read_data("../black")
114:        actual = fs(source)
115:        self.assertFormatEqual(expected, actual)
116:        black.assert_equivalent(source, actual)
117:        black.assert_stable(source, actual, line_length=ll)
118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
119:
120:    def test_piping(self) -> None:
121:        source, expected = read_data("../black")
122:        hold_stdin, hold_stdout = sys.stdin, sys.stdout
123:        try:
124:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
125:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
126:            sys.stdin.buffer.name = "<stdin>"  # type: ignore
127:            black.format_stdin_to_stdout(
128:                line_length=ll, fast=True, write_back=black.WriteBack.YES
129:            )
130:            sys.stdout.seek(0)
131:            actual = sys.stdout.read()
132:        finally:
133:            sys.stdin, sys.stdout = hold_stdin, hold_stdout
134:        self.assertFormatEqual(expected, actual)
135:        black.assert_equivalent(source, actual)
136:        black.assert_stable(source, actual, line_length=ll)
137:
138:    def test_piping_diff(self) -> None:
139:        source, _ = read_data("expression.py")
140:        expected, _ = read_data("expression.diff")

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:

Calling tool: grepTool
class WriteBack\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:117:class WriteBack(Enum):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:118:class WriteBack(Enum):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:117:class WriteBack(Enum):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
100:
101:    def trim_prefix(self, leaf: Leaf) -> None:
102:        leaf.prefix = leaf.prefix[self.consumed :]
103:
104:    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:
105:        """Returns a new Leaf from the consumed part of the prefix."""
106:        unformatted_prefix = leaf.prefix[: self.consumed]
107:        return Leaf(token.NEWLINE, unformatted_prefix)
108:
109:
110:class FormatOn(FormatError):
111:    """Found a comment like `# fmt: on` in the file."""
112:
113:
114:class FormatOff(FormatError):
115:    """Found a comment like `# fmt: off` in the file."""
116:
117:
118:class WriteBack(Enum):
119:    NO = 0
120:    YES = 1
121:    DIFF = 2
122:
123:    @classmethod
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
125:        if check and not diff:
126:            return cls.NO
127:
128:        return cls.DIFF if diff else cls.YES
129:
130:
131:class Changed(Enum):
132:    NO = 0
133:    CACHED = 1
134:    YES = 2
135:
136:
137:class FileMode(Flag):
138:    AUTO_DETECT = 0
139:    PYTHON36 = 1

Calling tool: grepTool
== write_back\.YES|== write_back\.DIFF|== write_back
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:477:    if write_back == write_back.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:480:    elif write_back == write_back.DIFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:479:    if write_back == write_back.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:482:    elif write_back == write_back.DIFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:477:    if write_back == write_back.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:480:    elif write_back == write_back.DIFF:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original
460:) -> bool:
461:    """Format file under `src` path. Return True if changed.
462:
463:    If `write_back` is True, write reformatted code back to stdout.
464:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
465:    """
466:    if src.suffix == ".pyi":
467:        mode |= FileMode.PYI
468:    with tokenize.open(src) as src_buffer:
469:        src_contents = src_buffer.read()
470:    try:
471:        dst_contents = format_file_contents(
472:            src_contents, line_length=line_length, fast=fast, mode=mode
473:        )
474:    except NothingChanged:
475:        return False
476:
477:    if write_back == write_back.YES:
478:        with open(src, "w", encoding=src_buffer.encoding) as f:
479:            f.write(dst_contents)
480:    elif write_back == write_back.DIFF:
481:        src_name = f"{src}  (original)"
482:        dst_name = f"{src}  (formatted)"
483:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
484:        if lock:
485:            lock.acquire()
486:        try:
487:            sys.stdout.write(diff_contents)
488:        finally:
489:            if lock:
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:

Calling tool: grepTool
def format_stdin_to_stdout\(
Matched content:
494:def format_stdin_to_stdout(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)
560:    is_pyi = bool(mode & FileMode.PYI)
561:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
562:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
563:    lines = LineGenerator(
564:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
565:        is_pyi=is_pyi,
566:        normalize_strings=normalize_strings,
567:    )
568:    elt = EmptyLineTracker(is_pyi=is_pyi)
569:    empty_line = Line()
570:    after = 0
571:    for current_line in lines.visit(src_node):
572:        for _ in range(after):
573:            dst_contents += str(empty_line)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: The test writes files with LF and CRLF and calls format_file_in_place with WriteBack.YES, but in the implementation the condition uses `if write_back == write_back.YES:` (black.py:479) which attempts to access attribute YES on the enum instance, causing an AttributeError and preventing the file from being written. Thus the updated file bytes cannot be validated and the requirement is not met.


Validating todo item 1 of 14
description: 'Verify black.py imports io to support new TextIOWrapper and BytesIO usage.'

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py

Calling tool: grepTool
^import io$
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/driver.py:20:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:7:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/driver.py:20:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/identify/identify.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/setuptools_scm/utils.py:11:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/toml/decoder.py:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/click/_compat.py:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/click/_winconsole.py:11:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/resources.py:10:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/util.py:10:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/readme_renderer/rst.py:16:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/readme_renderer/integration/distutils.py:17:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pycparser/__init__.py:13:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/wheel.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/cryptography/hazmat/primitives/serialization/pkcs7.py:11:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/installed.py:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/develop.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/sdist.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/toml.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/pkg_resources/__init__.py:22:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/urllib3/packages/backports/makefile.py:9:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/urllib3/contrib/appengine.py:43:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/urllib3/response.py:3:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/flake8/utils.py:5:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/distlib/resources.py:10:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/distlib/util.py:10:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/urllib3/util/ssltransport.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/requests/utils.py:11:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/rich/__main__.py:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/rich/progress.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/rich/file_proxy.py:1:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_internal/utils/misc.py:8:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_internal/network/session.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/rich/console.py:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/cachecontrol/serialize.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/requests/utils.py:13:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/entrypoints.py:8:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/coverage/tomlconfig.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/urllib3/packages/backports/makefile.py:9:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/urllib3/response.py:4:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/urllib3/contrib/appengine.py:42:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/mypy/stubdoc.py:7:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/mypy/dmypy_server.py:9:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/coverage/annotate.py:6:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/yaml/__init__.py:18:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/nodeenv.py:14:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2/fcntl.pyi:2:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/twine/package.py:18:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/mypy/util.py:9:import io
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/zipp/__init__.py:10:import io

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
1:import asyncio
2:import pickle
3:from asyncio.base_events import BaseEventLoop
4:from concurrent.futures import Executor, ProcessPoolExecutor
5:from enum import Enum, Flag
6:from functools import partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import re
14:import tokenize
15:import signal
16:import sys
17:from typing import (
18:    Any,
19:    Callable,
20:    Collection,
21:    Dict,
22:    Generic,
23:    Iterable,
24:    Iterator,
25:    List,
26:    Optional,
27:    Pattern,
28:    Sequence,
29:    Set,
30:    Tuple,
31:    Type,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:

Calling tool: grepTool
TextIOWrapper|BytesIO
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:489:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:526:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:537:            f = io.TextIOWrapper(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:611:    srcbuf = io.BytesIO(src)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:6:from io import BytesIO, TextIOWrapper
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:124:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:125:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:143:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:144:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:209:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/bleach/_vendor/html5lib/_inputstream.py:18:    from io import BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/bleach/_vendor/html5lib/_inputstream.py:20:    BytesIO = StringIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/bleach/_vendor/html5lib/_inputstream.py:448:            stream = BytesIO(source)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/_compat.py:18:    from io import BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/_compat.py:20:    BytesIO = StringIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/babel/_compat.py:21:    from io import StringIO, BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/babel/_compat.py:45:    from cStringIO import StringIO as BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/tests/test_commandline.py:17:            buf = io.BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pkginfo/tests/test_commandline.py:54:            buf = io.BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/__init__.py:65:from .payload import BytesIOPayload as BytesIOPayload
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/__init__.py:179:    'BytesIOPayload',
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/payload.py:41:           'IOBasePayload', 'BytesIOPayload', 'BufferedReaderPayload',
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/payload.py:227:                          "io.BytesIO object instead", ResourceWarning,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/payload.py:356:class BytesIOPayload(IOBasePayload):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/payload.py:374:            # io.BufferedReader(io.BytesIO(b'data'))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/aiohttp/payload.py:448:PAYLOAD_REGISTRY.register(BytesIOPayload, io.BytesIO)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/scripts.py:7:from io import BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/scripts.py:242:            stream = BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/locators.py:9:from io import BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/locators.py:596:        'gzip': lambda b: gzip.GzipFile(fileobj=BytesIO(d)).read(),
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/resources.py:254:        return io.BytesIO(self.get_bytes(resource))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/util.py:1254:    """zip a directory tree into a BytesIO object"""
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/util.py:1255:    result = io.BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/_backport/tarfile.py:834:    # XXX TextIOWrapper uses the read1() method.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/distlib/compat.py:67:    from io import TextIOWrapper as file_type
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/bccache.py:19:from ._compat import BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/bccache.py:85:        self.load_bytecode(BytesIO(string))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/bccache.py:89:        out = BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/cffi/verifier.py:23:    class NativeIO(io.BytesIO):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/_compat.py:22:    from io import BytesIO, StringIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/_compat.py:55:    from cStringIO import StringIO as BytesIO, StringIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/jinja2/_compat.py:57:    NativeStringIO = BytesIO
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/cffi/recompiler.py:1416:    class NativeIO(io.BytesIO):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/cryptography/hazmat/primitives/serialization/pkcs7.py:350:    fp = io.BytesIO()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/flake8/utils.py:198:    fd = io.BytesIO(stdin_value)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/flake8/utils.py:212:            stdin_value = io.BytesIO(sys.stdin.read())
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/cachecontrol/serialize.py:36:            response._fp = io.BytesIO(body)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/cachecontrol/serialize.py:129:                body = io.BytesIO(body_raw)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/lib/python3.8/site-packages/pip/_vendor/cachecontrol/serialize.py:139:            body = io.BytesIO(body_raw.encode("utf8"))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import sys
10:from tempfile import TemporaryDirectory
11:from typing import Any, List, Tuple, Iterator
12:import unittest
13:from unittest.mock import patch
14:import re
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:ll = 88
22:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
23:fs = partial(black.format_str, line_length=ll)
24:THIS_FILE = Path(__file__)
25:THIS_DIR = THIS_FILE.parent
26:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
27:
28:
29:def dump_to_stderr(*output: str) -> str:
30:    return "\n" + "\n".join(output) + "\n"
31:
32:
33:def read_data(name: str) -> Tuple[str, str]:
34:    """read_data('test_name') -> 'input', 'output'"""
35:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
36:        name += ".py"
37:    _input: List[str] = []
38:    _output: List[str] = []
39:    with open(THIS_DIR / name, "r", encoding="utf8") as test:
40:        lines = test.readlines()

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Confirmed black.py includes `import io` at line 7, matching the diff. The file uses io.TextIOWrapper and io.BytesIO later (lines ~489, 526, 537, 611, 615), so the import supports the new usage.

Todo item 1 of 14 is correct
description: 'Verify black.py imports io to support new TextIOWrapper and BytesIO usage.'

Validating todo item 2 of 14
description: 'Confirm new helper function prepare_input(src: bytes) exists in black.py with signature Tuple[str, str, str] and returns (newline, encoding, decoded_contents).'

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None

Calling tool: grepTool
from typing import.*Tuple
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
Tuple\[
Matched content:
69:CacheInfo = Tuple[Timestamp, FileSize]
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
837:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
961:    comments: List[Tuple[Index, Leaf]] = Factory(list)
1299:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1314:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
3139:def enumerate_reversed(sequence: Sequence[T]) -> Iterator[Tuple[Index, T]]:
3149:) -> Iterator[Tuple[Index, Leaf, int]]:
3155:        Callable[[Sequence[Leaf]], Iterator[Tuple[Index, Leaf]]],
3308:) -> Tuple[List[Path], List[Path]]:

Calling tool: grepTool
from typing import
Matched content:
17:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
1:import asyncio
2:import pickle
3:from asyncio.base_events import BaseEventLoop
4:from concurrent.futures import Executor, ProcessPoolExecutor
5:from enum import Enum, Flag
6:from functools import partial, wraps
7:import io
8:import keyword
9:import logging
10:from multiprocessing import Manager
11:import os
12:from pathlib import Path
13:import re
14:import tokenize
15:import signal
16:import sys
17:from typing import (
18:    Any,
19:    Callable,
20:    Collection,
21:    Dict,
22:    Generic,
23:    Iterable,
24:    Iterator,
25:    List,
26:    Optional,
27:    Pattern,
28:    Sequence,
29:    Set,
30:    Tuple,
31:    Type,
32:    TypeVar,
33:    Union,
34:    cast,
35:)
36:
37:from appdirs import user_cache_dir
38:from attr import dataclass, Factory
39:import click
40:
41:# lib2to3 fork
42:from blib2to3.pytree import Node, Leaf, type_repr
43:from blib2to3 import pygram, pytree
44:from blib2to3.pgen2 import driver, token
45:from blib2to3.pgen2.parse import ParseError
46:
47:
48:__version__ = "18.5b1"
49:DEFAULT_LINE_LENGTH = 88
50:DEFAULT_EXCLUDES = (
51:    r"/(\.git|\.hg|\.mypy_cache|\.tox|\.venv|_build|buck-out|build|dist)/"
52:)
53:DEFAULT_INCLUDES = r"\.pyi?$"
54:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
55:
56:
57:# types
58:FileContent = str
59:Encoding = str
60:Depth = int

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Function prepare_input is present in black.py at line ~605 with signature Tuple[str, str, str] and returns a tuple (newline, encoding, decoded_contents) as shown by the return statement.

Todo item 2 of 14 is correct
description: 'Confirm new helper function prepare_input(src: bytes) exists in black.py with signature Tuple[str, str, str] and returns (newline, encoding, decoded_contents).'

Validating todo item 3 of 14
description: 'Check prepare_input uses tokenize.detect_encoding on a BytesIO of the source to determine encoding and inspects lines[0][-2:] to detect CRLF (sets '\r\n') vs LF (sets '\n').'

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
670:        instead.
671:
672:        Then yields objects of type `T` from the selected visitor.
673:        """
674:        if node.type < 256:
675:            name = token.tok_name[node.type]
676:        else:
677:            name = type_repr(node.type)
678:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
679:
680:    def visit_default(self, node: LN) -> Iterator[T]:
681:        """Default `visit_*()` implementation. Recurses to children of `node`."""

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, prepare_input creates a BytesIO from the source, calls tokenize.detect_encoding(srcbuf.readline) to get encoding and lines, and sets newline to '\r\n' if lines[0][-2:] equals b'\r\n' otherwise '\n'. This matches the requirement exactly.

Todo item 3 of 14 is correct
description: 'Check prepare_input uses tokenize.detect_encoding on a BytesIO of the source to determine encoding and inspects lines[0][-2:] to detect CRLF (sets '\r\n') vs LF (sets '\n').'

Validating todo item 4 of 14
description: 'Ensure prepare_input resets the BytesIO position to 0 after detect_encoding and decodes using io.TextIOWrapper without a newline argument so that universal newlines produce only '\n' in decoded_contents.'

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: prepare_input seeks the BytesIO back to 0 after tokenize.detect_encoding and decodes via io.TextIOWrapper(srcbuf, encoding) without a newline argument, enabling universal newline translation to produce only '\n' in decoded contents.

Todo item 4 of 14 is correct
description: 'Ensure prepare_input resets the BytesIO position to 0 after detect_encoding and decodes using io.TextIOWrapper without a newline argument so that universal newlines produce only '\n' in decoded_contents.'

Validating todo item 5 of 14
description: 'In format_file_in_place, verify that the file is opened in binary mode ('rb') and passed through prepare_input to obtain newline and encoding before formatting.'

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:

Calling tool: grepTool
^import io$
Matched content:
7:import io

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, format_file_in_place opens the file in binary mode (open(src, "rb")) and immediately passes the bytes to prepare_input to obtain newline and encoding (lines 470-471) before formatting. This satisfies the requirement.

Todo item 5 of 14 is correct
description: 'In format_file_in_place, verify that the file is opened in binary mode ('rb') and passed through prepare_input to obtain newline and encoding before formatting.'

Validating todo item 6 of 14
description: 'In format_file_in_place with WriteBack.YES, check that the file is opened for writing with open(src, 'w', encoding=encoding, newline=newline) to preserve original line endings on write-back.'

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
440:                if task.cancelled():
441:                    cancelled.append(task)
442:                elif task.exception():
443:                    report.failed(src, str(task.exception()))
444:                else:
445:                    formatted.append(src)
446:                    report.done(src, Changed.YES if task.result() else Changed.NO)
447:    if cancelled:
448:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
449:    if write_back == WriteBack.YES and formatted:
450:        write_cache(cache, formatted, line_length, mode)
451:
452:
453:def format_file_in_place(
454:    src: Path,
455:    line_length: int,
456:    fast: bool,
457:    write_back: WriteBack = WriteBack.NO,
458:    mode: FileMode = FileMode.AUTO_DETECT,
459:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
460:) -> bool:
461:    """Format file under `src` path. Return True if changed.
462:
463:    If `write_back` is True, write reformatted code back to stdout.
464:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
465:    """
466:    if src.suffix == ".pyi":
467:        mode |= FileMode.PYI
468:    with tokenize.open(src) as src_buffer:
469:        src_contents = src_buffer.read()
470:    try:
471:        dst_contents = format_file_contents(
472:            src_contents, line_length=line_length, fast=fast, mode=mode
473:        )
474:    except NothingChanged:
475:        return False
476:
477:    if write_back == write_back.YES:
478:        with open(src, "w", encoding=src_buffer.encoding) as f:
479:            f.write(dst_contents)
480:    elif write_back == write_back.DIFF:
481:        src_name = f"{src}  (original)"
482:        dst_name = f"{src}  (formatted)"
483:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
484:        if lock:
485:            lock.acquire()
486:        try:
487:            sys.stdout.write(diff_contents)
488:        finally:
489:            if lock:
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)

Calling tool: grepTool
write_back == write_back\.YES
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:477:    if write_back == write_back.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:479:    if write_back == write_back.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:477:    if write_back == write_back.YES:

Calling tool: grepTool
class WriteBack\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:117:class WriteBack(Enum):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:118:class WriteBack(Enum):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:117:class WriteBack(Enum):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
110:class FormatOn(FormatError):
111:    """Found a comment like `# fmt: on` in the file."""
112:
113:
114:class FormatOff(FormatError):
115:    """Found a comment like `# fmt: off` in the file."""
116:
117:
118:class WriteBack(Enum):
119:    NO = 0
120:    YES = 1
121:    DIFF = 2
122:
123:    @classmethod
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
125:        if check and not diff:
126:            return cls.NO
127:
128:        return cls.DIFF if diff else cls.YES
129:

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py, within format_file_in_place, the YES write-back branch opens the file with open(src, "w", encoding=encoding, newline=newline) (lines 479-481), using values obtained from prepare_input. This preserves original line endings on write-back as required.

Todo item 6 of 14 is correct
description: 'In format_file_in_place with WriteBack.YES, check that the file is opened for writing with open(src, 'w', encoding=encoding, newline=newline) to preserve original line endings on write-back.'

Validating todo item 7 of 14
description: 'In format_file_in_place with WriteBack.DIFF, confirm stdout writing is done via an io.TextIOWrapper over sys.stdout.buffer using the detected encoding and newline, with write_through=True, and that f.detach() is called afterward (and that the lock around writing is preserved).'

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
430:        pending: Iterable[asyncio.Task] = tasks.keys()
431:        try:
432:            loop.add_signal_handler(signal.SIGINT, cancel, pending)
433:            loop.add_signal_handler(signal.SIGTERM, cancel, pending)
434:        except NotImplementedError:
435:            # There are no good alternatives for these on Windows
436:            pass
437:        while pending:
438:            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
439:            for task in done:
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In format_file_in_places WriteBack.DIFF branch (black.py:486-499), output is written using io.TextIOWrapper(sys.stdout.buffer, encoding=encoding, newline=newline, write_through=True), then f.detach() is called. The write is wrapped in a lock acquire/try/finally with lock.release(), preserving the lock behavior.

Todo item 7 of 14 is correct
description: 'In format_file_in_place with WriteBack.DIFF, confirm stdout writing is done via an io.TextIOWrapper over sys.stdout.buffer using the detected encoding and newline, with write_through=True, and that f.detach() is called afterward (and that the lock around writing is preserved).'

Validating todo item 8 of 14
description: 'In format_stdin_to_stdout, verify it reads from sys.stdin.buffer.read(), passes bytes to prepare_input, and uses the returned newline and encoding.'

Calling tool: grepTool
def format_stdin_to_stdout\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:494:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:503:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:494:def format_stdin_to_stdout(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, format_stdin_to_stdout reads from sys.stdin.buffer.read(), passes those bytes to prepare_input, and uses the returned newline and encoding when writing via a TextIOWrapper in both YES and DIFF branches (lines ~515-544).

Todo item 8 of 14 is correct
description: 'In format_stdin_to_stdout, verify it reads from sys.stdin.buffer.read(), passes bytes to prepare_input, and uses the returned newline and encoding.'

Validating todo item 9 of 14
description: 'In format_stdin_to_stdout, confirm both WriteBack.YES and WriteBack.DIFF paths write via an io.TextIOWrapper over sys.stdout.buffer with the detected encoding and newline, call f.write(...), and then f.detach().'

Calling tool: grepTool
def format_stdin_to_stdout\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:494:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:503:def format_stdin_to_stdout(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:494:def format_stdin_to_stdout(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """
580:    src_node = lib2to3_parse(src_contents)
581:    dst_contents = ""
582:    future_imports = get_future_imports(src_node)
583:    is_pyi = bool(mode & FileMode.PYI)
584:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
585:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
586:    lines = LineGenerator(
587:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
588:        is_pyi=is_pyi,
589:        normalize_strings=normalize_strings,
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In format_stdin_to_stdout, both WriteBack.YES and WriteBack.DIFF branches wrap sys.stdout.buffer in io.TextIOWrapper using the detected encoding and newline from prepare_input, perform f.write(...) of the respective content, and then call f.detach(). Verified at lines 525-544 in black.py.

Todo item 9 of 14 is correct
description: 'In format_stdin_to_stdout, confirm both WriteBack.YES and WriteBack.DIFF paths write via an io.TextIOWrapper over sys.stdout.buffer with the detected encoding and newline, call f.write(...), and then f.detach().'

Validating todo item 10 of 14
description: 'Verify lib2to3_parse unconditionally appends a single '\n' when the input doesn't end with a newline, removing the previous CRLF detection logic, which is now unnecessary due to universal newline decoding.'

Calling tool: grepTool
def lib2to3_parse\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:589:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:625:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:589:def lib2to3_parse(src_txt: str) -> Node:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:

Calling tool: grepTool
\r\n
Grep command failed with exit code 2: rg: .rgignore: No such file or directory (os error 2)
rg: the literal "\n" is not allowed in a regex

Consider enabling multiline mode with the --multiline flag (or -U for short).
When multiline mode is enabled, new line characters can be matched.


Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
580:
581:
582:GRAMMARS = [
583:    pygram.python_grammar_no_print_statement_no_exec_statement,
584:    pygram.python_grammar_no_print_statement,
585:    pygram.python_grammar,
586:]
587:
588:
589:def lib2to3_parse(src_txt: str) -> Node:
590:    """Given a string with source, return the lib2to3 Node."""
591:    grammar = pygram.python_grammar_no_print_statement
592:    if src_txt[-1] != "\n":
593:        nl = "\r\n" if "\r\n" in src_txt[:1024] else "\n"
594:        src_txt += nl
595:    for grammar in GRAMMARS:
596:        drv = driver.Driver(grammar, pytree.convert)
597:        try:
598:            result = drv.parse_string(src_txt, True)
599:            break
600:
601:        except ParseError as pe:
602:            lineno, column = pe.context[1]
603:            lines = src_txt.splitlines()
604:            try:
605:                faulty_line = lines[lineno - 1]
606:            except IndexError:
607:                faulty_line = "<line number missing in source>"
608:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
609:    else:
610:        raise exc from None
611:
612:    if isinstance(result, Leaf):
613:        result = Node(syms.file_input, [result])
614:    return result
615:
616:
617:def lib2to3_unparse(node: Node) -> str:
618:    """Given a lib2to3 node, return its string representation."""
619:    code = str(node)
620:    return code
621:
622:
623:T = TypeVar("T")
624:
625:
626:class Visitor(Generic[T]):
627:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
628:
629:    def visit(self, node: LN) -> Iterator[T]:
630:        """Main method to visit `node` and its children.
631:
632:        It tries to find a `visit_*()` method for the given `node.type`, like
633:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
634:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
635:        instead.
636:
637:        Then yields objects of type `T` from the selected visitor.
638:        """
639:        if node.type < 256:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original
580:
581:
582:GRAMMARS = [
583:    pygram.python_grammar_no_print_statement_no_exec_statement,
584:    pygram.python_grammar_no_print_statement,
585:    pygram.python_grammar,
586:]
587:
588:
589:def lib2to3_parse(src_txt: str) -> Node:
590:    """Given a string with source, return the lib2to3 Node."""
591:    grammar = pygram.python_grammar_no_print_statement
592:    if src_txt[-1] != "\n":
593:        nl = "\r\n" if "\r\n" in src_txt[:1024] else "\n"
594:        src_txt += nl
595:    for grammar in GRAMMARS:
596:        drv = driver.Driver(grammar, pytree.convert)
597:        try:
598:            result = drv.parse_string(src_txt, True)
599:            break
600:
601:        except ParseError as pe:
602:            lineno, column = pe.context[1]
603:            lines = src_txt.splitlines()
604:            try:
605:                faulty_line = lines[lineno - 1]
606:            except IndexError:
607:                faulty_line = "<line number missing in source>"
608:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
609:    else:
610:        raise exc from None
611:
612:    if isinstance(result, Leaf):
613:        result = Node(syms.file_input, [result])
614:    return result
615:
616:
617:def lib2to3_unparse(node: Node) -> str:
618:    """Given a lib2to3 node, return its string representation."""
619:    code = str(node)
620:    return code
621:
622:
623:T = TypeVar("T")
624:
625:
626:class Visitor(Generic[T]):
627:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
628:
629:    def visit(self, node: LN) -> Iterator[T]:
630:        """Main method to visit `node` and its children.
631:
632:        It tries to find a `visit_*()` method for the given `node.type`, like
633:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
634:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
635:        instead.
636:
637:        Then yields objects of type `T` from the selected visitor.
638:        """
639:        if node.type < 256:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black/black.py at lines 625-631, lib2to3_parse now appends a single "\n" when the input doesnt end with a newline. The previous CRLF detection logic was removed. This aligns with universal newline decoding handled earlier by prepare_input.

Todo item 10 of 14 is correct
description: 'Verify lib2to3_parse unconditionally appends a single '\n' when the input doesn't end with a newline, removing the previous CRLF detection logic, which is now unnecessary due to universal newline decoding.'

Validating todo item 11 of 14
description: 'Ensure all code paths that pass source text to lib2to3_parse (e.g., format_str via format_file_contents) supply text that has been decoded through prepare_input so only LF newlines are present in-memory.'

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
430:        pending: Iterable[asyncio.Task] = tasks.keys()
431:        try:
432:            loop.add_signal_handler(signal.SIGINT, cancel, pending)
433:            loop.add_signal_handler(signal.SIGTERM, cancel, pending)
434:        except NotImplementedError:
435:            # There are no good alternatives for these on Windows
436:            pass
437:        while pending:
438:            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
439:            for task in done:
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """
560:    if src_contents.strip() == "":
561:        raise NothingChanged
562:
563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
564:    if src_contents == dst_contents:
565:        raise NothingChanged
566:
567:    if not fast:
568:        assert_equivalent(src_contents, dst_contents)
569:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
570:    return dst_contents
571:
572:
573:def format_str(
574:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
575:) -> FileContent:
576:    """Reformat a string and return new contents.
577:
578:    `line_length` determines how many characters per line are allowed.
579:    """
580:    src_node = lib2to3_parse(src_contents)
581:    dst_contents = ""
582:    future_imports = get_future_imports(src_node)
583:    is_pyi = bool(mode & FileMode.PYI)
584:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
585:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
586:    lines = LineGenerator(
587:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
588:        is_pyi=is_pyi,
589:        normalize_strings=normalize_strings,
590:    )
591:    elt = EmptyLineTracker(is_pyi=is_pyi)
592:    empty_line = Line()
593:    after = 0
594:    for current_line in lines.visit(src_node):
595:        for _ in range(after):
596:            dst_contents += str(empty_line)
597:        before, after = elt.maybe_empty_lines(current_line)
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:
658:T = TypeVar("T")
659:
660:
661:class Visitor(Generic[T]):
662:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
663:
664:    def visit(self, node: LN) -> Iterator[T]:
665:        """Main method to visit `node` and its children.
666:
667:        It tries to find a `visit_*()` method for the given `node.type`, like
668:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
669:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
670:        instead.
671:
672:        Then yields objects of type `T` from the selected visitor.
673:        """
674:        if node.type < 256:
675:            name = token.tok_name[node.type]
676:        else:
677:            name = type_repr(node.type)
678:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
679:
680:    def visit_default(self, node: LN) -> Iterator[T]:
681:        """Default `visit_*()` implementation. Recurses to children of `node`."""
682:        if isinstance(node, Node):
683:            for child in node.children:
684:                yield from self.visit(child)
685:
686:
687:@dataclass
688:class DebugVisitor(Visitor[T]):
689:    tree_depth: int = 0

Calling tool: grepTool
lib2to3_parse\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:557:    src_node = lib2to3_parse(src_contents)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:589:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:683:        list(v.visit(lib2to3_parse(code)))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:580:    src_node = lib2to3_parse(src_contents)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:625:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:718:        list(v.visit(lib2to3_parse(code)))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:88:                exp_node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:95:                exp_node = black.lib2to3_parse(actual)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:656:        node = black.lib2to3_parse("def f(*, arg): ...\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:658:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:660:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:663:        node = black.lib2to3_parse(source)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:665:        node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:668:        node = black.lib2to3_parse(source)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:670:        node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:674:        node = black.lib2to3_parse("\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:676:        node = black.lib2to3_parse("from __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:678:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:680:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:682:        node = black.lib2to3_parse(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:686:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:688:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:690:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:692:        node = black.lib2to3_parse("from some.module import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:739:        n = black.lib2to3_parse("\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:557:    src_node = lib2to3_parse(src_contents)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:589:def lib2to3_parse(src_txt: str) -> Node:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:683:        list(v.visit(lib2to3_parse(code)))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/debug_visitor.py:32:        list(v.visit(lib2to3_parse(code)))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:88:                exp_node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:95:                exp_node = black.lib2to3_parse(actual)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:654:        node = black.lib2to3_parse("def f(*, arg): ...\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:656:        node = black.lib2to3_parse("def f(*, arg,): ...\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:658:        node = black.lib2to3_parse("def f(*, arg): f'string'\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:661:        node = black.lib2to3_parse(source)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:663:        node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:666:        node = black.lib2to3_parse(source)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:668:        node = black.lib2to3_parse(expected)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:672:        node = black.lib2to3_parse("\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:674:        node = black.lib2to3_parse("from __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:676:        node = black.lib2to3_parse("from __future__ import multiple, imports\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:678:        node = black.lib2to3_parse("from __future__ import (parenthesized, imports)\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:680:        node = black.lib2to3_parse(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:684:        node = black.lib2to3_parse("# comment\nfrom __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:686:        node = black.lib2to3_parse('"""docstring"""\nfrom __future__ import black\n')
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:688:        node = black.lib2to3_parse("some(other, code)\nfrom __future__ import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:690:        node = black.lib2to3_parse("from some.module import black\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:737:        n = black.lib2to3_parse("\n")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/debug_visitor.py:32:        list(v.visit(lib2to3_parse(code)))

Calling tool: grepTool
format_file_contents\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:471:        dst_contents = format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:524:def format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/plugin/black.vim:99:    new_buffer_str = black.format_file_contents(buffer_str, line_length=line_length, fast=fast)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:473:        dst_contents = format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:547:def format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:719:    def test_format_file_contents(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:722:            black.format_file_contents(empty, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:725:            black.format_file_contents(just_nl, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:728:            black.format_file_contents(same, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:731:        actual = black.format_file_contents(different, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:735:            black.format_file_contents(invalid, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:471:        dst_contents = format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:524:def format_file_contents(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/plugin/black.vim:99:    new_buffer_str = black.format_file_contents(buffer_str, line_length=line_length, fast=fast)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:717:    def test_format_file_contents(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:720:            black.format_file_contents(empty, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:723:            black.format_file_contents(just_nl, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:726:            black.format_file_contents(same, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:729:        actual = black.format_file_contents(different, line_length=ll, fast=False)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:733:            black.format_file_contents(invalid, line_length=ll, fast=False)

Calling tool: grepTool
format_str\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:550:def format_str(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:3027:    newdst = format_str(dst, line_length=line_length, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:563:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:573:def format_str(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:3062:    newdst = format_str(dst, line_length=line_length, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:550:def format_str(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:3027:    newdst = format_str(dst, line_length=line_length, mode=mode)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
3000:
3001:    def _v(node: ast.AST, depth: int = 0) -> Iterator[str]:
3002:        """Simple visitor generating strings to compare ASTs by content."""
3003:        yield f"{'  ' * depth}{node.__class__.__name__}("
3004:
3005:        for field in sorted(node._fields):
3006:            try:
3007:                value = getattr(node, field)
3008:            except AttributeError:
3009:                continue
3010:
3011:            yield f"{'  ' * (depth+1)}{field}="
3012:
3013:            if isinstance(value, list):
3014:                for item in value:
3015:                    if isinstance(item, ast.AST):
3016:                        yield from _v(item, depth + 2)
3017:
3018:            elif isinstance(value, ast.AST):
3019:                yield from _v(value, depth + 2)
3020:
3021:            else:
3022:                yield f"{'  ' * (depth+2)}{value!r},  # {value.__class__.__name__}"
3023:
3024:        yield f"{'  ' * depth})  # /{node.__class__.__name__}"
3025:
3026:    try:
3027:        src_ast = ast.parse(src)
3028:    except Exception as exc:
3029:        major, minor = sys.version_info[:2]
3030:        raise AssertionError(
3031:            f"cannot use --safe with this file; failed to parse source file "
3032:            f"with Python {major}.{minor}'s builtin AST. Re-run with --fast "
3033:            f"or stop using deprecated Python 2 syntax. AST error message: {exc}"
3034:        )
3035:
3036:    try:
3037:        dst_ast = ast.parse(dst)
3038:    except Exception as exc:
3039:        log = dump_to_file("".join(traceback.format_tb(exc.__traceback__)), dst)
3040:        raise AssertionError(
3041:            f"INTERNAL ERROR: Black produced invalid code: {exc}. "
3042:            f"Please report a bug on https://github.com/ambv/black/issues.  "
3043:            f"This invalid output might be helpful: {log}"
3044:        ) from None
3045:
3046:    src_ast_str = "\n".join(_v(src_ast))
3047:    dst_ast_str = "\n".join(_v(dst_ast))
3048:    if src_ast_str != dst_ast_str:
3049:        log = dump_to_file(diff(src_ast_str, dst_ast_str, "src", "dst"))
3050:        raise AssertionError(
3051:            f"INTERNAL ERROR: Black produced code that is not equivalent to "
3052:            f"the source.  "
3053:            f"Please report a bug on https://github.com/ambv/black/issues.  "
3054:            f"This diff might be helpful: {log}"
3055:        ) from None
3056:
3057:
3058:def assert_stable(
3059:    src: str, dst: str, line_length: int, mode: FileMode = FileMode.AUTO_DETECT
3060:) -> None:
3061:    """Raise AssertionError if `dst` reformats differently the second time."""
3062:    newdst = format_str(dst, line_length=line_length, mode=mode)
3063:    if dst != newdst:
3064:        log = dump_to_file(
3065:            diff(src, dst, "source", "first pass"),
3066:            diff(dst, newdst, "first pass", "second pass"),
3067:        )
3068:        raise AssertionError(
3069:            f"INTERNAL ERROR: Black produced different code on the second pass "
3070:            f"of the formatter.  "
3071:            f"Please report a bug on https://github.com/ambv/black/issues.  "
3072:            f"This diff might be helpful: {log}"
3073:        ) from None
3074:
3075:
3076:def dump_to_file(*output: str) -> str:
3077:    """Dump `output` to a temporary file. Return path to the file."""
3078:    import tempfile
3079:
3080:    with tempfile.NamedTemporaryFile(
3081:        mode="w", prefix="blk_", suffix=".log", delete=False, encoding="utf8"
3082:    ) as f:
3083:        for lines in output:
3084:            f.write(lines)
3085:            if lines and lines[-1] != "\n":
3086:                f.write("\n")
3087:    return f.name
3088:
3089:
3090:def diff(a: str, b: str, a_name: str, b_name: str) -> str:
3091:    """Return a unified diff string between strings `a` and `b`."""
3092:    import difflib
3093:
3094:    a_lines = [line + "\n" for line in a.split("\n")]
3095:    b_lines = [line + "\n" for line in b.split("\n")]
3096:    return "".join(
3097:        difflib.unified_diff(a_lines, b_lines, fromfile=a_name, tofile=b_name, n=5)
3098:    )
3099:
3100:
3101:def cancel(tasks: Iterable[asyncio.Task]) -> None:
3102:    """asyncio signal handler that cancels all `tasks` and reports to stderr."""
3103:    err("Aborted!")
3104:    for task in tasks:
3105:        task.cancel()
3106:
3107:
3108:def shutdown(loop: BaseEventLoop) -> None:
3109:    """Cancel all pending tasks on `loop`, wait for them, and close the loop."""
3110:    try:
3111:        # This part is borrowed from asyncio/runners.py in Python 3.7b2.
3112:        to_cancel = [task for task in asyncio.Task.all_tasks(loop) if not task.done()]
3113:        if not to_cancel:
3114:            return
3115:
3116:        for task in to_cancel:
3117:            task.cancel()
3118:        loop.run_until_complete(
3119:            asyncio.gather(*to_cancel, loop=loop, return_exceptions=True)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
430:        try:
431:            loop.add_signal_handler(signal.SIGINT, cancel, pending)
432:            loop.add_signal_handler(signal.SIGTERM, cancel, pending)
433:        except NotImplementedError:
434:            # There are no good alternatives for these on Windows
435:            pass
436:        while pending:
437:            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
438:            for task in done:
439:                src = tasks.pop(task)
440:                if task.cancelled():
441:                    cancelled.append(task)
442:                elif task.exception():
443:                    report.failed(src, str(task.exception()))
444:                else:
445:                    formatted.append(src)
446:                    report.done(src, Changed.YES if task.result() else Changed.NO)
447:    if cancelled:
448:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
449:    if write_back == WriteBack.YES and formatted:
450:        write_cache(cache, formatted, line_length, mode)
451:
452:
453:def format_file_in_place(
454:    src: Path,
455:    line_length: int,
456:    fast: bool,
457:    write_back: WriteBack = WriteBack.NO,
458:    mode: FileMode = FileMode.AUTO_DETECT,
459:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
460:) -> bool:
461:    """Format file under `src` path. Return True if changed.
462:
463:    If `write_back` is True, write reformatted code back to stdout.
464:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
465:    """
466:    if src.suffix == ".pyi":
467:        mode |= FileMode.PYI
468:    with tokenize.open(src) as src_buffer:
469:        src_contents = src_buffer.read()
470:    try:
471:        dst_contents = format_file_contents(
472:            src_contents, line_length=line_length, fast=fast, mode=mode
473:        )
474:    except NothingChanged:
475:        return False
476:
477:    if write_back == write_back.YES:
478:        with open(src, "w", encoding=src_buffer.encoding) as f:
479:            f.write(dst_contents)
480:    elif write_back == write_back.DIFF:
481:        src_name = f"{src}  (original)"
482:        dst_name = f"{src}  (formatted)"
483:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
484:        if lock:
485:            lock.acquire()
486:        try:
487:            sys.stdout.write(diff_contents)
488:        finally:
489:            if lock:
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)
560:    is_pyi = bool(mode & FileMode.PYI)
561:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
562:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
563:    lines = LineGenerator(
564:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
565:        is_pyi=is_pyi,
566:        normalize_strings=normalize_strings,
567:    )
568:    elt = EmptyLineTracker(is_pyi=is_pyi)
569:    empty_line = Line()
570:    after = 0
571:    for current_line in lines.visit(src_node):
572:        for _ in range(after):
573:            dst_contents += str(empty_line)
574:        before, after = elt.maybe_empty_lines(current_line)
575:        for _ in range(before):
576:            dst_contents += str(empty_line)
577:        for line in split_line(current_line, line_length=line_length, py36=py36):
578:            dst_contents += str(line)
579:    return dst_contents
580:
581:
582:GRAMMARS = [
583:    pygram.python_grammar_no_print_statement_no_exec_statement,
584:    pygram.python_grammar_no_print_statement,
585:    pygram.python_grammar,
586:]
587:
588:
589:def lib2to3_parse(src_txt: str) -> Node:
590:    """Given a string with source, return the lib2to3 Node."""
591:    grammar = pygram.python_grammar_no_print_statement
592:    if src_txt[-1] != "\n":
593:        nl = "\r\n" if "\r\n" in src_txt[:1024] else "\n"
594:        src_txt += nl
595:    for grammar in GRAMMARS:
596:        drv = driver.Driver(grammar, pytree.convert)
597:        try:
598:            result = drv.parse_string(src_txt, True)
599:            break
600:
601:        except ParseError as pe:
602:            lineno, column = pe.context[1]
603:            lines = src_txt.splitlines()
604:            try:
605:                faulty_line = lines[lineno - 1]
606:            except IndexError:
607:                faulty_line = "<line number missing in source>"
608:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
609:    else:
610:        raise exc from None
611:
612:    if isinstance(result, Leaf):
613:        result = Node(syms.file_input, [result])
614:    return result
615:
616:
617:def lib2to3_unparse(node: Node) -> str:
618:    """Given a lib2to3 node, return its string representation."""
619:    code = str(node)
620:    return code
621:
622:
623:T = TypeVar("T")
624:
625:
626:class Visitor(Generic[T]):
627:    """Basic lib2to3 visitor that yields things of type `T` on `visit()`."""
628:
629:    def visit(self, node: LN) -> Iterator[T]:
630:        """Main method to visit `node` and its children.
631:
632:        It tries to find a `visit_*()` method for the given `node.type`, like
633:        `visit_simple_stmt` for Node objects or `visit_INDENT` for Leaf objects.
634:        If no dedicated `visit_*()` method is found, chooses `visit_default()`
635:        instead.
636:
637:        Then yields objects of type `T` from the selected visitor.
638:        """
639:        if node.type < 256:
640:            name = token.tok_name[node.type]
641:        else:
642:            name = type_repr(node.type)
643:        yield from getattr(self, f"visit_{name}", self.visit_default)(node)
644:
645:    def visit_default(self, node: LN) -> Iterator[T]:
646:        """Default `visit_*()` implementation. Recurses to children of `node`."""
647:        if isinstance(node, Node):
648:            for child in node.children:
649:                yield from self.visit(child)
650:
651:
652:@dataclass
653:class DebugVisitor(Visitor[T]):
654:    tree_depth: int = 0
655:
656:    def visit_default(self, node: LN) -> Iterator[T]:
657:        indent = " " * (2 * self.tree_depth)
658:        if isinstance(node, Node):
659:            _type = type_repr(node.type)
660:            out(f"{indent}{_type}", fg="yellow")
661:            self.tree_depth += 1
662:            for child in node.children:
663:                yield from self.visit(child)
664:
665:            self.tree_depth -= 1
666:            out(f"{indent}/{_type}", fg="yellow", bold=False)
667:        else:
668:            _type = token.tok_name.get(node.type, str(node.type))
669:            out(f"{indent}{_type}", fg="blue", nl=False)
670:            if node.prefix:
671:                # We don't have to handle prefixes for `Node` objects since
672:                # that delegates to the first child anyway.
673:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
674:            out(f" {node.value!r}", fg="blue", bold=False)
675:
676:    @classmethod
677:    def show(cls, code: str) -> None:
678:        """Pretty-print the lib2to3 AST of a given string of `code`.
679:
680:        Convenience method for debugging.
681:        """
682:        v: DebugVisitor[None] = DebugVisitor()
683:        list(v.visit(lib2to3_parse(code)))
684:
685:
686:KEYWORDS = set(keyword.kwlist)
687:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
688:FLOW_CONTROL = {"return", "raise", "break", "continue"}
689:STATEMENT = {

Calling tool: grepTool
sys\.stdin|open\(|tokenize\.open\(
Matched content:
470:    with open(src, "rb") as buf:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
3291:    with cache_file.open("rb") as fobj:
3333:        with cache_file.open("wb") as fobj:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, both input paths that lead to lib2to3_parse (format_file_in_place and format_stdin_to_stdout via format_file_contentsformat_str) now decode with prepare_input, which uses TextIOWrapper with universal newlines ensuring only LF in-memory. lib2to3_parse was simplified to always append \n, relying on LF-only input. No other production code paths call lib2to3_parse with raw text.

Todo item 11 of 14 is correct
description: 'Ensure all code paths that pass source text to lib2to3_parse (e.g., format_str via format_file_contents) supply text that has been decoded through prepare_input so only LF newlines are present in-memory.'

Validating todo item 12 of 14
description: 'Confirm there are no remaining write-back code paths that open files for writing without specifying newline=..., which could reintroduce platform-dependent line ending conversions when formatting in place.'

Calling tool: grepTool
open\(
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:468:    with tokenize.open(src) as src_buffer:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:478:        with open(src, "w", encoding=src_buffer.encoding) as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:3256:    with cache_file.open("rb") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:3298:        with cache_file.open("wb") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/tokenize.py:344:        readline = open(myfile).next    # Example of alternate readline
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/tokenize.py:566:    if len(sys.argv) > 1: tokenize(open(sys.argv[1]).readline)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/driver.py:114:        with io.open(filename, "r", encoding=encoding) as stream:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/pgen.py:15:            stream = open(filename)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/grammar.py:89:        with open(filename, "wb") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/grammar.py:94:        with open(filename, "rb") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/setup.py:15:    with open(readme_md, encoding="utf8") as ld_file:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/setup.py:22:    with open(black_py, "r", encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/conv.py:62:            f = open(filename)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/blib2to3/pgen2/conv.py:113:            f = open(filename)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:470:    with open(src, "rb") as buf:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:480:        with open(src, "w", encoding=encoding, newline=newline) as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:3291:    with cache_file.open("rb") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:3333:        with cache_file.open("wb") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/docs/conf.py:30:    with open(str(black_py), "r", encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/docs/conf.py:38:    with open(str(template), "r", encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/docs/conf.py:40:    with open(str(target), "w", encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/docs/conf.py:63:    with open(str(readme), "r", encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/docs/conf.py:73:                output = open(str(output_path), "w", encoding="utf8")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/tokenize.py:344:        readline = open(myfile).next    # Example of alternate readline
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/tokenize.py:566:    if len(sys.argv) > 1: tokenize(open(sys.argv[1]).readline)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/driver.py:114:        with io.open(filename, "r", encoding=encoding) as stream:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/conv.py:62:            f = open(filename)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/conv.py:113:            f = open(filename)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/comments5.py:20:with open(some_temp_file) as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/comments5.py:24:    with open(some_other_file) as w:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/grammar.py:89:        with open(filename, "wb") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/blib2to3/pgen2/grammar.py:94:        with open(filename, "rb") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/comments5.py:20:with open(some_temp_file) as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/comments5.py:24:    with open(some_other_file) as w:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:39:    with open(THIS_DIR / name, "r", encoding="utf8") as test:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:192:            with open(tmp_file, encoding="utf8") as f:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:766:            with cache_file.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:770:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:781:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:786:            with src.open("r") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:796:            with one.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:799:            with two.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:804:            with one.open("r") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:806:            with two.open("r") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:816:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:876:            with failing.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:879:            with clean.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:945:            with open(path, "w") as fh:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:949:            with open(path, "r") as fh:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:969:                with open(path, "w") as fh:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: grepTool
\.open\("w"\)
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:768:            with cache_file.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:772:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:783:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:798:            with one.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:801:            with two.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:818:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:878:            with failing.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:881:            with clean.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:766:            with cache_file.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:770:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:781:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:796:            with one.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:799:            with two.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:816:            with src.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:876:            with failing.open("w") as fobj:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/tests/test_black.py:879:            with clean.open("w") as fobj:

Calling tool: grepTool
write_back\s*==\s*WriteBack\.YES
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:377:            if write_back == WriteBack.YES and changed is not Changed.NO:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:449:    if write_back == WriteBack.YES and formatted:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:516:        if write_back == WriteBack.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:378:            if write_back == WriteBack.YES and changed is not Changed.NO:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:450:    if write_back == WriteBack.YES and formatted:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:525:        if write_back == WriteBack.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:377:            if write_back == WriteBack.YES and changed is not Changed.NO:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:449:    if write_back == WriteBack.YES and formatted:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:516:        if write_back == WriteBack.YES:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
340:
341:
342:def reformat_one(
343:    src: Path,
344:    line_length: int,
345:    fast: bool,
346:    write_back: WriteBack,
347:    mode: FileMode,
348:    report: "Report",
349:) -> None:
350:    """Reformat a single file under `src` without spawning child processes.
351:
352:    If `quiet` is True, non-error messages are not output. `line_length`,
353:    `write_back`, `fast` and `pyi` options are passed to
354:    :func:`format_file_in_place` or :func:`format_stdin_to_stdout`.
355:    """
356:    try:
357:        changed = Changed.NO
358:        if not src.is_file() and str(src) == "-":
359:            if format_stdin_to_stdout(
360:                line_length=line_length, fast=fast, write_back=write_back, mode=mode
361:            ):
362:                changed = Changed.YES
363:        else:
364:            cache: Cache = {}
365:            if write_back != WriteBack.DIFF:
366:                cache = read_cache(line_length, mode)
367:                res_src = src.resolve()
368:                if res_src in cache and cache[res_src] == get_cache_info(res_src):
369:                    changed = Changed.CACHED
370:            if changed is not Changed.CACHED and format_file_in_place(
371:                src,
372:                line_length=line_length,
373:                fast=fast,
374:                write_back=write_back,
375:                mode=mode,
376:            ):
377:                changed = Changed.YES
378:            if write_back == WriteBack.YES and changed is not Changed.NO:
379:                write_cache(cache, [src], line_length, mode)
380:        report.done(src, changed)
381:    except Exception as exc:
382:        report.failed(src, str(exc))
383:
384:
385:async def schedule_formatting(
386:    sources: List[Path],
387:    line_length: int,
388:    fast: bool,
389:    write_back: WriteBack,
390:    mode: FileMode,
391:    report: "Report",
392:    loop: BaseEventLoop,
393:    executor: Executor,
394:) -> None:
395:    """Run formatting of `sources` in parallel using the provided `executor`.
396:
397:    (Use ProcessPoolExecutors for actual parallelism.)
398:
399:    `line_length`, `write_back`, `fast`, and `pyi` options are passed to
400:    :func:`format_file_in_place`.
401:    """
402:    cache: Cache = {}
403:    if write_back != WriteBack.DIFF:
404:        cache = read_cache(line_length, mode)
405:        sources, cached = filter_cached(cache, sources)
406:        for src in cached:
407:            report.done(src, Changed.CACHED)
408:    cancelled = []
409:    formatted = []
410:    if sources:
411:        lock = None
412:        if write_back == WriteBack.DIFF:
413:            # For diff output, we need locks to ensure we don't interleave output
414:            # from different processes.
415:            manager = Manager()
416:            lock = manager.Lock()
417:        tasks = {
418:            loop.run_in_executor(
419:                executor,
420:                format_file_in_place,
421:                src,
422:                line_length,
423:                fast,
424:                write_back,
425:                mode,
426:                lock,
427:            ): src
428:            for src in sorted(sources)
429:        }
430:        pending: Iterable[asyncio.Task] = tasks.keys()
431:        try:
432:            loop.add_signal_handler(signal.SIGINT, cancel, pending)
433:            loop.add_signal_handler(signal.SIGTERM, cancel, pending)
434:        except NotImplementedError:
435:            # There are no good alternatives for these on Windows
436:            pass
437:        while pending:
438:            done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
439:            for task in done:
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py
440:                if task.cancelled():
441:                    cancelled.append(task)
442:                elif task.exception():
443:                    report.failed(src, str(task.exception()))
444:                else:
445:                    formatted.append(src)
446:                    report.done(src, Changed.YES if task.result() else Changed.NO)
447:    if cancelled:
448:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
449:    if write_back == WriteBack.YES and formatted:
450:        write_cache(cache, formatted, line_length, mode)
451:
452:
453:def format_file_in_place(
454:    src: Path,
455:    line_length: int,
456:    fast: bool,
457:    write_back: WriteBack = WriteBack.NO,
458:    mode: FileMode = FileMode.AUTO_DETECT,
459:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
460:) -> bool:
461:    """Format file under `src` path. Return True if changed.
462:
463:    If `write_back` is True, write reformatted code back to stdout.
464:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
465:    """
466:    if src.suffix == ".pyi":
467:        mode |= FileMode.PYI
468:    with tokenize.open(src) as src_buffer:
469:        src_contents = src_buffer.read()
470:    try:
471:        dst_contents = format_file_contents(
472:            src_contents, line_length=line_length, fast=fast, mode=mode
473:        )
474:    except NothingChanged:
475:        return False
476:
477:    if write_back == write_back.YES:
478:        with open(src, "w", encoding=src_buffer.encoding) as f:
479:            f.write(dst_contents)
480:    elif write_back == write_back.DIFF:
481:        src_name = f"{src}  (original)"
482:        dst_name = f"{src}  (formatted)"
483:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
484:        if lock:
485:            lock.acquire()
486:        try:
487:            sys.stdout.write(diff_contents)
488:        finally:
489:            if lock:
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)

Calling tool: grepTool
def write_cache\(
Matched content:
3324:def write_cache(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
3280:
3281:
3282:def read_cache(line_length: int, mode: FileMode) -> Cache:
3283:    """Read the cache if it exists and is well formed.
3284:
3285:    If it is not well formed, the call to write_cache later should resolve the issue.
3286:    """
3287:    cache_file = get_cache_file(line_length, mode)
3288:    if not cache_file.exists():
3289:        return {}
3290:
3291:    with cache_file.open("rb") as fobj:
3292:        try:
3293:            cache: Cache = pickle.load(fobj)
3294:        except pickle.UnpicklingError:
3295:            return {}
3296:
3297:    return cache
3298:
3299:
3300:def get_cache_info(path: Path) -> CacheInfo:
3301:    """Return the information used to check if a file is already formatted or not."""
3302:    stat = path.stat()
3303:    return stat.st_mtime, stat.st_size
3304:
3305:
3306:def filter_cached(
3307:    cache: Cache, sources: Iterable[Path]
3308:) -> Tuple[List[Path], List[Path]]:
3309:    """Split a list of paths into two.
3310:
3311:    The first list contains paths of files that modified on disk or are not in the
3312:    cache. The other list contains paths to non-modified files.
3313:    """
3314:    todo, done = [], []
3315:    for src in sources:
3316:        src = src.resolve()
3317:        if cache.get(src) != get_cache_info(src):
3318:            todo.append(src)
3319:        else:
3320:            done.append(src)
3321:    return todo, done
3322:
3323:
3324:def write_cache(
3325:    cache: Cache, sources: List[Path], line_length: int, mode: FileMode
3326:) -> None:
3327:    """Update the cache file."""
3328:    cache_file = get_cache_file(line_length, mode)
3329:    try:
3330:        if not CACHE_DIR.exists():
3331:            CACHE_DIR.mkdir(parents=True)
3332:        new_cache = {**cache, **{src.resolve(): get_cache_info(src) for src in sources}}
3333:        with cache_file.open("wb") as fobj:
3334:            pickle.dump(new_cache, fobj, protocol=pickle.HIGHEST_PROTOCOL)
3335:    except OSError:
3336:        pass
3337:
3338:
3339:if __name__ == "__main__":
3340:    main()

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Searched the modified code for file write-back paths and verified the only in-place write uses open(src, "w", encoding=encoding, newline=newline) in black.py:480. No other in-place write paths without newline were found; other writes are either to stdout or binary cache files.

Todo item 12 of 14 is correct
description: 'Confirm there are no remaining write-back code paths that open files for writing without specifying newline=..., which could reintroduce platform-dependent line ending conversions when formatting in place.'

Validating todo item 13 of 14
description: 'Check the test tests/test_black.py::BlackTestCase.test_preserves_line_endings writes files with both '\n' and '\r\n', calls format_file_in_place with WriteBack.YES, and asserts that the updated file bytes contain the original newline sequence; additionally for '\n' it asserts absence of '\r\n'.'

Calling tool: grepTool
test_preserves_line_endings\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py:1113:    def test_preserves_line_endings(self) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_preserves_line_endings

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py
1088:        path = THIS_DIR / "include_exclude_tests"
1089:        report = black.Report()
1090:        empty = re.compile(r"")
1091:        sources: List[Path] = []
1092:        expected = [
1093:            Path(path / "b/dont_exclude/a.py"),
1094:            Path(path / "b/dont_exclude/a.pyi"),
1095:            Path(path / "b/exclude/a.py"),
1096:            Path(path / "b/exclude/a.pyi"),
1097:            Path(path / "b/.definitely_exclude/a.py"),
1098:            Path(path / "b/.definitely_exclude/a.pyi"),
1099:        ]
1100:        this_abs = THIS_DIR.resolve()
1101:        sources.extend(
1102:            black.gen_python_files_in_dir(
1103:                path, this_abs, re.compile(black.DEFAULT_INCLUDES), empty, report
1104:            )
1105:        )
1106:        self.assertEqual(sorted(expected), sorted(sources))
1107:
1108:    def test_invalid_include_exclude(self) -> None:
1109:        for option in ["--include", "--exclude"]:
1110:            result = CliRunner().invoke(black.main, ["-", option, "**()(!!*)"])
1111:            self.assertEqual(result.exit_code, 2)
1112:
1113:    def test_preserves_line_endings(self) -> None:
1114:        with TemporaryDirectory() as workspace:
1115:            test_file = Path(workspace) / "test.py"
1116:            for nl in ["\n", "\r\n"]:
1117:                contents = nl.join(["def f(  ):", "    pass"])
1118:                test_file.write_bytes(contents.encode())
1119:                ff(test_file, write_back=black.WriteBack.YES)
1120:                updated_contents: bytes = test_file.read_bytes()
1121:                self.assertIn(nl.encode(), updated_contents)  # type: ignore
1122:                if nl == "\n":
1123:                    self.assertNotIn(b"\r\n", updated_contents)  # type: ignore
1124:
1125:
1126:if __name__ == "__main__":
1127:    unittest.main()

Calling tool: grepTool
\bff\(
Matched content:
109:        self.assertFalse(ff(THIS_FILE))
118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
163:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
193:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
210:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.DIFF))
1119:                ff(test_file, write_back=black.WriteBack.YES)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:from concurrent.futures import ThreadPoolExecutor
4:from contextlib import contextmanager
5:from functools import partial
6:from io import BytesIO, TextIOWrapper
7:import os
8:from pathlib import Path
9:import sys
10:from tempfile import TemporaryDirectory
11:from typing import Any, List, Tuple, Iterator
12:import unittest
13:from unittest.mock import patch
14:import re
15:
16:from click import unstyle
17:from click.testing import CliRunner
18:
19:import black
20:
21:ll = 88
22:ff = partial(black.format_file_in_place, line_length=ll, fast=True)
23:fs = partial(black.format_str, line_length=ll)
24:THIS_FILE = Path(__file__)
25:THIS_DIR = THIS_FILE.parent
26:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
27:
28:
29:def dump_to_stderr(*output: str) -> str:
30:    return "\n" + "\n".join(output) + "\n"
31:
32:
33:def read_data(name: str) -> Tuple[str, str]:
34:    """read_data('test_name') -> 'input', 'output'"""
35:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
36:        name += ".py"
37:    _input: List[str] = []
38:    _output: List[str] = []
39:    with open(THIS_DIR / name, "r", encoding="utf8") as test:
40:        lines = test.readlines()
41:    result = _input
42:    for line in lines:
43:        line = line.replace(EMPTY_LINE, "")
44:        if line.rstrip() == "# output":
45:            result = _output
46:            continue
47:
48:        result.append(line)
49:    if _input and not _output:
50:        # If there's no output marker, treat the entire file as already pre-formatted.
51:        _output = _input[:]
52:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
53:
54:
55:@contextmanager
56:def cache_dir(exists: bool = True) -> Iterator[Path]:
57:    with TemporaryDirectory() as workspace:
58:        cache_dir = Path(workspace)
59:        if not exists:
60:            cache_dir = cache_dir / "new"
61:        with patch("black.CACHE_DIR", cache_dir):
62:            yield cache_dir
63:
64:
65:@contextmanager
66:def event_loop(close: bool) -> Iterator[None]:
67:    policy = asyncio.get_event_loop_policy()
68:    old_loop = policy.get_event_loop()
69:    loop = policy.new_event_loop()
70:    asyncio.set_event_loop(loop)
71:    try:
72:        yield
73:
74:    finally:
75:        policy.set_event_loop(old_loop)
76:        if close:
77:            loop.close()
78:
79:
80:class BlackTestCase(unittest.TestCase):
81:    maxDiff = None
82:
83:    def assertFormatEqual(self, expected: str, actual: str) -> None:
84:        if actual != expected and not os.environ.get("SKIP_AST_PRINT"):
85:            bdv: black.DebugVisitor[Any]
86:            black.out("Expected tree:", fg="green")
87:            try:
88:                exp_node = black.lib2to3_parse(expected)
89:                bdv = black.DebugVisitor()
90:                list(bdv.visit(exp_node))
91:            except Exception as ve:
92:                black.err(str(ve))
93:            black.out("Actual tree:", fg="red")
94:            try:
95:                exp_node = black.lib2to3_parse(actual)
96:                bdv = black.DebugVisitor()
97:                list(bdv.visit(exp_node))
98:            except Exception as ve:
99:                black.err(str(ve))
100:        self.assertEqual(expected, actual)
101:
102:    @patch("black.dump_to_file", dump_to_stderr)
103:    def test_self(self) -> None:
104:        source, expected = read_data("test_black")
105:        actual = fs(source)
106:        self.assertFormatEqual(expected, actual)
107:        black.assert_equivalent(source, actual)
108:        black.assert_stable(source, actual, line_length=ll)
109:        self.assertFalse(ff(THIS_FILE))
110:
111:    @patch("black.dump_to_file", dump_to_stderr)
112:    def test_black(self) -> None:
113:        source, expected = read_data("../black")
114:        actual = fs(source)
115:        self.assertFormatEqual(expected, actual)
116:        black.assert_equivalent(source, actual)
117:        black.assert_stable(source, actual, line_length=ll)
118:        self.assertFalse(ff(THIS_DIR / ".." / "black.py"))
119:
120:    def test_piping(self) -> None:
121:        source, expected = read_data("../black")
122:        hold_stdin, hold_stdout = sys.stdin, sys.stdout
123:        try:
124:            sys.stdin = TextIOWrapper(BytesIO(source.encode("utf8")), encoding="utf8")
125:            sys.stdout = TextIOWrapper(BytesIO(), encoding="utf8")
126:            sys.stdin.buffer.name = "<stdin>"  # type: ignore
127:            black.format_stdin_to_stdout(
128:                line_length=ll, fast=True, write_back=black.WriteBack.YES
129:            )
130:            sys.stdout.seek(0)
131:            actual = sys.stdout.read()
132:        finally:
133:            sys.stdin, sys.stdout = hold_stdin, hold_stdout
134:        self.assertFormatEqual(expected, actual)
135:        black.assert_equivalent(source, actual)
136:        black.assert_stable(source, actual, line_length=ll)
137:
138:    def test_piping_diff(self) -> None:
139:        source, _ = read_data("expression.py")
140:        expected, _ = read_data("expression.diff")

Calling tool: grepTool
def format_file_in_place\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:453:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:454:def format_file_in_place(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:453:def format_file_in_place(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
440:                src = tasks.pop(task)
441:                if task.cancelled():
442:                    cancelled.append(task)
443:                elif task.exception():
444:                    report.failed(src, str(task.exception()))
445:                else:
446:                    formatted.append(src)
447:                    report.done(src, Changed.YES if task.result() else Changed.NO)
448:    if cancelled:
449:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
450:    if write_back == WriteBack.YES and formatted:
451:        write_cache(cache, formatted, line_length, mode)
452:
453:
454:def format_file_in_place(
455:    src: Path,
456:    line_length: int,
457:    fast: bool,
458:    write_back: WriteBack = WriteBack.NO,
459:    mode: FileMode = FileMode.AUTO_DETECT,
460:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
461:) -> bool:
462:    """Format file under `src` path. Return True if changed.
463:
464:    If `write_back` is True, write reformatted code back to stdout.
465:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
466:    """
467:    if src.suffix == ".pyi":
468:        mode |= FileMode.PYI
469:
470:    with open(src, "rb") as buf:
471:        newline, encoding, src_contents = prepare_input(buf.read())
472:    try:
473:        dst_contents = format_file_contents(
474:            src_contents, line_length=line_length, fast=fast, mode=mode
475:        )
476:    except NothingChanged:
477:        return False
478:
479:    if write_back == write_back.YES:
480:        with open(src, "w", encoding=encoding, newline=newline) as f:
481:            f.write(dst_contents)
482:    elif write_back == write_back.DIFF:
483:        src_name = f"{src}  (original)"
484:        dst_name = f"{src}  (formatted)"
485:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
486:        if lock:
487:            lock.acquire()
488:        try:
489:            f = io.TextIOWrapper(
490:                sys.stdout.buffer,
491:                encoding=encoding,
492:                newline=newline,
493:                write_through=True,
494:            )
495:            f.write(diff_contents)
496:            f.detach()
497:        finally:
498:            if lock:
499:                lock.release()
500:    return True
501:
502:
503:def format_stdin_to_stdout(
504:    line_length: int,
505:    fast: bool,
506:    write_back: WriteBack = WriteBack.NO,
507:    mode: FileMode = FileMode.AUTO_DETECT,
508:) -> bool:
509:    """Format file on stdin. Return True if changed.
510:
511:    If `write_back` is True, write reformatted code back to stdout.
512:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
513:    :func:`format_file_contents`.
514:    """
515:    newline, encoding, src = prepare_input(sys.stdin.buffer.read())
516:    dst = src
517:    try:
518:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
519:        return True
520:
521:    except NothingChanged:
522:        return False
523:
524:    finally:
525:        if write_back == WriteBack.YES:
526:            f = io.TextIOWrapper(
527:                sys.stdout.buffer,
528:                encoding=encoding,
529:                newline=newline,
530:                write_through=True,
531:            )
532:            f.write(dst)
533:            f.detach()
534:        elif write_back == WriteBack.DIFF:
535:            src_name = "<stdin>  (original)"
536:            dst_name = "<stdin>  (formatted)"
537:            f = io.TextIOWrapper(
538:                sys.stdout.buffer,
539:                encoding=encoding,
540:                newline=newline,
541:                write_through=True,
542:            )
543:            f.write(diff(src, dst, src_name, dst_name))
544:            f.detach()
545:
546:
547:def format_file_contents(
548:    src_contents: str,
549:    *,
550:    line_length: int,
551:    fast: bool,
552:    mode: FileMode = FileMode.AUTO_DETECT,
553:) -> FileContent:
554:    """Reformat contents a file and return new contents.
555:
556:    If `fast` is False, additionally confirm that the reformatted code is
557:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
558:    `line_length` is passed to :func:`format_str`.
559:    """

Calling tool: grepTool
def prepare_input\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:605:def prepare_input(src: bytes) -> Tuple[str, str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
598:        for _ in range(before):
599:            dst_contents += str(empty_line)
600:        for line in split_line(current_line, line_length=line_length, py36=py36):
601:            dst_contents += str(line)
602:    return dst_contents
603:
604:
605:def prepare_input(src: bytes) -> Tuple[str, str, str]:
606:    """Analyze `src` and return a tuple of (newline, encoding, decoded_contents)
607:
608:    Where `newline` is either CRLF or LF, and `decoded_contents` is decoded with
609:    universal newlines (i.e. only LF).
610:    """
611:    srcbuf = io.BytesIO(src)
612:    encoding, lines = tokenize.detect_encoding(srcbuf.readline)
613:    newline = "\r\n" if b"\r\n" == lines[0][-2:] else "\n"
614:    srcbuf.seek(0)
615:    return newline, encoding, io.TextIOWrapper(srcbuf, encoding).read()
616:
617:
618:GRAMMARS = [
619:    pygram.python_grammar_no_print_statement_no_exec_statement,
620:    pygram.python_grammar_no_print_statement,
621:    pygram.python_grammar,
622:]
623:
624:
625:def lib2to3_parse(src_txt: str) -> Node:
626:    """Given a string with source, return the lib2to3 Node."""
627:    grammar = pygram.python_grammar_no_print_statement
628:    if src_txt[-1] != "\n":
629:        src_txt += "\n"
630:    for grammar in GRAMMARS:
631:        drv = driver.Driver(grammar, pytree.convert)
632:        try:
633:            result = drv.parse_string(src_txt, True)
634:            break
635:
636:        except ParseError as pe:
637:            lineno, column = pe.context[1]
638:            lines = src_txt.splitlines()
639:            try:
640:                faulty_line = lines[lineno - 1]
641:            except IndexError:
642:                faulty_line = "<line number missing in source>"
643:            exc = ValueError(f"Cannot parse: {lineno}:{column}: {faulty_line}")
644:    else:
645:        raise exc from None
646:
647:    if isinstance(result, Leaf):
648:        result = Node(syms.file_input, [result])
649:    return result
650:
651:
652:def lib2to3_unparse(node: Node) -> str:
653:    """Given a lib2to3 node, return its string representation."""
654:    code = str(node)
655:    return code
656:
657:

Calling tool: grepTool
class WriteBack\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:117:class WriteBack(Enum):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:118:class WriteBack(Enum):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:117:class WriteBack(Enum):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py
100:
101:    def trim_prefix(self, leaf: Leaf) -> None:
102:        leaf.prefix = leaf.prefix[self.consumed :]
103:
104:    def leaf_from_consumed(self, leaf: Leaf) -> Leaf:
105:        """Returns a new Leaf from the consumed part of the prefix."""
106:        unformatted_prefix = leaf.prefix[: self.consumed]
107:        return Leaf(token.NEWLINE, unformatted_prefix)
108:
109:
110:class FormatOn(FormatError):
111:    """Found a comment like `# fmt: on` in the file."""
112:
113:
114:class FormatOff(FormatError):
115:    """Found a comment like `# fmt: off` in the file."""
116:
117:
118:class WriteBack(Enum):
119:    NO = 0
120:    YES = 1
121:    DIFF = 2
122:
123:    @classmethod
124:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
125:        if check and not diff:
126:            return cls.NO
127:
128:        return cls.DIFF if diff else cls.YES
129:
130:
131:class Changed(Enum):
132:    NO = 0
133:    CACHED = 1
134:    YES = 2
135:
136:
137:class FileMode(Flag):
138:    AUTO_DETECT = 0
139:    PYTHON36 = 1

Calling tool: grepTool
== write_back\.YES|== write_back\.DIFF|== write_back
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:477:    if write_back == write_back.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original:480:    elif write_back == write_back.DIFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:479:    if write_back == write_back.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py:482:    elif write_back == write_back.DIFF:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:477:    if write_back == write_back.YES:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/env/src/black/black.py:480:    elif write_back == write_back.DIFF:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original
460:) -> bool:
461:    """Format file under `src` path. Return True if changed.
462:
463:    If `write_back` is True, write reformatted code back to stdout.
464:    `line_length` and `fast` options are passed to :func:`format_file_contents`.
465:    """
466:    if src.suffix == ".pyi":
467:        mode |= FileMode.PYI
468:    with tokenize.open(src) as src_buffer:
469:        src_contents = src_buffer.read()
470:    try:
471:        dst_contents = format_file_contents(
472:            src_contents, line_length=line_length, fast=fast, mode=mode
473:        )
474:    except NothingChanged:
475:        return False
476:
477:    if write_back == write_back.YES:
478:        with open(src, "w", encoding=src_buffer.encoding) as f:
479:            f.write(dst_contents)
480:    elif write_back == write_back.DIFF:
481:        src_name = f"{src}  (original)"
482:        dst_name = f"{src}  (formatted)"
483:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
484:        if lock:
485:            lock.acquire()
486:        try:
487:            sys.stdout.write(diff_contents)
488:        finally:
489:            if lock:
490:                lock.release()
491:    return True
492:
493:
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:

Calling tool: grepTool
def format_stdin_to_stdout\(
Matched content:
494:def format_stdin_to_stdout(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-18/bad/black/black.py.original
494:def format_stdin_to_stdout(
495:    line_length: int,
496:    fast: bool,
497:    write_back: WriteBack = WriteBack.NO,
498:    mode: FileMode = FileMode.AUTO_DETECT,
499:) -> bool:
500:    """Format file on stdin. Return True if changed.
501:
502:    If `write_back` is True, write reformatted code back to stdout.
503:    `line_length`, `fast`, `is_pyi`, and `force_py36` arguments are passed to
504:    :func:`format_file_contents`.
505:    """
506:    src = sys.stdin.read()
507:    dst = src
508:    try:
509:        dst = format_file_contents(src, line_length=line_length, fast=fast, mode=mode)
510:        return True
511:
512:    except NothingChanged:
513:        return False
514:
515:    finally:
516:        if write_back == WriteBack.YES:
517:            sys.stdout.write(dst)
518:        elif write_back == WriteBack.DIFF:
519:            src_name = "<stdin>  (original)"
520:            dst_name = "<stdin>  (formatted)"
521:            sys.stdout.write(diff(src, dst, src_name, dst_name))
522:
523:
524:def format_file_contents(
525:    src_contents: str,
526:    *,
527:    line_length: int,
528:    fast: bool,
529:    mode: FileMode = FileMode.AUTO_DETECT,
530:) -> FileContent:
531:    """Reformat contents a file and return new contents.
532:
533:    If `fast` is False, additionally confirm that the reformatted code is
534:    valid by calling :func:`assert_equivalent` and :func:`assert_stable` on it.
535:    `line_length` is passed to :func:`format_str`.
536:    """
537:    if src_contents.strip() == "":
538:        raise NothingChanged
539:
540:    dst_contents = format_str(src_contents, line_length=line_length, mode=mode)
541:    if src_contents == dst_contents:
542:        raise NothingChanged
543:
544:    if not fast:
545:        assert_equivalent(src_contents, dst_contents)
546:        assert_stable(src_contents, dst_contents, line_length=line_length, mode=mode)
547:    return dst_contents
548:
549:
550:def format_str(
551:    src_contents: str, line_length: int, *, mode: FileMode = FileMode.AUTO_DETECT
552:) -> FileContent:
553:    """Reformat a string and return new contents.
554:
555:    `line_length` determines how many characters per line are allowed.
556:    """
557:    src_node = lib2to3_parse(src_contents)
558:    dst_contents = ""
559:    future_imports = get_future_imports(src_node)
560:    is_pyi = bool(mode & FileMode.PYI)
561:    py36 = bool(mode & FileMode.PYTHON36) or is_python36(src_node)
562:    normalize_strings = not bool(mode & FileMode.NO_STRING_NORMALIZATION)
563:    lines = LineGenerator(
564:        remove_u_prefix=py36 or "unicode_literals" in future_imports,
565:        is_pyi=is_pyi,
566:        normalize_strings=normalize_strings,
567:    )
568:    elt = EmptyLineTracker(is_pyi=is_pyi)
569:    empty_line = Line()
570:    after = 0
571:    for current_line in lines.visit(src_node):
572:        for _ in range(after):
573:            dst_contents += str(empty_line)

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: The test writes files with LF and CRLF and calls format_file_in_place with WriteBack.YES, but in the implementation the condition uses `if write_back == write_back.YES:` (black.py:479) which attempts to access attribute YES on the enum instance, causing an AttributeError and preventing the file from being written. Thus the updated file bytes cannot be validated and the requirement is not met.


=== PHASE 2 COMPLETE ===

