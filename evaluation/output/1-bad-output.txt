=== PHASE 1: ANALYSIS ===

[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def reformat_many\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_works_in_mono_process_only_environment",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "async def schedule_formatting\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "from typing import .*Optional",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "^from typing import .*",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "class WriteBack\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "ProcessPoolExecutor\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "schedule_formatting\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py"
]
Calling tool: grepTool
def reformat_many\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.original:612:def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py:612:def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:3:@@ -618,7 +618,14 @@ def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:19:@@ -633,7 +640,8 @@ def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py:612:def reformat_many(

Calling tool: grepTool
test_works_in_mono_process_only_environment
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_works_in_mono_process_only_environment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/coverage_bugsinpy.txt:3:FAIL: test_works_in_mono_process_only_environment (tests.test_black.BlackTestCase)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/coverage_bugsinpy.txt:8:  File "/workspace/BugsInPy/framework/bin/temp/black-1/bad/black/tests/test_black.py", line 1288, in test_works_in_mono_process_only_environment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_works_in_mono_process_only_environment
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/tests/test_black.py:1277:    def test_works_in_mono_process_only_environment(self, mock_executor) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/tests/test_black.py
1240:            cache = black.read_cache(mode)
1241:            self.assertIn(src, cache)
1242:
1243:    def test_cache_single_file_already_cached(self) -> None:
1244:        mode = black.FileMode()
1245:        with cache_dir() as workspace:
1246:            src = (workspace / "test.py").resolve()
1247:            with src.open("w") as fobj:
1248:                fobj.write("print('hello')")
1249:            black.write_cache({}, [src], mode)
1250:            self.invokeBlack([str(src)])
1251:            with src.open("r") as fobj:
1252:                self.assertEqual(fobj.read(), "print('hello')")
1253:
1254:    @event_loop(close=False)
1255:    def test_cache_multiple_files(self) -> None:
1256:        mode = black.FileMode()
1257:        with cache_dir() as workspace, patch(
1258:            "black.ProcessPoolExecutor", new=ThreadPoolExecutor
1259:        ):
1260:            one = (workspace / "one.py").resolve()
1261:            with one.open("w") as fobj:
1262:                fobj.write("print('hello')")
1263:            two = (workspace / "two.py").resolve()
1264:            with two.open("w") as fobj:
1265:                fobj.write("print('hello')")
1266:            black.write_cache({}, [one], mode)
1267:            self.invokeBlack([str(workspace)])
1268:            with one.open("r") as fobj:
1269:                self.assertEqual(fobj.read(), "print('hello')")
1270:            with two.open("r") as fobj:
1271:                self.assertEqual(fobj.read(), 'print("hello")\n')
1272:            cache = black.read_cache(mode)
1273:            self.assertIn(one, cache)
1274:            self.assertIn(two, cache)
1275:
1276:    @patch("black.ProcessPoolExecutor", autospec=True)
1277:    def test_works_in_mono_process_only_environment(self, mock_executor) -> None:
1278:        mock_executor.side_effect = OSError()
1279:        mode = black.FileMode()
1280:        with cache_dir() as workspace:
1281:            one = (workspace / "one.py").resolve()
1282:            with one.open("w") as fobj:
1283:                fobj.write("print('hello')")
1284:            two = (workspace / "two.py").resolve()
1285:            with two.open("w") as fobj:
1286:                fobj.write("print('hello')")
1287:            black.write_cache({}, [one], mode)
1288:            self.invokeBlack([str(workspace)])
1289:            with one.open("r") as fobj:
1290:                self.assertEqual(fobj.read(), "print('hello')")
1291:            with two.open("r") as fobj:
1292:                self.assertEqual(fobj.read(), 'print("hello")\n')
1293:            cache = black.read_cache(mode)
1294:            self.assertIn(one, cache)
1295:            self.assertIn(two, cache)
1296:
1297:    def test_no_cache_when_writeback_diff(self) -> None:
1298:        mode = black.FileMode()
1299:        with cache_dir() as workspace:
1300:            src = (workspace / "test.py").resolve()
1301:            with src.open("w") as fobj:
1302:                fobj.write("print('hello')")
1303:            self.invokeBlack([str(src), "--diff"])
1304:            cache_file = black.get_cache_file(mode)
1305:            self.assertFalse(cache_file.exists())
1306:
1307:    def test_no_cache_when_stdin(self) -> None:
1308:        mode = black.FileMode()
1309:        with cache_dir():
1310:            result = CliRunner().invoke(
1311:                black.main, ["-"], input=BytesIO(b"print('hello')")
1312:            )
1313:            self.assertEqual(result.exit_code, 0)
1314:            cache_file = black.get_cache_file(mode)
1315:            self.assertFalse(cache_file.exists())
1316:
1317:    def test_read_cache_no_cachefile(self) -> None:
1318:        mode = black.FileMode()
1319:        with cache_dir():
1320:            self.assertEqual(black.read_cache(mode), {})
1321:
1322:    def test_write_cache_read_cache(self) -> None:
1323:        mode = black.FileMode()
1324:        with cache_dir() as workspace:
1325:            src = (workspace / "test.py").resolve()
1326:            src.touch()
1327:            black.write_cache({}, [src], mode)
1328:            cache = black.read_cache(mode)
1329:            self.assertIn(src, cache)
1330:            self.assertEqual(cache[src], black.get_cache_info(src))
1331:
1332:    def test_filter_cached(self) -> None:
1333:        with TemporaryDirectory() as workspace:
1334:            path = Path(workspace)
1335:            uncached = (path / "uncached").resolve()
1336:            cached = (path / "cached").resolve()
1337:            cached_but_changed = (path / "changed").resolve()
1338:            uncached.touch()
1339:            cached.touch()
1340:            cached_but_changed.touch()
1341:            cache = {cached: black.get_cache_info(cached), cached_but_changed: (0.0, 0)}
1342:            todo, done = black.filter_cached(
1343:                cache, {uncached, cached, cached_but_changed}
1344:            )
1345:            self.assertEqual(todo, {uncached, cached_but_changed})
1346:            self.assertEqual(done, {cached})
1347:
1348:    def test_write_cache_creates_directory_if_needed(self) -> None:
1349:        mode = black.FileMode()
1350:        with cache_dir(exists=False) as workspace:
1351:            self.assertFalse(workspace.exists())
1352:            black.write_cache({}, [], mode)
1353:            self.assertTrue(workspace.exists())
1354:
1355:    @event_loop(close=False)
1356:    def test_failed_formatting_does_not_get_cached(self) -> None:
1357:        mode = black.FileMode()
1358:        with cache_dir() as workspace, patch(
1359:            "black.ProcessPoolExecutor", new=ThreadPoolExecutor

Calling tool: grepTool
async def schedule_formatting\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.original:639:async def schedule_formatting(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py:647:async def schedule_formatting(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:28: async def schedule_formatting(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:29:@@ -643,7 +651,7 @@ async def schedule_formatting(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py:639:async def schedule_formatting(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
612:def reformat_many(
613:    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
614:) -> None:
615:    """Reformat multiple files using a ProcessPoolExecutor."""
616:    loop = asyncio.get_event_loop()
617:    worker_count = os.cpu_count()
618:    if sys.platform == "win32":
619:        # Work around https://bugs.python.org/issue26903
620:        worker_count = min(worker_count, 61)
621:    try:
622:        executor = ProcessPoolExecutor(max_workers=worker_count)
623:    except OSError:
624:        # we arrive here if the underlying system does not support multi-processing
625:        # like in AWS Lambda, in which case we gracefully fallback to the default
626:        # mono-process Executor by using None
627:        executor = ProcessPoolExecutor()
628:
629:    try:
630:        loop.run_until_complete(
631:            schedule_formatting(
632:                sources=sources,
633:                fast=fast,
634:                write_back=write_back,
635:                mode=mode,
636:                report=report,
637:                loop=loop,
638:                executor=executor,
639:            )
640:        )
641:    finally:
642:        shutdown(loop)
643:        if executor is not None:
644:            pass
645:
646:
647:async def schedule_formatting(
648:    sources: Set[Path],
649:    fast: bool,
650:    write_back: WriteBack,
651:    mode: Mode,
652:    report: "Report",
653:    loop: asyncio.AbstractEventLoop,
654:    executor: Optional[Executor],
655:) -> None:
656:    """Run formatting of `sources` in parallel using the provided `executor`.
657:
658:    (Use ProcessPoolExecutors for actual parallelism.)
659:
660:    `write_back`, `fast`, and `mode` options are passed to
661:    :func:`format_file_in_place`.
662:    """
663:    cache: Cache = {}
664:    if write_back != WriteBack.DIFF:
665:        cache = read_cache(mode)
666:        sources, cached = filter_cached(cache, sources)
667:        for src in sorted(cached):
668:            report.done(src, Changed.CACHED)
669:    if not sources:
670:        return
671:
672:    cancelled = []
673:    sources_to_cache = []
674:    lock = None
675:    if write_back == WriteBack.DIFF:
676:        # For diff output, we need locks to ensure we don't interleave output
677:        # from different processes.
678:        manager = Manager()
679:        lock = manager.Lock()
680:    tasks = {
681:        asyncio.ensure_future(
682:            loop.run_in_executor(
683:                executor, format_file_in_place, src, fast, mode, write_back, lock
684:            )
685:        ): src
686:        for src in sorted(sources)
687:    }
688:    pending: Iterable["asyncio.Future[bool]"] = tasks.keys()
689:    try:
690:        loop.add_signal_handler(signal.SIGINT, cancel, pending)
691:        loop.add_signal_handler(signal.SIGTERM, cancel, pending)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
692:    except NotImplementedError:
693:        # There are no good alternatives for these on Windows.
694:        pass
695:    while pending:
696:        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
697:        for task in done:
698:            src = tasks.pop(task)
699:            if task.cancelled():
700:                cancelled.append(task)
701:            elif task.exception():
702:                report.failed(src, str(task.exception()))
703:            else:
704:                changed = Changed.YES if task.result() else Changed.NO
705:                # If the file was written back or was successfully checked as
706:                # well-formatted, store this information in the cache.
707:                if write_back is WriteBack.YES or (
708:                    write_back is WriteBack.CHECK and changed is Changed.NO
709:                ):
710:                    sources_to_cache.append(src)
711:                report.done(src, changed)
712:    if cancelled:
713:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
714:    if sources_to_cache:
715:        write_cache(cache, sources_to_cache, mode)
716:
717:
718:def format_file_in_place(
719:    src: Path,
720:    fast: bool,
721:    mode: Mode,
722:    write_back: WriteBack = WriteBack.NO,
723:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
724:) -> bool:
725:    """Format file under `src` path. Return True if changed.
726:
727:    If `write_back` is DIFF, write a diff to stdout. If it is YES, write reformatted
728:    code to the file.
729:    `mode` and `fast` options are passed to :func:`format_file_contents`.
730:    """
731:    if src.suffix == ".pyi":
732:        mode = replace(mode, is_pyi=True)
733:
734:    then = datetime.utcfromtimestamp(src.stat().st_mtime)
735:    with open(src, "rb") as buf:
736:        src_contents, encoding, newline = decode_bytes(buf.read())
737:    try:
738:        dst_contents = format_file_contents(src_contents, fast=fast, mode=mode)
739:    except NothingChanged:
740:        return False
741:
742:    if write_back == WriteBack.YES:
743:        with open(src, "w", encoding=encoding, newline=newline) as f:
744:            f.write(dst_contents)
745:    elif write_back in (WriteBack.DIFF, WriteBack.COLOR_DIFF):
746:        now = datetime.utcnow()
747:        src_name = f"{src}\t{then} +0000"
748:        dst_name = f"{src}\t{now} +0000"
749:        diff_contents = diff(src_contents, dst_contents, src_name, dst_name)
750:
751:        if write_back == write_back.COLOR_DIFF:
752:            diff_contents = color_diff(diff_contents)
753:
754:        with lock or nullcontext():
755:            f = io.TextIOWrapper(
756:                sys.stdout.buffer,
757:                encoding=encoding,
758:                newline=newline,
759:                write_through=True,
760:            )
761:            f = wrap_stream_for_windows(f)
762:            f.write(diff_contents)
763:            f.detach()
764:
765:    return True
766:
767:
768:def color_diff(contents: str) -> str:
769:    """Inject the ANSI color codes to the diff."""
770:    lines = contents.split("\n")
771:    for i, line in enumerate(lines):
772:        if line.startswith("+++") or line.startswith("---"):
773:            line = "\033[1;37m" + line + "\033[0m"  # bold white, reset
774:        if line.startswith("@@"):
775:            line = "\033[36m" + line + "\033[0m"  # cyan, reset
776:        if line.startswith("+"):
777:            line = "\033[32m" + line + "\033[0m"  # green, reset
778:        elif line.startswith("-"):
779:            line = "\033[31m" + line + "\033[0m"  # red, reset
780:        lines[i] = line
781:    return "\n".join(lines)
782:
783:
784:def wrap_stream_for_windows(
785:    f: io.TextIOWrapper,
786:) -> Union[io.TextIOWrapper, "colorama.AnsiToWin32.AnsiToWin32"]:
787:    """
788:    Wrap the stream in colorama's wrap_stream so colors are shown on Windows.
789:
790:    If `colorama` is not found, then no change is made. If `colorama` does
791:    exist, then it handles the logic to determine whether or not to change
792:    things.
793:    """
794:    try:
795:        from colorama import initialise
796:
797:        # We set `strip=False` so that we can don't have to modify
798:        # test_express_diff_with_color.
799:        f = initialise.wrap_stream(
800:            f, convert=None, strip=False, autoreset=False, wrap=True
801:        )
802:
803:        # wrap_stream returns a `colorama.AnsiToWin32.AnsiToWin32` object
804:        # which does not have a `detach()` method. So we fake one.
805:        f.detach = lambda *args, **kwargs: None  # type: ignore
806:    except ImportError:
807:        pass
808:
809:    return f
810:
811:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.original
612:def reformat_many(
613:    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
614:) -> None:
615:    """Reformat multiple files using a ProcessPoolExecutor."""
616:    loop = asyncio.get_event_loop()
617:    worker_count = os.cpu_count()
618:    if sys.platform == "win32":
619:        # Work around https://bugs.python.org/issue26903
620:        worker_count = min(worker_count, 61)
621:    executor = ProcessPoolExecutor(max_workers=worker_count)
622:    try:
623:        loop.run_until_complete(
624:            schedule_formatting(
625:                sources=sources,
626:                fast=fast,
627:                write_back=write_back,
628:                mode=mode,
629:                report=report,
630:                loop=loop,
631:                executor=executor,
632:            )
633:        )
634:    finally:
635:        shutdown(loop)
636:        executor.shutdown()
637:
638:
639:async def schedule_formatting(
640:    sources: Set[Path],
641:    fast: bool,
642:    write_back: WriteBack,
643:    mode: Mode,
644:    report: "Report",
645:    loop: asyncio.AbstractEventLoop,
646:    executor: Executor,
647:) -> None:
648:    """Run formatting of `sources` in parallel using the provided `executor`.
649:
650:    (Use ProcessPoolExecutors for actual parallelism.)
651:
652:    `write_back`, `fast`, and `mode` options are passed to
653:    :func:`format_file_in_place`.
654:    """
655:    cache: Cache = {}
656:    if write_back != WriteBack.DIFF:
657:        cache = read_cache(mode)
658:        sources, cached = filter_cached(cache, sources)
659:        for src in sorted(cached):
660:            report.done(src, Changed.CACHED)
661:    if not sources:
662:        return
663:
664:    cancelled = []
665:    sources_to_cache = []
666:    lock = None
667:    if write_back == WriteBack.DIFF:
668:        # For diff output, we need locks to ensure we don't interleave output
669:        # from different processes.
670:        manager = Manager()
671:        lock = manager.Lock()
672:    tasks = {
673:        asyncio.ensure_future(
674:            loop.run_in_executor(
675:                executor, format_file_in_place, src, fast, mode, write_back, lock
676:            )
677:        ): src
678:        for src in sorted(sources)
679:    }
680:    pending: Iterable["asyncio.Future[bool]"] = tasks.keys()
681:    try:
682:        loop.add_signal_handler(signal.SIGINT, cancel, pending)
683:        loop.add_signal_handler(signal.SIGTERM, cancel, pending)
684:    except NotImplementedError:
685:        # There are no good alternatives for these on Windows.
686:        pass
687:    while pending:
688:        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
689:        for task in done:
690:            src = tasks.pop(task)
691:            if task.cancelled():

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py
612:def reformat_many(
613:    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
614:) -> None:
615:    """Reformat multiple files using a ProcessPoolExecutor."""
616:    loop = asyncio.get_event_loop()
617:    worker_count = os.cpu_count()
618:    if sys.platform == "win32":
619:        # Work around https://bugs.python.org/issue26903
620:        worker_count = min(worker_count, 61)
621:    executor = ProcessPoolExecutor(max_workers=worker_count)
622:    try:
623:        loop.run_until_complete(
624:            schedule_formatting(
625:                sources=sources,
626:                fast=fast,
627:                write_back=write_back,
628:                mode=mode,
629:                report=report,
630:                loop=loop,
631:                executor=executor,
632:            )
633:        )
634:    finally:
635:        shutdown(loop)
636:        executor.shutdown()
637:
638:
639:async def schedule_formatting(
640:    sources: Set[Path],
641:    fast: bool,
642:    write_back: WriteBack,
643:    mode: Mode,
644:    report: "Report",
645:    loop: asyncio.AbstractEventLoop,
646:    executor: Executor,
647:) -> None:
648:    """Run formatting of `sources` in parallel using the provided `executor`.
649:
650:    (Use ProcessPoolExecutors for actual parallelism.)
651:
652:    `write_back`, `fast`, and `mode` options are passed to
653:    :func:`format_file_in_place`.
654:    """
655:    cache: Cache = {}
656:    if write_back != WriteBack.DIFF:
657:        cache = read_cache(mode)
658:        sources, cached = filter_cached(cache, sources)
659:        for src in sorted(cached):
660:            report.done(src, Changed.CACHED)
661:    if not sources:
662:        return
663:
664:    cancelled = []
665:    sources_to_cache = []
666:    lock = None
667:    if write_back == WriteBack.DIFF:
668:        # For diff output, we need locks to ensure we don't interleave output
669:        # from different processes.
670:        manager = Manager()
671:        lock = manager.Lock()
672:    tasks = {
673:        asyncio.ensure_future(
674:            loop.run_in_executor(
675:                executor, format_file_in_place, src, fast, mode, write_back, lock
676:            )
677:        ): src
678:        for src in sorted(sources)
679:    }
680:    pending: Iterable["asyncio.Future[bool]"] = tasks.keys()
681:    try:
682:        loop.add_signal_handler(signal.SIGINT, cancel, pending)
683:        loop.add_signal_handler(signal.SIGTERM, cancel, pending)
684:    except NotImplementedError:
685:        # There are no good alternatives for these on Windows.
686:        pass
687:    while pending:
688:        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
689:        for task in done:
690:            src = tasks.pop(task)
691:            if task.cancelled():

Calling tool: grepTool
from typing import .*Optional
Showing first 50 results from grep. Consider using a more specific pattern or path.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/blib2to3/pgen2/grammar.py:19:from typing import Any, Dict, List, Optional, Text, Tuple, TypeVar, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/blib2to3/pgen2/grammar.py:19:from typing import Any, Dict, List, Optional, Text, Tuple, TypeVar, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/async_timeout/__init__.py:5:from typing import Optional, Type, Any  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/packaging/markers.py:20:    from typing import Any, Callable, Dict, List, Optional, Tuple, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/packaging/version.py:14:    from typing import Callable, Iterator, List, Optional, SupportsInt, Tuple, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/emitwrapper.py:14:from typing import List, Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/options.py:1:from typing import Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/specialize.py:15:from typing import Callable, Optional, Dict, Tuple
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/build.py:27:from typing import List, Tuple, Any, Optional, Dict, Union, Set, Iterable, cast
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/genexpr.py:6:from typing import List, Optional, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/exceptions.py:12:from typing import List, Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/genfunc.py:6:from typing import Optional, List, Tuple, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/emitclass.py:4:from typing import Optional, List, Tuple, Dict, Callable, Mapping, Set
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/http_parser.py:8:from typing import Any, List, Optional, Tuple, Type, Union  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/test/testutil.py:8:from typing import List, Callable, Iterator, Optional, Tuple
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/nonlocalcontrol.py:2:from typing import Optional, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/emit.py:4:from typing import List, Set, Dict, Optional, Callable, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/genopscontext.py:1:from typing import List, Optional, Tuple
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/web_runner.py:5:from typing import Any, List, Optional, Set
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/namegen.py:1:from typing import List, Dict, Tuple, Set, Optional, Iterable
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/genopsprepare.py:1:from typing import List, Dict, Iterable, Optional, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/genopsmapper.py:1:from typing import Dict, Optional, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/genstatement.py:1:from typing import Optional, List, Tuple, Sequence, Callable
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/locks.py:3:from typing import Any, Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/client_proto.py:3:from typing import Any, Optional, Tuple
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/genclass.py:1:from typing import List, Optional, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/emitmodule.py:9:from typing import List, Tuple, Dict, Iterable, Set, TypeVar, Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/http_websocket.py:12:from typing import Any, Callable, List, Optional, Tuple, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/ops_primitive.py:9:from typing import Dict, List, Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/genops.py:14:from typing import Callable, Dict, List, Tuple, Optional, Union, Sequence, Set, Any
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/tcp_helpers.py:6:from typing import Optional  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/http_writer.py:6:from typing import Any, Awaitable, Callable, Optional, Union  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/client_exceptions.py:5:from typing import TYPE_CHECKING, Any, Optional, Tuple, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/genopsutil.py:1:from typing import Dict, Any, Union, Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/formdata.py:2:from typing import Any, Iterable, List, Optional  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/mypyc/analysis.py:5:from typing import Dict, Tuple, List, Set, TypeVar, Iterator, Generic, Optional, Iterable, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/resolver.py:3:from typing import Any, Dict, List, Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/base_protocol.py:2:from typing import Optional, cast
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/web_server.py:3:from typing import Any, Awaitable, Callable, Dict, List, Optional  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/streams.py:5:from typing import Awaitable, Callable, Generic, Optional, Tuple, TypeVar
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/http_exceptions.py:4:from typing import Optional, Union
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/web.py:8:from typing import Any, Awaitable, Callable, List, Optional, Type, Union, cast
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/web_exceptions.py:2:from typing import Any, Dict, Iterable, List, Optional, Set  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/client_ws.py:4:from typing import Any, Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/worker.py:9:from typing import Any, Awaitable, Callable, Optional, Union  # noqa
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/aiohttp/web_ws.py:6:from typing import Any, Iterable, Optional, Tuple
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/flake8/checker.py:8:from typing import Dict, List, Optional, Tuple
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/pre_commit/meta_hooks/identity.py:2:from typing import Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/pre_commit/meta_hooks/check_useless_excludes.py:3:from typing import Optional
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/lib/python3.8/site-packages/pre_commit/meta_hooks/check_hooks_apply.py:2:from typing import Optional

Calling tool: grepTool
^from typing import .*
Matched content:
23:from typing import (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
1:import ast
2:import asyncio
3:from abc import ABC, abstractmethod
4:from collections import defaultdict
5:from concurrent.futures import Executor, ProcessPoolExecutor
6:from contextlib import contextmanager
7:from datetime import datetime
8:from enum import Enum
9:from functools import lru_cache, partial, wraps
10:import io
11:import itertools
12:import logging
13:from multiprocessing import Manager, freeze_support
14:import os
15:from pathlib import Path
16:import pickle
17:import regex as re
18:import signal
19:import sys
20:import tempfile
21:import tokenize
22:import traceback
23:from typing import (
24:    Any,
25:    Callable,
26:    Collection,
27:    Dict,
28:    Generator,
29:    Generic,
30:    Iterable,
31:    Iterator,
32:    List,
33:    Optional,
34:    Pattern,
35:    Sequence,
36:    Set,
37:    Tuple,
38:    Type,
39:    TypeVar,
40:    Union,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
41:    cast,
42:    TYPE_CHECKING,
43:)
44:from typing_extensions import Final
45:from mypy_extensions import mypyc_attr
46:
47:from appdirs import user_cache_dir
48:from dataclasses import dataclass, field, replace
49:import click
50:import toml
51:from typed_ast import ast3, ast27
52:from pathspec import PathSpec
53:
54:# lib2to3 fork
55:from blib2to3.pytree import Node, Leaf, type_repr
56:from blib2to3 import pygram, pytree
57:from blib2to3.pgen2 import driver, token
58:from blib2to3.pgen2.grammar import Grammar
59:from blib2to3.pgen2.parse import ParseError
60:
61:from _black_version import version as __version__
62:
63:if TYPE_CHECKING:
64:    import colorama  # noqa: F401
65:
66:DEFAULT_LINE_LENGTH = 88
67:DEFAULT_EXCLUDES = r"/(\.eggs|\.git|\.hg|\.mypy_cache|\.nox|\.tox|\.venv|\.svn|_build|buck-out|build|dist)/"  # noqa: B950
68:DEFAULT_INCLUDES = r"\.pyi?$"
69:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
70:
71:STRING_PREFIX_CHARS: Final = "furbFURB"  # All possible string prefix characters.
72:
73:
74:# types
75:FileContent = str
76:Encoding = str
77:NewLine = str
78:Depth = int
79:NodeType = int
80:ParserState = int

Calling tool: grepTool
class WriteBack\(
Matched content:
142:class WriteBack(Enum):

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
140:
141:
142:class WriteBack(Enum):
143:    NO = 0
144:    YES = 1
145:    DIFF = 2
146:    CHECK = 3
147:    COLOR_DIFF = 4
148:
149:    @classmethod
150:    def from_configuration(
151:        cls, *, check: bool, diff: bool, color: bool = False
152:    ) -> "WriteBack":
153:        if check and not diff:
154:            return cls.CHECK
155:
156:        if diff and color:
157:            return cls.COLOR_DIFF
158:
159:        return cls.DIFF if diff else cls.YES
160:
161:
162:class Changed(Enum):
163:    NO = 0
164:    CACHED = 1
165:    YES = 2
166:
167:
168:class TargetVersion(Enum):
169:    PY27 = 2
170:    PY33 = 3
171:    PY34 = 4
172:    PY35 = 5
173:    PY36 = 6
174:    PY37 = 7
175:    PY38 = 8
176:
177:    def is_python2(self) -> bool:
178:        return self is TargetVersion.PY27
179:
180:
181:PY36_VERSIONS = {TargetVersion.PY36, TargetVersion.PY37, TargetVersion.PY38}
182:
183:
184:class Feature(Enum):
185:    # All string literals are unicode
186:    UNICODE_LITERALS = 1
187:    F_STRINGS = 2
188:    NUMERIC_UNDERSCORES = 3
189:    TRAILING_COMMA_IN_CALL = 4
190:    TRAILING_COMMA_IN_DEF = 5
191:    # The following two feature-flags are mutually exclusive, and exactly one should be
192:    # set for every version of python.
193:    ASYNC_IDENTIFIERS = 6
194:    ASYNC_KEYWORDS = 7
195:    ASSIGNMENT_EXPRESSIONS = 8
196:    POS_ONLY_ARGUMENTS = 9
197:
198:
199:VERSION_TO_FEATURES: Dict[TargetVersion, Set[Feature]] = {

Calling tool: grepTool
ProcessPoolExecutor\(
Matched content:
622:        executor = ProcessPoolExecutor(max_workers=worker_count)
627:        executor = ProcessPoolExecutor()

Calling tool: grepTool
schedule_formatting\(
Matched content:
631:            schedule_formatting(
647:async def schedule_formatting(

Calling tool: createTodo
Todo List Created
Todo List (12 items):
- [ ] In black.py reformat_many(), verify ProcessPoolExecutor creation is wrapped in try/except catching OSError (not a broader exception). (ID: todo-1)
- [ ] Verify that on catching OSError in reformat_many(), the code falls back to a non-multiprocessing path by setting executor = None (not creating another ProcessPoolExecutor instance). (ID: todo-2)
- [ ] Verify that there is only a single attempt to instantiate ProcessPoolExecutor in reformat_many(); the fallback path must not call ProcessPoolExecutor again. (ID: todo-3)
- [ ] Confirm that schedule_formatting()’s signature accepts Optional[Executor] and that reformat_many() passes the executor variable (which may be None) to it. (ID: todo-4)
- [ ] Within schedule_formatting(), verify loop.run_in_executor() uses the executor parameter directly so that passing None results in the default executor being used (no ProcessPoolExecutor usage on the fallback path). (ID: todo-5)
- [ ] Ensure no other code path in reformat_many() or schedule_formatting() references or instantiates ProcessPoolExecutor after the OSError is caught. (ID: todo-6)
- [ ] Verify that the finally block in reformat_many() properly shuts down the executor only when it was created (i.e., call executor.shutdown() when executor is not None), and does not attempt shutdown when executor is None. (ID: todo-7)
- [ ] Check that the Windows-specific worker_count cap (min(cpu_count, 61)) remains intact and unchanged aside from the fallback logic. (ID: todo-8)
- [ ] Confirm that Optional is imported from typing and used for the executor type annotation in schedule_formatting(). (ID: todo-9)
- [ ] Verify that caching behavior in schedule_formatting() (writing to cache for WriteBack.YES and appropriate CHECK cases) remains unchanged and is independent of the executor being None. (ID: todo-10)
- [ ] Verify that multiprocessing.Manager() and lock creation are still gated behind write_back == WriteBack.DIFF so that in non-diff scenarios (as exercised by the test) multiprocessing primitives are not created. (ID: todo-11)
- [ ] Validate that the unit test tests/test_black.py::BlackTestCase::test_works_in_mono_process_only_environment patches black.ProcessPoolExecutor to raise OSError and that the implementation under test will not attempt to construct ProcessPoolExecutor again after the exception. (ID: todo-12)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 12
description: 'In black.py reformat_many(), verify ProcessPoolExecutor creation is wrapped in try/except catching OSError (not a broader exception).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def reformat_many\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black"
]
Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py

Calling tool: grepTool
def reformat_many\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.original:612:def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py:612:def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:3:@@ -618,7 +618,14 @@ def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:19:@@ -633,7 +640,8 @@ def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py:612:def reformat_many(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
600:                src, fast=fast, write_back=write_back, mode=mode
601:            ):
602:                changed = Changed.YES
603:            if (write_back is WriteBack.YES and changed is not Changed.CACHED) or (
604:                write_back is WriteBack.CHECK and changed is Changed.NO
605:            ):
606:                write_cache(cache, [src], mode)
607:        report.done(src, changed)
608:    except Exception as exc:
609:        report.failed(src, str(exc))
610:
611:
612:def reformat_many(
613:    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
614:) -> None:
615:    """Reformat multiple files using a ProcessPoolExecutor."""
616:    loop = asyncio.get_event_loop()
617:    worker_count = os.cpu_count()
618:    if sys.platform == "win32":
619:        # Work around https://bugs.python.org/issue26903
620:        worker_count = min(worker_count, 61)
621:    try:
622:        executor = ProcessPoolExecutor(max_workers=worker_count)
623:    except OSError:
624:        # we arrive here if the underlying system does not support multi-processing
625:        # like in AWS Lambda, in which case we gracefully fallback to the default
626:        # mono-process Executor by using None
627:        executor = ProcessPoolExecutor()
628:
629:    try:
630:        loop.run_until_complete(
631:            schedule_formatting(
632:                sources=sources,
633:                fast=fast,
634:                write_back=write_back,
635:                mode=mode,
636:                report=report,
637:                loop=loop,
638:                executor=executor,
639:            )
640:        )
641:    finally:
642:        shutdown(loop)
643:        if executor is not None:
644:            pass
645:
646:
647:async def schedule_formatting(
648:    sources: Set[Path],
649:    fast: bool,
650:    write_back: WriteBack,
651:    mode: Mode,
652:    report: "Report",
653:    loop: asyncio.AbstractEventLoop,
654:    executor: Optional[Executor],
655:) -> None:
656:    """Run formatting of `sources` in parallel using the provided `executor`.
657:
658:    (Use ProcessPoolExecutors for actual parallelism.)
659:
660:    `write_back`, `fast`, and `mode` options are passed to
661:    :func:`format_file_in_place`.
662:    """
663:    cache: Cache = {}
664:    if write_back != WriteBack.DIFF:
665:        cache = read_cache(mode)
666:        sources, cached = filter_cached(cache, sources)
667:        for src in sorted(cached):
668:            report.done(src, Changed.CACHED)
669:    if not sources:
670:        return
671:
672:    cancelled = []
673:    sources_to_cache = []
674:    lock = None
675:    if write_back == WriteBack.DIFF:
676:        # For diff output, we need locks to ensure we don't interleave output
677:        # from different processes.
678:        manager = Manager()
679:        lock = manager.Lock()
680:    tasks = {
681:        asyncio.ensure_future(
682:            loop.run_in_executor(
683:                executor, format_file_in_place, src, fast, mode, write_back, lock
684:            )
685:        ): src
686:        for src in sorted(sources)
687:    }
688:    pending: Iterable["asyncio.Future[bool]"] = tasks.keys()
689:    try:
690:        loop.add_signal_handler(signal.SIGINT, cancel, pending)
691:        loop.add_signal_handler(signal.SIGTERM, cancel, pending)
692:    except NotImplementedError:
693:        # There are no good alternatives for these on Windows.
694:        pass
695:    while pending:
696:        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
697:        for task in done:
698:            src = tasks.pop(task)
699:            if task.cancelled():
700:                cancelled.append(task)
701:            elif task.exception():
702:                report.failed(src, str(task.exception()))
703:            else:
704:                changed = Changed.YES if task.result() else Changed.NO
705:                # If the file was written back or was successfully checked as
706:                # well-formatted, store this information in the cache.
707:                if write_back is WriteBack.YES or (
708:                    write_back is WriteBack.CHECK and changed is Changed.NO
709:                ):
710:                    sources_to_cache.append(src)
711:                report.done(src, changed)
712:    if cancelled:
713:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
714:    if sources_to_cache:
715:        write_cache(cache, sources_to_cache, mode)
716:
717:
718:def format_file_in_place(
719:    src: Path,

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py’s reformat_many(), the ProcessPoolExecutor(max_workers=worker_count) call is enclosed in a try block with an except OSError fallback. It does not use a broader exception type. Verified at lines 621–627 of black/black.py.


Todo item 1 of 12 is correct
description: 'In black.py reformat_many(), verify ProcessPoolExecutor creation is wrapped in try/except catching OSError (not a broader exception).'
Validating todo item 2 of 12
description: 'Verify that on catching OSError in reformat_many(), the code falls back to a non-multiprocessing path by setting executor = None (not creating another ProcessPoolExecutor instance).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def reformat_many\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black"
]
Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py

Calling tool: grepTool
def reformat_many\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.original:612:def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py:612:def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:3:@@ -618,7 +618,14 @@ def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:19:@@ -633,7 +640,8 @@ def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py:612:def reformat_many(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
600:                src, fast=fast, write_back=write_back, mode=mode
601:            ):
602:                changed = Changed.YES
603:            if (write_back is WriteBack.YES and changed is not Changed.CACHED) or (
604:                write_back is WriteBack.CHECK and changed is Changed.NO
605:            ):
606:                write_cache(cache, [src], mode)
607:        report.done(src, changed)
608:    except Exception as exc:
609:        report.failed(src, str(exc))
610:
611:
612:def reformat_many(
613:    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
614:) -> None:
615:    """Reformat multiple files using a ProcessPoolExecutor."""
616:    loop = asyncio.get_event_loop()
617:    worker_count = os.cpu_count()
618:    if sys.platform == "win32":
619:        # Work around https://bugs.python.org/issue26903
620:        worker_count = min(worker_count, 61)
621:    try:
622:        executor = ProcessPoolExecutor(max_workers=worker_count)
623:    except OSError:
624:        # we arrive here if the underlying system does not support multi-processing
625:        # like in AWS Lambda, in which case we gracefully fallback to the default
626:        # mono-process Executor by using None
627:        executor = ProcessPoolExecutor()
628:
629:    try:
630:        loop.run_until_complete(
631:            schedule_formatting(
632:                sources=sources,
633:                fast=fast,
634:                write_back=write_back,
635:                mode=mode,
636:                report=report,
637:                loop=loop,
638:                executor=executor,
639:            )
640:        )
641:    finally:
642:        shutdown(loop)
643:        if executor is not None:
644:            pass
645:
646:
647:async def schedule_formatting(
648:    sources: Set[Path],
649:    fast: bool,
650:    write_back: WriteBack,
651:    mode: Mode,
652:    report: "Report",
653:    loop: asyncio.AbstractEventLoop,
654:    executor: Optional[Executor],
655:) -> None:
656:    """Run formatting of `sources` in parallel using the provided `executor`.
657:
658:    (Use ProcessPoolExecutors for actual parallelism.)
659:
660:    `write_back`, `fast`, and `mode` options are passed to
661:    :func:`format_file_in_place`.
662:    """
663:    cache: Cache = {}
664:    if write_back != WriteBack.DIFF:
665:        cache = read_cache(mode)
666:        sources, cached = filter_cached(cache, sources)
667:        for src in sorted(cached):
668:            report.done(src, Changed.CACHED)
669:    if not sources:
670:        return
671:
672:    cancelled = []
673:    sources_to_cache = []
674:    lock = None
675:    if write_back == WriteBack.DIFF:
676:        # For diff output, we need locks to ensure we don't interleave output
677:        # from different processes.
678:        manager = Manager()
679:        lock = manager.Lock()
680:    tasks = {
681:        asyncio.ensure_future(
682:            loop.run_in_executor(
683:                executor, format_file_in_place, src, fast, mode, write_back, lock
684:            )
685:        ): src
686:        for src in sorted(sources)
687:    }
688:    pending: Iterable["asyncio.Future[bool]"] = tasks.keys()
689:    try:
690:        loop.add_signal_handler(signal.SIGINT, cancel, pending)
691:        loop.add_signal_handler(signal.SIGTERM, cancel, pending)
692:    except NotImplementedError:
693:        # There are no good alternatives for these on Windows.
694:        pass
695:    while pending:
696:        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
697:        for task in done:
698:            src = tasks.pop(task)
699:            if task.cancelled():
700:                cancelled.append(task)
701:            elif task.exception():
702:                report.failed(src, str(task.exception()))
703:            else:
704:                changed = Changed.YES if task.result() else Changed.NO
705:                # If the file was written back or was successfully checked as
706:                # well-formatted, store this information in the cache.
707:                if write_back is WriteBack.YES or (
708:                    write_back is WriteBack.CHECK and changed is Changed.NO
709:                ):
710:                    sources_to_cache.append(src)
711:                report.done(src, changed)
712:    if cancelled:
713:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
714:    if sources_to_cache:
715:        write_cache(cache, sources_to_cache, mode)
716:
717:
718:def format_file_in_place(
719:    src: Path,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py
600:                src, fast=fast, write_back=write_back, mode=mode
601:            ):
602:                changed = Changed.YES
603:            if (write_back is WriteBack.YES and changed is not Changed.CACHED) or (
604:                write_back is WriteBack.CHECK and changed is Changed.NO
605:            ):
606:                write_cache(cache, [src], mode)
607:        report.done(src, changed)
608:    except Exception as exc:
609:        report.failed(src, str(exc))
610:
611:
612:def reformat_many(
613:    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
614:) -> None:
615:    """Reformat multiple files using a ProcessPoolExecutor."""
616:    loop = asyncio.get_event_loop()
617:    worker_count = os.cpu_count()
618:    if sys.platform == "win32":
619:        # Work around https://bugs.python.org/issue26903
620:        worker_count = min(worker_count, 61)
621:    executor = ProcessPoolExecutor(max_workers=worker_count)
622:    try:
623:        loop.run_until_complete(
624:            schedule_formatting(
625:                sources=sources,
626:                fast=fast,
627:                write_back=write_back,
628:                mode=mode,
629:                report=report,
630:                loop=loop,
631:                executor=executor,
632:            )
633:        )
634:    finally:
635:        shutdown(loop)
636:        executor.shutdown()
637:
638:
639:async def schedule_formatting(
640:    sources: Set[Path],
641:    fast: bool,
642:    write_back: WriteBack,
643:    mode: Mode,
644:    report: "Report",
645:    loop: asyncio.AbstractEventLoop,
646:    executor: Executor,
647:) -> None:
648:    """Run formatting of `sources` in parallel using the provided `executor`.
649:
650:    (Use ProcessPoolExecutors for actual parallelism.)
651:
652:    `write_back`, `fast`, and `mode` options are passed to
653:    :func:`format_file_in_place`.
654:    """
655:    cache: Cache = {}
656:    if write_back != WriteBack.DIFF:
657:        cache = read_cache(mode)
658:        sources, cached = filter_cached(cache, sources)
659:        for src in sorted(cached):
660:            report.done(src, Changed.CACHED)
661:    if not sources:
662:        return
663:
664:    cancelled = []
665:    sources_to_cache = []
666:    lock = None
667:    if write_back == WriteBack.DIFF:
668:        # For diff output, we need locks to ensure we don't interleave output
669:        # from different processes.
670:        manager = Manager()
671:        lock = manager.Lock()
672:    tasks = {
673:        asyncio.ensure_future(
674:            loop.run_in_executor(
675:                executor, format_file_in_place, src, fast, mode, write_back, lock
676:            )
677:        ): src
678:        for src in sorted(sources)
679:    }
680:    pending: Iterable["asyncio.Future[bool]"] = tasks.keys()
681:    try:
682:        loop.add_signal_handler(signal.SIGINT, cancel, pending)
683:        loop.add_signal_handler(signal.SIGTERM, cancel, pending)
684:    except NotImplementedError:
685:        # There are no good alternatives for these on Windows.
686:        pass
687:    while pending:
688:        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
689:        for task in done:
690:            src = tasks.pop(task)
691:            if task.cancelled():
692:                cancelled.append(task)
693:            elif task.exception():
694:                report.failed(src, str(task.exception()))
695:            else:
696:                changed = Changed.YES if task.result() else Changed.NO
697:                # If the file was written back or was successfully checked as
698:                # well-formatted, store this information in the cache.
699:                if write_back is WriteBack.YES or (
700:                    write_back is WriteBack.CHECK and changed is Changed.NO
701:                ):
702:                    sources_to_cache.append(src)
703:                report.done(src, changed)
704:    if cancelled:
705:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
706:    if sources_to_cache:
707:        write_cache(cache, sources_to_cache, mode)
708:
709:
710:def format_file_in_place(
711:    src: Path,
712:    fast: bool,
713:    mode: Mode,
714:    write_back: WriteBack = WriteBack.NO,
715:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
716:) -> bool:
717:    """Format file under `src` path. Return True if changed.
718:
719:    If `write_back` is DIFF, write a diff to stdout. If it is YES, write reformatted

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: In black/black.py reformat_many(), the OSError handler sets executor = ProcessPoolExecutor() (lines ~623–627) instead of executor = None. Although schedule_formatting now accepts Optional[Executor], the code does not actually use the non-multiprocessing path as required.


Validating todo item 1 of 12
description: 'In black.py reformat_many(), verify ProcessPoolExecutor creation is wrapped in try/except catching OSError (not a broader exception).'

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py

Calling tool: grepTool
def reformat_many\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.original:612:def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py:612:def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:3:@@ -618,7 +618,14 @@ def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:19:@@ -633,7 +640,8 @@ def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py:612:def reformat_many(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
600:                src, fast=fast, write_back=write_back, mode=mode
601:            ):
602:                changed = Changed.YES
603:            if (write_back is WriteBack.YES and changed is not Changed.CACHED) or (
604:                write_back is WriteBack.CHECK and changed is Changed.NO
605:            ):
606:                write_cache(cache, [src], mode)
607:        report.done(src, changed)
608:    except Exception as exc:
609:        report.failed(src, str(exc))
610:
611:
612:def reformat_many(
613:    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
614:) -> None:
615:    """Reformat multiple files using a ProcessPoolExecutor."""
616:    loop = asyncio.get_event_loop()
617:    worker_count = os.cpu_count()
618:    if sys.platform == "win32":
619:        # Work around https://bugs.python.org/issue26903
620:        worker_count = min(worker_count, 61)
621:    try:
622:        executor = ProcessPoolExecutor(max_workers=worker_count)
623:    except OSError:
624:        # we arrive here if the underlying system does not support multi-processing
625:        # like in AWS Lambda, in which case we gracefully fallback to the default
626:        # mono-process Executor by using None
627:        executor = ProcessPoolExecutor()
628:
629:    try:
630:        loop.run_until_complete(
631:            schedule_formatting(
632:                sources=sources,
633:                fast=fast,
634:                write_back=write_back,
635:                mode=mode,
636:                report=report,
637:                loop=loop,
638:                executor=executor,
639:            )
640:        )
641:    finally:
642:        shutdown(loop)
643:        if executor is not None:
644:            pass
645:
646:
647:async def schedule_formatting(
648:    sources: Set[Path],
649:    fast: bool,
650:    write_back: WriteBack,
651:    mode: Mode,
652:    report: "Report",
653:    loop: asyncio.AbstractEventLoop,
654:    executor: Optional[Executor],
655:) -> None:
656:    """Run formatting of `sources` in parallel using the provided `executor`.
657:
658:    (Use ProcessPoolExecutors for actual parallelism.)
659:
660:    `write_back`, `fast`, and `mode` options are passed to
661:    :func:`format_file_in_place`.
662:    """
663:    cache: Cache = {}
664:    if write_back != WriteBack.DIFF:
665:        cache = read_cache(mode)
666:        sources, cached = filter_cached(cache, sources)
667:        for src in sorted(cached):
668:            report.done(src, Changed.CACHED)
669:    if not sources:
670:        return
671:
672:    cancelled = []
673:    sources_to_cache = []
674:    lock = None
675:    if write_back == WriteBack.DIFF:
676:        # For diff output, we need locks to ensure we don't interleave output
677:        # from different processes.
678:        manager = Manager()
679:        lock = manager.Lock()
680:    tasks = {
681:        asyncio.ensure_future(
682:            loop.run_in_executor(
683:                executor, format_file_in_place, src, fast, mode, write_back, lock
684:            )
685:        ): src
686:        for src in sorted(sources)
687:    }
688:    pending: Iterable["asyncio.Future[bool]"] = tasks.keys()
689:    try:
690:        loop.add_signal_handler(signal.SIGINT, cancel, pending)
691:        loop.add_signal_handler(signal.SIGTERM, cancel, pending)
692:    except NotImplementedError:
693:        # There are no good alternatives for these on Windows.
694:        pass
695:    while pending:
696:        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
697:        for task in done:
698:            src = tasks.pop(task)
699:            if task.cancelled():
700:                cancelled.append(task)
701:            elif task.exception():
702:                report.failed(src, str(task.exception()))
703:            else:
704:                changed = Changed.YES if task.result() else Changed.NO
705:                # If the file was written back or was successfully checked as
706:                # well-formatted, store this information in the cache.
707:                if write_back is WriteBack.YES or (
708:                    write_back is WriteBack.CHECK and changed is Changed.NO
709:                ):
710:                    sources_to_cache.append(src)
711:                report.done(src, changed)
712:    if cancelled:
713:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
714:    if sources_to_cache:
715:        write_cache(cache, sources_to_cache, mode)
716:
717:
718:def format_file_in_place(
719:    src: Path,

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py’s reformat_many(), the ProcessPoolExecutor(max_workers=worker_count) call is enclosed in a try block with an except OSError fallback. It does not use a broader exception type. Verified at lines 621–627 of black/black.py.

Todo item 1 of 12 is correct
description: 'In black.py reformat_many(), verify ProcessPoolExecutor creation is wrapped in try/except catching OSError (not a broader exception).'

Validating todo item 2 of 12
description: 'Verify that on catching OSError in reformat_many(), the code falls back to a non-multiprocessing path by setting executor = None (not creating another ProcessPoolExecutor instance).'

Calling tool: globTool
**/black.py
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py

Calling tool: grepTool
def reformat_many\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.original:612:def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py:612:def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:3:@@ -618,7 +618,14 @@ def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py.rej:19:@@ -633,7 +640,8 @@ def reformat_many(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py:612:def reformat_many(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/black.py
600:                src, fast=fast, write_back=write_back, mode=mode
601:            ):
602:                changed = Changed.YES
603:            if (write_back is WriteBack.YES and changed is not Changed.CACHED) or (
604:                write_back is WriteBack.CHECK and changed is Changed.NO
605:            ):
606:                write_cache(cache, [src], mode)
607:        report.done(src, changed)
608:    except Exception as exc:
609:        report.failed(src, str(exc))
610:
611:
612:def reformat_many(
613:    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
614:) -> None:
615:    """Reformat multiple files using a ProcessPoolExecutor."""
616:    loop = asyncio.get_event_loop()
617:    worker_count = os.cpu_count()
618:    if sys.platform == "win32":
619:        # Work around https://bugs.python.org/issue26903
620:        worker_count = min(worker_count, 61)
621:    try:
622:        executor = ProcessPoolExecutor(max_workers=worker_count)
623:    except OSError:
624:        # we arrive here if the underlying system does not support multi-processing
625:        # like in AWS Lambda, in which case we gracefully fallback to the default
626:        # mono-process Executor by using None
627:        executor = ProcessPoolExecutor()
628:
629:    try:
630:        loop.run_until_complete(
631:            schedule_formatting(
632:                sources=sources,
633:                fast=fast,
634:                write_back=write_back,
635:                mode=mode,
636:                report=report,
637:                loop=loop,
638:                executor=executor,
639:            )
640:        )
641:    finally:
642:        shutdown(loop)
643:        if executor is not None:
644:            pass
645:
646:
647:async def schedule_formatting(
648:    sources: Set[Path],
649:    fast: bool,
650:    write_back: WriteBack,
651:    mode: Mode,
652:    report: "Report",
653:    loop: asyncio.AbstractEventLoop,
654:    executor: Optional[Executor],
655:) -> None:
656:    """Run formatting of `sources` in parallel using the provided `executor`.
657:
658:    (Use ProcessPoolExecutors for actual parallelism.)
659:
660:    `write_back`, `fast`, and `mode` options are passed to
661:    :func:`format_file_in_place`.
662:    """
663:    cache: Cache = {}
664:    if write_back != WriteBack.DIFF:
665:        cache = read_cache(mode)
666:        sources, cached = filter_cached(cache, sources)
667:        for src in sorted(cached):
668:            report.done(src, Changed.CACHED)
669:    if not sources:
670:        return
671:
672:    cancelled = []
673:    sources_to_cache = []
674:    lock = None
675:    if write_back == WriteBack.DIFF:
676:        # For diff output, we need locks to ensure we don't interleave output
677:        # from different processes.
678:        manager = Manager()
679:        lock = manager.Lock()
680:    tasks = {
681:        asyncio.ensure_future(
682:            loop.run_in_executor(
683:                executor, format_file_in_place, src, fast, mode, write_back, lock
684:            )
685:        ): src
686:        for src in sorted(sources)
687:    }
688:    pending: Iterable["asyncio.Future[bool]"] = tasks.keys()
689:    try:
690:        loop.add_signal_handler(signal.SIGINT, cancel, pending)
691:        loop.add_signal_handler(signal.SIGTERM, cancel, pending)
692:    except NotImplementedError:
693:        # There are no good alternatives for these on Windows.
694:        pass
695:    while pending:
696:        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
697:        for task in done:
698:            src = tasks.pop(task)
699:            if task.cancelled():
700:                cancelled.append(task)
701:            elif task.exception():
702:                report.failed(src, str(task.exception()))
703:            else:
704:                changed = Changed.YES if task.result() else Changed.NO
705:                # If the file was written back or was successfully checked as
706:                # well-formatted, store this information in the cache.
707:                if write_back is WriteBack.YES or (
708:                    write_back is WriteBack.CHECK and changed is Changed.NO
709:                ):
710:                    sources_to_cache.append(src)
711:                report.done(src, changed)
712:    if cancelled:
713:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
714:    if sources_to_cache:
715:        write_cache(cache, sources_to_cache, mode)
716:
717:
718:def format_file_in_place(
719:    src: Path,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-1/bad/black/env/src/black/black.py
600:                src, fast=fast, write_back=write_back, mode=mode
601:            ):
602:                changed = Changed.YES
603:            if (write_back is WriteBack.YES and changed is not Changed.CACHED) or (
604:                write_back is WriteBack.CHECK and changed is Changed.NO
605:            ):
606:                write_cache(cache, [src], mode)
607:        report.done(src, changed)
608:    except Exception as exc:
609:        report.failed(src, str(exc))
610:
611:
612:def reformat_many(
613:    sources: Set[Path], fast: bool, write_back: WriteBack, mode: Mode, report: "Report"
614:) -> None:
615:    """Reformat multiple files using a ProcessPoolExecutor."""
616:    loop = asyncio.get_event_loop()
617:    worker_count = os.cpu_count()
618:    if sys.platform == "win32":
619:        # Work around https://bugs.python.org/issue26903
620:        worker_count = min(worker_count, 61)
621:    executor = ProcessPoolExecutor(max_workers=worker_count)
622:    try:
623:        loop.run_until_complete(
624:            schedule_formatting(
625:                sources=sources,
626:                fast=fast,
627:                write_back=write_back,
628:                mode=mode,
629:                report=report,
630:                loop=loop,
631:                executor=executor,
632:            )
633:        )
634:    finally:
635:        shutdown(loop)
636:        executor.shutdown()
637:
638:
639:async def schedule_formatting(
640:    sources: Set[Path],
641:    fast: bool,
642:    write_back: WriteBack,
643:    mode: Mode,
644:    report: "Report",
645:    loop: asyncio.AbstractEventLoop,
646:    executor: Executor,
647:) -> None:
648:    """Run formatting of `sources` in parallel using the provided `executor`.
649:
650:    (Use ProcessPoolExecutors for actual parallelism.)
651:
652:    `write_back`, `fast`, and `mode` options are passed to
653:    :func:`format_file_in_place`.
654:    """
655:    cache: Cache = {}
656:    if write_back != WriteBack.DIFF:
657:        cache = read_cache(mode)
658:        sources, cached = filter_cached(cache, sources)
659:        for src in sorted(cached):
660:            report.done(src, Changed.CACHED)
661:    if not sources:
662:        return
663:
664:    cancelled = []
665:    sources_to_cache = []
666:    lock = None
667:    if write_back == WriteBack.DIFF:
668:        # For diff output, we need locks to ensure we don't interleave output
669:        # from different processes.
670:        manager = Manager()
671:        lock = manager.Lock()
672:    tasks = {
673:        asyncio.ensure_future(
674:            loop.run_in_executor(
675:                executor, format_file_in_place, src, fast, mode, write_back, lock
676:            )
677:        ): src
678:        for src in sorted(sources)
679:    }
680:    pending: Iterable["asyncio.Future[bool]"] = tasks.keys()
681:    try:
682:        loop.add_signal_handler(signal.SIGINT, cancel, pending)
683:        loop.add_signal_handler(signal.SIGTERM, cancel, pending)
684:    except NotImplementedError:
685:        # There are no good alternatives for these on Windows.
686:        pass
687:    while pending:
688:        done, _ = await asyncio.wait(pending, return_when=asyncio.FIRST_COMPLETED)
689:        for task in done:
690:            src = tasks.pop(task)
691:            if task.cancelled():
692:                cancelled.append(task)
693:            elif task.exception():
694:                report.failed(src, str(task.exception()))
695:            else:
696:                changed = Changed.YES if task.result() else Changed.NO
697:                # If the file was written back or was successfully checked as
698:                # well-formatted, store this information in the cache.
699:                if write_back is WriteBack.YES or (
700:                    write_back is WriteBack.CHECK and changed is Changed.NO
701:                ):
702:                    sources_to_cache.append(src)
703:                report.done(src, changed)
704:    if cancelled:
705:        await asyncio.gather(*cancelled, loop=loop, return_exceptions=True)
706:    if sources_to_cache:
707:        write_cache(cache, sources_to_cache, mode)
708:
709:
710:def format_file_in_place(
711:    src: Path,
712:    fast: bool,
713:    mode: Mode,
714:    write_back: WriteBack = WriteBack.NO,
715:    lock: Any = None,  # multiprocessing.Manager().Lock() is some crazy proxy
716:) -> bool:
717:    """Format file under `src` path. Return True if changed.
718:
719:    If `write_back` is DIFF, write a diff to stdout. If it is YES, write reformatted

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: In black/black.py reformat_many(), the OSError handler sets executor = ProcessPoolExecutor() (lines ~623–627) instead of executor = None. Although schedule_formatting now accepts Optional[Executor], the code does not actually use the non-multiprocessing path as required.


=== PHASE 2 COMPLETE ===

