=== PHASE 1: ANALYSIS ===

[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "normalize_invisible_parens\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "test_tuple_assign",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "tupleassign", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "parens_after", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "visit_stmt\\(self, node: Node, keywords: Set\\[str\\], parens: Set\\[str\\]\\)",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "visit_stmt\\(", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def visit_assign", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def visit_.*assign",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "visit_assign", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def visit_.*expr_stmt",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def visit_.*stmt", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "expr_stmt", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "ASSIGNMENTS", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py" ]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "is_one_tuple\\(|is_tuple",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def read_data", "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/test_black.py" ]
Calling tool: grepTool
normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:1582:        normalize_invisible_parens(node, parens_after=parens)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:1582:        normalize_invisible_parens(node, parens_after=parens)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:1582:        normalize_invisible_parens(node, parens_after=parens)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py
2695:        # Capitalize in "2L" because "l" looks too similar to "1".
2696:        if suffix == "l":
2697:            suffix = "L"
2698:        text = f"{format_float_or_int_string(number)}{suffix}"
2699:    else:
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py
2695:        # Capitalize in "2L" because "l" looks too similar to "1".
2696:        if suffix == "l":
2697:            suffix = "L"
2698:        text = f"{format_float_or_int_string(number)}{suffix}"
2699:    else:
2700:        text = format_float_or_int_string(text)
2701:    leaf.value = text
2702:
2703:
2704:def format_float_or_int_string(text: str) -> str:
2705:    """Formats a float string like "1.0"."""
2706:    if "." not in text:
2707:        return text
2708:
2709:    before, after = text.split(".")
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,

Calling tool: grepTool
test_tuple_assign
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/coverage_bugsinpy.txt:1:coverage run -m unittest -q tests.test_black.BlackTestCase.test_tuple_assign
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/coverage_bugsinpy.txt:69:FAIL: test_tuple_assign (tests.test_black.BlackTestCase)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/coverage_bugsinpy.txt:74:  File "/workspace/BugsInPy/framework/bin/temp/black-7/bad/black/tests/test_black.py", line 549, in test_tuple_assign
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_tuple_assign
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/test_black.py:546:    def test_tuple_assign(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/test_black.py
520:
521:    @patch("black.dump_to_file", dump_to_stderr)
522:    def test_remove_empty_parentheses_after_class(self) -> None:
523:        source, expected = read_data("class_blank_parentheses")
524:        actual = fs(source)
525:        self.assertFormatEqual(expected, actual)
526:        black.assert_equivalent(source, actual)
527:        black.assert_stable(source, actual, black.FileMode())
528:
529:    @patch("black.dump_to_file", dump_to_stderr)
530:    def test_new_line_between_class_and_code(self) -> None:
531:        source, expected = read_data("class_methods_new_line")
532:        actual = fs(source)
533:        self.assertFormatEqual(expected, actual)
534:        black.assert_equivalent(source, actual)
535:        black.assert_stable(source, actual, black.FileMode())
536:
537:    @patch("black.dump_to_file", dump_to_stderr)
538:    def test_bracket_match(self) -> None:
539:        source, expected = read_data("bracketmatch")
540:        actual = fs(source)
541:        self.assertFormatEqual(expected, actual)
542:        black.assert_equivalent(source, actual)
543:        black.assert_stable(source, actual, black.FileMode())
544:
545:    @patch("black.dump_to_file", dump_to_stderr)
546:    def test_tuple_assign(self) -> None:
547:        source, expected = read_data("tupleassign")
548:        actual = fs(source)
549:        self.assertFormatEqual(expected, actual)
550:        black.assert_equivalent(source, actual)
551:        black.assert_stable(source, actual, black.FileMode())
552:
553:    def test_tab_comment_indentation(self) -> None:
554:        contents_tab = "if 1:\n\tif 2:\n\t\tpass\n\t# comment\n\tpass\n"
555:        contents_spc = "if 1:\n    if 2:\n        pass\n    # comment\n    pass\n"
556:        self.assertFormatEqual(contents_spc, fs(contents_spc))
557:        self.assertFormatEqual(contents_spc, fs(contents_tab))
558:
559:        contents_tab = "if 1:\n\tif 2:\n\t\tpass\n\t\t# comment\n\tpass\n"
560:        contents_spc = "if 1:\n    if 2:\n        pass\n        # comment\n    pass\n"
561:        self.assertFormatEqual(contents_spc, fs(contents_spc))
562:        self.assertFormatEqual(contents_spc, fs(contents_tab))
563:
564:        # mixed tabs and spaces (valid Python 2 code)
565:        contents_tab = "if 1:\n        if 2:\n\t\tpass\n\t# comment\n        pass\n"
566:        contents_spc = "if 1:\n    if 2:\n        pass\n    # comment\n    pass\n"
567:        self.assertFormatEqual(contents_spc, fs(contents_spc))
568:        self.assertFormatEqual(contents_spc, fs(contents_tab))
569:
570:        contents_tab = "if 1:\n        if 2:\n\t\tpass\n\t\t# comment\n        pass\n"
571:        contents_spc = "if 1:\n    if 2:\n        pass\n        # comment\n    pass\n"
572:        self.assertFormatEqual(contents_spc, fs(contents_spc))
573:        self.assertFormatEqual(contents_spc, fs(contents_tab))
574:
575:    def test_report_verbose(self) -> None:
576:        report = black.Report(verbose=True)
577:        out_lines = []
578:        err_lines = []
579:
580:        def out(msg: str, **kwargs: Any) -> None:
581:            out_lines.append(msg)
582:
583:        def err(msg: str, **kwargs: Any) -> None:
584:            err_lines.append(msg)
585:
586:        with patch("black.out", out), patch("black.err", err):
587:            report.done(Path("f1"), black.Changed.NO)
588:            self.assertEqual(len(out_lines), 1)
589:            self.assertEqual(len(err_lines), 0)
590:            self.assertEqual(out_lines[-1], "f1 already well formatted, good job.")
591:            self.assertEqual(unstyle(str(report)), "1 file left unchanged.")
592:            self.assertEqual(report.return_code, 0)
593:            report.done(Path("f2"), black.Changed.YES)
594:            self.assertEqual(len(out_lines), 2)
595:            self.assertEqual(len(err_lines), 0)
596:            self.assertEqual(out_lines[-1], "reformatted f2")
597:            self.assertEqual(
598:                unstyle(str(report)), "1 file reformatted, 1 file left unchanged."
599:            )

Calling tool: grepTool
tupleassign
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/bugsinpy_bug.info:4:test_file="tests/data/tupleassign.py;tests/test_black.py"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/test_black.py:547:        source, expected = read_data("tupleassign")

Calling tool: globTool
**/tests/data/*tupleassign*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/data/tupleassign.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/data/tupleassign.py
1:sdfjklsdfsjldkflkjsf, sdfjsdfjlksdljkfsdlkf, sdfsdjfklsdfjlksdljkf, sdsfsdfjskdflsfsdf = 1, 2, 3
2:
3:
4:# output
5:(
6:    sdfjklsdfsjldkflkjsf,
7:    sdfjsdfjlksdljkfsdlkf,
8:    sdfsdjfklsdfjlksdljkf,
9:    sdsfsdfjskdflsfsdf,
10:) = (1, 2, 3)

Calling tool: grepTool
parens_after
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:1582:        normalize_invisible_parens(node, parens_after=parens)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:2716:    `parens_after` is a set of string leaf values immeditely after which parens
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:1582:        normalize_invisible_parens(node, parens_after=parens)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:2716:    `parens_after` is a set of string leaf values immeditely after which parens
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:1582:        normalize_invisible_parens(node, parens_after=parens)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:2716:    `parens_after` is a set of string leaf values immeditely after which parens
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py
1550:        # In blib2to3 INDENT never holds comments.
1551:        yield from self.line(+1)
1552:        yield from self.visit_default(node)
1553:
1554:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1555:        """Decrease indentation level, maybe yield a line."""
1556:        # The current line might still wait for trailing comments.  At DEDENT time
1557:        # there won't be any (they would be prefixes on the preceding NEWLINE).
1558:        # Emit the line then.
1559:        yield from self.line()
1560:
1561:        # While DEDENT has no value, its prefix may contain standalone comments
1562:        # that belong to the current indentation level.  Get 'em.
1563:        yield from self.visit_default(node)
1564:
1565:        # Finally, emit the dedent.
1566:        yield from self.line(-1)
1567:
1568:    def visit_stmt(
1569:        self, node: Node, keywords: Set[str], parens: Set[str]
1570:    ) -> Iterator[Line]:
1571:        """Visit a statement.
1572:
1573:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1574:        `def`, `with`, `class`, `assert` and assignments.
1575:
1576:        The relevant Python language `keywords` for a given statement will be
1577:        NAME leaves within it. This methods puts those on a separate line.
1578:
1579:        `parens` holds a set of string leaf values immediately after which
1580:        invisible parens should be put.
1581:        """
1582:        normalize_invisible_parens(node, parens_after=parens)
1583:        for child in node.children:
1584:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1585:                yield from self.line()
1586:
1587:            yield from self.visit(child)
1588:
1589:    def visit_suite(self, node: Node) -> Iterator[Line]:
1590:        """Visit a suite."""
1591:        if self.is_pyi and is_stub_suite(node):
1592:            yield from self.visit(node.children[2])
1593:        else:
1594:            yield from self.visit_default(node)
1595:
1596:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1597:        """Visit a statement without nested statements."""
1598:        is_suite_like = node.parent and node.parent.type in STATEMENT
1599:        if is_suite_like:
1600:            if self.is_pyi and is_stub_body(node):
1601:                yield from self.visit_default(node)
1602:            else:
1603:                yield from self.line(+1)
1604:                yield from self.visit_default(node)
1605:                yield from self.line(-1)
1606:
1607:        else:
1608:            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):
1609:                yield from self.line()
1610:            yield from self.visit_default(node)
1611:
1612:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:
1613:        """Visit `async def`, `async for`, `async with`."""
1614:        yield from self.line()
1615:
1616:        children = iter(node.children)
1617:        for child in children:
1618:            yield from self.visit(child)
1619:
1620:            if child.type == token.ASYNC:
1621:                break
1622:
1623:        internal_stmt = next(children)
1624:        for child in internal_stmt.children:
1625:            yield from self.visit(child)
1626:
1627:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1628:        """Visit decorators."""
1629:        for child in node.children:

Calling tool: grepTool
visit_stmt\(self, node: Node, keywords: Set\[str\], parens: Set\[str\]\)
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
visit_stmt\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:1568:    def visit_stmt(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:1568:    def visit_stmt(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:1568:    def visit_stmt(

Calling tool: grepTool
def visit_assign
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypyc/genopsvisitor.py:98:    def visit_assignment_stmt(self, stmt: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypyc/genopsvisitor.py:233:    def visit_assignment_expr(self, o: AssignmentExpr) -> Value:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypyc/emitfunc.py:179:    def visit_assign(self, op: Assign) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypyc/analysis.py:150:    def visit_assign(self, op: Assign) -> GenAndKill:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypyc/analysis.py:219:    def visit_assign(self, op: Assign) -> GenAndKill:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypyc/analysis.py:281:    def visit_assign(self, op: Assign) -> GenAndKill:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypyc/analysis.py:317:    def visit_assign(self, op: Assign) -> GenAndKill:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypyc/analysis.py:356:    def visit_assign(self, op: Assign) -> GenAndKill:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypyc/ops.py:2141:    def visit_assign(self, op: Assign) -> T:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/mixedtraverser.py:63:    def visit_assignment_stmt(self, o: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/semanal.py:1882:    def visit_assignment_expr(self, s: AssignmentExpr) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/semanal.py:1886:    def visit_assignment_stmt(self, s: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/checker.py:2005:    def visit_assignment_stmt(self, s: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/strconv.py:205:    def visit_assignment_stmt(self, o: 'mypy.nodes.AssignmentStmt') -> str:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/strconv.py:428:    def visit_assignment_expr(self, o: 'mypy.nodes.AssignmentExpr') -> str:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/checkexpr.py:2791:    def visit_assignment_expr(self, e: AssignmentExpr) -> Type:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/renaming.py:171:    def visit_assignment_stmt(self, s: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/traverser.py:84:    def visit_assignment_stmt(self, o: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/traverser.py:201:    def visit_assignment_expr(self, o: AssignmentExpr) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/stats.py:166:    def visit_assignment_stmt(self, o: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/stats.py:278:    def visit_assignment_expr(self, o: AssignmentExpr) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/visitor.py:95:    def visit_assignment_expr(self, o: 'mypy.nodes.AssignmentExpr') -> T:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/visitor.py:196:    def visit_assignment_stmt(self, o: 'mypy.nodes.AssignmentStmt') -> T:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/visitor.py:376:    def visit_assignment_stmt(self, o: 'mypy.nodes.AssignmentStmt') -> T:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/visitor.py:481:    def visit_assignment_expr(self, o: 'mypy.nodes.AssignmentExpr') -> T:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/semanal_pass1.py:108:    def visit_assignment_stmt(self, s: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/literals.py:162:    def visit_assignment_expr(self, e: AssignmentExpr) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/server/astmerge.py:196:    def visit_assignment_stmt(self, node: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/server/subexpr.py:106:    def visit_assignment_expr(self, e: AssignmentExpr) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/test/visitors.py:30:    def visit_assignment_stmt(self, s: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/server/deps.py:353:    def visit_assignment_stmt(self, o: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/server/aststrip.py:165:    def visit_assignment_stmt(self, node: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/treetransform.py:224:    def visit_assignment_stmt(self, node: AssignmentStmt) -> AssignmentStmt:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/treetransform.py:414:    def visit_assignment_expr(self, node: AssignmentExpr) -> AssignmentExpr:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/stubgen.py:769:    def visit_assignment_stmt(self, o: AssignmentStmt) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/stubgen.py:1125:    def visit_assignment_stmt(self, o: AssignmentStmt) -> None:

Calling tool: grepTool
def visit_.*assign
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
visit_assign
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
def visit_.*expr_stmt
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
def visit_.*stmt
Matched content:
1568:    def visit_stmt(
1596:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1612:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:

Calling tool: grepTool
expr_stmt
Matched content:
1664:        self.visit_expr_stmt = partial(v, keywords=Ø, parens=ASSIGNMENTS)
2852:        or (is_yield(node) and parent.type != syms.expr_stmt)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py
1640:        yield from self.line()
1641:
1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1643:        if not self.current_line.bracket_tracker.any_open_brackets():
1644:            yield from self.line()
1645:        yield from self.visit_default(leaf)
1646:
1647:    def __attrs_post_init__(self) -> None:
1648:        """You are in a twisty little maze of passages."""
1649:        v = self.visit_stmt
1650:        Ø: Set[str] = set()
1651:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1652:        self.visit_if_stmt = partial(
1653:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1654:        )
1655:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1656:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1657:        self.visit_try_stmt = partial(
1658:            v, keywords={"try", "except", "else", "finally"}, parens=Ø
1659:        )
1660:        self.visit_except_clause = partial(v, keywords={"except"}, parens=Ø)
1661:        self.visit_with_stmt = partial(v, keywords={"with"}, parens=Ø)
1662:        self.visit_funcdef = partial(v, keywords={"def"}, parens=Ø)
1663:        self.visit_classdef = partial(v, keywords={"class"}, parens=Ø)
1664:        self.visit_expr_stmt = partial(v, keywords=Ø, parens=ASSIGNMENTS)
1665:        self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})
1666:        self.visit_import_from = partial(v, keywords=Ø, parens={"import"})
1667:        self.visit_del_stmt = partial(v, keywords=Ø, parens={"del"})
1668:        self.visit_async_funcdef = self.visit_async_stmt
1669:        self.visit_decorated = self.visit_decorators
1670:
1671:
1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
1673:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1674:OPENING_BRACKETS = set(BRACKET.keys())
1675:CLOSING_BRACKETS = set(BRACKET.values())
1676:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1678:
1679:
1680:def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa: C901
1681:    """Return whitespace prefix if needed for the given `leaf`.
1682:
1683:    `complex_subscript` signals whether the given leaf is part of a subscription
1684:    which has non-trivial arguments, like arithmetic expressions or function calls.
1685:    """
1686:    NO = ""
1687:    SPACE = " "
1688:    DOUBLESPACE = "  "
1689:    t = leaf.type
1690:    p = leaf.parent
1691:    v = leaf.value
1692:    if t in ALWAYS_NO_SPACE:
1693:        return NO
1694:
1695:    if t == token.COMMENT:
1696:        return DOUBLESPACE
1697:
1698:    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"
1699:    if t == token.COLON and p.type not in {

Calling tool: grepTool
ASSIGNMENTS
Matched content:
911:ASSIGNMENTS = {
1664:        self.visit_expr_stmt = partial(v, keywords=Ø, parens=ASSIGNMENTS)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py
900:    syms.comparison,
901:    syms.star_expr,
902:    syms.expr,
903:    syms.xor_expr,
904:    syms.and_expr,
905:    syms.shift_expr,
906:    syms.arith_expr,
907:    syms.trailer,
908:    syms.term,
909:    syms.power,
910:}
911:ASSIGNMENTS = {
912:    "=",
913:    "+=",
914:    "-=",
915:    "*=",
916:    "@=",
917:    "/=",
918:    "%=",
919:    "&=",
920:    "|=",
921:    "^=",
922:    "<<=",
923:    ">>=",
924:    "**=",
925:    "//=",
926:}
927:COMPREHENSION_PRIORITY = 20
928:COMMA_PRIORITY = 18
929:TERNARY_PRIORITY = 16
930:LOGIC_PRIORITY = 14
931:STRING_PRIORITY = 12
932:COMPARATOR_PRIORITY = 10
933:MATH_PRIORITIES = {
934:    token.VBAR: 9,
935:    token.CIRCUMFLEX: 8,
936:    token.AMPER: 7,
937:    token.LEFTSHIFT: 6,
938:    token.RIGHTSHIFT: 6,
939:    token.PLUS: 5,

Calling tool: grepTool
is_one_tuple\(|is_tuple
Matched content:
2736:            elif is_one_tuple(child):
2851:        or is_one_tuple(node)
2880:def is_one_tuple(node: LN) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py
2840:
2841:
2842:def maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool:
2843:    """If it's safe, make the parens in the atom `node` invisible, recursively.
2844:
2845:    Returns whether the node should itself be wrapped in invisible parentheses.
2846:
2847:    """
2848:    if (
2849:        node.type != syms.atom
2850:        or is_empty_tuple(node)
2851:        or is_one_tuple(node)
2852:        or (is_yield(node) and parent.type != syms.expr_stmt)
2853:        or max_delimiter_priority_in_atom(node) >= COMMA_PRIORITY
2854:    ):
2855:        return False
2856:
2857:    first = node.children[0]
2858:    last = node.children[-1]
2859:    if first.type == token.LPAR and last.type == token.RPAR:
2860:        # make parentheses invisible
2861:        first.value = ""  # type: ignore
2862:        last.value = ""  # type: ignore
2863:        if len(node.children) > 1:
2864:            maybe_make_parens_invisible_in_atom(node.children[1], parent=parent)
2865:        return False
2866:
2867:    return True
2868:
2869:
2870:def is_empty_tuple(node: LN) -> bool:
2871:    """Return True if `node` holds an empty tuple."""
2872:    return (
2873:        node.type == syms.atom
2874:        and len(node.children) == 2
2875:        and node.children[0].type == token.LPAR
2876:        and node.children[1].type == token.RPAR
2877:    )
2878:
2879:
2880:def is_one_tuple(node: LN) -> bool:
2881:    """Return True if `node` holds a tuple with one element, with or without parens."""
2882:    if node.type == syms.atom:
2883:        if len(node.children) != 3:
2884:            return False
2885:
2886:        lpar, gexp, rpar = node.children
2887:        if not (
2888:            lpar.type == token.LPAR
2889:            and gexp.type == syms.testlist_gexp
2890:            and rpar.type == token.RPAR
2891:        ):
2892:            return False
2893:
2894:        return len(gexp.children) == 2 and gexp.children[1].type == token.COMMA
2895:
2896:    return (
2897:        node.type in IMPLICIT_TUPLE
2898:        and len(node.children) == 2
2899:        and node.children[1].type == token.COMMA

Calling tool: grepTool
def read_data
Matched content:
57:def read_data(name: str, data: bool = True) -> Tuple[str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/test_black.py
48:]
49:T = TypeVar("T")
50:R = TypeVar("R")
51:
52:
53:def dump_to_stderr(*output: str) -> str:
54:    return "\n" + "\n".join(output) + "\n"
55:
56:
57:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
58:    """read_data('test_name') -> 'input', 'output'"""
59:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
60:        name += ".py"
61:    _input: List[str] = []
62:    _output: List[str] = []
63:    base_dir = THIS_DIR / "data" if data else THIS_DIR
64:    with open(base_dir / name, "r", encoding="utf8") as test:
65:        lines = test.readlines()
66:    result = _input
67:    for line in lines:
68:        line = line.replace(EMPTY_LINE, "")
69:        if line.rstrip() == "# output":
70:            result = _output
71:            continue
72:
73:        result.append(line)
74:    if _input and not _output:
75:        # If there's no output marker, treat the entire file as already pre-formatted.
76:        _output = _input[:]
77:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
78:
79:

Calling tool: createTodo
Todo List Created
Todo List (10 items):
- [ ] In `black.py`, locate `normalize_invisible_parens(node, parens_after)` and verify the new early branch exists to detect tuple-unpack LHS: it should check `index == 0` and `isinstance(child, Node)` and `child.type == syms.testlist_star_expr` to trigger LHS-specific handling (per PR). (ID: todo-1)
- [ ] In `normalize_invisible_parens`, confirm that when wrapping a `child` in a new `Node(syms.atom, [lpar, child, rpar])`, the implementation now preserves the original `child.prefix` by: saving `prefix = child.prefix`, setting `child.prefix = ""`, assigning `new_child = Node(...)`, applying `new_child.prefix = prefix`, and inserting `new_child`. This must be applied consistently to all wrapping paths in this function (both where `maybe_make_parens_invisible_in_atom` is True and the general non-multiline-string wrapping branch). (ID: todo-2)
- [ ] Verify that the specific wrapping used for LHS tuple-unpack (testlist_star_expr) results in visible parentheses (i.e., `Leaf(token.LPAR, "(")` and `Leaf(token.RPAR, ")")`) rather than invisible ones when formatting requires splitting, consistent with the expected output in `tests/data/tupleassign.py`. (ID: todo-3)
- [ ] Confirm that at the end of each loop iteration in `normalize_invisible_parens`, the assignment to `check_lpar` has been changed to `check_lpar = False` (replacing the previous `isinstance(child, Leaf) and child.value in parens_after`). (ID: todo-4)
- [ ] Ensure no other logic in `normalize_invisible_parens` was inadvertently altered outside of the PR scope: the special-case handling for `node.type == syms.import_from` remains functionally the same (making or inserting invisible parentheses for import-from statements). (ID: todo-5)
- [ ] Verify that `visit_expr_stmt` is configured to call `visit_stmt` with `parens=ASSIGNMENTS` so that `normalize_invisible_parens` is invoked for assignment statements (confirm the `ASSIGNMENTS` constant includes `"="` and augmented assignment operators). (ID: todo-6)
- [ ] Inspect `tests/data/tupleassign.py` to confirm the expected output shows parentheses added around the left-hand tuple targets and the right-hand side values, matching the PR intent (multi-line visible parentheses form). (ID: todo-7)
- [ ] Check that the LHS-specific handling targets only tuple-style LHS (i.e., a `testlist_star_expr` representing multiple targets), not simple assignments to a single name; if implemented, confirm there is a guard (e.g., presence of a comma in the child) to avoid parenthesizing non-tuple LHS. (ID: todo-8)
- [ ] Verify that wrapping the LHS (and other children) does not drop or misplace prefixes/comments: where a node with a non-empty `prefix` is wrapped, the prefix is attached to the newly created `Node(syms.atom, ...)` rather than being lost, across all wrapping branches. (ID: todo-9)
- [ ] Confirm that the function still avoids wrapping multiline string leaves (the `isinstance(child, Leaf) and is_multiline_string(child)` exclusion remains intact) and that this behavior remains unchanged by the PR. (ID: todo-10)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 10
description: 'In `black.py`, locate `normalize_invisible_parens(node, parens_after)` and verify the new early branch exists to detect tuple-unpack LHS: it should check `index == 0` and `isinstance(child, Node)` and `child.type == syms.testlist_star_expr` to trigger LHS-specific handling (per PR).'
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "def normalize_invisible_parens\\(",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black"
]
[ "rg", "--no-heading", "--line-number", "--ignore-file", ".rgignore", "testlist_star_expr",
  "/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black"
]
Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True
2820:
2821:            previous_consumed = comment.consumed
2822:
2823:    return False
2824:
2825:
2826:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2827:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2828:
2829:    Stops at the end of the block.

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True
2820:
2821:            previous_consumed = comment.consumed
2822:
2823:    return False
2824:
2825:
2826:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2827:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2828:
2829:    Stops at the end of the block.
2830:    """
2831:    container: Optional[LN] = container_of(leaf)
2832:    while container is not None and container.type != token.ENDMARKER:
2833:        for comment in list_comments(container.prefix, is_endmarker=False):
2834:            if comment.value in FMT_ON:
2835:                return
2836:
2837:        yield container
2838:
2839:        container = container.next_sibling
2840:
2841:
2842:def maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool:
2843:    """If it's safe, make the parens in the atom `node` invisible, recursively.
2844:
2845:    Returns whether the node should itself be wrapped in invisible parentheses.
2846:
2847:    """
2848:    if (
2849:        node.type != syms.atom

Calling tool: grepTool
testlist_star_expr
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:892:    syms.testlist_star_expr,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:892:    syms.testlist_star_expr,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/coverage_bugsinpy.txt:41:      testlist_star_expr
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/coverage_bugsinpy.txt:49:      /testlist_star_expr
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/data/fmtonoff.py:67:def testlist_star_expr():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/data/fmtonoff.py:274:def testlist_star_expr():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:892:    syms.testlist_star_expr,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/blib2to3/pygram.pyi:89:    testlist_star_expr: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/blib2to3/Grammar.txt:38:expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/blib2to3/Grammar.txt:39:                     ('=' (yield_expr|testlist_star_expr))*)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/blib2to3/Grammar.txt:41:testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/blib2to3/pygram.pyi:89:    testlist_star_expr: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/tests/data/fmtonoff.py:67:def testlist_star_expr():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/tests/data/fmtonoff.py:274:def testlist_star_expr():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/blib2to3/Grammar.txt:38:expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/blib2to3/Grammar.txt:39:                     ('=' (yield_expr|testlist_star_expr))*)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/blib2to3/Grammar.txt:41:testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2and3/lib2to3/pygram.pyi:85:    testlist_star_expr: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/3/symbol.pyi:25:testlist_star_expr: int

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: In black.py’s normalize_invisible_parens, there is no early branch checking index == 0, isinstance(child, Node), and child.type == syms.testlist_star_expr. The loop starts with `if check_lpar:` and sets `check_lpar` from `parens_after`; the new LHS-specific handling from the PR is missing.


Validating todo item 1 of 10
description: 'In `black.py`, locate `normalize_invisible_parens(node, parens_after)` and verify the new early branch exists to detect tuple-unpack LHS: it should check `index == 0` and `isinstance(child, Node)` and `child.type == syms.testlist_star_expr` to trigger LHS-specific handling (per PR).'

Calling tool: grepTool
def normalize_invisible_parens\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True
2820:
2821:            previous_consumed = comment.consumed
2822:
2823:    return False
2824:
2825:
2826:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2827:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2828:
2829:    Stops at the end of the block.

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py
2710:    return f"{before or 0}.{after or 0}"
2711:
2712:
2713:def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:
2714:    """Make existing optional parentheses invisible or create new ones.
2715:
2716:    `parens_after` is a set of string leaf values immeditely after which parens
2717:    should be put.
2718:
2719:    Standardizes on visible parentheses for single-element tuples, and keeps
2720:    existing visible parentheses for other tuples and generator expressions.
2721:    """
2722:    for pc in list_comments(node.prefix, is_endmarker=False):
2723:        if pc.value in FMT_OFF:
2724:            # This `node` has a prefix with `# fmt: off`, don't mess with parens.
2725:            return
2726:
2727:    check_lpar = False
2728:    for index, child in enumerate(list(node.children)):
2729:        if check_lpar:
2730:            if child.type == syms.atom:
2731:                if maybe_make_parens_invisible_in_atom(child, parent=node):
2732:                    lpar = Leaf(token.LPAR, "")
2733:                    rpar = Leaf(token.RPAR, "")
2734:                    index = child.remove() or 0
2735:                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2736:            elif is_one_tuple(child):
2737:                # wrap child in visible parentheses
2738:                lpar = Leaf(token.LPAR, "(")
2739:                rpar = Leaf(token.RPAR, ")")
2740:                child.remove()
2741:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2742:            elif node.type == syms.import_from:
2743:                # "import from" nodes store parentheses directly as part of
2744:                # the statement
2745:                if child.type == token.LPAR:
2746:                    # make parentheses invisible
2747:                    child.value = ""  # type: ignore
2748:                    node.children[-1].value = ""  # type: ignore
2749:                elif child.type != token.STAR:
2750:                    # insert invisible parentheses
2751:                    node.insert_child(index, Leaf(token.LPAR, ""))
2752:                    node.append_child(Leaf(token.RPAR, ""))
2753:                break
2754:
2755:            elif not (isinstance(child, Leaf) and is_multiline_string(child)):
2756:                # wrap child in invisible parentheses
2757:                lpar = Leaf(token.LPAR, "")
2758:                rpar = Leaf(token.RPAR, "")
2759:                index = child.remove() or 0
2760:                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))
2761:
2762:        check_lpar = isinstance(child, Leaf) and child.value in parens_after
2763:
2764:
2765:def normalize_fmt_off(node: Node) -> None:
2766:    """Convert content between `# fmt: off`/`# fmt: on` into standalone comments."""
2767:    try_again = True
2768:    while try_again:
2769:        try_again = convert_one_fmt_off_pair(node)
2770:
2771:
2772:def convert_one_fmt_off_pair(node: Node) -> bool:
2773:    """Convert content of a single `# fmt: off`/`# fmt: on` into a standalone comment.
2774:
2775:    Returns True if a pair was converted.
2776:    """
2777:    for leaf in node.leaves():
2778:        previous_consumed = 0
2779:        for comment in list_comments(leaf.prefix, is_endmarker=False):
2780:            if comment.value in FMT_OFF:
2781:                # We only want standalone comments. If there's no previous leaf or
2782:                # the previous leaf is indentation, it's a standalone comment in
2783:                # disguise.
2784:                if comment.type != STANDALONE_COMMENT:
2785:                    prev = preceding_leaf(leaf)
2786:                    if prev and prev.type not in WHITESPACE:
2787:                        continue
2788:
2789:                ignored_nodes = list(generate_ignored_nodes(leaf))
2790:                if not ignored_nodes:
2791:                    continue
2792:
2793:                first = ignored_nodes[0]  # Can be a container node with the `leaf`.
2794:                parent = first.parent
2795:                prefix = first.prefix
2796:                first.prefix = prefix[comment.consumed :]
2797:                hidden_value = (
2798:                    comment.value + "\n" + "".join(str(n) for n in ignored_nodes)
2799:                )
2800:                if hidden_value.endswith("\n"):
2801:                    # That happens when one of the `ignored_nodes` ended with a NEWLINE
2802:                    # leaf (possibly followed by a DEDENT).
2803:                    hidden_value = hidden_value[:-1]
2804:                first_idx = None
2805:                for ignored in ignored_nodes:
2806:                    index = ignored.remove()
2807:                    if first_idx is None:
2808:                        first_idx = index
2809:                assert parent is not None, "INTERNAL ERROR: fmt: on/off handling (1)"
2810:                assert first_idx is not None, "INTERNAL ERROR: fmt: on/off handling (2)"
2811:                parent.insert_child(
2812:                    first_idx,
2813:                    Leaf(
2814:                        STANDALONE_COMMENT,
2815:                        hidden_value,
2816:                        prefix=prefix[:previous_consumed] + "\n" * comment.newlines,
2817:                    ),
2818:                )
2819:                return True
2820:
2821:            previous_consumed = comment.consumed
2822:
2823:    return False
2824:
2825:
2826:def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
2827:    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.
2828:
2829:    Stops at the end of the block.
2830:    """
2831:    container: Optional[LN] = container_of(leaf)
2832:    while container is not None and container.type != token.ENDMARKER:
2833:        for comment in list_comments(container.prefix, is_endmarker=False):
2834:            if comment.value in FMT_ON:
2835:                return
2836:
2837:        yield container
2838:
2839:        container = container.next_sibling
2840:
2841:
2842:def maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool:
2843:    """If it's safe, make the parens in the atom `node` invisible, recursively.
2844:
2845:    Returns whether the node should itself be wrapped in invisible parentheses.
2846:
2847:    """
2848:    if (
2849:        node.type != syms.atom

Calling tool: grepTool
testlist_star_expr
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:892:    syms.testlist_star_expr,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py:1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:892:    syms.testlist_star_expr,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/black.py.original:1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/coverage_bugsinpy.txt:41:      testlist_star_expr
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/coverage_bugsinpy.txt:49:      /testlist_star_expr
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/data/fmtonoff.py:67:def testlist_star_expr():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/tests/data/fmtonoff.py:274:def testlist_star_expr():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:892:    syms.testlist_star_expr,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/black.py:1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/blib2to3/pygram.pyi:89:    testlist_star_expr: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/blib2to3/Grammar.txt:38:expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/blib2to3/Grammar.txt:39:                     ('=' (yield_expr|testlist_star_expr))*)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/blib2to3/Grammar.txt:41:testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/blib2to3/pygram.pyi:89:    testlist_star_expr: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/tests/data/fmtonoff.py:67:def testlist_star_expr():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/src/black/tests/data/fmtonoff.py:274:def testlist_star_expr():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/blib2to3/Grammar.txt:38:expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/blib2to3/Grammar.txt:39:                     ('=' (yield_expr|testlist_star_expr))*)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/blib2to3/Grammar.txt:41:testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [',']
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/2and3/lib2to3/pygram.pyi:85:    testlist_star_expr: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-7/bad/black/env/lib/python3.8/site-packages/mypy/typeshed/stdlib/3/symbol.pyi:25:testlist_star_expr: int

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: In black.py’s normalize_invisible_parens, there is no early branch checking index == 0, isinstance(child, Node), and child.type == syms.testlist_star_expr. The loop starts with `if check_lpar:` and sets `check_lpar` from `parens_after`; the new LHS-specific handling from the PR is missing.


=== PHASE 2 COMPLETE ===

