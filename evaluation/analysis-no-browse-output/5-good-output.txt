=== PHASE 1: ANALYSIS ===

Calling tool: createTodo
Todo List Created
Todo List (11 items):
- [ ] Verify that in black.py the modified leaf.parent.type condition now includes syms.typedargslist alongside syms.arglist in the comma counting logic, and that syms.typedargslist is defined/imported in scope. (ID: todo-1)
- [ ] Confirm that the updated comma counting block (where commas is incremented and a break occurs) is part of the code path used to decide trailing comma removal for function definition parameters, so that including syms.typedargslist will cause removal for typed argument lists as intended. (ID: todo-2)
- [ ] In bracket_split_build_line, verify the new no_commas variable is defined as: original.is_def and not any(l.type == token.COMMA for l in leaves), and that original.is_def correctly identifies function definitions (not calls or other constructs). (ID: todo-3)
- [ ] Check that the condition if original.is_import or no_commas: correctly broadens the existing behavior to also apply the trailing-comma ensuring logic to function definition lines with a single argument (no existing commas), without affecting lines that already contain a comma. (ID: todo-4)
- [ ] Inspect the loop that walks leaves from the end and skips STANDALONE_COMMENT tokens; verify that the subsequent code adds the comma after the last non-comment leaf and does not place it after any comments. (ID: todo-5)
- [ ] Ensure the trailing comma addition logic does not add commas to empty parameter lists (e.g., def f():) because of the surrounding if leaves: guard and the no_commas definition. (ID: todo-6)
- [ ] Verify that multiple-argument function definition lines will not match no_commas (since a COMMA token should be present among leaves), preventing accidental extra commas. (ID: todo-7)
- [ ] Confirm that comments in this context that should be skipped are represented by STANDALONE_COMMENT; check that no other comment token types need to be handled here to satisfy the PR note "be careful not to add one after any comments." (ID: todo-8)
- [ ] Validate that test_function_trailing_comma includes cases for: one-argument function definition formatted as one(a,), two-argument function definition formatted without trailing comma, and equivalent cases with type-annotated parameters (typedargslist). (ID: todo-9)
- [ ] Check that the updated comment above the no_commas logic accurately reflects behavior ("imports and standalone function arguments") and aligns with the implemented condition. (ID: todo-10)
- [ ] Verify that all referenced constants/names (token.COMMA, STANDALONE_COMMENT, syms.arglist, syms.typedargslist) are imported/in scope within black.py to avoid NameError. (ID: todo-11)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 11
description: 'Verify that in black.py the modified leaf.parent.type condition now includes syms.typedargslist alongside syms.arglist in the comma counting logic, and that syms.typedargslist is defined/imported in scope.'
Calling tool: grepTool
typedargslist
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
typedargslist
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:941:    syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1357:                    syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1811:                elif prevp.parent.type == syms.typedargslist:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1856:    elif p.type == syms.typedargslist:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2579:            if is_vararg(leaf, within={syms.typedargslist}):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:3172:            n.type in {syms.typedargslist, syms.arglist}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:3176:            if n.type == syms.typedargslist:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/blib2to3/pygram.pyi:95:    typedargslist: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function.py:47:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function.py:50:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function.py:183:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function.py:191:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/blib2to3/Grammar.txt:20:parameters: '(' [typedargslist] ')'
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/blib2to3/Grammar.txt:21:typedargslist: ((tfpdef ['=' test] ',')*
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/fmtonoff.py:116:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/fmtonoff.py:329:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/debug_visitor.out:72:            typedargslist
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/debug_visitor.out:87:            /typedargslist
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/debug_visitor.out:676:              typedargslist
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/debug_visitor.out:691:              /typedargslist
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/comments2.py:62:    if typedargslist:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/comments2.py:224:    if typedargslist:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:34:                syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:44:                syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:86:                syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:127:                syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:137:                syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:181:                syms.typedargslist,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:
1378:            return False
1379:
1380:        if not self.leaves:
1381:            comment.type = STANDALONE_COMMENT
1382:            comment.prefix = ""
1383:            return False
1384:
1385:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1386:        return True
1387:

Calling tool: grepTool
python_symbols\s+as\s+syms|import\s+syms|syms\s*=
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:82:syms = pygram.python_symbols

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
60:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
61:
62:
63:# types
64:FileContent = str
65:Encoding = str
66:NewLine = str
67:Depth = int
68:NodeType = int
69:LeafID = int
70:Priority = int
71:Index = int
72:LN = Union[Leaf, Node]
73:SplitFunc = Callable[["Line", Collection["Feature"]], Iterator["Line"]]
74:Timestamp = float
75:FileSize = int
76:CacheInfo = Tuple[Timestamp, FileSize]
77:Cache = Dict[Path, CacheInfo]
78:out = partial(click.secho, bold=True, err=True)
79:err = partial(click.secho, fg="red", err=True)
80:
81:pygram.initialize(CACHE_DIR)
82:syms = pygram.python_symbols
83:
84:
85:class NothingChanged(UserWarning):
86:    """Raised when reformatted code is the same as source."""
87:
88:
89:class CannotSplit(Exception):
90:    """A readable split that fits the allotted line length is impossible."""
91:
92:
93:class InvalidInput(ValueError):
94:    """Raised when input source code fails all parse attempts."""
95:
96:
97:class WriteBack(Enum):
98:    NO = 0
99:    YES = 1

Calling tool: grepTool
import\s+pygram|from\s+.*\s+import\s+pygram
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:48:from blib2to3 import pygram, pytree

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
930:    token.DOUBLESLASH,
931:    token.PERCENT,
932:    token.AT,
933:    token.TILDE,
934:    token.DOUBLESTAR,
935:}
936:STARS = {token.STAR, token.DOUBLESTAR}
937:VARARGS_PARENTS = {
938:    syms.arglist,
939:    syms.argument,  # double star in arglist
940:    syms.trailer,  # single argument to call
941:    syms.typedargslist,
942:    syms.varargslist,  # lambdas
943:}
944:UNPACKING_PARENTS = {
945:    syms.atom,  # single element of a list or set literal
946:    syms.dictsetmaker,
947:    syms.listmaker,
948:    syms.testlist_gexp,
949:    syms.testlist_star_expr,
950:}
951:TEST_DESCENDANTS = {
952:    syms.test,
953:    syms.lambdef,
954:    syms.or_test,
955:    syms.and_test,
956:    syms.not_test,
957:    syms.comparison,
958:    syms.star_expr,
959:    syms.expr,
960:    syms.xor_expr,
961:    syms.and_expr,
962:    syms.shift_expr,
963:    syms.arith_expr,
964:    syms.trailer,
965:    syms.term,
966:    syms.power,
967:}
968:ASSIGNMENTS = {
969:    "=",

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1320:        if closing.type == token.RBRACE:
1321:            self.remove_trailing_comma()
1322:            return True
1323:
1324:        if closing.type == token.RSQB:
1325:            comma = self.leaves[-1]
1326:            if comma.parent and comma.parent.type == syms.listmaker:
1327:                self.remove_trailing_comma()
1328:                return True
1329:
1330:        # For parens let's check if it's safe to remove the comma.
1331:        # Imports are always safe.
1332:        if self.is_import:
1333:            self.remove_trailing_comma()
1334:            return True
1335:
1336:        # Otherwise, if the trailing one is the only one, we might mistakenly
1337:        # change a tuple into a different type by removing the comma.
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, the comma counting logic now checks leaf.parent.type in {syms.arglist, syms.typedargslist} (lines 1355-1358), confirming inclusion of syms.typedargslist. syms is set via syms = pygram.python_symbols (line 82) with pygram imported, and syms.typedargslist is used elsewhere and defined (blib2to3/pygram.pyi), so it is in scope.


Todo item 1 of 11 is correct
description: 'Verify that in black.py the modified leaf.parent.type condition now includes syms.typedargslist alongside syms.arglist in the comma counting logic, and that syms.typedargslist is defined/imported in scope.'
Validating todo item 2 of 11
description: 'Confirm that the updated comma counting block (where commas is incremented and a break occurs) is part of the code path used to decide trailing comma removal for function definition parameters, so that including syms.typedargslist will cause removal for typed argument lists as intended.'
Calling tool: grepTool
def maybe_remove_trailing_comma\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1295:            if leaf_id in ignored_ids:
1296:                continue
1297:
1298:            for comment in comments:
1299:                if is_type_comment(comment):
1300:                    return True
1301:
1302:        return False
1303:
1304:    def contains_multiline_strings(self) -> bool:
1305:        for leaf in self.leaves:
1306:            if is_multiline_string(leaf):
1307:                return True
1308:
1309:        return False
1310:
1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1312:        """Remove trailing comma if there is one and it's safe."""
1313:        if not (
1314:            self.leaves
1315:            and self.leaves[-1].type == token.COMMA
1316:            and closing.type in CLOSING_BRACKETS
1317:        ):
1318:            return False
1319:
1320:        if closing.type == token.RBRACE:
1321:            self.remove_trailing_comma()
1322:            return True
1323:
1324:        if closing.type == token.RSQB:
1325:            comma = self.leaves[-1]
1326:            if comma.parent and comma.parent.type == syms.listmaker:
1327:                self.remove_trailing_comma()
1328:                return True
1329:
1330:        # For parens let's check if it's safe to remove the comma.
1331:        # Imports are always safe.
1332:        if self.is_import:
1333:            self.remove_trailing_comma()
1334:            return True
1335:
1336:        # Otherwise, if the trailing one is the only one, we might mistakenly
1337:        # change a tuple into a different type by removing the comma.
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:
1378:            return False
1379:
1380:        if not self.leaves:
1381:            comment.type = STANDALONE_COMMENT
1382:            comment.prefix = ""
1383:            return False
1384:
1385:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1386:        return True
1387:
1388:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1389:        """Generate comments that should appear directly after `leaf`."""
1390:        return self.comments.get(id(leaf), [])
1391:
1392:    def remove_trailing_comma(self) -> None:
1393:        """Remove the trailing comma and moves the comments attached to it."""
1394:        trailing_comma = self.leaves.pop()
1395:        trailing_comma_comments = self.comments.pop(id(trailing_comma), [])
1396:        self.comments.setdefault(id(self.leaves[-1]), []).extend(
1397:            trailing_comma_comments
1398:        )
1399:
1400:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1401:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1402:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1403:        if open_lsqb is None:
1404:            return False
1405:
1406:        subscript_start = open_lsqb.next_sibling
1407:
1408:        if isinstance(subscript_start, Node):
1409:            if subscript_start.type == syms.listmaker:
1410:                return False
1411:
1412:            if subscript_start.type == syms.subscriptlist:
1413:                subscript_start = child_towards(subscript_start, leaf)
1414:        return subscript_start is not None and any(
1415:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
1416:        )
1417:
1418:    def __str__(self) -> str:
1419:        """Render the line."""
1420:        if not self:
1421:            return "\n"
1422:
1423:        indent = "    " * self.depth
1424:        leaves = iter(self.leaves)
1425:        first = next(leaves)
1426:        res = f"{first.prefix}{indent}{first.value}"
1427:        for leaf in leaves:
1428:            res += str(leaf)
1429:        for comment in itertools.chain.from_iterable(self.comments.values()):
1430:            res += str(comment)
1431:        return res + "\n"
1432:
1433:    def __bool__(self) -> bool:
1434:        """Return True if the line has leaves or comments."""
1435:        return bool(self.leaves or self.comments)
1436:
1437:
1438:@dataclass
1439:class EmptyLineTracker:
1440:    """Provides a stateful method that returns the number of potential extra
1441:    empty lines needed before and after the currently processed line.
1442:
1443:    Note: this tracker works on lines that haven't been split yet.  It assumes
1444:    the prefix of the first leaf consists of optional newlines.  Those newlines
1445:    are consumed by `maybe_empty_lines()` and included in the computation.
1446:    """
1447:
1448:    is_pyi: bool = False
1449:    previous_line: Optional[Line] = None
1450:    previous_after: int = 0
1451:    previous_defs: List[int] = Factory(list)
1452:
1453:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1454:        """Return the number of extra empty lines before and after the `current_line`.
1455:
1456:        This is for separating `def`, `async def` and `class` with extra empty
1457:        lines (two on module-level).
1458:        """
1459:        before, after = self._maybe_empty_lines(current_line)
1460:        before -= self.previous_after
1461:        self.previous_after = after
1462:        self.previous_line = current_line
1463:        return before, after
1464:
1465:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1466:        max_allowed = 1
1467:        if current_line.depth == 0:
1468:            max_allowed = 1 if self.is_pyi else 2
1469:        if current_line.leaves:
1470:            # Consume the first leaf's extra newlines.
1471:            first_leaf = current_line.leaves[0]
1472:            before = first_leaf.prefix.count("\n")
1473:            before = min(before, max_allowed)
1474:            first_leaf.prefix = ""
1475:        else:
1476:            before = 0
1477:        depth = current_line.depth
1478:        while self.previous_defs and self.previous_defs[-1] >= depth:
1479:            self.previous_defs.pop()
1480:            if self.is_pyi:
1481:                before = 0 if depth else 1
1482:            else:
1483:                before = 1 if depth else 2
1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
1485:            return self._maybe_empty_lines_for_class_or_def(current_line, before)
1486:
1487:        if (
1488:            self.previous_line
1489:            and self.previous_line.is_import
1490:            and not current_line.is_import
1491:            and depth == self.previous_line.depth
1492:        ):
1493:            return (before or 1), 0
1494:
1495:        if (
1496:            self.previous_line
1497:            and self.previous_line.is_class
1498:            and current_line.is_triple_quoted_string
1499:        ):
1500:            return before, 1
1501:
1502:        return before, 0
1503:
1504:    def _maybe_empty_lines_for_class_or_def(
1505:        self, current_line: Line, before: int
1506:    ) -> Tuple[int, int]:
1507:        if not current_line.is_decorator:
1508:            self.previous_defs.append(current_line.depth)
1509:        if self.previous_line is None:
1510:            # Don't insert empty lines before the first line in the file.
1511:            return 0, 0
1512:
1513:        if self.previous_line.is_decorator:
1514:            return 0, 0

Calling tool: grepTool
maybe_remove_trailing_comma\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1176:            self.maybe_remove_trailing_comma(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1125:        if (
1126:            self._lambda_argument_depths
1127:            and self._lambda_argument_depths[-1] == self.depth
1128:            and leaf.type == token.COLON
1129:        ):
1130:            self.depth -= 1
1131:            self._lambda_argument_depths.pop()
1132:            return True
1133:
1134:        return False
1135:
1136:    def get_open_lsqb(self) -> Optional[Leaf]:
1137:        """Return the most recent opening square bracket (if any)."""
1138:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1139:
1140:
1141:@dataclass
1142:class Line:
1143:    """Holds leaves and comments. Can be printed with `str(line)`."""
1144:
1145:    depth: int = 0
1146:    leaves: List[Leaf] = Factory(list)
1147:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)  # keys ordered like `leaves`
1148:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1149:    inside_brackets: bool = False
1150:    should_explode: bool = False
1151:
1152:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1153:        """Add a new `leaf` to the end of the line.
1154:
1155:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1156:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1157:        Trailing commas are maybe removed, unpacked for loop variables are
1158:        demoted from being delimiters.
1159:
1160:        Inline comments are put aside.
1161:        """
1162:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1163:        if not has_value:
1164:            return
1165:
1166:        if token.COLON == leaf.type and self.is_class_paren_empty:
1167:            del self.leaves[-2:]
1168:        if self.leaves and not preformatted:
1169:            # Note: at this point leaf.prefix should be empty except for
1170:            # imports, for which we only preserve newlines.
1171:            leaf.prefix += whitespace(
1172:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1173:            )
1174:        if self.inside_brackets or not preformatted:
1175:            self.bracket_tracker.mark(leaf)
1176:            self.maybe_remove_trailing_comma(leaf)
1177:        if not self.append_comment(leaf):
1178:            self.leaves.append(leaf)
1179:
1180:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1181:        """Like :func:`append()` but disallow invalid standalone comment structure.
1182:
1183:        Raises ValueError when any `leaf` is appended after a standalone comment
1184:        or when a standalone comment is not the first leaf on the line.
1185:        """
1186:        if self.bracket_tracker.depth == 0:
1187:            if self.is_comment:
1188:                raise ValueError("cannot append to standalone comments")
1189:
1190:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1191:                raise ValueError(
1192:                    "cannot append standalone comments to a populated line"
1193:                )
1194:
1195:        self.append(leaf, preformatted=preformatted)
1196:
1197:    @property
1198:    def is_comment(self) -> bool:
1199:        """Is this line a standalone comment?"""
1200:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1201:
1202:    @property
1203:    def is_decorator(self) -> bool:
1204:        """Is this line a decorator?"""

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2455:
2456:    Do nothing otherwise.
2457:
2458:    A left- or right-hand split is based on a pair of brackets. Content before
2459:    (and including) the opening bracket is left on one line, content inside the
2460:    brackets is put on a separate line, and finally content starting with and
2461:    following the closing bracket is put on a separate line.
2462:
2463:    Those are called `head`, `body`, and `tail`, respectively. If the split
2464:    produced the same line (all content in `head`) or ended up with an empty `body`
2465:    and the `tail` is just the closing bracket, then it's considered failed.
2466:    """
2467:    tail_len = len(str(tail).strip())
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:
2548:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2549:    except ValueError:
2550:        raise CannotSplit("No delimiters found")
2551:
2552:    if delimiter_priority == DOT_PRIORITY:
2553:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2554:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")

Calling tool: grepTool
remove_trailing_comma\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1176:            self.maybe_remove_trailing_comma(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1321:            self.remove_trailing_comma()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1327:                self.remove_trailing_comma()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1333:            self.remove_trailing_comma()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1363:            self.remove_trailing_comma()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1392:    def remove_trailing_comma(self) -> None:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The updated comma-counting block is inside Line.maybe_remove_trailing_comma (black.py:1352-1361). This method is called during line building when appending a closing bracket (Line.append at black.py:1176), which applies to function definition parameter lists. Including syms.typedargslist in the parent-type check ensures trailing comma removal logic applies to typed argument lists.


Todo item 2 of 11 is correct
description: 'Confirm that the updated comma counting block (where commas is incremented and a break occurs) is part of the code path used to decide trailing comma removal for function definition parameters, so that including syms.typedargslist will cause removal for typed argument lists as intended.'
Validating todo item 3 of 11
description: 'In bracket_split_build_line, verify the new no_commas variable is defined as: original.is_def and not any(l.type == token.COMMA for l in leaves), and that original.is_def correctly identifies function definitions (not calls or other constructs).'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:
2548:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2549:    except ValueError:

Calling tool: grepTool
is_def\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1229:    def is_def(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1517:            self.previous_line.is_class or self.previous_line.is_def
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1537:            elif current_line.is_def and not self.previous_line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2282:    if line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2496:            no_commas = original.is_def and not any(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1200:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1201:
1202:    @property
1203:    def is_decorator(self) -> bool:
1204:        """Is this line a decorator?"""
1205:        return bool(self) and self.leaves[0].type == token.AT
1206:
1207:    @property
1208:    def is_import(self) -> bool:
1209:        """Is this an import line?"""
1210:        return bool(self) and is_import(self.leaves[0])
1211:
1212:    @property
1213:    def is_class(self) -> bool:
1214:        """Is this line a class definition?"""
1215:        return (
1216:            bool(self)
1217:            and self.leaves[0].type == token.NAME
1218:            and self.leaves[0].value == "class"
1219:        )
1220:
1221:    @property
1222:    def is_stub_class(self) -> bool:
1223:        """Is this line a class definition with a body consisting only of "..."?"""
1224:        return self.is_class and self.leaves[-3:] == [
1225:            Leaf(token.DOT, ".") for _ in range(3)
1226:        ]
1227:
1228:    @property
1229:    def is_def(self) -> bool:
1230:        """Is this a function definition? (Also returns True for async defs.)"""
1231:        try:
1232:            first_leaf = self.leaves[0]
1233:        except IndexError:
1234:            return False
1235:
1236:        try:
1237:            second_leaf: Optional[Leaf] = self.leaves[1]
1238:        except IndexError:
1239:            second_leaf = None
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC
1242:            and second_leaf is not None
1243:            and second_leaf.type == token.NAME
1244:            and second_leaf.value == "def"
1245:        )
1246:
1247:    @property
1248:    def is_class_paren_empty(self) -> bool:
1249:        """Is this a class with no base classes but using parentheses?
1250:
1251:        Those are unnecessary and should be removed.
1252:        """
1253:        return (
1254:            bool(self)
1255:            and len(self.leaves) == 4
1256:            and self.is_class
1257:            and self.leaves[2].type == token.LPAR
1258:            and self.leaves[2].value == "("
1259:            and self.leaves[3].type == token.RPAR
1260:            and self.leaves[3].value == ")"
1261:        )
1262:
1263:    @property
1264:    def is_triple_quoted_string(self) -> bool:
1265:        """Is the line a triple quoted string?"""
1266:        return (
1267:            bool(self)
1268:            and self.leaves[0].type == token.STRING
1269:            and self.leaves[0].value.startswith(('"""', "'''"))
1270:        )
1271:
1272:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1273:        """If so, needs to be split before emitting."""
1274:        for leaf in self.leaves:
1275:            if leaf.type == STANDALONE_COMMENT:
1276:                if leaf.bracket_depth <= depth_limit:
1277:                    return True
1278:        return False
1279:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py’s bracket_split_build_line, no_commas is defined exactly as `original.is_def and not any(l.type == token.COMMA for l in leaves)`. The `original` parameter is a Line, and Line.is_def checks for ‘def’ or ‘async def’ at the start, correctly identifying function definitions (not calls).


Todo item 3 of 11 is correct
description: 'In bracket_split_build_line, verify the new no_commas variable is defined as: original.is_def and not any(l.type == token.COMMA for l in leaves), and that original.is_def correctly identifies function definitions (not calls or other constructs).'
Validating todo item 4 of 11
description: 'Check that the condition if original.is_import or no_commas: correctly broadens the existing behavior to also apply the trailing-comma ensuring logic to function definition lines with a single argument (no existing commas), without affecting lines that already contain a comma.'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:

Calling tool: grepTool
is_def
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1229:    def is_def(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1517:            self.previous_line.is_class or self.previous_line.is_def
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1537:            elif current_line.is_def and not self.previous_line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2282:    if line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2496:            no_commas = original.is_def and not any(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1210:        return bool(self) and is_import(self.leaves[0])
1211:
1212:    @property
1213:    def is_class(self) -> bool:
1214:        """Is this line a class definition?"""
1215:        return (
1216:            bool(self)
1217:            and self.leaves[0].type == token.NAME
1218:            and self.leaves[0].value == "class"
1219:        )
1220:
1221:    @property
1222:    def is_stub_class(self) -> bool:
1223:        """Is this line a class definition with a body consisting only of "..."?"""
1224:        return self.is_class and self.leaves[-3:] == [
1225:            Leaf(token.DOT, ".") for _ in range(3)
1226:        ]
1227:
1228:    @property
1229:    def is_def(self) -> bool:
1230:        """Is this a function definition? (Also returns True for async defs.)"""
1231:        try:
1232:            first_leaf = self.leaves[0]
1233:        except IndexError:
1234:            return False
1235:
1236:        try:
1237:            second_leaf: Optional[Leaf] = self.leaves[1]
1238:        except IndexError:
1239:            second_leaf = None
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC
1242:            and second_leaf is not None
1243:            and second_leaf.type == token.NAME
1244:            and second_leaf.value == "def"
1245:        )
1246:
1247:    @property
1248:    def is_class_paren_empty(self) -> bool:
1249:        """Is this a class with no base classes but using parentheses?

Calling tool: grepTool
maybe_remove_trailing_comma\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1176:            self.maybe_remove_trailing_comma(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1298:            for comment in comments:
1299:                if is_type_comment(comment):
1300:                    return True
1301:
1302:        return False
1303:
1304:    def contains_multiline_strings(self) -> bool:
1305:        for leaf in self.leaves:
1306:            if is_multiline_string(leaf):
1307:                return True
1308:
1309:        return False
1310:
1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1312:        """Remove trailing comma if there is one and it's safe."""
1313:        if not (
1314:            self.leaves
1315:            and self.leaves[-1].type == token.COMMA
1316:            and closing.type in CLOSING_BRACKETS
1317:        ):
1318:            return False
1319:
1320:        if closing.type == token.RBRACE:
1321:            self.remove_trailing_comma()
1322:            return True
1323:
1324:        if closing.type == token.RSQB:
1325:            comma = self.leaves[-1]
1326:            if comma.parent and comma.parent.type == syms.listmaker:
1327:                self.remove_trailing_comma()
1328:                return True
1329:
1330:        # For parens let's check if it's safe to remove the comma.
1331:        # Imports are always safe.
1332:        if self.is_import:
1333:            self.remove_trailing_comma()
1334:            return True
1335:
1336:        # Otherwise, if the trailing one is the only one, we might mistakenly
1337:        # change a tuple into a different type by removing the comma.
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:
1378:            return False
1379:
1380:        if not self.leaves:
1381:            comment.type = STANDALONE_COMMENT
1382:            comment.prefix = ""
1383:            return False
1384:
1385:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1386:        return True
1387:

Calling tool: grepTool
test_function_trailing_comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_function_trailing_comma
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py:268:    def test_function_trailing_comma(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py
240:        self.assertEqual(expected, actual)
241:
242:    @patch("black.dump_to_file", dump_to_stderr)
243:    def test_setup(self) -> None:
244:        source, expected = read_data("../setup", data=False)
245:        actual = fs(source)
246:        self.assertFormatEqual(expected, actual)
247:        black.assert_equivalent(source, actual)
248:        black.assert_stable(source, actual, black.FileMode())
249:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
250:
251:    @patch("black.dump_to_file", dump_to_stderr)
252:    def test_function(self) -> None:
253:        source, expected = read_data("function")
254:        actual = fs(source)
255:        self.assertFormatEqual(expected, actual)
256:        black.assert_equivalent(source, actual)
257:        black.assert_stable(source, actual, black.FileMode())
258:
259:    @patch("black.dump_to_file", dump_to_stderr)
260:    def test_function2(self) -> None:
261:        source, expected = read_data("function2")
262:        actual = fs(source)
263:        self.assertFormatEqual(expected, actual)
264:        black.assert_equivalent(source, actual)
265:        black.assert_stable(source, actual, black.FileMode())
266:
267:    @patch("black.dump_to_file", dump_to_stderr)
268:    def test_function_trailing_comma(self) -> None:
269:        source, expected = read_data("function_trailing_comma")
270:        actual = fs(source)
271:        self.assertFormatEqual(expected, actual)
272:        black.assert_equivalent(source, actual)
273:        black.assert_stable(source, actual, black.FileMode())
274:
275:    @patch("black.dump_to_file", dump_to_stderr)
276:    def test_expression(self) -> None:
277:        source, expected = read_data("expression")
278:        actual = fs(source)
279:        self.assertFormatEqual(expected, actual)
280:        black.assert_equivalent(source, actual)
281:        black.assert_stable(source, actual, black.FileMode())
282:
283:    def test_expression_ff(self) -> None:
284:        source, expected = read_data("expression")
285:        tmp_file = Path(black.dump_to_file(source))
286:        try:
287:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
288:            with open(tmp_file, encoding="utf8") as f:
289:                actual = f.read()
290:        finally:
291:            os.unlink(tmp_file)
292:        self.assertFormatEqual(expected, actual)
293:        with patch("black.dump_to_file", dump_to_stderr):
294:            black.assert_equivalent(source, actual)
295:            black.assert_stable(source, actual, black.FileMode())
296:
297:    def test_expression_diff(self) -> None:
298:        source, _ = read_data("expression.py")
299:        expected, _ = read_data("expression.diff")

Calling tool: globTool
**/*function_trailing_comma*
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black: No such file or directory (os error 2)


Calling tool: globTool
**/*function_trailing_comma*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py
1:def f(a,):
2:    ...
3:
4:def f(a:int=1,):
5:    ...
6:
7:# output
8:
9:def f(a):
10:    ...
11:
12:
13:def f(a: int = 1):
14:    ...

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In bracket_split_build_line, the new condition computes no_commas = original.is_def and not any(l.type == token.COMMA for l in leaves) and uses if original.is_import or no_commas: to trigger trailing-comma insertion. This applies the logic to function definition lines with a single argument (no commas) and the inner loop breaks if a comma is already present, so lines that already contain a comma are unaffected.


Todo item 4 of 11 is correct
description: 'Check that the condition if original.is_import or no_commas: correctly broadens the existing behavior to also apply the trailing-comma ensuring logic to function definition lines with a single argument (no existing commas), without affecting lines that already contain a comma.'
Validating todo item 5 of 11
description: 'Inspect the loop that walks leaves from the end and skips STANDALONE_COMMENT tokens; verify that the subsequent code adds the comma after the last non-comment leaf and does not place it after any comments.'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In bracket_split_build_line, the loop walks from the end, skipping STANDALONE_COMMENT leaves, then either breaks if it finds an existing COMMA or inserts a COMMA at i+1. This ensures the comma is placed immediately after the last non-comment leaf and before any trailing comments.


Todo item 5 of 11 is correct
description: 'Inspect the loop that walks leaves from the end and skips STANDALONE_COMMENT tokens; verify that the subsequent code adds the comma after the last non-comment leaf and does not place it after any comments.'
Validating todo item 6 of 11
description: 'Ensure the trailing comma addition logic does not add commas to empty parameter lists (e.g., def f():) because of the surrounding if leaves: guard and the no_commas definition.'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:
2548:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2549:    except ValueError:
2550:        raise CannotSplit("No delimiters found")
2551:
2552:    if delimiter_priority == DOT_PRIORITY:
2553:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2554:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2555:
2556:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2557:    lowest_depth = sys.maxsize
2558:    trailing_comma_safe = True
2559:
2560:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2561:        """Append `leaf` to current line or to new line if appending impossible."""
2562:        nonlocal current_line
2563:        try:
2564:            current_line.append_safe(leaf, preformatted=True)
2565:        except ValueError:
2566:            yield current_line
2567:
2568:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2569:            current_line.append(leaf)
2570:
2571:    for leaf in line.leaves:
2572:        yield from append_to_line(leaf)
2573:
2574:        for comment_after in line.comments_after(leaf):
2575:            yield from append_to_line(comment_after)
2576:
2577:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2578:        if leaf.bracket_depth == lowest_depth:
2579:            if is_vararg(leaf, within={syms.typedargslist}):
2580:                trailing_comma_safe = (
2581:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features
2582:                )
2583:            elif is_vararg(leaf, within={syms.arglist, syms.argument}):
2584:                trailing_comma_safe = (
2585:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features
2586:                )
2587:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:

Calling tool: grepTool
no_commas\s*=
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2496:            no_commas = original.is_def and not any(

Calling tool: grepTool
Ensure a trailing comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2494:            # Ensure a trailing comma for imports and standalone function arguments, but

Calling tool: grepTool
is_def\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1229:    def is_def(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1517:            self.previous_line.is_class or self.previous_line.is_def
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1537:            elif current_line.is_def and not self.previous_line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2282:    if line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2496:            no_commas = original.is_def and not any(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1218:            and self.leaves[0].value == "class"
1219:        )
1220:
1221:    @property
1222:    def is_stub_class(self) -> bool:
1223:        """Is this line a class definition with a body consisting only of "..."?"""
1224:        return self.is_class and self.leaves[-3:] == [
1225:            Leaf(token.DOT, ".") for _ in range(3)
1226:        ]
1227:
1228:    @property
1229:    def is_def(self) -> bool:
1230:        """Is this a function definition? (Also returns True for async defs.)"""
1231:        try:
1232:            first_leaf = self.leaves[0]
1233:        except IndexError:
1234:            return False
1235:
1236:        try:
1237:            second_leaf: Optional[Leaf] = self.leaves[1]
1238:        except IndexError:
1239:            second_leaf = None
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC
1242:            and second_leaf is not None
1243:            and second_leaf.type == token.NAME
1244:            and second_leaf.value == "def"
1245:        )
1246:
1247:    @property
1248:    def is_class_paren_empty(self) -> bool:
1249:        """Is this a class with no base classes but using parentheses?
1250:
1251:        Those are unnecessary and should be removed.
1252:        """
1253:        return (
1254:            bool(self)
1255:            and len(self.leaves) == 4
1256:            and self.is_class
1257:            and self.leaves[2].type == token.LPAR
1258:            and self.leaves[2].value == "("
1259:            and self.leaves[3].type == token.RPAR
1260:            and self.leaves[3].value == ")"
1261:        )
1262:
1263:    @property
1264:    def is_triple_quoted_string(self) -> bool:
1265:        """Is the line a triple quoted string?"""
1266:        return (
1267:            bool(self)
1268:            and self.leaves[0].type == token.STRING
1269:            and self.leaves[0].value.startswith(('"""', "'''"))
1270:        )
1271:
1272:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1273:        """If so, needs to be split before emitting."""
1274:        for leaf in self.leaves:
1275:            if leaf.type == STANDALONE_COMMENT:
1276:                if leaf.bracket_depth <= depth_limit:
1277:                    return True
1278:        return False
1279:

Calling tool: grepTool
bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2355:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2356:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2357:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2403:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2404:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2405:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2328:def left_hand_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2329:    """Split line into many lines, starting with the first matching bracket pair.
2330:
2331:    Note: this usually looks weird, only use this for function definitions.
2332:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2333:    :func:`right_hand_split` which also handles optional parentheses.
2334:    """
2335:    tail_leaves: List[Leaf] = []
2336:    body_leaves: List[Leaf] = []
2337:    head_leaves: List[Leaf] = []
2338:    current_leaves = head_leaves
2339:    matching_bracket = None
2340:    for leaf in line.leaves:
2341:        if (
2342:            current_leaves is body_leaves
2343:            and leaf.type in CLOSING_BRACKETS
2344:            and leaf.opening_bracket is matching_bracket
2345:        ):
2346:            current_leaves = tail_leaves if body_leaves else head_leaves
2347:        current_leaves.append(leaf)
2348:        if current_leaves is head_leaves:
2349:            if leaf.type in OPENING_BRACKETS:
2350:                matching_bracket = leaf
2351:                current_leaves = body_leaves
2352:    if not matching_bracket:
2353:        raise CannotSplit("No brackets found")
2354:
2355:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2356:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2357:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2358:    bracket_split_succeeded_or_raise(head, body, tail)
2359:    for result in (head, body, tail):
2360:        if result:
2361:            yield result
2362:
2363:
2364:def right_hand_split(
2365:    line: Line,
2366:    line_length: int,
2367:    features: Collection[Feature] = (),
2368:    omit: Collection[LeafID] = (),
2369:) -> Iterator[Line]:
2370:    """Split line into many lines, starting with the last matching bracket pair.
2371:
2372:    If the split was by optional parentheses, attempt splitting without them, too.
2373:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2374:    this split.
2375:
2376:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2377:    """
2378:    tail_leaves: List[Leaf] = []
2379:    body_leaves: List[Leaf] = []
2380:    head_leaves: List[Leaf] = []
2381:    current_leaves = tail_leaves
2382:    opening_bracket = None
2383:    closing_bracket = None
2384:    for leaf in reversed(line.leaves):
2385:        if current_leaves is body_leaves:
2386:            if leaf is opening_bracket:
2387:                current_leaves = head_leaves if body_leaves else tail_leaves
2388:        current_leaves.append(leaf)
2389:        if current_leaves is tail_leaves:
2390:            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:
2391:                opening_bracket = leaf.opening_bracket
2392:                closing_bracket = leaf
2393:                current_leaves = body_leaves
2394:    if not (opening_bracket and closing_bracket and head_leaves):
2395:        # If there is no opening or closing_bracket that means the split failed and
2396:        # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means
2397:        # the matching `opening_bracket` wasn't available on `line` anymore.
2398:        raise CannotSplit("No brackets found")
2399:
2400:    tail_leaves.reverse()
2401:    body_leaves.reverse()
2402:    head_leaves.reverse()
2403:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
2404:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
2405:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
2406:    bracket_split_succeeded_or_raise(head, body, tail)
2407:    if (
2408:        # the body shouldn't be exploded
2409:        not body.should_explode
2410:        # the opening bracket is an optional paren
2411:        and opening_bracket.type == token.LPAR
2412:        and not opening_bracket.value
2413:        # the closing bracket is an optional paren
2414:        and closing_bracket.type == token.RPAR
2415:        and not closing_bracket.value
2416:        # it's not an import (optional parens are the only thing we can split on
2417:        # in this case; attempting a split without them is a waste of time)
2418:        and not line.is_import
2419:        # there are no standalone comments in the body
2420:        and not body.contains_standalone_comments(0)
2421:        # and we can actually remove the parens
2422:        and can_omit_invisible_parens(body, line_length)
2423:    ):
2424:        omit = {id(closing_bracket), *omit}
2425:        try:
2426:            yield from right_hand_split(line, line_length, features=features, omit=omit)
2427:            return

Calling tool: grepTool
def bracket_split_succeeded_or_raise\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2453:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2446:    ensure_visible(opening_bracket)
2447:    ensure_visible(closing_bracket)
2448:    for result in (head, body, tail):
2449:        if result:
2450:            yield result
2451:
2452:
2453:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
2454:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
2455:
2456:    Do nothing otherwise.
2457:
2458:    A left- or right-hand split is based on a pair of brackets. Content before
2459:    (and including) the opening bracket is left on one line, content inside the
2460:    brackets is put on a separate line, and finally content starting with and
2461:    following the closing bracket is put on a separate line.
2462:
2463:    Those are called `head`, `body`, and `tail`, respectively. If the split
2464:    produced the same line (all content in `head`) or ended up with an empty `body`
2465:    and the `tail` is just the closing bracket, then it's considered failed.
2466:    """
2467:    tail_len = len(str(tail).strip())
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In bracket_split_build_line, the trailing comma logic is guarded by `if leaves:` and `no_commas = original.is_def and not any(l.type == token.COMMA for l in leaves)`. For empty parameter lists, `leaves` is empty, so the code inside the guard doesn’t run and no comma is added. I verified the exact implementation lines (2491–2508).


Todo item 6 of 11 is correct
description: 'Ensure the trailing comma addition logic does not add commas to empty parameter lists (e.g., def f():) because of the surrounding if leaves: guard and the no_commas definition.'
Validating todo item 7 of 11
description: 'Verify that multiple-argument function definition lines will not match no_commas (since a COMMA token should be present among leaves), preventing accidental extra commas.'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:

Calling tool: grepTool
bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2355:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2356:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2357:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2403:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2404:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2405:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2328:def left_hand_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2329:    """Split line into many lines, starting with the first matching bracket pair.
2330:
2331:    Note: this usually looks weird, only use this for function definitions.
2332:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2333:    :func:`right_hand_split` which also handles optional parentheses.
2334:    """
2335:    tail_leaves: List[Leaf] = []
2336:    body_leaves: List[Leaf] = []
2337:    head_leaves: List[Leaf] = []
2338:    current_leaves = head_leaves
2339:    matching_bracket = None
2340:    for leaf in line.leaves:
2341:        if (
2342:            current_leaves is body_leaves
2343:            and leaf.type in CLOSING_BRACKETS
2344:            and leaf.opening_bracket is matching_bracket
2345:        ):
2346:            current_leaves = tail_leaves if body_leaves else head_leaves
2347:        current_leaves.append(leaf)
2348:        if current_leaves is head_leaves:
2349:            if leaf.type in OPENING_BRACKETS:
2350:                matching_bracket = leaf
2351:                current_leaves = body_leaves
2352:    if not matching_bracket:
2353:        raise CannotSplit("No brackets found")
2354:
2355:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2356:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2357:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2358:    bracket_split_succeeded_or_raise(head, body, tail)
2359:    for result in (head, body, tail):
2360:        if result:
2361:            yield result
2362:
2363:
2364:def right_hand_split(
2365:    line: Line,
2366:    line_length: int,
2367:    features: Collection[Feature] = (),
2368:    omit: Collection[LeafID] = (),
2369:) -> Iterator[Line]:
2370:    """Split line into many lines, starting with the last matching bracket pair.
2371:
2372:    If the split was by optional parentheses, attempt splitting without them, too.
2373:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2374:    this split.
2375:
2376:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2377:    """
2378:    tail_leaves: List[Leaf] = []
2379:    body_leaves: List[Leaf] = []
2380:    head_leaves: List[Leaf] = []
2381:    current_leaves = tail_leaves
2382:    opening_bracket = None
2383:    closing_bracket = None
2384:    for leaf in reversed(line.leaves):
2385:        if current_leaves is body_leaves:
2386:            if leaf is opening_bracket:
2387:                current_leaves = head_leaves if body_leaves else tail_leaves
2388:        current_leaves.append(leaf)
2389:        if current_leaves is tail_leaves:
2390:            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:
2391:                opening_bracket = leaf.opening_bracket
2392:                closing_bracket = leaf
2393:                current_leaves = body_leaves
2394:    if not (opening_bracket and closing_bracket and head_leaves):
2395:        # If there is no opening or closing_bracket that means the split failed and
2396:        # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means
2397:        # the matching `opening_bracket` wasn't available on `line` anymore.
2398:        raise CannotSplit("No brackets found")
2399:
2400:    tail_leaves.reverse()
2401:    body_leaves.reverse()
2402:    head_leaves.reverse()
2403:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
2404:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
2405:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
2406:    bracket_split_succeeded_or_raise(head, body, tail)
2407:    if (
2408:        # the body shouldn't be exploded
2409:        not body.should_explode
2410:        # the opening bracket is an optional paren
2411:        and opening_bracket.type == token.LPAR
2412:        and not opening_bracket.value
2413:        # the closing bracket is an optional paren
2414:        and closing_bracket.type == token.RPAR
2415:        and not closing_bracket.value
2416:        # it's not an import (optional parens are the only thing we can split on
2417:        # in this case; attempting a split without them is a waste of time)
2418:        and not line.is_import
2419:        # there are no standalone comments in the body
2420:        and not body.contains_standalone_comments(0)
2421:        # and we can actually remove the parens
2422:        and can_omit_invisible_parens(body, line_length)
2423:    ):
2424:        omit = {id(closing_bracket), *omit}
2425:        try:
2426:            yield from right_hand_split(line, line_length, features=features, omit=omit)
2427:            return

Calling tool: grepTool
test_function_trailing_comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_function_trailing_comma
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py:268:    def test_function_trailing_comma(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py
240:        self.assertEqual(expected, actual)
241:
242:    @patch("black.dump_to_file", dump_to_stderr)
243:    def test_setup(self) -> None:
244:        source, expected = read_data("../setup", data=False)
245:        actual = fs(source)
246:        self.assertFormatEqual(expected, actual)
247:        black.assert_equivalent(source, actual)
248:        black.assert_stable(source, actual, black.FileMode())
249:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
250:
251:    @patch("black.dump_to_file", dump_to_stderr)
252:    def test_function(self) -> None:
253:        source, expected = read_data("function")
254:        actual = fs(source)
255:        self.assertFormatEqual(expected, actual)
256:        black.assert_equivalent(source, actual)
257:        black.assert_stable(source, actual, black.FileMode())
258:
259:    @patch("black.dump_to_file", dump_to_stderr)
260:    def test_function2(self) -> None:
261:        source, expected = read_data("function2")
262:        actual = fs(source)
263:        self.assertFormatEqual(expected, actual)
264:        black.assert_equivalent(source, actual)
265:        black.assert_stable(source, actual, black.FileMode())
266:
267:    @patch("black.dump_to_file", dump_to_stderr)
268:    def test_function_trailing_comma(self) -> None:
269:        source, expected = read_data("function_trailing_comma")
270:        actual = fs(source)
271:        self.assertFormatEqual(expected, actual)
272:        black.assert_equivalent(source, actual)
273:        black.assert_stable(source, actual, black.FileMode())
274:
275:    @patch("black.dump_to_file", dump_to_stderr)
276:    def test_expression(self) -> None:
277:        source, expected = read_data("expression")
278:        actual = fs(source)
279:        self.assertFormatEqual(expected, actual)
280:        black.assert_equivalent(source, actual)
281:        black.assert_stable(source, actual, black.FileMode())
282:
283:    def test_expression_ff(self) -> None:
284:        source, expected = read_data("expression")
285:        tmp_file = Path(black.dump_to_file(source))
286:        try:
287:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
288:            with open(tmp_file, encoding="utf8") as f:
289:                actual = f.read()
290:        finally:
291:            os.unlink(tmp_file)
292:        self.assertFormatEqual(expected, actual)
293:        with patch("black.dump_to_file", dump_to_stderr):
294:            black.assert_equivalent(source, actual)
295:            black.assert_stable(source, actual, black.FileMode())
296:
297:    def test_expression_diff(self) -> None:
298:        source, _ = read_data("expression.py")
299:        expected, _ = read_data("expression.diff")
300:        tmp_file = Path(black.dump_to_file(source))
301:        diff_header = re.compile(
302:            rf"{re.escape(str(tmp_file))}\t\d\d\d\d-\d\d-\d\d "
303:            rf"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
304:        )
305:        try:
306:            result = BlackRunner().invoke(black.main, ["--diff", str(tmp_file)])
307:            self.assertEqual(result.exit_code, 0)
308:        finally:
309:            os.unlink(tmp_file)

Calling tool: globTool
**/*function_trailing_comma*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py
1:def f(a,):
2:    ...
3:
4:def f(a:int=1,):
5:    ...
6:
7:# output
8:
9:def f(a):
10:    ...
11:
12:
13:def f(a: int = 1):
14:    ...

Calling tool: grepTool
maybe_remove_trailing_comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1176:            self.maybe_remove_trailing_comma(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1290:                ignored_ids.add(id(last_leaf))
1291:        except IndexError:
1292:            return False
1293:
1294:        for leaf_id, comments in self.comments.items():
1295:            if leaf_id in ignored_ids:
1296:                continue
1297:
1298:            for comment in comments:
1299:                if is_type_comment(comment):
1300:                    return True
1301:
1302:        return False
1303:
1304:    def contains_multiline_strings(self) -> bool:
1305:        for leaf in self.leaves:
1306:            if is_multiline_string(leaf):
1307:                return True
1308:
1309:        return False
1310:
1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1312:        """Remove trailing comma if there is one and it's safe."""
1313:        if not (
1314:            self.leaves
1315:            and self.leaves[-1].type == token.COMMA
1316:            and closing.type in CLOSING_BRACKETS
1317:        ):
1318:            return False
1319:
1320:        if closing.type == token.RBRACE:
1321:            self.remove_trailing_comma()
1322:            return True
1323:
1324:        if closing.type == token.RSQB:
1325:            comma = self.leaves[-1]
1326:            if comma.parent and comma.parent.type == syms.listmaker:
1327:                self.remove_trailing_comma()
1328:                return True
1329:
1330:        # For parens let's check if it's safe to remove the comma.
1331:        # Imports are always safe.
1332:        if self.is_import:
1333:            self.remove_trailing_comma()
1334:            return True
1335:
1336:        # Otherwise, if the trailing one is the only one, we might mistakenly
1337:        # change a tuple into a different type by removing the comma.
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:
1378:            return False
1379:
1380:        if not self.leaves:
1381:            comment.type = STANDALONE_COMMENT
1382:            comment.prefix = ""
1383:            return False
1384:
1385:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1386:        return True
1387:
1388:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1389:        """Generate comments that should appear directly after `leaf`."""

Calling tool: grepTool
is_def\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1229:    def is_def(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1517:            self.previous_line.is_class or self.previous_line.is_def
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1537:            elif current_line.is_def and not self.previous_line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2282:    if line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2496:            no_commas = original.is_def and not any(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1208:    def is_import(self) -> bool:
1209:        """Is this an import line?"""
1210:        return bool(self) and is_import(self.leaves[0])
1211:
1212:    @property
1213:    def is_class(self) -> bool:
1214:        """Is this line a class definition?"""
1215:        return (
1216:            bool(self)
1217:            and self.leaves[0].type == token.NAME
1218:            and self.leaves[0].value == "class"
1219:        )
1220:
1221:    @property
1222:    def is_stub_class(self) -> bool:
1223:        """Is this line a class definition with a body consisting only of "..."?"""
1224:        return self.is_class and self.leaves[-3:] == [
1225:            Leaf(token.DOT, ".") for _ in range(3)
1226:        ]
1227:
1228:    @property
1229:    def is_def(self) -> bool:
1230:        """Is this a function definition? (Also returns True for async defs.)"""
1231:        try:
1232:            first_leaf = self.leaves[0]
1233:        except IndexError:
1234:            return False
1235:
1236:        try:
1237:            second_leaf: Optional[Leaf] = self.leaves[1]
1238:        except IndexError:
1239:            second_leaf = None
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC
1242:            and second_leaf is not None
1243:            and second_leaf.type == token.NAME
1244:            and second_leaf.value == "def"
1245:        )
1246:
1247:    @property

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In bracket_split_build_line, no_commas is set to original.is_def and not any(l.type == token.COMMA for l in leaves). For multi-argument function definitions, the body leaves include at least one COMMA token (argument separators), so no_commas is False and the insertion block is skipped, preventing extra commas.


Todo item 7 of 11 is correct
description: 'Verify that multiple-argument function definition lines will not match no_commas (since a COMMA token should be present among leaves), preventing accidental extra commas.'
Validating todo item 8 of 11
description: 'Confirm that comments in this context that should be skipped are represented by STANDALONE_COMMENT; check that no other comment token types need to be handled here to satisfy the PR note "be careful not to add one after any comments."'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:
2548:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2549:    except ValueError:
2550:        raise CannotSplit("No delimiters found")
2551:

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:909:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:910:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1190:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1200:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1275:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1371:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1381:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1722:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1757:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2172:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2190:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2222:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2502:                    if leaves[i].type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2598:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2654:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2894:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2924:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:3224:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
880:            if node.prefix:
881:                # We don't have to handle prefixes for `Node` objects since
882:                # that delegates to the first child anyway.
883:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
884:            out(f" {node.value!r}", fg="blue", bold=False)
885:
886:    @classmethod
887:    def show(cls, code: Union[str, Leaf, Node]) -> None:
888:        """Pretty-print the lib2to3 AST of a given string of `code`.
889:
890:        Convenience method for debugging.
891:        """
892:        v: DebugVisitor[None] = DebugVisitor()
893:        if isinstance(code, str):
894:            code = lib2to3_parse(code)
895:        list(v.visit(code))
896:
897:
898:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
899:STATEMENT = {
900:    syms.if_stmt,
901:    syms.while_stmt,
902:    syms.for_stmt,
903:    syms.try_stmt,
904:    syms.except_clause,
905:    syms.with_stmt,
906:    syms.funcdef,
907:    syms.classdef,
908:}
909:STANDALONE_COMMENT = 153
910:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
911:LOGIC_OPERATORS = {"and", "or"}
912:COMPARATORS = {
913:    token.LESS,
914:    token.GREATER,
915:    token.EQEQUAL,
916:    token.NOTEQUAL,
917:    token.LESSEQUAL,
918:    token.GREATEREQUAL,
919:}
920:MATH_OPERATORS = {
921:    token.VBAR,
922:    token.CIRCUMFLEX,
923:    token.AMPER,
924:    token.LEFTSHIFT,
925:    token.RIGHTSHIFT,
926:    token.PLUS,
927:    token.MINUS,
928:    token.STAR,
929:    token.SLASH,
930:    token.DOUBLESLASH,
931:    token.PERCENT,
932:    token.AT,
933:    token.TILDE,
934:    token.DOUBLESTAR,
935:}
936:STARS = {token.STAR, token.DOUBLESTAR}
937:VARARGS_PARENTS = {
938:    syms.arglist,
939:    syms.argument,  # double star in arglist
940:    syms.trailer,  # single argument to call
941:    syms.typedargslist,
942:    syms.varargslist,  # lambdas
943:}
944:UNPACKING_PARENTS = {
945:    syms.atom,  # single element of a list or set literal
946:    syms.dictsetmaker,
947:    syms.listmaker,
948:    syms.testlist_gexp,
949:    syms.testlist_star_expr,
950:}
951:TEST_DESCENDANTS = {
952:    syms.test,
953:    syms.lambdef,
954:    syms.or_test,
955:    syms.and_test,
956:    syms.not_test,
957:    syms.comparison,
958:    syms.star_expr,
959:    syms.expr,
960:    syms.xor_expr,
961:    syms.and_expr,
962:    syms.shift_expr,
963:    syms.arith_expr,
964:    syms.trailer,
965:    syms.term,
966:    syms.power,
967:}
968:ASSIGNMENTS = {
969:    "=",
970:    "+=",
971:    "-=",
972:    "*=",
973:    "@=",
974:    "/=",
975:    "%=",
976:    "&=",
977:    "|=",
978:    "^=",
979:    "<<=",
980:    ">>=",
981:    "**=",
982:    "//=",
983:}
984:COMPREHENSION_PRIORITY = 20
985:COMMA_PRIORITY = 18
986:TERNARY_PRIORITY = 16
987:LOGIC_PRIORITY = 14
988:STRING_PRIORITY = 12
989:COMPARATOR_PRIORITY = 10
990:MATH_PRIORITIES = {
991:    token.VBAR: 9,
992:    token.CIRCUMFLEX: 8,
993:    token.AMPER: 7,
994:    token.LEFTSHIFT: 6,
995:    token.RIGHTSHIFT: 6,
996:    token.PLUS: 5,
997:    token.MINUS: 5,
998:    token.STAR: 4,
999:    token.SLASH: 4,
1000:    token.DOUBLESLASH: 4,
1001:    token.PERCENT: 4,
1002:    token.AT: 4,
1003:    token.TILDE: 3,
1004:    token.DOUBLESTAR: 2,
1005:}
1006:DOT_PRIORITY = 1
1007:
1008:
1009:@dataclass
1010:class BracketTracker:
1011:    """Keeps track of brackets on a line."""
1012:
1013:    depth: int = 0
1014:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
1015:    delimiters: Dict[LeafID, Priority] = Factory(dict)
1016:    previous: Optional[Leaf] = None
1017:    _for_loop_depths: List[int] = Factory(list)
1018:    _lambda_argument_depths: List[int] = Factory(list)
1019:
1020:    def mark(self, leaf: Leaf) -> None:
1021:        """Mark `leaf` with bracket-related metadata. Keep track of delimiters.
1022:
1023:        All leaves receive an int `bracket_depth` field that stores how deep
1024:        within brackets a given leaf is. 0 means there are no enclosing brackets
1025:        that started on this line.
1026:
1027:        If a leaf is itself a closing bracket, it receives an `opening_bracket`
1028:        field that it forms a pair with. This is a one-directional link to
1029:        avoid reference cycles.
1030:
1031:        If a leaf is a delimiter (a token on which Black can split the line if
1032:        needed) and it's on depth 0, its `id()` is stored in the tracker's
1033:        `delimiters` field.
1034:        """
1035:        if leaf.type == token.COMMENT:
1036:            return
1037:
1038:        self.maybe_decrement_after_for_loop_variable(leaf)
1039:        self.maybe_decrement_after_lambda_arguments(leaf)
1040:        if leaf.type in CLOSING_BRACKETS:
1041:            self.depth -= 1
1042:            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))
1043:            leaf.opening_bracket = opening_bracket
1044:        leaf.bracket_depth = self.depth
1045:        if self.depth == 0:
1046:            delim = is_split_before_delimiter(leaf, self.previous)
1047:            if delim and self.previous is not None:
1048:                self.delimiters[id(self.previous)] = delim
1049:            else:
1050:                delim = is_split_after_delimiter(leaf, self.previous)
1051:                if delim:
1052:                    self.delimiters[id(leaf)] = delim
1053:        if leaf.type in OPENING_BRACKETS:
1054:            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf
1055:            self.depth += 1
1056:        self.previous = leaf
1057:        self.maybe_increment_lambda_arguments(leaf)
1058:        self.maybe_increment_for_loop_variable(leaf)
1059:
1060:    def any_open_brackets(self) -> bool:
1061:        """Return True if there is an yet unmatched open bracket on the line."""
1062:        return bool(self.bracket_match)
1063:
1064:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> Priority:
1065:        """Return the highest priority of a delimiter found on the line.
1066:
1067:        Values are consistent with what `is_split_*_delimiter()` return.
1068:        Raises ValueError on no delimiters.
1069:        """
1070:        return max(v for k, v in self.delimiters.items() if k not in exclude)
1071:
1072:    def delimiter_count_with_priority(self, priority: Priority = 0) -> int:
1073:        """Return the number of delimiters with the given `priority`.
1074:
1075:        If no `priority` is passed, defaults to max priority on the line.
1076:        """
1077:        if not self.delimiters:
1078:            return 0
1079:
1080:        priority = priority or self.max_delimiter_priority()
1081:        return sum(1 for p in self.delimiters.values() if p == priority)
1082:
1083:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
1084:        """In a for loop, or comprehension, the variables are often unpacks.
1085:
1086:        To avoid splitting on the comma in this situation, increase the depth of
1087:        tokens between `for` and `in`.
1088:        """
1089:        if leaf.type == token.NAME and leaf.value == "for":
1090:            self.depth += 1
1091:            self._for_loop_depths.append(self.depth)
1092:            return True
1093:
1094:        return False
1095:
1096:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
1097:        """See `maybe_increment_for_loop_variable` above for explanation."""
1098:        if (
1099:            self._for_loop_depths
1100:            and self._for_loop_depths[-1] == self.depth
1101:            and leaf.type == token.NAME
1102:            and leaf.value == "in"
1103:        ):
1104:            self.depth -= 1
1105:            self._for_loop_depths.pop()
1106:            return True
1107:
1108:        return False
1109:
1110:    def maybe_increment_lambda_arguments(self, leaf: Leaf) -> bool:
1111:        """In a lambda expression, there might be more than one argument.
1112:
1113:        To avoid splitting on the comma in this situation, increase the depth of
1114:        tokens between `lambda` and `:`.
1115:        """
1116:        if leaf.type == token.NAME and leaf.value == "lambda":
1117:            self.depth += 1
1118:            self._lambda_argument_depths.append(self.depth)
1119:            return True
1120:
1121:        return False
1122:
1123:    def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:
1124:        """See `maybe_increment_lambda_arguments` above for explanation."""
1125:        if (
1126:            self._lambda_argument_depths
1127:            and self._lambda_argument_depths[-1] == self.depth
1128:            and leaf.type == token.COLON
1129:        ):
1130:            self.depth -= 1
1131:            self._lambda_argument_depths.pop()
1132:            return True
1133:
1134:        return False
1135:
1136:    def get_open_lsqb(self) -> Optional[Leaf]:
1137:        """Return the most recent opening square bracket (if any)."""
1138:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1139:
1140:
1141:@dataclass
1142:class Line:
1143:    """Holds leaves and comments. Can be printed with `str(line)`."""
1144:
1145:    depth: int = 0
1146:    leaves: List[Leaf] = Factory(list)
1147:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)  # keys ordered like `leaves`
1148:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1149:    inside_brackets: bool = False
1150:    should_explode: bool = False
1151:
1152:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1153:        """Add a new `leaf` to the end of the line.
1154:
1155:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1156:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1157:        Trailing commas are maybe removed, unpacked for loop variables are
1158:        demoted from being delimiters.
1159:
1160:        Inline comments are put aside.
1161:        """
1162:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1163:        if not has_value:
1164:            return
1165:
1166:        if token.COLON == leaf.type and self.is_class_paren_empty:
1167:            del self.leaves[-2:]
1168:        if self.leaves and not preformatted:
1169:            # Note: at this point leaf.prefix should be empty except for
1170:            # imports, for which we only preserve newlines.
1171:            leaf.prefix += whitespace(
1172:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1173:            )
1174:        if self.inside_brackets or not preformatted:
1175:            self.bracket_tracker.mark(leaf)
1176:            self.maybe_remove_trailing_comma(leaf)
1177:        if not self.append_comment(leaf):
1178:            self.leaves.append(leaf)
1179:
1180:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1181:        """Like :func:`append()` but disallow invalid standalone comment structure.
1182:
1183:        Raises ValueError when any `leaf` is appended after a standalone comment
1184:        or when a standalone comment is not the first leaf on the line.
1185:        """
1186:        if self.bracket_tracker.depth == 0:
1187:            if self.is_comment:
1188:                raise ValueError("cannot append to standalone comments")
1189:
1190:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1191:                raise ValueError(
1192:                    "cannot append standalone comments to a populated line"
1193:                )
1194:
1195:        self.append(leaf, preformatted=preformatted)
1196:
1197:    @property
1198:    def is_comment(self) -> bool:
1199:        """Is this line a standalone comment?"""
1200:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1201:
1202:    @property
1203:    def is_decorator(self) -> bool:
1204:        """Is this line a decorator?"""
1205:        return bool(self) and self.leaves[0].type == token.AT
1206:
1207:    @property
1208:    def is_import(self) -> bool:
1209:        """Is this an import line?"""
1210:        return bool(self) and is_import(self.leaves[0])
1211:
1212:    @property
1213:    def is_class(self) -> bool:
1214:        """Is this line a class definition?"""
1215:        return (
1216:            bool(self)
1217:            and self.leaves[0].type == token.NAME
1218:            and self.leaves[0].value == "class"
1219:        )

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1220:
1221:    @property
1222:    def is_stub_class(self) -> bool:
1223:        """Is this line a class definition with a body consisting only of "..."?"""
1224:        return self.is_class and self.leaves[-3:] == [
1225:            Leaf(token.DOT, ".") for _ in range(3)
1226:        ]
1227:
1228:    @property
1229:    def is_def(self) -> bool:
1230:        """Is this a function definition? (Also returns True for async defs.)"""
1231:        try:
1232:            first_leaf = self.leaves[0]
1233:        except IndexError:
1234:            return False
1235:
1236:        try:
1237:            second_leaf: Optional[Leaf] = self.leaves[1]
1238:        except IndexError:
1239:            second_leaf = None
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC
1242:            and second_leaf is not None
1243:            and second_leaf.type == token.NAME
1244:            and second_leaf.value == "def"
1245:        )
1246:
1247:    @property
1248:    def is_class_paren_empty(self) -> bool:
1249:        """Is this a class with no base classes but using parentheses?
1250:
1251:        Those are unnecessary and should be removed.
1252:        """
1253:        return (
1254:            bool(self)
1255:            and len(self.leaves) == 4
1256:            and self.is_class
1257:            and self.leaves[2].type == token.LPAR
1258:            and self.leaves[2].value == "("
1259:            and self.leaves[3].type == token.RPAR
1260:            and self.leaves[3].value == ")"
1261:        )
1262:
1263:    @property
1264:    def is_triple_quoted_string(self) -> bool:
1265:        """Is the line a triple quoted string?"""
1266:        return (
1267:            bool(self)
1268:            and self.leaves[0].type == token.STRING
1269:            and self.leaves[0].value.startswith(('"""', "'''"))
1270:        )
1271:
1272:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1273:        """If so, needs to be split before emitting."""
1274:        for leaf in self.leaves:
1275:            if leaf.type == STANDALONE_COMMENT:
1276:                if leaf.bracket_depth <= depth_limit:
1277:                    return True
1278:        return False
1279:
1280:    def contains_inner_type_comments(self) -> bool:
1281:        ignored_ids = set()
1282:        try:
1283:            last_leaf = self.leaves[-1]
1284:            ignored_ids.add(id(last_leaf))
1285:            if last_leaf.type == token.COMMA:
1286:                # When trailing commas are inserted by Black for consistency, comments
1287:                # after the previous last element are not moved (they don't have to,
1288:                # rendering will still be correct).  So we ignore trailing commas.
1289:                last_leaf = self.leaves[-2]
1290:                ignored_ids.add(id(last_leaf))
1291:        except IndexError:
1292:            return False
1293:
1294:        for leaf_id, comments in self.comments.items():
1295:            if leaf_id in ignored_ids:
1296:                continue
1297:
1298:            for comment in comments:
1299:                if is_type_comment(comment):
1300:                    return True
1301:
1302:        return False
1303:
1304:    def contains_multiline_strings(self) -> bool:
1305:        for leaf in self.leaves:
1306:            if is_multiline_string(leaf):
1307:                return True
1308:
1309:        return False
1310:
1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1312:        """Remove trailing comma if there is one and it's safe."""
1313:        if not (
1314:            self.leaves
1315:            and self.leaves[-1].type == token.COMMA
1316:            and closing.type in CLOSING_BRACKETS
1317:        ):
1318:            return False
1319:
1320:        if closing.type == token.RBRACE:
1321:            self.remove_trailing_comma()
1322:            return True
1323:
1324:        if closing.type == token.RSQB:
1325:            comma = self.leaves[-1]
1326:            if comma.parent and comma.parent.type == syms.listmaker:
1327:                self.remove_trailing_comma()
1328:                return True
1329:
1330:        # For parens let's check if it's safe to remove the comma.
1331:        # Imports are always safe.
1332:        if self.is_import:
1333:            self.remove_trailing_comma()
1334:            return True
1335:
1336:        # Otherwise, if the trailing one is the only one, we might mistakenly
1337:        # change a tuple into a different type by removing the comma.
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:
1378:            return False
1379:
1380:        if not self.leaves:
1381:            comment.type = STANDALONE_COMMENT
1382:            comment.prefix = ""
1383:            return False
1384:
1385:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1386:        return True
1387:
1388:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1389:        """Generate comments that should appear directly after `leaf`."""
1390:        return self.comments.get(id(leaf), [])
1391:
1392:    def remove_trailing_comma(self) -> None:
1393:        """Remove the trailing comma and moves the comments attached to it."""
1394:        trailing_comma = self.leaves.pop()
1395:        trailing_comma_comments = self.comments.pop(id(trailing_comma), [])
1396:        self.comments.setdefault(id(self.leaves[-1]), []).extend(
1397:            trailing_comma_comments
1398:        )
1399:
1400:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1401:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1402:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1403:        if open_lsqb is None:
1404:            return False
1405:
1406:        subscript_start = open_lsqb.next_sibling
1407:
1408:        if isinstance(subscript_start, Node):
1409:            if subscript_start.type == syms.listmaker:
1410:                return False
1411:
1412:            if subscript_start.type == syms.subscriptlist:
1413:                subscript_start = child_towards(subscript_start, leaf)
1414:        return subscript_start is not None and any(
1415:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
1416:        )
1417:
1418:    def __str__(self) -> str:
1419:        """Render the line."""
1420:        if not self:
1421:            return "\n"
1422:
1423:        indent = "    " * self.depth
1424:        leaves = iter(self.leaves)
1425:        first = next(leaves)
1426:        res = f"{first.prefix}{indent}{first.value}"
1427:        for leaf in leaves:
1428:            res += str(leaf)
1429:        for comment in itertools.chain.from_iterable(self.comments.values()):
1430:            res += str(comment)
1431:        return res + "\n"
1432:
1433:    def __bool__(self) -> bool:
1434:        """Return True if the line has leaves or comments."""
1435:        return bool(self.leaves or self.comments)
1436:
1437:
1438:@dataclass
1439:class EmptyLineTracker:
1440:    """Provides a stateful method that returns the number of potential extra
1441:    empty lines needed before and after the currently processed line.
1442:
1443:    Note: this tracker works on lines that haven't been split yet.  It assumes
1444:    the prefix of the first leaf consists of optional newlines.  Those newlines
1445:    are consumed by `maybe_empty_lines()` and included in the computation.
1446:    """
1447:
1448:    is_pyi: bool = False
1449:    previous_line: Optional[Line] = None
1450:    previous_after: int = 0
1451:    previous_defs: List[int] = Factory(list)
1452:
1453:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1454:        """Return the number of extra empty lines before and after the `current_line`.
1455:
1456:        This is for separating `def`, `async def` and `class` with extra empty
1457:        lines (two on module-level).
1458:        """
1459:        before, after = self._maybe_empty_lines(current_line)
1460:        before -= self.previous_after
1461:        self.previous_after = after
1462:        self.previous_line = current_line
1463:        return before, after
1464:
1465:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1466:        max_allowed = 1
1467:        if current_line.depth == 0:
1468:            max_allowed = 1 if self.is_pyi else 2
1469:        if current_line.leaves:
1470:            # Consume the first leaf's extra newlines.
1471:            first_leaf = current_line.leaves[0]
1472:            before = first_leaf.prefix.count("\n")
1473:            before = min(before, max_allowed)
1474:            first_leaf.prefix = ""
1475:        else:
1476:            before = 0
1477:        depth = current_line.depth
1478:        while self.previous_defs and self.previous_defs[-1] >= depth:
1479:            self.previous_defs.pop()
1480:            if self.is_pyi:
1481:                before = 0 if depth else 1
1482:            else:
1483:                before = 1 if depth else 2
1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
1485:            return self._maybe_empty_lines_for_class_or_def(current_line, before)
1486:
1487:        if (
1488:            self.previous_line
1489:            and self.previous_line.is_import
1490:            and not current_line.is_import
1491:            and depth == self.previous_line.depth
1492:        ):
1493:            return (before or 1), 0
1494:
1495:        if (
1496:            self.previous_line
1497:            and self.previous_line.is_class
1498:            and current_line.is_triple_quoted_string
1499:        ):
1500:            return before, 1
1501:
1502:        return before, 0
1503:
1504:    def _maybe_empty_lines_for_class_or_def(
1505:        self, current_line: Line, before: int
1506:    ) -> Tuple[int, int]:
1507:        if not current_line.is_decorator:
1508:            self.previous_defs.append(current_line.depth)
1509:        if self.previous_line is None:
1510:            # Don't insert empty lines before the first line in the file.
1511:            return 0, 0
1512:
1513:        if self.previous_line.is_decorator:
1514:            return 0, 0
1515:
1516:        if self.previous_line.depth < current_line.depth and (
1517:            self.previous_line.is_class or self.previous_line.is_def
1518:        ):
1519:            return 0, 0
1520:
1521:        if (
1522:            self.previous_line.is_comment
1523:            and self.previous_line.depth == current_line.depth
1524:            and before == 0
1525:        ):
1526:            return 0, 0
1527:
1528:        if self.is_pyi:
1529:            if self.previous_line.depth > current_line.depth:
1530:                newlines = 1
1531:            elif current_line.is_class or self.previous_line.is_class:
1532:                if current_line.is_stub_class and self.previous_line.is_stub_class:
1533:                    # No blank line between classes with an empty body
1534:                    newlines = 0
1535:                else:
1536:                    newlines = 1
1537:            elif current_line.is_def and not self.previous_line.is_def:
1538:                # Blank line between a block of functions and a block of non-functions
1539:                newlines = 1
1540:            else:
1541:                newlines = 0
1542:        else:
1543:            newlines = 2
1544:        if current_line.depth and newlines:
1545:            newlines -= 1
1546:        return newlines, 0
1547:
1548:
1549:@dataclass
1550:class LineGenerator(Visitor[Line]):
1551:    """Generates reformatted Line objects.  Empty lines are not emitted.
1552:
1553:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
1554:    in ways that will no longer stringify to valid Python code on the tree.
1555:    """
1556:
1557:    is_pyi: bool = False
1558:    normalize_strings: bool = True
1559:    current_line: Line = Factory(Line)
1560:    remove_u_prefix: bool = False
1561:
1562:    def line(self, indent: int = 0) -> Iterator[Line]:
1563:        """Generate a line.
1564:
1565:        If the line is empty, only emit if it makes sense.
1566:        If the line is too long, split it first and then generate.
1567:
1568:        If any lines were generated, set up a new current_line.
1569:        """
1570:        if not self.current_line:
1571:            self.current_line.depth += indent
1572:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1573:
1574:        complete_line = self.current_line
1575:        self.current_line = Line(depth=complete_line.depth + indent)
1576:        yield complete_line
1577:
1578:    def visit_default(self, node: LN) -> Iterator[Line]:
1579:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1580:        if isinstance(node, Leaf):
1581:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1582:            for comment in generate_comments(node):
1583:                if any_open_brackets:
1584:                    # any comment within brackets is subject to splitting
1585:                    self.current_line.append(comment)
1586:                elif comment.type == token.COMMENT:
1587:                    # regular trailing comment
1588:                    self.current_line.append(comment)
1589:                    yield from self.line()
1590:
1591:                else:
1592:                    # regular standalone comment
1593:                    yield from self.line()
1594:
1595:                    self.current_line.append(comment)
1596:                    yield from self.line()
1597:
1598:            normalize_prefix(node, inside_brackets=any_open_brackets)
1599:            if self.normalize_strings and node.type == token.STRING:
1600:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1601:                normalize_string_quotes(node)
1602:            if node.type == token.NUMBER:
1603:                normalize_numeric_literal(node)
1604:            if node.type not in WHITESPACE:
1605:                self.current_line.append(node)
1606:        yield from super().visit_default(node)
1607:
1608:    def visit_atom(self, node: Node) -> Iterator[Line]:
1609:        # Always make parentheses invisible around a single node, because it should
1610:        # not be needed (except in the case of yield, where removing the parentheses
1611:        # produces a SyntaxError).
1612:        if (
1613:            len(node.children) == 3
1614:            and isinstance(node.children[0], Leaf)
1615:            and node.children[0].type == token.LPAR
1616:            and isinstance(node.children[2], Leaf)
1617:            and node.children[2].type == token.RPAR
1618:            and isinstance(node.children[1], Leaf)
1619:            and not (
1620:                node.children[1].type == token.NAME
1621:                and node.children[1].value == "yield"
1622:            )
1623:        ):
1624:            node.children[0].value = ""
1625:            node.children[2].value = ""
1626:        yield from super().visit_default(node)
1627:
1628:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1629:        """Increase indentation level, maybe yield a line."""
1630:        # In blib2to3 INDENT never holds comments.
1631:        yield from self.line(+1)
1632:        yield from self.visit_default(node)
1633:
1634:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1635:        """Decrease indentation level, maybe yield a line."""
1636:        # The current line might still wait for trailing comments.  At DEDENT time
1637:        # there won't be any (they would be prefixes on the preceding NEWLINE).
1638:        # Emit the line then.
1639:        yield from self.line()
1640:
1641:        # While DEDENT has no value, its prefix may contain standalone comments
1642:        # that belong to the current indentation level.  Get 'em.
1643:        yield from self.visit_default(node)
1644:
1645:        # Finally, emit the dedent.
1646:        yield from self.line(-1)
1647:
1648:    def visit_stmt(
1649:        self, node: Node, keywords: Set[str], parens: Set[str]
1650:    ) -> Iterator[Line]:
1651:        """Visit a statement.
1652:
1653:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1654:        `def`, `with`, `class`, `assert` and assignments.
1655:
1656:        The relevant Python language `keywords` for a given statement will be
1657:        NAME leaves within it. This methods puts those on a separate line.
1658:
1659:        `parens` holds a set of string leaf values immediately after which
1660:        invisible parens should be put.
1661:        """
1662:        normalize_invisible_parens(node, parens_after=parens)
1663:        for child in node.children:
1664:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1665:                yield from self.line()
1666:
1667:            yield from self.visit(child)
1668:
1669:    def visit_suite(self, node: Node) -> Iterator[Line]:
1670:        """Visit a suite."""
1671:        if self.is_pyi and is_stub_suite(node):
1672:            yield from self.visit(node.children[2])
1673:        else:
1674:            yield from self.visit_default(node)
1675:
1676:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1677:        """Visit a statement without nested statements."""
1678:        is_suite_like = node.parent and node.parent.type in STATEMENT
1679:        if is_suite_like:
1680:            if self.is_pyi and is_stub_body(node):
1681:                yield from self.visit_default(node)
1682:            else:
1683:                yield from self.line(+1)
1684:                yield from self.visit_default(node)
1685:                yield from self.line(-1)
1686:
1687:        else:
1688:            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):
1689:                yield from self.line()
1690:            yield from self.visit_default(node)
1691:
1692:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:
1693:        """Visit `async def`, `async for`, `async with`."""
1694:        yield from self.line()
1695:
1696:        children = iter(node.children)
1697:        for child in children:
1698:            yield from self.visit(child)
1699:
1700:            if child.type == token.ASYNC:
1701:                break
1702:
1703:        internal_stmt = next(children)
1704:        for child in internal_stmt.children:
1705:            yield from self.visit(child)
1706:
1707:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1708:        """Visit decorators."""
1709:        for child in node.children:
1710:            yield from self.line()
1711:            yield from self.visit(child)
1712:
1713:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1714:        """Remove a semicolon and put the other statement on a separate line."""
1715:        yield from self.line()
1716:
1717:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1718:        """End of file. Process outstanding comments and end with a newline."""
1719:        yield from self.visit_default(leaf)
1720:        yield from self.line()
1721:
1722:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1723:        if not self.current_line.bracket_tracker.any_open_brackets():
1724:            yield from self.line()
1725:        yield from self.visit_default(leaf)
1726:
1727:    def __attrs_post_init__(self) -> None:
1728:        """You are in a twisty little maze of passages."""
1729:        v = self.visit_stmt
1730:        Ø: Set[str] = set()
1731:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1732:        self.visit_if_stmt = partial(
1733:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1734:        )
1735:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1736:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1737:        self.visit_try_stmt = partial(
1738:            v, keywords={"try", "except", "else", "finally"}, parens=Ø
1739:        )

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2160:    move because it does away with modifying the grammar to include all the
2161:    possible places in which comments can be placed.
2162:
2163:    The sad consequence for us though is that comments don't "belong" anywhere.
2164:    This is why this function generates simple parentless Leaf objects for
2165:    comments.  We simply don't know what the correct parent should be.
2166:
2167:    No matter though, we can live without this.  We really only need to
2168:    differentiate between inline and standalone comments.  The latter don't
2169:    share the line with any code.
2170:
2171:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2172:    are emitted with a fake STANDALONE_COMMENT token identifier.
2173:    """
2174:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2175:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2176:
2177:
2178:@dataclass
2179:class ProtoComment:
2180:    """Describes a piece of syntax that is a comment.
2181:
2182:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2183:
2184:    * it can be cached (`Leaf` objects should not be reused more than once as
2185:      they store their lineno, column, prefix, and parent information);
2186:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2187:      simplifies handling of special marker comments like ``# fmt: off/on``.
2188:    """
2189:
2190:    type: int  # token.COMMENT or STANDALONE_COMMENT
2191:    value: str  # content of the comment
2192:    newlines: int  # how many newlines before the comment
2193:    consumed: int  # how many characters of the original leaf's prefix did we consume
2194:
2195:
2196:@lru_cache(maxsize=4096)
2197:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2198:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2199:    result: List[ProtoComment] = []
2200:    if not prefix or "#" not in prefix:
2201:        return result
2202:
2203:    consumed = 0
2204:    nlines = 0
2205:    ignored_lines = 0
2206:    for index, line in enumerate(prefix.split("\n")):
2207:        consumed += len(line) + 1  # adding the length of the split '\n'
2208:        line = line.lstrip()
2209:        if not line:
2210:            nlines += 1
2211:        if not line.startswith("#"):
2212:            # Escaped newlines outside of a comment are not really newlines at
2213:            # all. We treat a single-line comment following an escaped newline
2214:            # as a simple trailing comment.
2215:            if line.endswith("\\"):
2216:                ignored_lines += 1
2217:            continue
2218:
2219:        if index == ignored_lines and not is_endmarker:
2220:            comment_type = token.COMMENT  # simple trailing comment
2221:        else:
2222:            comment_type = STANDALONE_COMMENT
2223:        comment = make_comment(line)
2224:        result.append(
2225:            ProtoComment(
2226:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2227:            )
2228:        )
2229:        nlines = 0
2230:    return result
2231:
2232:
2233:def make_comment(content: str) -> str:
2234:    """Return a consistently formatted comment from the given `content` string.
2235:
2236:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2237:    space between the hash sign and the content.
2238:
2239:    If `content` didn't start with a hash sign, one is provided.
2240:    """
2241:    content = content.rstrip()
2242:    if not content:
2243:        return "#"
2244:
2245:    if content[0] == "#":
2246:        content = content[1:]
2247:    if content and content[0] not in " !:#'%":
2248:        content = " " + content
2249:    return "#" + content
2250:
2251:
2252:def split_line(
2253:    line: Line,
2254:    line_length: int,
2255:    inner: bool = False,
2256:    features: Collection[Feature] = (),
2257:) -> Iterator[Line]:
2258:    """Split a `line` into potentially many lines.
2259:

Calling tool: grepTool
be careful not to add one after any comments
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2495:            # be careful not to add one after any comments.

Calling tool: grepTool
test_function_trailing_comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_function_trailing_comma
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py:268:    def test_function_trailing_comma(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py
250:
251:    @patch("black.dump_to_file", dump_to_stderr)
252:    def test_function(self) -> None:
253:        source, expected = read_data("function")
254:        actual = fs(source)
255:        self.assertFormatEqual(expected, actual)
256:        black.assert_equivalent(source, actual)
257:        black.assert_stable(source, actual, black.FileMode())
258:
259:    @patch("black.dump_to_file", dump_to_stderr)
260:    def test_function2(self) -> None:
261:        source, expected = read_data("function2")
262:        actual = fs(source)
263:        self.assertFormatEqual(expected, actual)
264:        black.assert_equivalent(source, actual)
265:        black.assert_stable(source, actual, black.FileMode())
266:
267:    @patch("black.dump_to_file", dump_to_stderr)
268:    def test_function_trailing_comma(self) -> None:
269:        source, expected = read_data("function_trailing_comma")
270:        actual = fs(source)
271:        self.assertFormatEqual(expected, actual)
272:        black.assert_equivalent(source, actual)
273:        black.assert_stable(source, actual, black.FileMode())
274:
275:    @patch("black.dump_to_file", dump_to_stderr)
276:    def test_expression(self) -> None:
277:        source, expected = read_data("expression")
278:        actual = fs(source)
279:        self.assertFormatEqual(expected, actual)
280:        black.assert_equivalent(source, actual)
281:        black.assert_stable(source, actual, black.FileMode())
282:
283:    def test_expression_ff(self) -> None:
284:        source, expected = read_data("expression")
285:        tmp_file = Path(black.dump_to_file(source))
286:        try:
287:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
288:            with open(tmp_file, encoding="utf8") as f:
289:                actual = f.read()
290:        finally:
291:            os.unlink(tmp_file)
292:        self.assertFormatEqual(expected, actual)
293:        with patch("black.dump_to_file", dump_to_stderr):
294:            black.assert_equivalent(source, actual)
295:            black.assert_stable(source, actual, black.FileMode())
296:
297:    def test_expression_diff(self) -> None:
298:        source, _ = read_data("expression.py")
299:        expected, _ = read_data("expression.diff")
300:        tmp_file = Path(black.dump_to_file(source))
301:        diff_header = re.compile(
302:            rf"{re.escape(str(tmp_file))}\t\d\d\d\d-\d\d-\d\d "
303:            rf"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
304:        )
305:        try:
306:            result = BlackRunner().invoke(black.main, ["--diff", str(tmp_file)])
307:            self.assertEqual(result.exit_code, 0)
308:        finally:
309:            os.unlink(tmp_file)
310:        actual = result.output
311:        actual = diff_header.sub("[Deterministic header]", actual)
312:        actual = actual.rstrip() + "\n"  # the diff output has a trailing space
313:        if expected != actual:
314:            dump = black.dump_to_file(actual)
315:            msg = (
316:                f"Expected diff isn't equal to the actual. If you made changes "
317:                f"to expression.py and this is an anticipated difference, "
318:                f"overwrite tests/data/expression.diff with {dump}"
319:            )
320:            self.assertEqual(expected, actual, msg)
321:
322:    @patch("black.dump_to_file", dump_to_stderr)
323:    def test_fstring(self) -> None:
324:        source, expected = read_data("fstring")
325:        actual = fs(source)
326:        self.assertFormatEqual(expected, actual)
327:        black.assert_equivalent(source, actual)
328:        black.assert_stable(source, actual, black.FileMode())
329:

Calling tool: globTool
**/tests/data/function_trailing_comma*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py
1:def f(a,):
2:    ...
3:
4:def f(a:int=1,):
5:    ...
6:
7:# output
8:
9:def f(a):
10:    ...
11:
12:
13:def f(a: int = 1):
14:    ...

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: In bracket_split_build_line, the skip logic only checks STANDALONE_COMMENT, but inline comments are token.COMMENT and are attached via comments_after(). Since they’re not in leaves, the inserted comma will come after an inline comment (e.g., `a  # cmt,`). So comments other than STANDALONE_COMMENT need handling to satisfy “not to add one after any comments.”


Validating todo item 1 of 11
description: 'Verify that in black.py the modified leaf.parent.type condition now includes syms.typedargslist alongside syms.arglist in the comma counting logic, and that syms.typedargslist is defined/imported in scope.'

Calling tool: grepTool
typedargslist
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/{{FOLDER_PATH}}: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/{{FOLDER_PATH}}: No such file or directory (os error 2)


Calling tool: grepTool
typedargslist
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:941:    syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1357:                    syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1811:                elif prevp.parent.type == syms.typedargslist:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1856:    elif p.type == syms.typedargslist:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2579:            if is_vararg(leaf, within={syms.typedargslist}):
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:3172:            n.type in {syms.typedargslist, syms.arglist}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:3176:            if n.type == syms.typedargslist:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/blib2to3/pygram.pyi:95:    typedargslist: int
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function.py:47:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function.py:50:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function.py:183:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function.py:191:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/blib2to3/Grammar.txt:20:parameters: '(' [typedargslist] ')'
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/blib2to3/Grammar.txt:21:typedargslist: ((tfpdef ['=' test] ',')*
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/fmtonoff.py:116:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/fmtonoff.py:329:        typedargslist.extend(
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/debug_visitor.out:72:            typedargslist
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/debug_visitor.out:87:            /typedargslist
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/debug_visitor.out:676:              typedargslist
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/debug_visitor.out:691:              /typedargslist
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/comments2.py:62:    if typedargslist:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/comments2.py:224:    if typedargslist:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:34:                syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:44:                syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:86:                syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:127:                syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:137:                syms.typedargslist,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/empty_lines.py:181:                syms.typedargslist,

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:
1378:            return False
1379:
1380:        if not self.leaves:
1381:            comment.type = STANDALONE_COMMENT
1382:            comment.prefix = ""
1383:            return False
1384:
1385:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1386:        return True
1387:

Calling tool: grepTool
python_symbols\s+as\s+syms|import\s+syms|syms\s*=
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:82:syms = pygram.python_symbols

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
60:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
61:
62:
63:# types
64:FileContent = str
65:Encoding = str
66:NewLine = str
67:Depth = int
68:NodeType = int
69:LeafID = int
70:Priority = int
71:Index = int
72:LN = Union[Leaf, Node]
73:SplitFunc = Callable[["Line", Collection["Feature"]], Iterator["Line"]]
74:Timestamp = float
75:FileSize = int
76:CacheInfo = Tuple[Timestamp, FileSize]
77:Cache = Dict[Path, CacheInfo]
78:out = partial(click.secho, bold=True, err=True)
79:err = partial(click.secho, fg="red", err=True)
80:
81:pygram.initialize(CACHE_DIR)
82:syms = pygram.python_symbols
83:
84:
85:class NothingChanged(UserWarning):
86:    """Raised when reformatted code is the same as source."""
87:
88:
89:class CannotSplit(Exception):
90:    """A readable split that fits the allotted line length is impossible."""
91:
92:
93:class InvalidInput(ValueError):
94:    """Raised when input source code fails all parse attempts."""
95:
96:
97:class WriteBack(Enum):
98:    NO = 0
99:    YES = 1

Calling tool: grepTool
import\s+pygram|from\s+.*\s+import\s+pygram
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:48:from blib2to3 import pygram, pytree

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
930:    token.DOUBLESLASH,
931:    token.PERCENT,
932:    token.AT,
933:    token.TILDE,
934:    token.DOUBLESTAR,
935:}
936:STARS = {token.STAR, token.DOUBLESTAR}
937:VARARGS_PARENTS = {
938:    syms.arglist,
939:    syms.argument,  # double star in arglist
940:    syms.trailer,  # single argument to call
941:    syms.typedargslist,
942:    syms.varargslist,  # lambdas
943:}
944:UNPACKING_PARENTS = {
945:    syms.atom,  # single element of a list or set literal
946:    syms.dictsetmaker,
947:    syms.listmaker,
948:    syms.testlist_gexp,
949:    syms.testlist_star_expr,
950:}
951:TEST_DESCENDANTS = {
952:    syms.test,
953:    syms.lambdef,
954:    syms.or_test,
955:    syms.and_test,
956:    syms.not_test,
957:    syms.comparison,
958:    syms.star_expr,
959:    syms.expr,
960:    syms.xor_expr,
961:    syms.and_expr,
962:    syms.shift_expr,
963:    syms.arith_expr,
964:    syms.trailer,
965:    syms.term,
966:    syms.power,
967:}
968:ASSIGNMENTS = {
969:    "=",

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1320:        if closing.type == token.RBRACE:
1321:            self.remove_trailing_comma()
1322:            return True
1323:
1324:        if closing.type == token.RSQB:
1325:            comma = self.leaves[-1]
1326:            if comma.parent and comma.parent.type == syms.listmaker:
1327:                self.remove_trailing_comma()
1328:                return True
1329:
1330:        # For parens let's check if it's safe to remove the comma.
1331:        # Imports are always safe.
1332:        if self.is_import:
1333:            self.remove_trailing_comma()
1334:            return True
1335:
1336:        # Otherwise, if the trailing one is the only one, we might mistakenly
1337:        # change a tuple into a different type by removing the comma.
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py, the comma counting logic now checks leaf.parent.type in {syms.arglist, syms.typedargslist} (lines 1355-1358), confirming inclusion of syms.typedargslist. syms is set via syms = pygram.python_symbols (line 82) with pygram imported, and syms.typedargslist is used elsewhere and defined (blib2to3/pygram.pyi), so it is in scope.

Todo item 1 of 11 is correct
description: 'Verify that in black.py the modified leaf.parent.type condition now includes syms.typedargslist alongside syms.arglist in the comma counting logic, and that syms.typedargslist is defined/imported in scope.'

Validating todo item 2 of 11
description: 'Confirm that the updated comma counting block (where commas is incremented and a break occurs) is part of the code path used to decide trailing comma removal for function definition parameters, so that including syms.typedargslist will cause removal for typed argument lists as intended.'

Calling tool: grepTool
def maybe_remove_trailing_comma\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1295:            if leaf_id in ignored_ids:
1296:                continue
1297:
1298:            for comment in comments:
1299:                if is_type_comment(comment):
1300:                    return True
1301:
1302:        return False
1303:
1304:    def contains_multiline_strings(self) -> bool:
1305:        for leaf in self.leaves:
1306:            if is_multiline_string(leaf):
1307:                return True
1308:
1309:        return False
1310:
1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1312:        """Remove trailing comma if there is one and it's safe."""
1313:        if not (
1314:            self.leaves
1315:            and self.leaves[-1].type == token.COMMA
1316:            and closing.type in CLOSING_BRACKETS
1317:        ):
1318:            return False
1319:
1320:        if closing.type == token.RBRACE:
1321:            self.remove_trailing_comma()
1322:            return True
1323:
1324:        if closing.type == token.RSQB:
1325:            comma = self.leaves[-1]
1326:            if comma.parent and comma.parent.type == syms.listmaker:
1327:                self.remove_trailing_comma()
1328:                return True
1329:
1330:        # For parens let's check if it's safe to remove the comma.
1331:        # Imports are always safe.
1332:        if self.is_import:
1333:            self.remove_trailing_comma()
1334:            return True
1335:
1336:        # Otherwise, if the trailing one is the only one, we might mistakenly
1337:        # change a tuple into a different type by removing the comma.
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:
1378:            return False
1379:
1380:        if not self.leaves:
1381:            comment.type = STANDALONE_COMMENT
1382:            comment.prefix = ""
1383:            return False
1384:
1385:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1386:        return True
1387:
1388:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1389:        """Generate comments that should appear directly after `leaf`."""
1390:        return self.comments.get(id(leaf), [])
1391:
1392:    def remove_trailing_comma(self) -> None:
1393:        """Remove the trailing comma and moves the comments attached to it."""
1394:        trailing_comma = self.leaves.pop()
1395:        trailing_comma_comments = self.comments.pop(id(trailing_comma), [])
1396:        self.comments.setdefault(id(self.leaves[-1]), []).extend(
1397:            trailing_comma_comments
1398:        )
1399:
1400:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1401:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1402:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1403:        if open_lsqb is None:
1404:            return False
1405:
1406:        subscript_start = open_lsqb.next_sibling
1407:
1408:        if isinstance(subscript_start, Node):
1409:            if subscript_start.type == syms.listmaker:
1410:                return False
1411:
1412:            if subscript_start.type == syms.subscriptlist:
1413:                subscript_start = child_towards(subscript_start, leaf)
1414:        return subscript_start is not None and any(
1415:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
1416:        )
1417:
1418:    def __str__(self) -> str:
1419:        """Render the line."""
1420:        if not self:
1421:            return "\n"
1422:
1423:        indent = "    " * self.depth
1424:        leaves = iter(self.leaves)
1425:        first = next(leaves)
1426:        res = f"{first.prefix}{indent}{first.value}"
1427:        for leaf in leaves:
1428:            res += str(leaf)
1429:        for comment in itertools.chain.from_iterable(self.comments.values()):
1430:            res += str(comment)
1431:        return res + "\n"
1432:
1433:    def __bool__(self) -> bool:
1434:        """Return True if the line has leaves or comments."""
1435:        return bool(self.leaves or self.comments)
1436:
1437:
1438:@dataclass
1439:class EmptyLineTracker:
1440:    """Provides a stateful method that returns the number of potential extra
1441:    empty lines needed before and after the currently processed line.
1442:
1443:    Note: this tracker works on lines that haven't been split yet.  It assumes
1444:    the prefix of the first leaf consists of optional newlines.  Those newlines
1445:    are consumed by `maybe_empty_lines()` and included in the computation.
1446:    """
1447:
1448:    is_pyi: bool = False
1449:    previous_line: Optional[Line] = None
1450:    previous_after: int = 0
1451:    previous_defs: List[int] = Factory(list)
1452:
1453:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1454:        """Return the number of extra empty lines before and after the `current_line`.
1455:
1456:        This is for separating `def`, `async def` and `class` with extra empty
1457:        lines (two on module-level).
1458:        """
1459:        before, after = self._maybe_empty_lines(current_line)
1460:        before -= self.previous_after
1461:        self.previous_after = after
1462:        self.previous_line = current_line
1463:        return before, after
1464:
1465:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1466:        max_allowed = 1
1467:        if current_line.depth == 0:
1468:            max_allowed = 1 if self.is_pyi else 2
1469:        if current_line.leaves:
1470:            # Consume the first leaf's extra newlines.
1471:            first_leaf = current_line.leaves[0]
1472:            before = first_leaf.prefix.count("\n")
1473:            before = min(before, max_allowed)
1474:            first_leaf.prefix = ""
1475:        else:
1476:            before = 0
1477:        depth = current_line.depth
1478:        while self.previous_defs and self.previous_defs[-1] >= depth:
1479:            self.previous_defs.pop()
1480:            if self.is_pyi:
1481:                before = 0 if depth else 1
1482:            else:
1483:                before = 1 if depth else 2
1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
1485:            return self._maybe_empty_lines_for_class_or_def(current_line, before)
1486:
1487:        if (
1488:            self.previous_line
1489:            and self.previous_line.is_import
1490:            and not current_line.is_import
1491:            and depth == self.previous_line.depth
1492:        ):
1493:            return (before or 1), 0
1494:
1495:        if (
1496:            self.previous_line
1497:            and self.previous_line.is_class
1498:            and current_line.is_triple_quoted_string
1499:        ):
1500:            return before, 1
1501:
1502:        return before, 0
1503:
1504:    def _maybe_empty_lines_for_class_or_def(
1505:        self, current_line: Line, before: int
1506:    ) -> Tuple[int, int]:
1507:        if not current_line.is_decorator:
1508:            self.previous_defs.append(current_line.depth)
1509:        if self.previous_line is None:
1510:            # Don't insert empty lines before the first line in the file.
1511:            return 0, 0
1512:
1513:        if self.previous_line.is_decorator:
1514:            return 0, 0

Calling tool: grepTool
maybe_remove_trailing_comma\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1176:            self.maybe_remove_trailing_comma(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1125:        if (
1126:            self._lambda_argument_depths
1127:            and self._lambda_argument_depths[-1] == self.depth
1128:            and leaf.type == token.COLON
1129:        ):
1130:            self.depth -= 1
1131:            self._lambda_argument_depths.pop()
1132:            return True
1133:
1134:        return False
1135:
1136:    def get_open_lsqb(self) -> Optional[Leaf]:
1137:        """Return the most recent opening square bracket (if any)."""
1138:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1139:
1140:
1141:@dataclass
1142:class Line:
1143:    """Holds leaves and comments. Can be printed with `str(line)`."""
1144:
1145:    depth: int = 0
1146:    leaves: List[Leaf] = Factory(list)
1147:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)  # keys ordered like `leaves`
1148:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1149:    inside_brackets: bool = False
1150:    should_explode: bool = False
1151:
1152:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1153:        """Add a new `leaf` to the end of the line.
1154:
1155:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1156:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1157:        Trailing commas are maybe removed, unpacked for loop variables are
1158:        demoted from being delimiters.
1159:
1160:        Inline comments are put aside.
1161:        """
1162:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1163:        if not has_value:
1164:            return
1165:
1166:        if token.COLON == leaf.type and self.is_class_paren_empty:
1167:            del self.leaves[-2:]
1168:        if self.leaves and not preformatted:
1169:            # Note: at this point leaf.prefix should be empty except for
1170:            # imports, for which we only preserve newlines.
1171:            leaf.prefix += whitespace(
1172:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1173:            )
1174:        if self.inside_brackets or not preformatted:
1175:            self.bracket_tracker.mark(leaf)
1176:            self.maybe_remove_trailing_comma(leaf)
1177:        if not self.append_comment(leaf):
1178:            self.leaves.append(leaf)
1179:
1180:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1181:        """Like :func:`append()` but disallow invalid standalone comment structure.
1182:
1183:        Raises ValueError when any `leaf` is appended after a standalone comment
1184:        or when a standalone comment is not the first leaf on the line.
1185:        """
1186:        if self.bracket_tracker.depth == 0:
1187:            if self.is_comment:
1188:                raise ValueError("cannot append to standalone comments")
1189:
1190:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1191:                raise ValueError(
1192:                    "cannot append standalone comments to a populated line"
1193:                )
1194:
1195:        self.append(leaf, preformatted=preformatted)
1196:
1197:    @property
1198:    def is_comment(self) -> bool:
1199:        """Is this line a standalone comment?"""
1200:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1201:
1202:    @property
1203:    def is_decorator(self) -> bool:
1204:        """Is this line a decorator?"""

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2455:
2456:    Do nothing otherwise.
2457:
2458:    A left- or right-hand split is based on a pair of brackets. Content before
2459:    (and including) the opening bracket is left on one line, content inside the
2460:    brackets is put on a separate line, and finally content starting with and
2461:    following the closing bracket is put on a separate line.
2462:
2463:    Those are called `head`, `body`, and `tail`, respectively. If the split
2464:    produced the same line (all content in `head`) or ended up with an empty `body`
2465:    and the `tail` is just the closing bracket, then it's considered failed.
2466:    """
2467:    tail_len = len(str(tail).strip())
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:
2548:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2549:    except ValueError:
2550:        raise CannotSplit("No delimiters found")
2551:
2552:    if delimiter_priority == DOT_PRIORITY:
2553:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2554:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")

Calling tool: grepTool
remove_trailing_comma\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1176:            self.maybe_remove_trailing_comma(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1321:            self.remove_trailing_comma()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1327:                self.remove_trailing_comma()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1333:            self.remove_trailing_comma()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1363:            self.remove_trailing_comma()
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1392:    def remove_trailing_comma(self) -> None:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The updated comma-counting block is inside Line.maybe_remove_trailing_comma (black.py:1352-1361). This method is called during line building when appending a closing bracket (Line.append at black.py:1176), which applies to function definition parameter lists. Including syms.typedargslist in the parent-type check ensures trailing comma removal logic applies to typed argument lists.

Todo item 2 of 11 is correct
description: 'Confirm that the updated comma counting block (where commas is incremented and a break occurs) is part of the code path used to decide trailing comma removal for function definition parameters, so that including syms.typedargslist will cause removal for typed argument lists as intended.'

Validating todo item 3 of 11
description: 'In bracket_split_build_line, verify the new no_commas variable is defined as: original.is_def and not any(l.type == token.COMMA for l in leaves), and that original.is_def correctly identifies function definitions (not calls or other constructs).'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:
2548:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2549:    except ValueError:

Calling tool: grepTool
is_def\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1229:    def is_def(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1517:            self.previous_line.is_class or self.previous_line.is_def
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1537:            elif current_line.is_def and not self.previous_line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2282:    if line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2496:            no_commas = original.is_def and not any(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1200:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1201:
1202:    @property
1203:    def is_decorator(self) -> bool:
1204:        """Is this line a decorator?"""
1205:        return bool(self) and self.leaves[0].type == token.AT
1206:
1207:    @property
1208:    def is_import(self) -> bool:
1209:        """Is this an import line?"""
1210:        return bool(self) and is_import(self.leaves[0])
1211:
1212:    @property
1213:    def is_class(self) -> bool:
1214:        """Is this line a class definition?"""
1215:        return (
1216:            bool(self)
1217:            and self.leaves[0].type == token.NAME
1218:            and self.leaves[0].value == "class"
1219:        )
1220:
1221:    @property
1222:    def is_stub_class(self) -> bool:
1223:        """Is this line a class definition with a body consisting only of "..."?"""
1224:        return self.is_class and self.leaves[-3:] == [
1225:            Leaf(token.DOT, ".") for _ in range(3)
1226:        ]
1227:
1228:    @property
1229:    def is_def(self) -> bool:
1230:        """Is this a function definition? (Also returns True for async defs.)"""
1231:        try:
1232:            first_leaf = self.leaves[0]
1233:        except IndexError:
1234:            return False
1235:
1236:        try:
1237:            second_leaf: Optional[Leaf] = self.leaves[1]
1238:        except IndexError:
1239:            second_leaf = None
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC
1242:            and second_leaf is not None
1243:            and second_leaf.type == token.NAME
1244:            and second_leaf.value == "def"
1245:        )
1246:
1247:    @property
1248:    def is_class_paren_empty(self) -> bool:
1249:        """Is this a class with no base classes but using parentheses?
1250:
1251:        Those are unnecessary and should be removed.
1252:        """
1253:        return (
1254:            bool(self)
1255:            and len(self.leaves) == 4
1256:            and self.is_class
1257:            and self.leaves[2].type == token.LPAR
1258:            and self.leaves[2].value == "("
1259:            and self.leaves[3].type == token.RPAR
1260:            and self.leaves[3].value == ")"
1261:        )
1262:
1263:    @property
1264:    def is_triple_quoted_string(self) -> bool:
1265:        """Is the line a triple quoted string?"""
1266:        return (
1267:            bool(self)
1268:            and self.leaves[0].type == token.STRING
1269:            and self.leaves[0].value.startswith(('"""', "'''"))
1270:        )
1271:
1272:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1273:        """If so, needs to be split before emitting."""
1274:        for leaf in self.leaves:
1275:            if leaf.type == STANDALONE_COMMENT:
1276:                if leaf.bracket_depth <= depth_limit:
1277:                    return True
1278:        return False
1279:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py’s bracket_split_build_line, no_commas is defined exactly as `original.is_def and not any(l.type == token.COMMA for l in leaves)`. The `original` parameter is a Line, and Line.is_def checks for ‘def’ or ‘async def’ at the start, correctly identifying function definitions (not calls).

Todo item 3 of 11 is correct
description: 'In bracket_split_build_line, verify the new no_commas variable is defined as: original.is_def and not any(l.type == token.COMMA for l in leaves), and that original.is_def correctly identifies function definitions (not calls or other constructs).'

Validating todo item 4 of 11
description: 'Check that the condition if original.is_import or no_commas: correctly broadens the existing behavior to also apply the trailing-comma ensuring logic to function definition lines with a single argument (no existing commas), without affecting lines that already contain a comma.'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:

Calling tool: grepTool
is_def
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1229:    def is_def(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1517:            self.previous_line.is_class or self.previous_line.is_def
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1537:            elif current_line.is_def and not self.previous_line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2282:    if line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2496:            no_commas = original.is_def and not any(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1210:        return bool(self) and is_import(self.leaves[0])
1211:
1212:    @property
1213:    def is_class(self) -> bool:
1214:        """Is this line a class definition?"""
1215:        return (
1216:            bool(self)
1217:            and self.leaves[0].type == token.NAME
1218:            and self.leaves[0].value == "class"
1219:        )
1220:
1221:    @property
1222:    def is_stub_class(self) -> bool:
1223:        """Is this line a class definition with a body consisting only of "..."?"""
1224:        return self.is_class and self.leaves[-3:] == [
1225:            Leaf(token.DOT, ".") for _ in range(3)
1226:        ]
1227:
1228:    @property
1229:    def is_def(self) -> bool:
1230:        """Is this a function definition? (Also returns True for async defs.)"""
1231:        try:
1232:            first_leaf = self.leaves[0]
1233:        except IndexError:
1234:            return False
1235:
1236:        try:
1237:            second_leaf: Optional[Leaf] = self.leaves[1]
1238:        except IndexError:
1239:            second_leaf = None
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC
1242:            and second_leaf is not None
1243:            and second_leaf.type == token.NAME
1244:            and second_leaf.value == "def"
1245:        )
1246:
1247:    @property
1248:    def is_class_paren_empty(self) -> bool:
1249:        """Is this a class with no base classes but using parentheses?

Calling tool: grepTool
maybe_remove_trailing_comma\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1176:            self.maybe_remove_trailing_comma(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1298:            for comment in comments:
1299:                if is_type_comment(comment):
1300:                    return True
1301:
1302:        return False
1303:
1304:    def contains_multiline_strings(self) -> bool:
1305:        for leaf in self.leaves:
1306:            if is_multiline_string(leaf):
1307:                return True
1308:
1309:        return False
1310:
1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1312:        """Remove trailing comma if there is one and it's safe."""
1313:        if not (
1314:            self.leaves
1315:            and self.leaves[-1].type == token.COMMA
1316:            and closing.type in CLOSING_BRACKETS
1317:        ):
1318:            return False
1319:
1320:        if closing.type == token.RBRACE:
1321:            self.remove_trailing_comma()
1322:            return True
1323:
1324:        if closing.type == token.RSQB:
1325:            comma = self.leaves[-1]
1326:            if comma.parent and comma.parent.type == syms.listmaker:
1327:                self.remove_trailing_comma()
1328:                return True
1329:
1330:        # For parens let's check if it's safe to remove the comma.
1331:        # Imports are always safe.
1332:        if self.is_import:
1333:            self.remove_trailing_comma()
1334:            return True
1335:
1336:        # Otherwise, if the trailing one is the only one, we might mistakenly
1337:        # change a tuple into a different type by removing the comma.
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:
1378:            return False
1379:
1380:        if not self.leaves:
1381:            comment.type = STANDALONE_COMMENT
1382:            comment.prefix = ""
1383:            return False
1384:
1385:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1386:        return True
1387:

Calling tool: grepTool
test_function_trailing_comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_function_trailing_comma
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py:268:    def test_function_trailing_comma(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py
240:        self.assertEqual(expected, actual)
241:
242:    @patch("black.dump_to_file", dump_to_stderr)
243:    def test_setup(self) -> None:
244:        source, expected = read_data("../setup", data=False)
245:        actual = fs(source)
246:        self.assertFormatEqual(expected, actual)
247:        black.assert_equivalent(source, actual)
248:        black.assert_stable(source, actual, black.FileMode())
249:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
250:
251:    @patch("black.dump_to_file", dump_to_stderr)
252:    def test_function(self) -> None:
253:        source, expected = read_data("function")
254:        actual = fs(source)
255:        self.assertFormatEqual(expected, actual)
256:        black.assert_equivalent(source, actual)
257:        black.assert_stable(source, actual, black.FileMode())
258:
259:    @patch("black.dump_to_file", dump_to_stderr)
260:    def test_function2(self) -> None:
261:        source, expected = read_data("function2")
262:        actual = fs(source)
263:        self.assertFormatEqual(expected, actual)
264:        black.assert_equivalent(source, actual)
265:        black.assert_stable(source, actual, black.FileMode())
266:
267:    @patch("black.dump_to_file", dump_to_stderr)
268:    def test_function_trailing_comma(self) -> None:
269:        source, expected = read_data("function_trailing_comma")
270:        actual = fs(source)
271:        self.assertFormatEqual(expected, actual)
272:        black.assert_equivalent(source, actual)
273:        black.assert_stable(source, actual, black.FileMode())
274:
275:    @patch("black.dump_to_file", dump_to_stderr)
276:    def test_expression(self) -> None:
277:        source, expected = read_data("expression")
278:        actual = fs(source)
279:        self.assertFormatEqual(expected, actual)
280:        black.assert_equivalent(source, actual)
281:        black.assert_stable(source, actual, black.FileMode())
282:
283:    def test_expression_ff(self) -> None:
284:        source, expected = read_data("expression")
285:        tmp_file = Path(black.dump_to_file(source))
286:        try:
287:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
288:            with open(tmp_file, encoding="utf8") as f:
289:                actual = f.read()
290:        finally:
291:            os.unlink(tmp_file)
292:        self.assertFormatEqual(expected, actual)
293:        with patch("black.dump_to_file", dump_to_stderr):
294:            black.assert_equivalent(source, actual)
295:            black.assert_stable(source, actual, black.FileMode())
296:
297:    def test_expression_diff(self) -> None:
298:        source, _ = read_data("expression.py")
299:        expected, _ = read_data("expression.diff")

Calling tool: globTool
**/*function_trailing_comma*
Grep command failed with exit code 2: rg: /Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black: IO error for operation on /Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black: No such file or directory (os error 2)


Calling tool: globTool
**/*function_trailing_comma*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py
1:def f(a,):
2:    ...
3:
4:def f(a:int=1,):
5:    ...
6:
7:# output
8:
9:def f(a):
10:    ...
11:
12:
13:def f(a: int = 1):
14:    ...

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In bracket_split_build_line, the new condition computes no_commas = original.is_def and not any(l.type == token.COMMA for l in leaves) and uses if original.is_import or no_commas: to trigger trailing-comma insertion. This applies the logic to function definition lines with a single argument (no commas) and the inner loop breaks if a comma is already present, so lines that already contain a comma are unaffected.

Todo item 4 of 11 is correct
description: 'Check that the condition if original.is_import or no_commas: correctly broadens the existing behavior to also apply the trailing-comma ensuring logic to function definition lines with a single argument (no existing commas), without affecting lines that already contain a comma.'

Validating todo item 5 of 11
description: 'Inspect the loop that walks leaves from the end and skips STANDALONE_COMMENT tokens; verify that the subsequent code adds the comma after the last non-comment leaf and does not place it after any comments.'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In bracket_split_build_line, the loop walks from the end, skipping STANDALONE_COMMENT leaves, then either breaks if it finds an existing COMMA or inserts a COMMA at i+1. This ensures the comma is placed immediately after the last non-comment leaf and before any trailing comments.

Todo item 5 of 11 is correct
description: 'Inspect the loop that walks leaves from the end and skips STANDALONE_COMMENT tokens; verify that the subsequent code adds the comma after the last non-comment leaf and does not place it after any comments.'

Validating todo item 6 of 11
description: 'Ensure the trailing comma addition logic does not add commas to empty parameter lists (e.g., def f():) because of the surrounding if leaves: guard and the no_commas definition.'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:
2548:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2549:    except ValueError:
2550:        raise CannotSplit("No delimiters found")
2551:
2552:    if delimiter_priority == DOT_PRIORITY:
2553:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2554:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2555:
2556:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2557:    lowest_depth = sys.maxsize
2558:    trailing_comma_safe = True
2559:
2560:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2561:        """Append `leaf` to current line or to new line if appending impossible."""
2562:        nonlocal current_line
2563:        try:
2564:            current_line.append_safe(leaf, preformatted=True)
2565:        except ValueError:
2566:            yield current_line
2567:
2568:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2569:            current_line.append(leaf)
2570:
2571:    for leaf in line.leaves:
2572:        yield from append_to_line(leaf)
2573:
2574:        for comment_after in line.comments_after(leaf):
2575:            yield from append_to_line(comment_after)
2576:
2577:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2578:        if leaf.bracket_depth == lowest_depth:
2579:            if is_vararg(leaf, within={syms.typedargslist}):
2580:                trailing_comma_safe = (
2581:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features
2582:                )
2583:            elif is_vararg(leaf, within={syms.arglist, syms.argument}):
2584:                trailing_comma_safe = (
2585:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features
2586:                )
2587:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:

Calling tool: grepTool
no_commas\s*=
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2496:            no_commas = original.is_def and not any(

Calling tool: grepTool
Ensure a trailing comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2494:            # Ensure a trailing comma for imports and standalone function arguments, but

Calling tool: grepTool
is_def\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1229:    def is_def(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1517:            self.previous_line.is_class or self.previous_line.is_def
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1537:            elif current_line.is_def and not self.previous_line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2282:    if line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2496:            no_commas = original.is_def and not any(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1218:            and self.leaves[0].value == "class"
1219:        )
1220:
1221:    @property
1222:    def is_stub_class(self) -> bool:
1223:        """Is this line a class definition with a body consisting only of "..."?"""
1224:        return self.is_class and self.leaves[-3:] == [
1225:            Leaf(token.DOT, ".") for _ in range(3)
1226:        ]
1227:
1228:    @property
1229:    def is_def(self) -> bool:
1230:        """Is this a function definition? (Also returns True for async defs.)"""
1231:        try:
1232:            first_leaf = self.leaves[0]
1233:        except IndexError:
1234:            return False
1235:
1236:        try:
1237:            second_leaf: Optional[Leaf] = self.leaves[1]
1238:        except IndexError:
1239:            second_leaf = None
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC
1242:            and second_leaf is not None
1243:            and second_leaf.type == token.NAME
1244:            and second_leaf.value == "def"
1245:        )
1246:
1247:    @property
1248:    def is_class_paren_empty(self) -> bool:
1249:        """Is this a class with no base classes but using parentheses?
1250:
1251:        Those are unnecessary and should be removed.
1252:        """
1253:        return (
1254:            bool(self)
1255:            and len(self.leaves) == 4
1256:            and self.is_class
1257:            and self.leaves[2].type == token.LPAR
1258:            and self.leaves[2].value == "("
1259:            and self.leaves[3].type == token.RPAR
1260:            and self.leaves[3].value == ")"
1261:        )
1262:
1263:    @property
1264:    def is_triple_quoted_string(self) -> bool:
1265:        """Is the line a triple quoted string?"""
1266:        return (
1267:            bool(self)
1268:            and self.leaves[0].type == token.STRING
1269:            and self.leaves[0].value.startswith(('"""', "'''"))
1270:        )
1271:
1272:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1273:        """If so, needs to be split before emitting."""
1274:        for leaf in self.leaves:
1275:            if leaf.type == STANDALONE_COMMENT:
1276:                if leaf.bracket_depth <= depth_limit:
1277:                    return True
1278:        return False
1279:

Calling tool: grepTool
bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2355:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2356:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2357:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2403:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2404:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2405:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2328:def left_hand_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2329:    """Split line into many lines, starting with the first matching bracket pair.
2330:
2331:    Note: this usually looks weird, only use this for function definitions.
2332:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2333:    :func:`right_hand_split` which also handles optional parentheses.
2334:    """
2335:    tail_leaves: List[Leaf] = []
2336:    body_leaves: List[Leaf] = []
2337:    head_leaves: List[Leaf] = []
2338:    current_leaves = head_leaves
2339:    matching_bracket = None
2340:    for leaf in line.leaves:
2341:        if (
2342:            current_leaves is body_leaves
2343:            and leaf.type in CLOSING_BRACKETS
2344:            and leaf.opening_bracket is matching_bracket
2345:        ):
2346:            current_leaves = tail_leaves if body_leaves else head_leaves
2347:        current_leaves.append(leaf)
2348:        if current_leaves is head_leaves:
2349:            if leaf.type in OPENING_BRACKETS:
2350:                matching_bracket = leaf
2351:                current_leaves = body_leaves
2352:    if not matching_bracket:
2353:        raise CannotSplit("No brackets found")
2354:
2355:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2356:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2357:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2358:    bracket_split_succeeded_or_raise(head, body, tail)
2359:    for result in (head, body, tail):
2360:        if result:
2361:            yield result
2362:
2363:
2364:def right_hand_split(
2365:    line: Line,
2366:    line_length: int,
2367:    features: Collection[Feature] = (),
2368:    omit: Collection[LeafID] = (),
2369:) -> Iterator[Line]:
2370:    """Split line into many lines, starting with the last matching bracket pair.
2371:
2372:    If the split was by optional parentheses, attempt splitting without them, too.
2373:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2374:    this split.
2375:
2376:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2377:    """
2378:    tail_leaves: List[Leaf] = []
2379:    body_leaves: List[Leaf] = []
2380:    head_leaves: List[Leaf] = []
2381:    current_leaves = tail_leaves
2382:    opening_bracket = None
2383:    closing_bracket = None
2384:    for leaf in reversed(line.leaves):
2385:        if current_leaves is body_leaves:
2386:            if leaf is opening_bracket:
2387:                current_leaves = head_leaves if body_leaves else tail_leaves
2388:        current_leaves.append(leaf)
2389:        if current_leaves is tail_leaves:
2390:            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:
2391:                opening_bracket = leaf.opening_bracket
2392:                closing_bracket = leaf
2393:                current_leaves = body_leaves
2394:    if not (opening_bracket and closing_bracket and head_leaves):
2395:        # If there is no opening or closing_bracket that means the split failed and
2396:        # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means
2397:        # the matching `opening_bracket` wasn't available on `line` anymore.
2398:        raise CannotSplit("No brackets found")
2399:
2400:    tail_leaves.reverse()
2401:    body_leaves.reverse()
2402:    head_leaves.reverse()
2403:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
2404:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
2405:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
2406:    bracket_split_succeeded_or_raise(head, body, tail)
2407:    if (
2408:        # the body shouldn't be exploded
2409:        not body.should_explode
2410:        # the opening bracket is an optional paren
2411:        and opening_bracket.type == token.LPAR
2412:        and not opening_bracket.value
2413:        # the closing bracket is an optional paren
2414:        and closing_bracket.type == token.RPAR
2415:        and not closing_bracket.value
2416:        # it's not an import (optional parens are the only thing we can split on
2417:        # in this case; attempting a split without them is a waste of time)
2418:        and not line.is_import
2419:        # there are no standalone comments in the body
2420:        and not body.contains_standalone_comments(0)
2421:        # and we can actually remove the parens
2422:        and can_omit_invisible_parens(body, line_length)
2423:    ):
2424:        omit = {id(closing_bracket), *omit}
2425:        try:
2426:            yield from right_hand_split(line, line_length, features=features, omit=omit)
2427:            return

Calling tool: grepTool
def bracket_split_succeeded_or_raise\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2453:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2446:    ensure_visible(opening_bracket)
2447:    ensure_visible(closing_bracket)
2448:    for result in (head, body, tail):
2449:        if result:
2450:            yield result
2451:
2452:
2453:def bracket_split_succeeded_or_raise(head: Line, body: Line, tail: Line) -> None:
2454:    """Raise :exc:`CannotSplit` if the last left- or right-hand split failed.
2455:
2456:    Do nothing otherwise.
2457:
2458:    A left- or right-hand split is based on a pair of brackets. Content before
2459:    (and including) the opening bracket is left on one line, content inside the
2460:    brackets is put on a separate line, and finally content starting with and
2461:    following the closing bracket is put on a separate line.
2462:
2463:    Those are called `head`, `body`, and `tail`, respectively. If the split
2464:    produced the same line (all content in `head`) or ended up with an empty `body`
2465:    and the `tail` is just the closing bracket, then it's considered failed.
2466:    """
2467:    tail_len = len(str(tail).strip())
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In bracket_split_build_line, the trailing comma logic is guarded by `if leaves:` and `no_commas = original.is_def and not any(l.type == token.COMMA for l in leaves)`. For empty parameter lists, `leaves` is empty, so the code inside the guard doesn’t run and no comma is added. I verified the exact implementation lines (2491–2508).

Todo item 6 of 11 is correct
description: 'Ensure the trailing comma addition logic does not add commas to empty parameter lists (e.g., def f():) because of the surrounding if leaves: guard and the no_commas definition.'

Validating todo item 7 of 11
description: 'Verify that multiple-argument function definition lines will not match no_commas (since a COMMA token should be present among leaves), preventing accidental extra commas.'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2468:    if not body:
2469:        if tail_len == 0:
2470:            raise CannotSplit("Splitting brackets produced the same line")
2471:
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:

Calling tool: grepTool
bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2355:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2356:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2357:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2403:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2404:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2405:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2328:def left_hand_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2329:    """Split line into many lines, starting with the first matching bracket pair.
2330:
2331:    Note: this usually looks weird, only use this for function definitions.
2332:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2333:    :func:`right_hand_split` which also handles optional parentheses.
2334:    """
2335:    tail_leaves: List[Leaf] = []
2336:    body_leaves: List[Leaf] = []
2337:    head_leaves: List[Leaf] = []
2338:    current_leaves = head_leaves
2339:    matching_bracket = None
2340:    for leaf in line.leaves:
2341:        if (
2342:            current_leaves is body_leaves
2343:            and leaf.type in CLOSING_BRACKETS
2344:            and leaf.opening_bracket is matching_bracket
2345:        ):
2346:            current_leaves = tail_leaves if body_leaves else head_leaves
2347:        current_leaves.append(leaf)
2348:        if current_leaves is head_leaves:
2349:            if leaf.type in OPENING_BRACKETS:
2350:                matching_bracket = leaf
2351:                current_leaves = body_leaves
2352:    if not matching_bracket:
2353:        raise CannotSplit("No brackets found")
2354:
2355:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2356:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2357:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2358:    bracket_split_succeeded_or_raise(head, body, tail)
2359:    for result in (head, body, tail):
2360:        if result:
2361:            yield result
2362:
2363:
2364:def right_hand_split(
2365:    line: Line,
2366:    line_length: int,
2367:    features: Collection[Feature] = (),
2368:    omit: Collection[LeafID] = (),
2369:) -> Iterator[Line]:
2370:    """Split line into many lines, starting with the last matching bracket pair.
2371:
2372:    If the split was by optional parentheses, attempt splitting without them, too.
2373:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2374:    this split.
2375:
2376:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2377:    """
2378:    tail_leaves: List[Leaf] = []
2379:    body_leaves: List[Leaf] = []
2380:    head_leaves: List[Leaf] = []
2381:    current_leaves = tail_leaves
2382:    opening_bracket = None
2383:    closing_bracket = None
2384:    for leaf in reversed(line.leaves):
2385:        if current_leaves is body_leaves:
2386:            if leaf is opening_bracket:
2387:                current_leaves = head_leaves if body_leaves else tail_leaves
2388:        current_leaves.append(leaf)
2389:        if current_leaves is tail_leaves:
2390:            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:
2391:                opening_bracket = leaf.opening_bracket
2392:                closing_bracket = leaf
2393:                current_leaves = body_leaves
2394:    if not (opening_bracket and closing_bracket and head_leaves):
2395:        # If there is no opening or closing_bracket that means the split failed and
2396:        # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means
2397:        # the matching `opening_bracket` wasn't available on `line` anymore.
2398:        raise CannotSplit("No brackets found")
2399:
2400:    tail_leaves.reverse()
2401:    body_leaves.reverse()
2402:    head_leaves.reverse()
2403:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
2404:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
2405:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
2406:    bracket_split_succeeded_or_raise(head, body, tail)
2407:    if (
2408:        # the body shouldn't be exploded
2409:        not body.should_explode
2410:        # the opening bracket is an optional paren
2411:        and opening_bracket.type == token.LPAR
2412:        and not opening_bracket.value
2413:        # the closing bracket is an optional paren
2414:        and closing_bracket.type == token.RPAR
2415:        and not closing_bracket.value
2416:        # it's not an import (optional parens are the only thing we can split on
2417:        # in this case; attempting a split without them is a waste of time)
2418:        and not line.is_import
2419:        # there are no standalone comments in the body
2420:        and not body.contains_standalone_comments(0)
2421:        # and we can actually remove the parens
2422:        and can_omit_invisible_parens(body, line_length)
2423:    ):
2424:        omit = {id(closing_bracket), *omit}
2425:        try:
2426:            yield from right_hand_split(line, line_length, features=features, omit=omit)
2427:            return

Calling tool: grepTool
test_function_trailing_comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_function_trailing_comma
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py:268:    def test_function_trailing_comma(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py
240:        self.assertEqual(expected, actual)
241:
242:    @patch("black.dump_to_file", dump_to_stderr)
243:    def test_setup(self) -> None:
244:        source, expected = read_data("../setup", data=False)
245:        actual = fs(source)
246:        self.assertFormatEqual(expected, actual)
247:        black.assert_equivalent(source, actual)
248:        black.assert_stable(source, actual, black.FileMode())
249:        self.assertFalse(ff(THIS_DIR / ".." / "setup.py"))
250:
251:    @patch("black.dump_to_file", dump_to_stderr)
252:    def test_function(self) -> None:
253:        source, expected = read_data("function")
254:        actual = fs(source)
255:        self.assertFormatEqual(expected, actual)
256:        black.assert_equivalent(source, actual)
257:        black.assert_stable(source, actual, black.FileMode())
258:
259:    @patch("black.dump_to_file", dump_to_stderr)
260:    def test_function2(self) -> None:
261:        source, expected = read_data("function2")
262:        actual = fs(source)
263:        self.assertFormatEqual(expected, actual)
264:        black.assert_equivalent(source, actual)
265:        black.assert_stable(source, actual, black.FileMode())
266:
267:    @patch("black.dump_to_file", dump_to_stderr)
268:    def test_function_trailing_comma(self) -> None:
269:        source, expected = read_data("function_trailing_comma")
270:        actual = fs(source)
271:        self.assertFormatEqual(expected, actual)
272:        black.assert_equivalent(source, actual)
273:        black.assert_stable(source, actual, black.FileMode())
274:
275:    @patch("black.dump_to_file", dump_to_stderr)
276:    def test_expression(self) -> None:
277:        source, expected = read_data("expression")
278:        actual = fs(source)
279:        self.assertFormatEqual(expected, actual)
280:        black.assert_equivalent(source, actual)
281:        black.assert_stable(source, actual, black.FileMode())
282:
283:    def test_expression_ff(self) -> None:
284:        source, expected = read_data("expression")
285:        tmp_file = Path(black.dump_to_file(source))
286:        try:
287:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
288:            with open(tmp_file, encoding="utf8") as f:
289:                actual = f.read()
290:        finally:
291:            os.unlink(tmp_file)
292:        self.assertFormatEqual(expected, actual)
293:        with patch("black.dump_to_file", dump_to_stderr):
294:            black.assert_equivalent(source, actual)
295:            black.assert_stable(source, actual, black.FileMode())
296:
297:    def test_expression_diff(self) -> None:
298:        source, _ = read_data("expression.py")
299:        expected, _ = read_data("expression.diff")
300:        tmp_file = Path(black.dump_to_file(source))
301:        diff_header = re.compile(
302:            rf"{re.escape(str(tmp_file))}\t\d\d\d\d-\d\d-\d\d "
303:            rf"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
304:        )
305:        try:
306:            result = BlackRunner().invoke(black.main, ["--diff", str(tmp_file)])
307:            self.assertEqual(result.exit_code, 0)
308:        finally:
309:            os.unlink(tmp_file)

Calling tool: globTool
**/*function_trailing_comma*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py
1:def f(a,):
2:    ...
3:
4:def f(a:int=1,):
5:    ...
6:
7:# output
8:
9:def f(a):
10:    ...
11:
12:
13:def f(a: int = 1):
14:    ...

Calling tool: grepTool
maybe_remove_trailing_comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1176:            self.maybe_remove_trailing_comma(leaf)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1290:                ignored_ids.add(id(last_leaf))
1291:        except IndexError:
1292:            return False
1293:
1294:        for leaf_id, comments in self.comments.items():
1295:            if leaf_id in ignored_ids:
1296:                continue
1297:
1298:            for comment in comments:
1299:                if is_type_comment(comment):
1300:                    return True
1301:
1302:        return False
1303:
1304:    def contains_multiline_strings(self) -> bool:
1305:        for leaf in self.leaves:
1306:            if is_multiline_string(leaf):
1307:                return True
1308:
1309:        return False
1310:
1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1312:        """Remove trailing comma if there is one and it's safe."""
1313:        if not (
1314:            self.leaves
1315:            and self.leaves[-1].type == token.COMMA
1316:            and closing.type in CLOSING_BRACKETS
1317:        ):
1318:            return False
1319:
1320:        if closing.type == token.RBRACE:
1321:            self.remove_trailing_comma()
1322:            return True
1323:
1324:        if closing.type == token.RSQB:
1325:            comma = self.leaves[-1]
1326:            if comma.parent and comma.parent.type == syms.listmaker:
1327:                self.remove_trailing_comma()
1328:                return True
1329:
1330:        # For parens let's check if it's safe to remove the comma.
1331:        # Imports are always safe.
1332:        if self.is_import:
1333:            self.remove_trailing_comma()
1334:            return True
1335:
1336:        # Otherwise, if the trailing one is the only one, we might mistakenly
1337:        # change a tuple into a different type by removing the comma.
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:
1378:            return False
1379:
1380:        if not self.leaves:
1381:            comment.type = STANDALONE_COMMENT
1382:            comment.prefix = ""
1383:            return False
1384:
1385:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1386:        return True
1387:
1388:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1389:        """Generate comments that should appear directly after `leaf`."""

Calling tool: grepTool
is_def\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1229:    def is_def(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1517:            self.previous_line.is_class or self.previous_line.is_def
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1537:            elif current_line.is_def and not self.previous_line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2282:    if line.is_def:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2496:            no_commas = original.is_def and not any(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1208:    def is_import(self) -> bool:
1209:        """Is this an import line?"""
1210:        return bool(self) and is_import(self.leaves[0])
1211:
1212:    @property
1213:    def is_class(self) -> bool:
1214:        """Is this line a class definition?"""
1215:        return (
1216:            bool(self)
1217:            and self.leaves[0].type == token.NAME
1218:            and self.leaves[0].value == "class"
1219:        )
1220:
1221:    @property
1222:    def is_stub_class(self) -> bool:
1223:        """Is this line a class definition with a body consisting only of "..."?"""
1224:        return self.is_class and self.leaves[-3:] == [
1225:            Leaf(token.DOT, ".") for _ in range(3)
1226:        ]
1227:
1228:    @property
1229:    def is_def(self) -> bool:
1230:        """Is this a function definition? (Also returns True for async defs.)"""
1231:        try:
1232:            first_leaf = self.leaves[0]
1233:        except IndexError:
1234:            return False
1235:
1236:        try:
1237:            second_leaf: Optional[Leaf] = self.leaves[1]
1238:        except IndexError:
1239:            second_leaf = None
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC
1242:            and second_leaf is not None
1243:            and second_leaf.type == token.NAME
1244:            and second_leaf.value == "def"
1245:        )
1246:
1247:    @property

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In bracket_split_build_line, no_commas is set to original.is_def and not any(l.type == token.COMMA for l in leaves). For multi-argument function definitions, the body leaves include at least one COMMA token (argument separators), so no_commas is False and the insertion block is skipped, preventing extra commas.

Todo item 7 of 11 is correct
description: 'Verify that multiple-argument function definition lines will not match no_commas (since a COMMA token should be present among leaves), preventing accidental extra commas.'

Validating todo item 8 of 11
description: 'Confirm that comments in this context that should be skipped are represented by STANDALONE_COMMENT; check that no other comment token types need to be handled here to satisfy the PR note "be careful not to add one after any comments."'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2479:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2472:        elif tail_len < 3:
2473:            raise CannotSplit(
2474:                f"Splitting brackets on an empty body to save "
2475:                f"{tail_len} characters is not worth it"
2476:            )
2477:
2478:
2479:def bracket_split_build_line(
2480:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2481:) -> Line:
2482:    """Return a new line with given `leaves` and respective comments from `original`.
2483:
2484:    If `is_body` is True, the result line is one-indented inside brackets and as such
2485:    has its first leaf's prefix normalized and a trailing comma added when expected.
2486:    """
2487:    result = Line(depth=original.depth)
2488:    if is_body:
2489:        result.inside_brackets = True
2490:        result.depth += 1
2491:        if leaves:
2492:            # Since body is a new indent level, remove spurious leading whitespace.
2493:            normalize_prefix(leaves[0], inside_brackets=True)
2494:            # Ensure a trailing comma for imports and standalone function arguments, but
2495:            # be careful not to add one after any comments.
2496:            no_commas = original.is_def and not any(
2497:                l.type == token.COMMA for l in leaves
2498:            )
2499:
2500:            if original.is_import or no_commas:
2501:                for i in range(len(leaves) - 1, -1, -1):
2502:                    if leaves[i].type == STANDALONE_COMMENT:
2503:                        continue
2504:                    elif leaves[i].type == token.COMMA:
2505:                        break
2506:                    else:
2507:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2508:                        break
2509:    # Populate the line
2510:    for leaf in leaves:
2511:        result.append(leaf, preformatted=True)
2512:        for comment_after in original.comments_after(leaf):
2513:            result.append(comment_after, preformatted=True)
2514:    if is_body:
2515:        result.should_explode = should_explode(result, opening_bracket)
2516:    return result
2517:
2518:
2519:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2520:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2521:
2522:    This is a decorator over relevant split functions.
2523:    """
2524:
2525:    @wraps(split_func)
2526:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2527:        for l in split_func(line, features):
2528:            normalize_prefix(l.leaves[0], inside_brackets=True)
2529:            yield l
2530:
2531:    return split_wrapper
2532:
2533:
2534:@dont_increase_indentation
2535:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2536:    """Split according to delimiters of the highest priority.
2537:
2538:    If the appropriate Features are given, the split will add trailing commas
2539:    also in function signatures and calls that contain `*` and `**`.
2540:    """
2541:    try:
2542:        last_leaf = line.leaves[-1]
2543:    except IndexError:
2544:        raise CannotSplit("Line empty")
2545:
2546:    bt = line.bracket_tracker
2547:    try:
2548:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2549:    except ValueError:
2550:        raise CannotSplit("No delimiters found")
2551:

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:909:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:910:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1190:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1200:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1275:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1371:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1381:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1722:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:1757:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2172:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2190:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2222:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2502:                    if leaves[i].type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2598:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2654:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2894:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2924:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:3224:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
880:            if node.prefix:
881:                # We don't have to handle prefixes for `Node` objects since
882:                # that delegates to the first child anyway.
883:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
884:            out(f" {node.value!r}", fg="blue", bold=False)
885:
886:    @classmethod
887:    def show(cls, code: Union[str, Leaf, Node]) -> None:
888:        """Pretty-print the lib2to3 AST of a given string of `code`.
889:
890:        Convenience method for debugging.
891:        """
892:        v: DebugVisitor[None] = DebugVisitor()
893:        if isinstance(code, str):
894:            code = lib2to3_parse(code)
895:        list(v.visit(code))
896:
897:
898:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
899:STATEMENT = {
900:    syms.if_stmt,
901:    syms.while_stmt,
902:    syms.for_stmt,
903:    syms.try_stmt,
904:    syms.except_clause,
905:    syms.with_stmt,
906:    syms.funcdef,
907:    syms.classdef,
908:}
909:STANDALONE_COMMENT = 153
910:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
911:LOGIC_OPERATORS = {"and", "or"}
912:COMPARATORS = {
913:    token.LESS,
914:    token.GREATER,
915:    token.EQEQUAL,
916:    token.NOTEQUAL,
917:    token.LESSEQUAL,
918:    token.GREATEREQUAL,
919:}
920:MATH_OPERATORS = {
921:    token.VBAR,
922:    token.CIRCUMFLEX,
923:    token.AMPER,
924:    token.LEFTSHIFT,
925:    token.RIGHTSHIFT,
926:    token.PLUS,
927:    token.MINUS,
928:    token.STAR,
929:    token.SLASH,
930:    token.DOUBLESLASH,
931:    token.PERCENT,
932:    token.AT,
933:    token.TILDE,
934:    token.DOUBLESTAR,
935:}
936:STARS = {token.STAR, token.DOUBLESTAR}
937:VARARGS_PARENTS = {
938:    syms.arglist,
939:    syms.argument,  # double star in arglist
940:    syms.trailer,  # single argument to call
941:    syms.typedargslist,
942:    syms.varargslist,  # lambdas
943:}
944:UNPACKING_PARENTS = {
945:    syms.atom,  # single element of a list or set literal
946:    syms.dictsetmaker,
947:    syms.listmaker,
948:    syms.testlist_gexp,
949:    syms.testlist_star_expr,
950:}
951:TEST_DESCENDANTS = {
952:    syms.test,
953:    syms.lambdef,
954:    syms.or_test,
955:    syms.and_test,
956:    syms.not_test,
957:    syms.comparison,
958:    syms.star_expr,
959:    syms.expr,
960:    syms.xor_expr,
961:    syms.and_expr,
962:    syms.shift_expr,
963:    syms.arith_expr,
964:    syms.trailer,
965:    syms.term,
966:    syms.power,
967:}
968:ASSIGNMENTS = {
969:    "=",
970:    "+=",
971:    "-=",
972:    "*=",
973:    "@=",
974:    "/=",
975:    "%=",
976:    "&=",
977:    "|=",
978:    "^=",
979:    "<<=",
980:    ">>=",
981:    "**=",
982:    "//=",
983:}
984:COMPREHENSION_PRIORITY = 20
985:COMMA_PRIORITY = 18
986:TERNARY_PRIORITY = 16
987:LOGIC_PRIORITY = 14
988:STRING_PRIORITY = 12
989:COMPARATOR_PRIORITY = 10
990:MATH_PRIORITIES = {
991:    token.VBAR: 9,
992:    token.CIRCUMFLEX: 8,
993:    token.AMPER: 7,
994:    token.LEFTSHIFT: 6,
995:    token.RIGHTSHIFT: 6,
996:    token.PLUS: 5,
997:    token.MINUS: 5,
998:    token.STAR: 4,
999:    token.SLASH: 4,
1000:    token.DOUBLESLASH: 4,
1001:    token.PERCENT: 4,
1002:    token.AT: 4,
1003:    token.TILDE: 3,
1004:    token.DOUBLESTAR: 2,
1005:}
1006:DOT_PRIORITY = 1
1007:
1008:
1009:@dataclass
1010:class BracketTracker:
1011:    """Keeps track of brackets on a line."""
1012:
1013:    depth: int = 0
1014:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
1015:    delimiters: Dict[LeafID, Priority] = Factory(dict)
1016:    previous: Optional[Leaf] = None
1017:    _for_loop_depths: List[int] = Factory(list)
1018:    _lambda_argument_depths: List[int] = Factory(list)
1019:
1020:    def mark(self, leaf: Leaf) -> None:
1021:        """Mark `leaf` with bracket-related metadata. Keep track of delimiters.
1022:
1023:        All leaves receive an int `bracket_depth` field that stores how deep
1024:        within brackets a given leaf is. 0 means there are no enclosing brackets
1025:        that started on this line.
1026:
1027:        If a leaf is itself a closing bracket, it receives an `opening_bracket`
1028:        field that it forms a pair with. This is a one-directional link to
1029:        avoid reference cycles.
1030:
1031:        If a leaf is a delimiter (a token on which Black can split the line if
1032:        needed) and it's on depth 0, its `id()` is stored in the tracker's
1033:        `delimiters` field.
1034:        """
1035:        if leaf.type == token.COMMENT:
1036:            return
1037:
1038:        self.maybe_decrement_after_for_loop_variable(leaf)
1039:        self.maybe_decrement_after_lambda_arguments(leaf)
1040:        if leaf.type in CLOSING_BRACKETS:
1041:            self.depth -= 1
1042:            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))
1043:            leaf.opening_bracket = opening_bracket
1044:        leaf.bracket_depth = self.depth
1045:        if self.depth == 0:
1046:            delim = is_split_before_delimiter(leaf, self.previous)
1047:            if delim and self.previous is not None:
1048:                self.delimiters[id(self.previous)] = delim
1049:            else:
1050:                delim = is_split_after_delimiter(leaf, self.previous)
1051:                if delim:
1052:                    self.delimiters[id(leaf)] = delim
1053:        if leaf.type in OPENING_BRACKETS:
1054:            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf
1055:            self.depth += 1
1056:        self.previous = leaf
1057:        self.maybe_increment_lambda_arguments(leaf)
1058:        self.maybe_increment_for_loop_variable(leaf)
1059:
1060:    def any_open_brackets(self) -> bool:
1061:        """Return True if there is an yet unmatched open bracket on the line."""
1062:        return bool(self.bracket_match)
1063:
1064:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> Priority:
1065:        """Return the highest priority of a delimiter found on the line.
1066:
1067:        Values are consistent with what `is_split_*_delimiter()` return.
1068:        Raises ValueError on no delimiters.
1069:        """
1070:        return max(v for k, v in self.delimiters.items() if k not in exclude)
1071:
1072:    def delimiter_count_with_priority(self, priority: Priority = 0) -> int:
1073:        """Return the number of delimiters with the given `priority`.
1074:
1075:        If no `priority` is passed, defaults to max priority on the line.
1076:        """
1077:        if not self.delimiters:
1078:            return 0
1079:
1080:        priority = priority or self.max_delimiter_priority()
1081:        return sum(1 for p in self.delimiters.values() if p == priority)
1082:
1083:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
1084:        """In a for loop, or comprehension, the variables are often unpacks.
1085:
1086:        To avoid splitting on the comma in this situation, increase the depth of
1087:        tokens between `for` and `in`.
1088:        """
1089:        if leaf.type == token.NAME and leaf.value == "for":
1090:            self.depth += 1
1091:            self._for_loop_depths.append(self.depth)
1092:            return True
1093:
1094:        return False
1095:
1096:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
1097:        """See `maybe_increment_for_loop_variable` above for explanation."""
1098:        if (
1099:            self._for_loop_depths
1100:            and self._for_loop_depths[-1] == self.depth
1101:            and leaf.type == token.NAME
1102:            and leaf.value == "in"
1103:        ):
1104:            self.depth -= 1
1105:            self._for_loop_depths.pop()
1106:            return True
1107:
1108:        return False
1109:
1110:    def maybe_increment_lambda_arguments(self, leaf: Leaf) -> bool:
1111:        """In a lambda expression, there might be more than one argument.
1112:
1113:        To avoid splitting on the comma in this situation, increase the depth of
1114:        tokens between `lambda` and `:`.
1115:        """
1116:        if leaf.type == token.NAME and leaf.value == "lambda":
1117:            self.depth += 1
1118:            self._lambda_argument_depths.append(self.depth)
1119:            return True
1120:
1121:        return False
1122:
1123:    def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:
1124:        """See `maybe_increment_lambda_arguments` above for explanation."""
1125:        if (
1126:            self._lambda_argument_depths
1127:            and self._lambda_argument_depths[-1] == self.depth
1128:            and leaf.type == token.COLON
1129:        ):
1130:            self.depth -= 1
1131:            self._lambda_argument_depths.pop()
1132:            return True
1133:
1134:        return False
1135:
1136:    def get_open_lsqb(self) -> Optional[Leaf]:
1137:        """Return the most recent opening square bracket (if any)."""
1138:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1139:
1140:
1141:@dataclass
1142:class Line:
1143:    """Holds leaves and comments. Can be printed with `str(line)`."""
1144:
1145:    depth: int = 0
1146:    leaves: List[Leaf] = Factory(list)
1147:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)  # keys ordered like `leaves`
1148:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1149:    inside_brackets: bool = False
1150:    should_explode: bool = False
1151:
1152:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1153:        """Add a new `leaf` to the end of the line.
1154:
1155:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1156:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1157:        Trailing commas are maybe removed, unpacked for loop variables are
1158:        demoted from being delimiters.
1159:
1160:        Inline comments are put aside.
1161:        """
1162:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1163:        if not has_value:
1164:            return
1165:
1166:        if token.COLON == leaf.type and self.is_class_paren_empty:
1167:            del self.leaves[-2:]
1168:        if self.leaves and not preformatted:
1169:            # Note: at this point leaf.prefix should be empty except for
1170:            # imports, for which we only preserve newlines.
1171:            leaf.prefix += whitespace(
1172:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1173:            )
1174:        if self.inside_brackets or not preformatted:
1175:            self.bracket_tracker.mark(leaf)
1176:            self.maybe_remove_trailing_comma(leaf)
1177:        if not self.append_comment(leaf):
1178:            self.leaves.append(leaf)
1179:
1180:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1181:        """Like :func:`append()` but disallow invalid standalone comment structure.
1182:
1183:        Raises ValueError when any `leaf` is appended after a standalone comment
1184:        or when a standalone comment is not the first leaf on the line.
1185:        """
1186:        if self.bracket_tracker.depth == 0:
1187:            if self.is_comment:
1188:                raise ValueError("cannot append to standalone comments")
1189:
1190:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1191:                raise ValueError(
1192:                    "cannot append standalone comments to a populated line"
1193:                )
1194:
1195:        self.append(leaf, preformatted=preformatted)
1196:
1197:    @property
1198:    def is_comment(self) -> bool:
1199:        """Is this line a standalone comment?"""
1200:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1201:
1202:    @property
1203:    def is_decorator(self) -> bool:
1204:        """Is this line a decorator?"""
1205:        return bool(self) and self.leaves[0].type == token.AT
1206:
1207:    @property
1208:    def is_import(self) -> bool:
1209:        """Is this an import line?"""
1210:        return bool(self) and is_import(self.leaves[0])
1211:
1212:    @property
1213:    def is_class(self) -> bool:
1214:        """Is this line a class definition?"""
1215:        return (
1216:            bool(self)
1217:            and self.leaves[0].type == token.NAME
1218:            and self.leaves[0].value == "class"
1219:        )

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
1220:
1221:    @property
1222:    def is_stub_class(self) -> bool:
1223:        """Is this line a class definition with a body consisting only of "..."?"""
1224:        return self.is_class and self.leaves[-3:] == [
1225:            Leaf(token.DOT, ".") for _ in range(3)
1226:        ]
1227:
1228:    @property
1229:    def is_def(self) -> bool:
1230:        """Is this a function definition? (Also returns True for async defs.)"""
1231:        try:
1232:            first_leaf = self.leaves[0]
1233:        except IndexError:
1234:            return False
1235:
1236:        try:
1237:            second_leaf: Optional[Leaf] = self.leaves[1]
1238:        except IndexError:
1239:            second_leaf = None
1240:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1241:            first_leaf.type == token.ASYNC
1242:            and second_leaf is not None
1243:            and second_leaf.type == token.NAME
1244:            and second_leaf.value == "def"
1245:        )
1246:
1247:    @property
1248:    def is_class_paren_empty(self) -> bool:
1249:        """Is this a class with no base classes but using parentheses?
1250:
1251:        Those are unnecessary and should be removed.
1252:        """
1253:        return (
1254:            bool(self)
1255:            and len(self.leaves) == 4
1256:            and self.is_class
1257:            and self.leaves[2].type == token.LPAR
1258:            and self.leaves[2].value == "("
1259:            and self.leaves[3].type == token.RPAR
1260:            and self.leaves[3].value == ")"
1261:        )
1262:
1263:    @property
1264:    def is_triple_quoted_string(self) -> bool:
1265:        """Is the line a triple quoted string?"""
1266:        return (
1267:            bool(self)
1268:            and self.leaves[0].type == token.STRING
1269:            and self.leaves[0].value.startswith(('"""', "'''"))
1270:        )
1271:
1272:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1273:        """If so, needs to be split before emitting."""
1274:        for leaf in self.leaves:
1275:            if leaf.type == STANDALONE_COMMENT:
1276:                if leaf.bracket_depth <= depth_limit:
1277:                    return True
1278:        return False
1279:
1280:    def contains_inner_type_comments(self) -> bool:
1281:        ignored_ids = set()
1282:        try:
1283:            last_leaf = self.leaves[-1]
1284:            ignored_ids.add(id(last_leaf))
1285:            if last_leaf.type == token.COMMA:
1286:                # When trailing commas are inserted by Black for consistency, comments
1287:                # after the previous last element are not moved (they don't have to,
1288:                # rendering will still be correct).  So we ignore trailing commas.
1289:                last_leaf = self.leaves[-2]
1290:                ignored_ids.add(id(last_leaf))
1291:        except IndexError:
1292:            return False
1293:
1294:        for leaf_id, comments in self.comments.items():
1295:            if leaf_id in ignored_ids:
1296:                continue
1297:
1298:            for comment in comments:
1299:                if is_type_comment(comment):
1300:                    return True
1301:
1302:        return False
1303:
1304:    def contains_multiline_strings(self) -> bool:
1305:        for leaf in self.leaves:
1306:            if is_multiline_string(leaf):
1307:                return True
1308:
1309:        return False
1310:
1311:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1312:        """Remove trailing comma if there is one and it's safe."""
1313:        if not (
1314:            self.leaves
1315:            and self.leaves[-1].type == token.COMMA
1316:            and closing.type in CLOSING_BRACKETS
1317:        ):
1318:            return False
1319:
1320:        if closing.type == token.RBRACE:
1321:            self.remove_trailing_comma()
1322:            return True
1323:
1324:        if closing.type == token.RSQB:
1325:            comma = self.leaves[-1]
1326:            if comma.parent and comma.parent.type == syms.listmaker:
1327:                self.remove_trailing_comma()
1328:                return True
1329:
1330:        # For parens let's check if it's safe to remove the comma.
1331:        # Imports are always safe.
1332:        if self.is_import:
1333:            self.remove_trailing_comma()
1334:            return True
1335:
1336:        # Otherwise, if the trailing one is the only one, we might mistakenly
1337:        # change a tuple into a different type by removing the comma.
1338:        depth = closing.bracket_depth + 1
1339:        commas = 0
1340:        opening = closing.opening_bracket
1341:        for _opening_index, leaf in enumerate(self.leaves):
1342:            if leaf is opening:
1343:                break
1344:
1345:        else:
1346:            return False
1347:
1348:        for leaf in self.leaves[_opening_index + 1 :]:
1349:            if leaf is closing:
1350:                break
1351:
1352:            bracket_depth = leaf.bracket_depth
1353:            if bracket_depth == depth and leaf.type == token.COMMA:
1354:                commas += 1
1355:                if leaf.parent and leaf.parent.type in {
1356:                    syms.arglist,
1357:                    syms.typedargslist,
1358:                }:
1359:                    commas += 1
1360:                    break
1361:
1362:        if commas > 1:
1363:            self.remove_trailing_comma()
1364:            return True
1365:
1366:        return False
1367:
1368:    def append_comment(self, comment: Leaf) -> bool:
1369:        """Add an inline or standalone comment to the line."""
1370:        if (
1371:            comment.type == STANDALONE_COMMENT
1372:            and self.bracket_tracker.any_open_brackets()
1373:        ):
1374:            comment.prefix = ""
1375:            return False
1376:
1377:        if comment.type != token.COMMENT:
1378:            return False
1379:
1380:        if not self.leaves:
1381:            comment.type = STANDALONE_COMMENT
1382:            comment.prefix = ""
1383:            return False
1384:
1385:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1386:        return True
1387:
1388:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1389:        """Generate comments that should appear directly after `leaf`."""
1390:        return self.comments.get(id(leaf), [])
1391:
1392:    def remove_trailing_comma(self) -> None:
1393:        """Remove the trailing comma and moves the comments attached to it."""
1394:        trailing_comma = self.leaves.pop()
1395:        trailing_comma_comments = self.comments.pop(id(trailing_comma), [])
1396:        self.comments.setdefault(id(self.leaves[-1]), []).extend(
1397:            trailing_comma_comments
1398:        )
1399:
1400:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1401:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1402:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1403:        if open_lsqb is None:
1404:            return False
1405:
1406:        subscript_start = open_lsqb.next_sibling
1407:
1408:        if isinstance(subscript_start, Node):
1409:            if subscript_start.type == syms.listmaker:
1410:                return False
1411:
1412:            if subscript_start.type == syms.subscriptlist:
1413:                subscript_start = child_towards(subscript_start, leaf)
1414:        return subscript_start is not None and any(
1415:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()
1416:        )
1417:
1418:    def __str__(self) -> str:
1419:        """Render the line."""
1420:        if not self:
1421:            return "\n"
1422:
1423:        indent = "    " * self.depth
1424:        leaves = iter(self.leaves)
1425:        first = next(leaves)
1426:        res = f"{first.prefix}{indent}{first.value}"
1427:        for leaf in leaves:
1428:            res += str(leaf)
1429:        for comment in itertools.chain.from_iterable(self.comments.values()):
1430:            res += str(comment)
1431:        return res + "\n"
1432:
1433:    def __bool__(self) -> bool:
1434:        """Return True if the line has leaves or comments."""
1435:        return bool(self.leaves or self.comments)
1436:
1437:
1438:@dataclass
1439:class EmptyLineTracker:
1440:    """Provides a stateful method that returns the number of potential extra
1441:    empty lines needed before and after the currently processed line.
1442:
1443:    Note: this tracker works on lines that haven't been split yet.  It assumes
1444:    the prefix of the first leaf consists of optional newlines.  Those newlines
1445:    are consumed by `maybe_empty_lines()` and included in the computation.
1446:    """
1447:
1448:    is_pyi: bool = False
1449:    previous_line: Optional[Line] = None
1450:    previous_after: int = 0
1451:    previous_defs: List[int] = Factory(list)
1452:
1453:    def maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1454:        """Return the number of extra empty lines before and after the `current_line`.
1455:
1456:        This is for separating `def`, `async def` and `class` with extra empty
1457:        lines (two on module-level).
1458:        """
1459:        before, after = self._maybe_empty_lines(current_line)
1460:        before -= self.previous_after
1461:        self.previous_after = after
1462:        self.previous_line = current_line
1463:        return before, after
1464:
1465:    def _maybe_empty_lines(self, current_line: Line) -> Tuple[int, int]:
1466:        max_allowed = 1
1467:        if current_line.depth == 0:
1468:            max_allowed = 1 if self.is_pyi else 2
1469:        if current_line.leaves:
1470:            # Consume the first leaf's extra newlines.
1471:            first_leaf = current_line.leaves[0]
1472:            before = first_leaf.prefix.count("\n")
1473:            before = min(before, max_allowed)
1474:            first_leaf.prefix = ""
1475:        else:
1476:            before = 0
1477:        depth = current_line.depth
1478:        while self.previous_defs and self.previous_defs[-1] >= depth:
1479:            self.previous_defs.pop()
1480:            if self.is_pyi:
1481:                before = 0 if depth else 1
1482:            else:
1483:                before = 1 if depth else 2
1484:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
1485:            return self._maybe_empty_lines_for_class_or_def(current_line, before)
1486:
1487:        if (
1488:            self.previous_line
1489:            and self.previous_line.is_import
1490:            and not current_line.is_import
1491:            and depth == self.previous_line.depth
1492:        ):
1493:            return (before or 1), 0
1494:
1495:        if (
1496:            self.previous_line
1497:            and self.previous_line.is_class
1498:            and current_line.is_triple_quoted_string
1499:        ):
1500:            return before, 1
1501:
1502:        return before, 0
1503:
1504:    def _maybe_empty_lines_for_class_or_def(
1505:        self, current_line: Line, before: int
1506:    ) -> Tuple[int, int]:
1507:        if not current_line.is_decorator:
1508:            self.previous_defs.append(current_line.depth)
1509:        if self.previous_line is None:
1510:            # Don't insert empty lines before the first line in the file.
1511:            return 0, 0
1512:
1513:        if self.previous_line.is_decorator:
1514:            return 0, 0
1515:
1516:        if self.previous_line.depth < current_line.depth and (
1517:            self.previous_line.is_class or self.previous_line.is_def
1518:        ):
1519:            return 0, 0
1520:
1521:        if (
1522:            self.previous_line.is_comment
1523:            and self.previous_line.depth == current_line.depth
1524:            and before == 0
1525:        ):
1526:            return 0, 0
1527:
1528:        if self.is_pyi:
1529:            if self.previous_line.depth > current_line.depth:
1530:                newlines = 1
1531:            elif current_line.is_class or self.previous_line.is_class:
1532:                if current_line.is_stub_class and self.previous_line.is_stub_class:
1533:                    # No blank line between classes with an empty body
1534:                    newlines = 0
1535:                else:
1536:                    newlines = 1
1537:            elif current_line.is_def and not self.previous_line.is_def:
1538:                # Blank line between a block of functions and a block of non-functions
1539:                newlines = 1
1540:            else:
1541:                newlines = 0
1542:        else:
1543:            newlines = 2
1544:        if current_line.depth and newlines:
1545:            newlines -= 1
1546:        return newlines, 0
1547:
1548:
1549:@dataclass
1550:class LineGenerator(Visitor[Line]):
1551:    """Generates reformatted Line objects.  Empty lines are not emitted.
1552:
1553:    Note: destroys the tree it's visiting by mutating prefixes of its leaves
1554:    in ways that will no longer stringify to valid Python code on the tree.
1555:    """
1556:
1557:    is_pyi: bool = False
1558:    normalize_strings: bool = True
1559:    current_line: Line = Factory(Line)
1560:    remove_u_prefix: bool = False
1561:
1562:    def line(self, indent: int = 0) -> Iterator[Line]:
1563:        """Generate a line.
1564:
1565:        If the line is empty, only emit if it makes sense.
1566:        If the line is too long, split it first and then generate.
1567:
1568:        If any lines were generated, set up a new current_line.
1569:        """
1570:        if not self.current_line:
1571:            self.current_line.depth += indent
1572:            return  # Line is empty, don't emit. Creating a new one unnecessary.
1573:
1574:        complete_line = self.current_line
1575:        self.current_line = Line(depth=complete_line.depth + indent)
1576:        yield complete_line
1577:
1578:    def visit_default(self, node: LN) -> Iterator[Line]:
1579:        """Default `visit_*()` implementation. Recurses to children of `node`."""
1580:        if isinstance(node, Leaf):
1581:            any_open_brackets = self.current_line.bracket_tracker.any_open_brackets()
1582:            for comment in generate_comments(node):
1583:                if any_open_brackets:
1584:                    # any comment within brackets is subject to splitting
1585:                    self.current_line.append(comment)
1586:                elif comment.type == token.COMMENT:
1587:                    # regular trailing comment
1588:                    self.current_line.append(comment)
1589:                    yield from self.line()
1590:
1591:                else:
1592:                    # regular standalone comment
1593:                    yield from self.line()
1594:
1595:                    self.current_line.append(comment)
1596:                    yield from self.line()
1597:
1598:            normalize_prefix(node, inside_brackets=any_open_brackets)
1599:            if self.normalize_strings and node.type == token.STRING:
1600:                normalize_string_prefix(node, remove_u_prefix=self.remove_u_prefix)
1601:                normalize_string_quotes(node)
1602:            if node.type == token.NUMBER:
1603:                normalize_numeric_literal(node)
1604:            if node.type not in WHITESPACE:
1605:                self.current_line.append(node)
1606:        yield from super().visit_default(node)
1607:
1608:    def visit_atom(self, node: Node) -> Iterator[Line]:
1609:        # Always make parentheses invisible around a single node, because it should
1610:        # not be needed (except in the case of yield, where removing the parentheses
1611:        # produces a SyntaxError).
1612:        if (
1613:            len(node.children) == 3
1614:            and isinstance(node.children[0], Leaf)
1615:            and node.children[0].type == token.LPAR
1616:            and isinstance(node.children[2], Leaf)
1617:            and node.children[2].type == token.RPAR
1618:            and isinstance(node.children[1], Leaf)
1619:            and not (
1620:                node.children[1].type == token.NAME
1621:                and node.children[1].value == "yield"
1622:            )
1623:        ):
1624:            node.children[0].value = ""
1625:            node.children[2].value = ""
1626:        yield from super().visit_default(node)
1627:
1628:    def visit_INDENT(self, node: Node) -> Iterator[Line]:
1629:        """Increase indentation level, maybe yield a line."""
1630:        # In blib2to3 INDENT never holds comments.
1631:        yield from self.line(+1)
1632:        yield from self.visit_default(node)
1633:
1634:    def visit_DEDENT(self, node: Node) -> Iterator[Line]:
1635:        """Decrease indentation level, maybe yield a line."""
1636:        # The current line might still wait for trailing comments.  At DEDENT time
1637:        # there won't be any (they would be prefixes on the preceding NEWLINE).
1638:        # Emit the line then.
1639:        yield from self.line()
1640:
1641:        # While DEDENT has no value, its prefix may contain standalone comments
1642:        # that belong to the current indentation level.  Get 'em.
1643:        yield from self.visit_default(node)
1644:
1645:        # Finally, emit the dedent.
1646:        yield from self.line(-1)
1647:
1648:    def visit_stmt(
1649:        self, node: Node, keywords: Set[str], parens: Set[str]
1650:    ) -> Iterator[Line]:
1651:        """Visit a statement.
1652:
1653:        This implementation is shared for `if`, `while`, `for`, `try`, `except`,
1654:        `def`, `with`, `class`, `assert` and assignments.
1655:
1656:        The relevant Python language `keywords` for a given statement will be
1657:        NAME leaves within it. This methods puts those on a separate line.
1658:
1659:        `parens` holds a set of string leaf values immediately after which
1660:        invisible parens should be put.
1661:        """
1662:        normalize_invisible_parens(node, parens_after=parens)
1663:        for child in node.children:
1664:            if child.type == token.NAME and child.value in keywords:  # type: ignore
1665:                yield from self.line()
1666:
1667:            yield from self.visit(child)
1668:
1669:    def visit_suite(self, node: Node) -> Iterator[Line]:
1670:        """Visit a suite."""
1671:        if self.is_pyi and is_stub_suite(node):
1672:            yield from self.visit(node.children[2])
1673:        else:
1674:            yield from self.visit_default(node)
1675:
1676:    def visit_simple_stmt(self, node: Node) -> Iterator[Line]:
1677:        """Visit a statement without nested statements."""
1678:        is_suite_like = node.parent and node.parent.type in STATEMENT
1679:        if is_suite_like:
1680:            if self.is_pyi and is_stub_body(node):
1681:                yield from self.visit_default(node)
1682:            else:
1683:                yield from self.line(+1)
1684:                yield from self.visit_default(node)
1685:                yield from self.line(-1)
1686:
1687:        else:
1688:            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):
1689:                yield from self.line()
1690:            yield from self.visit_default(node)
1691:
1692:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:
1693:        """Visit `async def`, `async for`, `async with`."""
1694:        yield from self.line()
1695:
1696:        children = iter(node.children)
1697:        for child in children:
1698:            yield from self.visit(child)
1699:
1700:            if child.type == token.ASYNC:
1701:                break
1702:
1703:        internal_stmt = next(children)
1704:        for child in internal_stmt.children:
1705:            yield from self.visit(child)
1706:
1707:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1708:        """Visit decorators."""
1709:        for child in node.children:
1710:            yield from self.line()
1711:            yield from self.visit(child)
1712:
1713:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1714:        """Remove a semicolon and put the other statement on a separate line."""
1715:        yield from self.line()
1716:
1717:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1718:        """End of file. Process outstanding comments and end with a newline."""
1719:        yield from self.visit_default(leaf)
1720:        yield from self.line()
1721:
1722:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1723:        if not self.current_line.bracket_tracker.any_open_brackets():
1724:            yield from self.line()
1725:        yield from self.visit_default(leaf)
1726:
1727:    def __attrs_post_init__(self) -> None:
1728:        """You are in a twisty little maze of passages."""
1729:        v = self.visit_stmt
1730:        Ø: Set[str] = set()
1731:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1732:        self.visit_if_stmt = partial(
1733:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1734:        )
1735:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1736:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1737:        self.visit_try_stmt = partial(
1738:            v, keywords={"try", "except", "else", "finally"}, parens=Ø
1739:        )

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py
2160:    move because it does away with modifying the grammar to include all the
2161:    possible places in which comments can be placed.
2162:
2163:    The sad consequence for us though is that comments don't "belong" anywhere.
2164:    This is why this function generates simple parentless Leaf objects for
2165:    comments.  We simply don't know what the correct parent should be.
2166:
2167:    No matter though, we can live without this.  We really only need to
2168:    differentiate between inline and standalone comments.  The latter don't
2169:    share the line with any code.
2170:
2171:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2172:    are emitted with a fake STANDALONE_COMMENT token identifier.
2173:    """
2174:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2175:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2176:
2177:
2178:@dataclass
2179:class ProtoComment:
2180:    """Describes a piece of syntax that is a comment.
2181:
2182:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2183:
2184:    * it can be cached (`Leaf` objects should not be reused more than once as
2185:      they store their lineno, column, prefix, and parent information);
2186:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2187:      simplifies handling of special marker comments like ``# fmt: off/on``.
2188:    """
2189:
2190:    type: int  # token.COMMENT or STANDALONE_COMMENT
2191:    value: str  # content of the comment
2192:    newlines: int  # how many newlines before the comment
2193:    consumed: int  # how many characters of the original leaf's prefix did we consume
2194:
2195:
2196:@lru_cache(maxsize=4096)
2197:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2198:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2199:    result: List[ProtoComment] = []
2200:    if not prefix or "#" not in prefix:
2201:        return result
2202:
2203:    consumed = 0
2204:    nlines = 0
2205:    ignored_lines = 0
2206:    for index, line in enumerate(prefix.split("\n")):
2207:        consumed += len(line) + 1  # adding the length of the split '\n'
2208:        line = line.lstrip()
2209:        if not line:
2210:            nlines += 1
2211:        if not line.startswith("#"):
2212:            # Escaped newlines outside of a comment are not really newlines at
2213:            # all. We treat a single-line comment following an escaped newline
2214:            # as a simple trailing comment.
2215:            if line.endswith("\\"):
2216:                ignored_lines += 1
2217:            continue
2218:
2219:        if index == ignored_lines and not is_endmarker:
2220:            comment_type = token.COMMENT  # simple trailing comment
2221:        else:
2222:            comment_type = STANDALONE_COMMENT
2223:        comment = make_comment(line)
2224:        result.append(
2225:            ProtoComment(
2226:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2227:            )
2228:        )
2229:        nlines = 0
2230:    return result
2231:
2232:
2233:def make_comment(content: str) -> str:
2234:    """Return a consistently formatted comment from the given `content` string.
2235:
2236:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2237:    space between the hash sign and the content.
2238:
2239:    If `content` didn't start with a hash sign, one is provided.
2240:    """
2241:    content = content.rstrip()
2242:    if not content:
2243:        return "#"
2244:
2245:    if content[0] == "#":
2246:        content = content[1:]
2247:    if content and content[0] not in " !:#'%":
2248:        content = " " + content
2249:    return "#" + content
2250:
2251:
2252:def split_line(
2253:    line: Line,
2254:    line_length: int,
2255:    inner: bool = False,
2256:    features: Collection[Feature] = (),
2257:) -> Iterator[Line]:
2258:    """Split a `line` into potentially many lines.
2259:

Calling tool: grepTool
be careful not to add one after any comments
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/black.py:2495:            # be careful not to add one after any comments.

Calling tool: grepTool
test_function_trailing_comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_function_trailing_comma
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py:268:    def test_function_trailing_comma(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/test_black.py
250:
251:    @patch("black.dump_to_file", dump_to_stderr)
252:    def test_function(self) -> None:
253:        source, expected = read_data("function")
254:        actual = fs(source)
255:        self.assertFormatEqual(expected, actual)
256:        black.assert_equivalent(source, actual)
257:        black.assert_stable(source, actual, black.FileMode())
258:
259:    @patch("black.dump_to_file", dump_to_stderr)
260:    def test_function2(self) -> None:
261:        source, expected = read_data("function2")
262:        actual = fs(source)
263:        self.assertFormatEqual(expected, actual)
264:        black.assert_equivalent(source, actual)
265:        black.assert_stable(source, actual, black.FileMode())
266:
267:    @patch("black.dump_to_file", dump_to_stderr)
268:    def test_function_trailing_comma(self) -> None:
269:        source, expected = read_data("function_trailing_comma")
270:        actual = fs(source)
271:        self.assertFormatEqual(expected, actual)
272:        black.assert_equivalent(source, actual)
273:        black.assert_stable(source, actual, black.FileMode())
274:
275:    @patch("black.dump_to_file", dump_to_stderr)
276:    def test_expression(self) -> None:
277:        source, expected = read_data("expression")
278:        actual = fs(source)
279:        self.assertFormatEqual(expected, actual)
280:        black.assert_equivalent(source, actual)
281:        black.assert_stable(source, actual, black.FileMode())
282:
283:    def test_expression_ff(self) -> None:
284:        source, expected = read_data("expression")
285:        tmp_file = Path(black.dump_to_file(source))
286:        try:
287:            self.assertTrue(ff(tmp_file, write_back=black.WriteBack.YES))
288:            with open(tmp_file, encoding="utf8") as f:
289:                actual = f.read()
290:        finally:
291:            os.unlink(tmp_file)
292:        self.assertFormatEqual(expected, actual)
293:        with patch("black.dump_to_file", dump_to_stderr):
294:            black.assert_equivalent(source, actual)
295:            black.assert_stable(source, actual, black.FileMode())
296:
297:    def test_expression_diff(self) -> None:
298:        source, _ = read_data("expression.py")
299:        expected, _ = read_data("expression.diff")
300:        tmp_file = Path(black.dump_to_file(source))
301:        diff_header = re.compile(
302:            rf"{re.escape(str(tmp_file))}\t\d\d\d\d-\d\d-\d\d "
303:            rf"\d\d:\d\d:\d\d\.\d\d\d\d\d\d \+\d\d\d\d"
304:        )
305:        try:
306:            result = BlackRunner().invoke(black.main, ["--diff", str(tmp_file)])
307:            self.assertEqual(result.exit_code, 0)
308:        finally:
309:            os.unlink(tmp_file)
310:        actual = result.output
311:        actual = diff_header.sub("[Deterministic header]", actual)
312:        actual = actual.rstrip() + "\n"  # the diff output has a trailing space
313:        if expected != actual:
314:            dump = black.dump_to_file(actual)
315:            msg = (
316:                f"Expected diff isn't equal to the actual. If you made changes "
317:                f"to expression.py and this is an anticipated difference, "
318:                f"overwrite tests/data/expression.diff with {dump}"
319:            )
320:            self.assertEqual(expected, actual, msg)
321:
322:    @patch("black.dump_to_file", dump_to_stderr)
323:    def test_fstring(self) -> None:
324:        source, expected = read_data("fstring")
325:        actual = fs(source)
326:        self.assertFormatEqual(expected, actual)
327:        black.assert_equivalent(source, actual)
328:        black.assert_stable(source, actual, black.FileMode())
329:

Calling tool: globTool
**/tests/data/function_trailing_comma*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-5/good/black/tests/data/function_trailing_comma.py
1:def f(a,):
2:    ...
3:
4:def f(a:int=1,):
5:    ...
6:
7:# output
8:
9:def f(a):
10:    ...
11:
12:
13:def f(a: int = 1):
14:    ...

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as INCORRECT
Reason: In bracket_split_build_line, the skip logic only checks STANDALONE_COMMENT, but inline comments are token.COMMENT and are attached via comments_after(). Since they’re not in leaves, the inserted comma will come after an inline comment (e.g., `a  # cmt,`). So comments other than STANDALONE_COMMENT need handling to satisfy “not to add one after any comments.”


=== PHASE 2 COMPLETE ===

