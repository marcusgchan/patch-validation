=== PHASE 1: ANALYSIS ===

Calling tool: createTodo
Todo List Created
Todo List (11 items):
- [ ] In `black.py`, locate `bracket_split_build_line` and verify the trailing-comma logic is only applied when `original.is_import` and `leaves` is non-empty, preserving existing behavior for non-import cases. (ID: todo-1)
- [ ] Confirm `STANDALONE_COMMENT` is defined/imported in `black.py` and accessible within `bracket_split_build_line` (no NameError risk). Identify its definition to ensure it represents standalone comment leaves used in this code path. (ID: todo-2)
- [ ] Verify the new loop iterates backward over `leaves` and correctly skips all trailing `STANDALONE_COMMENT` leaves before making a decision about inserting a comma. (ID: todo-3)
- [ ] Check that the condition `elif leaves[i].type == token.COMMA: break` prevents inserting an additional comma when a trailing comma already exists before trailing comments (i.e., handles the regression case from Issue #671). (ID: todo-4)
- [ ] Verify that when the last non-comment leaf is not a comma, `leaves.insert(i + 1, Leaf(token.COMMA, ","))` inserts the comma immediately after that leaf (and not after any comments), matching the PR intent. (ID: todo-5)
- [ ] Confirm that if all trailing leaves are comments (or all leaves are comments), the loop exits without inserting a comma (i.e., no dangling comma is added at the end of the block). (ID: todo-6)
- [ ] Ensure that use of `Leaf(token.COMMA, ",")` is consistent with similar code elsewhere in the file (e.g., previously appended commas) and that `Leaf` and `token` are in scope for this function. (ID: todo-7)
- [ ] Verify that no remaining code paths still append a trailing comma for imports by only checking the last leaf (i.e., search for other 'Ensure a trailing comma' or `original.is_import` logic that might conflict and still append after comments). (ID: todo-8)
- [ ] Check that the surrounding logic remains unchanged and correct: `normalize_prefix(leaves[0], inside_brackets=True)` still runs and the subsequent population of `result` (`result.append(leaf, preformatted=True)`) is unaffected by the change. (ID: todo-9)
- [ ] Open the `test_comments7` test and confirm it covers a `from ... import (...)` block with commented-out lines at the end and asserts that the formatted result does not contain a standalone comma before the closing parenthesis (i.e., avoids the invalid output shown in Issue #671). (ID: todo-10)
- [ ] In `test_comments7`, verify that when the last real imported name lacks a trailing comma but is followed by comments, the expected formatted output contains a comma immediately after that name (before comments), not at the very end after comments. (ID: todo-11)


=== PHASE 1 COMPLETE ===

=== PHASE 2: VALIDATION ===

Validating todo item 1 of 11
description: 'In `black.py`, locate `bracket_split_build_line` and verify the trailing-comma logic is only applied when `original.is_import` and `leaves` is non-empty, preserving existing behavior for non-import cases.'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize
2468:    trailing_comma_safe = True
2469:
2470:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2471:        """Append `leaf` to current line or to new line if appending impossible."""
2472:        nonlocal current_line

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py’s bracket_split_build_line (lines 2405-2418), the trailing comma insertion is gated by `if leaves:` and further by `if original.is_import:`. No trailing comma logic is applied for non-import cases, preserving prior behavior.


Todo item 1 of 11 is correct
description: 'In `black.py`, locate `bracket_split_build_line` and verify the trailing-comma logic is only applied when `original.is_import` and `leaves` is non-empty, preserving existing behavior for non-import cases.'
Validating todo item 2 of 11
description: 'Confirm `STANDALONE_COMMENT` is defined/imported in `black.py` and accessible within `bracket_split_build_line` (no NameError risk). Identify its definition to ensure it represents standalone comment leaves used in this code path.'
Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:852:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1218:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1311:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1321:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2136:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2412:                    if leaves[i].type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2784:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2814:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3114:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
840:
841:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
842:STATEMENT = {
843:    syms.if_stmt,
844:    syms.while_stmt,
845:    syms.for_stmt,
846:    syms.try_stmt,
847:    syms.except_clause,
848:    syms.with_stmt,
849:    syms.funcdef,
850:    syms.classdef,
851:}
852:STANDALONE_COMMENT = 153
853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
854:LOGIC_OPERATORS = {"and", "or"}
855:COMPARATORS = {
856:    token.LESS,
857:    token.GREATER,
858:    token.EQEQUAL,
859:    token.NOTEQUAL,
860:    token.LESSEQUAL,
861:    token.GREATEREQUAL,
862:}
863:MATH_OPERATORS = {
864:    token.VBAR,
865:    token.CIRCUMFLEX,
866:    token.AMPER,
867:    token.LEFTSHIFT,
868:    token.RIGHTSHIFT,
869:    token.PLUS,
870:    token.MINUS,
871:    token.STAR,
872:    token.SLASH,
873:    token.DOUBLESLASH,
874:    token.PERCENT,
875:    token.AT,
876:    token.TILDE,
877:    token.DOUBLESTAR,
878:}
879:STARS = {token.STAR, token.DOUBLESTAR}

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2086:
2087:    No matter though, we can live without this.  We really only need to
2088:    differentiate between inline and standalone comments.  The latter don't
2089:    share the line with any code.
2090:
2091:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
2093:    """
2094:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2095:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2096:
2097:
2098:@dataclass
2099:class ProtoComment:
2100:    """Describes a piece of syntax that is a comment.
2101:
2102:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2103:
2104:    * it can be cached (`Leaf` objects should not be reused more than once as
2105:      they store their lineno, column, prefix, and parent information);
2106:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2107:      simplifies handling of special marker comments like ``# fmt: off/on``.
2108:    """
2109:
2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
2111:    value: str  # content of the comment
2112:    newlines: int  # how many newlines before the comment
2113:    consumed: int  # how many characters of the original leaf's prefix did we consume
2114:
2115:
2116:@lru_cache(maxsize=4096)
2117:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2118:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2119:    result: List[ProtoComment] = []
2120:    if not prefix or "#" not in prefix:
2121:        return result
2122:
2123:    consumed = 0
2124:    nlines = 0
2125:    for index, line in enumerate(prefix.split("\n")):
2126:        consumed += len(line) + 1  # adding the length of the split '\n'
2127:        line = line.lstrip()
2128:        if not line:
2129:            nlines += 1
2130:        if not line.startswith("#"):
2131:            continue
2132:
2133:        if index == 0 and not is_endmarker:
2134:            comment_type = token.COMMENT  # simple trailing comment
2135:        else:
2136:            comment_type = STANDALONE_COMMENT
2137:        comment = make_comment(line)
2138:        result.append(
2139:            ProtoComment(
2140:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2141:            )
2142:        )
2143:        nlines = 0
2144:    return result
2145:
2146:
2147:def make_comment(content: str) -> str:
2148:    """Return a consistently formatted comment from the given `content` string.
2149:
2150:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2151:    space between the hash sign and the content.
2152:
2153:    If `content` didn't start with a hash sign, one is provided.
2154:    """
2155:    content = content.rstrip()
2156:    if not content:
2157:        return "#"
2158:
2159:    if content[0] == "#":
2160:        content = content[1:]
2161:    if content and content[0] not in " !:#'%":
2162:        content = " " + content
2163:    return "#" + content
2164:
2165:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: STANDALONE_COMMENT is defined at black.py:852 and registered in token.tok_name; it’s used throughout to mark standalone comment leaves (e.g., set in list_comments at lines 2133-2137). bracket_split_build_line (around 2393-2418) references it in-scope, so there’s no NameError risk.


Todo item 2 of 11 is correct
description: 'Confirm `STANDALONE_COMMENT` is defined/imported in `black.py` and accessible within `bracket_split_build_line` (no NameError risk). Identify its definition to ensure it represents standalone comment leaves used in this code path.'
Validating todo item 3 of 11
description: 'Verify the new loop iterates backward over `leaves` and correctly skips all trailing `STANDALONE_COMMENT` leaves before making a decision about inserting a comma.'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize
2468:    trailing_comma_safe = True
2469:
2470:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2471:        """Append `leaf` to current line or to new line if appending impossible."""
2472:        nonlocal current_line
2473:        try:
2474:            current_line.append_safe(leaf, preformatted=True)
2475:        except ValueError:
2476:            yield current_line
2477:
2478:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2479:            current_line.append(leaf)
2480:
2481:    for leaf in line.leaves:
2482:        yield from append_to_line(leaf)
2483:
2484:        for comment_after in line.comments_after(leaf):
2485:            yield from append_to_line(comment_after)
2486:
2487:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2488:        if leaf.bracket_depth == lowest_depth:
2489:            if is_vararg(leaf, within={syms.typedargslist}):
2490:                trailing_comma_safe = (
2491:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features
2492:                )
2493:            elif is_vararg(leaf, within={syms.arglist, syms.argument}):
2494:                trailing_comma_safe = (
2495:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features
2496:                )
2497:
2498:        leaf_priority = bt.delimiters.get(id(leaf))
2499:        if leaf_priority == delimiter_priority:
2500:            yield current_line
2501:
2502:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2503:    if current_line:
2504:        if (
2505:            trailing_comma_safe
2506:            and delimiter_priority == COMMA_PRIORITY
2507:            and current_line.leaves[-1].type != token.COMMA

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py:2393+, the loop iterates from the end toward the start (range(len(leaves)-1, -1, -1)) and continues past any STANDALONE_COMMENT leaves. It then checks the first non-comment: if it’s a COMMA it breaks, otherwise inserts a comma at i+1. This correctly skips trailing comments before deciding on insertion.


Todo item 3 of 11 is correct
description: 'Verify the new loop iterates backward over `leaves` and correctly skips all trailing `STANDALONE_COMMENT` leaves before making a decision about inserting a comma.'
Validating todo item 4 of 11
description: 'Check that the condition `elif leaves[i].type == token.COMMA: break` prevents inserting an additional comma when a trailing comma already exists before trailing comments (i.e., handles the regression case from Issue #671).'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize

Calling tool: grepTool
test_comments7\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments7
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py:392:    def test_comments7(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py
380:        black.assert_equivalent(source, actual)
381:        black.assert_stable(source, actual, black.FileMode())
382:
383:    @patch("black.dump_to_file", dump_to_stderr)
384:    def test_comments6(self) -> None:
385:        source, expected = read_data("comments6")
386:        actual = fs(source)
387:        self.assertFormatEqual(expected, actual)
388:        black.assert_equivalent(source, actual)
389:        black.assert_stable(source, actual, black.FileMode())
390:
391:    @patch("black.dump_to_file", dump_to_stderr)
392:    def test_comments7(self) -> None:
393:        source, expected = read_data("comments7")
394:        actual = fs(source)
395:        self.assertFormatEqual(expected, actual)
396:        black.assert_equivalent(source, actual)
397:        black.assert_stable(source, actual, black.FileMode())
398:
399:    @patch("black.dump_to_file", dump_to_stderr)
400:    def test_cantfit(self) -> None:
401:        source, expected = read_data("cantfit")
402:        actual = fs(source)
403:        self.assertFormatEqual(expected, actual)
404:        black.assert_equivalent(source, actual)
405:        black.assert_stable(source, actual, black.FileMode())
406:
407:    @patch("black.dump_to_file", dump_to_stderr)
408:    def test_import_spacing(self) -> None:
409:        source, expected = read_data("import_spacing")
410:        actual = fs(source)
411:        self.assertFormatEqual(expected, actual)
412:        black.assert_equivalent(source, actual)
413:        black.assert_stable(source, actual, black.FileMode())
414:
415:    @patch("black.dump_to_file", dump_to_stderr)
416:    def test_composition(self) -> None:
417:        source, expected = read_data("composition")
418:        actual = fs(source)
419:        self.assertFormatEqual(expected, actual)

Calling tool: globTool
**/*comments7*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py
1:from .config import (
2:    Any,
3:    Bool,
4:    ConfigType,
5:    ConfigTypeAttributes,
6:    Int,
7:    Path,
8:    #  String,
9:    #  resolve_to_config_type,
10:    #  DEFAULT_TYPE_ATTRIBUTES,
11:)
12:
13:
14:from .config import (
15:    Any,
16:    Bool,
17:    ConfigType,
18:    ConfigTypeAttributes,
19:    Int,
20:    no_comma_here_yet
21:    #  and some comments,
22:    #  resolve_to_config_type,
23:    #  DEFAULT_TYPE_ATTRIBUTES,
24:)
25:
26:# output
27:
28:from .config import (
29:    Any,
30:    Bool,
31:    ConfigType,
32:    ConfigTypeAttributes,
33:    Int,
34:    Path,
35:    #  String,
36:    #  resolve_to_config_type,
37:    #  DEFAULT_TYPE_ATTRIBUTES,
38:)
39:
40:
41:from .config import (
42:    Any,
43:    Bool,
44:    ConfigType,
45:    ConfigTypeAttributes,
46:    Int,
47:    no_comma_here_yet,
48:    #  and some comments,
49:    #  resolve_to_config_type,
50:    #  DEFAULT_TYPE_ATTRIBUTES,
51:)

Calling tool: grepTool
STANDALONE_COMMENT\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:852:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1218:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1311:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1321:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2136:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2412:                    if leaves[i].type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2784:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2814:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3114:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
840:
841:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
842:STATEMENT = {
843:    syms.if_stmt,
844:    syms.while_stmt,
845:    syms.for_stmt,
846:    syms.try_stmt,
847:    syms.except_clause,
848:    syms.with_stmt,
849:    syms.funcdef,
850:    syms.classdef,
851:}
852:STANDALONE_COMMENT = 153
853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
854:LOGIC_OPERATORS = {"and", "or"}
855:COMPARATORS = {
856:    token.LESS,
857:    token.GREATER,
858:    token.EQEQUAL,
859:    token.NOTEQUAL,
860:    token.LESSEQUAL,
861:    token.GREATEREQUAL,
862:}
863:MATH_OPERATORS = {
864:    token.VBAR,
865:    token.CIRCUMFLEX,
866:    token.AMPER,
867:    token.LEFTSHIFT,
868:    token.RIGHTSHIFT,
869:    token.PLUS,

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In `black.py` lines 2411-2418, the loop skips trailing `STANDALONE_COMMENT` leaves and checks `elif leaves[i].type == token.COMMA: break`, which stops insertion when a trailing comma already exists before comments. This matches the requirement and is validated by the `tests/data/comments7.py` case where the first import remains unchanged.


Todo item 4 of 11 is correct
description: 'Check that the condition `elif leaves[i].type == token.COMMA: break` prevents inserting an additional comma when a trailing comma already exists before trailing comments (i.e., handles the regression case from Issue #671).'
Validating todo item 5 of 11
description: 'Verify that when the last non-comment leaf is not a comma, `leaves.insert(i + 1, Leaf(token.COMMA, ","))` inserts the comma immediately after that leaf (and not after any comments), matching the PR intent.'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:852:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1218:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1311:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1321:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2136:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2412:                    if leaves[i].type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2784:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2814:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3114:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py:2393-2426, the loop scans leaves backward, skips STANDALONE_COMMENTs, and if the first non-comment is not a COMMA, it inserts a COMMA at i+1. This places the comma immediately after the last non-comment leaf and before any trailing comments, matching the PR intent.


Todo item 5 of 11 is correct
description: 'Verify that when the last non-comment leaf is not a comma, `leaves.insert(i + 1, Leaf(token.COMMA, ","))` inserts the comma immediately after that leaf (and not after any comments), matching the PR intent.'
Validating todo item 6 of 11
description: 'Confirm that if all trailing leaves are comments (or all leaves are comments), the loop exits without inserting a comma (i.e., no dangling comma is added at the end of the block).'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py lines 2405-2418, the loop iterates backward over leaves, skipping STANDALONE_COMMENTs. If all leaves are comments, no non-comment is encountered, so no insertion occurs and no dangling comma is added.


Todo item 6 of 11 is correct
description: 'Confirm that if all trailing leaves are comments (or all leaves are comments), the loop exits without inserting a comma (i.e., no dangling comma is added at the end of the block).'
Validating todo item 7 of 11
description: 'Ensure that use of `Leaf(token.COMMA, ",")` is consistent with similar code elsewhere in the file (e.g., previously appended commas) and that `Leaf` and `token` are in scope for this function.'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize

Calling tool: grepTool
Leaf\(token\.COMMA, ","\)
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2510:            current_line.append(Leaf(token.COMMA, ","))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2488:        if leaf.bracket_depth == lowest_depth:
2489:            if is_vararg(leaf, within={syms.typedargslist}):
2490:                trailing_comma_safe = (
2491:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features
2492:                )
2493:            elif is_vararg(leaf, within={syms.arglist, syms.argument}):
2494:                trailing_comma_safe = (
2495:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features
2496:                )
2497:
2498:        leaf_priority = bt.delimiters.get(id(leaf))
2499:        if leaf_priority == delimiter_priority:
2500:            yield current_line
2501:
2502:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2503:    if current_line:
2504:        if (
2505:            trailing_comma_safe
2506:            and delimiter_priority == COMMA_PRIORITY
2507:            and current_line.leaves[-1].type != token.COMMA
2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
2509:        ):
2510:            current_line.append(Leaf(token.COMMA, ","))
2511:        yield current_line
2512:
2513:
2514:@dont_increase_indentation
2515:def standalone_comment_split(
2516:    line: Line, features: Collection[Feature] = ()
2517:) -> Iterator[Line]:
2518:    """Split standalone comments from the rest of the line."""
2519:    if not line.contains_standalone_comments(0):
2520:        raise CannotSplit("Line does not have any standalone comments")
2521:
2522:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2523:
2524:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2525:        """Append `leaf` to current line or to new line if appending impossible."""
2526:        nonlocal current_line
2527:        try:
2528:            current_line.append_safe(leaf, preformatted=True)
2529:        except ValueError:
2530:            yield current_line
2531:
2532:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2533:            current_line.append(leaf)
2534:
2535:    for leaf in line.leaves:
2536:        yield from append_to_line(leaf)
2537:

Calling tool: grepTool
import token
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/pytree.py:26:        # from .pgen2 import token // token.__dict__.items():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/pgen2/tokenize.py:36:from . import token
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/pgen2/parse.py:14:from . import token
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/pygram.py:10:from .pgen2 import token
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/pgen2/grammar.py:21:from . import token
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:18:import tokenize

Calling tool: grepTool
token\)
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
from .* import token
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
token\.
Showing first 50 results from grep. Consider using a more specific pattern or path.
793:            name = token.tok_name[node.type]
821:            _type = token.tok_name.get(node.type, str(node.type))
841:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
856:    token.LESS,
857:    token.GREATER,
858:    token.EQEQUAL,
859:    token.NOTEQUAL,
860:    token.LESSEQUAL,
861:    token.GREATEREQUAL,
864:    token.VBAR,
865:    token.CIRCUMFLEX,
866:    token.AMPER,
867:    token.LEFTSHIFT,
868:    token.RIGHTSHIFT,
869:    token.PLUS,
870:    token.MINUS,
871:    token.STAR,
872:    token.SLASH,
873:    token.DOUBLESLASH,
874:    token.PERCENT,
875:    token.AT,
876:    token.TILDE,
877:    token.DOUBLESTAR,
879:STARS = {token.STAR, token.DOUBLESTAR}
934:    token.VBAR: 9,
935:    token.CIRCUMFLEX: 8,
936:    token.AMPER: 7,
937:    token.LEFTSHIFT: 6,
938:    token.RIGHTSHIFT: 6,
939:    token.PLUS: 5,
940:    token.MINUS: 5,
941:    token.STAR: 4,
942:    token.SLASH: 4,
943:    token.DOUBLESLASH: 4,
944:    token.PERCENT: 4,
945:    token.AT: 4,
946:    token.TILDE: 3,
947:    token.DOUBLESTAR: 2,
978:        if leaf.type == token.COMMENT:
1032:        if leaf.type == token.NAME and leaf.value == "for":
1044:            and leaf.type == token.NAME
1059:        if leaf.type == token.NAME and leaf.value == "lambda":
1071:            and leaf.type == token.COLON
1081:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1109:        if token.COLON == leaf.type and self.is_class_paren_empty:
1148:        return bool(self) and self.leaves[0].type == token.AT
1160:            and self.leaves[0].type == token.NAME
1168:            Leaf(token.DOT, ".") for _ in range(3)
1183:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum
6:from functools import lru_cache, partial, wraps
7:import io
8:import itertools
9:import logging
10:from multiprocessing import Manager, freeze_support
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tempfile
18:import tokenize
19:from typing import (
20:    Any,
21:    Callable,
22:    Collection,
23:    Dict,
24:    Generator,
25:    Generic,
26:    Iterable,
27:    Iterator,
28:    List,
29:    Optional,
30:    Pattern,
31:    Sequence,
32:    Set,
33:    Tuple,
34:    TypeVar,
35:    Union,
36:    cast,
37:)
38:
39:from appdirs import user_cache_dir
40:from attr import dataclass, evolve, Factory
41:import click
42:import toml
43:
44:# lib2to3 fork
45:from blib2to3.pytree import Node, Leaf, type_repr
46:from blib2to3 import pygram, pytree
47:from blib2to3.pgen2 import driver, token
48:from blib2to3.pgen2.grammar import Grammar
49:from blib2to3.pgen2.parse import ParseError
50:
51:
52:__version__ = "19.3b0"
53:DEFAULT_LINE_LENGTH = 88
54:DEFAULT_EXCLUDES = (
55:    r"/(\.eggs|\.git|\.hg|\.mypy_cache|\.nox|\.tox|\.venv|_build|buck-out|build|dist)/"
56:)
57:DEFAULT_INCLUDES = r"\.pyi?$"
58:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
59:
60:
61:# types
62:FileContent = str
63:Encoding = str
64:NewLine = str
65:Depth = int
66:NodeType = int
67:LeafID = int
68:Priority = int
69:Index = int
70:LN = Union[Leaf, Node]
71:SplitFunc = Callable[["Line", Collection["Feature"]], Iterator["Line"]]
72:Timestamp = float
73:FileSize = int
74:CacheInfo = Tuple[Timestamp, FileSize]
75:Cache = Dict[Path, CacheInfo]
76:out = partial(click.secho, bold=True, err=True)
77:err = partial(click.secho, fg="red", err=True)
78:
79:pygram.initialize(CACHE_DIR)
80:syms = pygram.python_symbols
81:
82:
83:class NothingChanged(UserWarning):
84:    """Raised when reformatted code is the same as source."""
85:
86:
87:class CannotSplit(Exception):
88:    """A readable split that fits the allotted line length is impossible."""
89:
90:
91:class InvalidInput(ValueError):
92:    """Raised when input source code fails all parse attempts."""
93:
94:
95:class WriteBack(Enum):
96:    NO = 0
97:    YES = 1
98:    DIFF = 2
99:    CHECK = 3
100:
101:    @classmethod
102:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
103:        if check and not diff:
104:            return cls.CHECK
105:
106:        return cls.DIFF if diff else cls.YES
107:
108:
109:class Changed(Enum):
110:    NO = 0
111:    CACHED = 1
112:    YES = 2
113:
114:
115:class TargetVersion(Enum):
116:    PY27 = 2
117:    PY33 = 3
118:    PY34 = 4
119:    PY35 = 5
120:    PY36 = 6

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
852:STANDALONE_COMMENT = 153
853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1218:            if leaf.type == STANDALONE_COMMENT:
1311:            comment.type == STANDALONE_COMMENT
1321:            comment.type = STANDALONE_COMMENT
1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
2136:            comment_type = STANDALONE_COMMENT
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
2784:                if comment.type != STANDALONE_COMMENT:
2814:                        STANDALONE_COMMENT,
3114:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: grepTool
Leaf\(token\.COMMA
Matched content:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2510:            current_line.append(Leaf(token.COMMA, ","))

Calling tool: grepTool
\btoken\b\s*=
No files found. Call grepTool again with a more generic pattern.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The function uses Leaf(token.COMMA, ",") just like elsewhere in the file (e.g., at line ~2510 in delimiter_split). Both Leaf and token are imported at module scope (from blib2to3.pytree and blib2to3.pgen2 respectively), so they are in scope for bracket_split_build_line.


Todo item 7 of 11 is correct
description: 'Ensure that use of `Leaf(token.COMMA, ",")` is consistent with similar code elsewhere in the file (e.g., previously appended commas) and that `Leaf` and `token` are in scope for this function.'
Validating todo item 8 of 11
description: 'Verify that no remaining code paths still append a trailing comma for imports by only checking the last leaf (i.e., search for other 'Ensure a trailing comma' or `original.is_import` logic that might conflict and still append after comments).'
Calling tool: grepTool
Ensure a trailing comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2408:            # Ensure a trailing comma for imports, but be careful not to add one after

Calling tool: grepTool
original\.is_import
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2410:            if original.is_import:

Calling tool: grepTool
\bis_import\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/docs/reference/reference_functions.rst:21:.. autofunction:: black.is_import
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1151:    def is_import(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1153:        return bool(self) and is_import(self.leaves[0])
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1275:        if self.is_import:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1429:            and self.previous_line.is_import
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1430:            and not current_line.is_import
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2332:        and not line.is_import
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2410:            if original.is_import:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2545:def is_import(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2375:    following the closing bracket is put on a separate line.
2376:
2377:    Those are called `head`, `body`, and `tail`, respectively. If the split
2378:    produced the same line (all content in `head`) or ended up with an empty `body`
2379:    and the `tail` is just the closing bracket, then it's considered failed.
2380:    """
2381:    tail_len = len(str(tail).strip())
2382:    if not body:
2383:        if tail_len == 0:
2384:            raise CannotSplit("Splitting brackets produced the same line")
2385:
2386:        elif tail_len < 3:
2387:            raise CannotSplit(
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize
2468:    trailing_comma_safe = True
2469:
2470:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2471:        """Append `leaf` to current line or to new line if appending impossible."""
2472:        nonlocal current_line
2473:        try:
2474:            current_line.append_safe(leaf, preformatted=True)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1140:    @property
1141:    def is_comment(self) -> bool:
1142:        """Is this line a standalone comment?"""
1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1144:
1145:    @property
1146:    def is_decorator(self) -> bool:
1147:        """Is this line a decorator?"""
1148:        return bool(self) and self.leaves[0].type == token.AT
1149:
1150:    @property
1151:    def is_import(self) -> bool:
1152:        """Is this an import line?"""
1153:        return bool(self) and is_import(self.leaves[0])
1154:
1155:    @property
1156:    def is_class(self) -> bool:
1157:        """Is this line a class definition?"""
1158:        return (
1159:            bool(self)
1160:            and self.leaves[0].type == token.NAME
1161:            and self.leaves[0].value == "class"
1162:        )
1163:
1164:    @property
1165:    def is_stub_class(self) -> bool:
1166:        """Is this line a class definition with a body consisting only of "..."?"""
1167:        return self.is_class and self.leaves[-3:] == [
1168:            Leaf(token.DOT, ".") for _ in range(3)
1169:        ]
1170:
1171:    @property
1172:    def is_def(self) -> bool:
1173:        """Is this a function definition? (Also returns True for async defs.)"""
1174:        try:
1175:            first_leaf = self.leaves[0]
1176:        except IndexError:
1177:            return False
1178:
1179:        try:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1268:            comma = self.leaves[-1]
1269:            if comma.parent and comma.parent.type == syms.listmaker:
1270:                self.remove_trailing_comma()
1271:                return True
1272:
1273:        # For parens let's check if it's safe to remove the comma.
1274:        # Imports are always safe.
1275:        if self.is_import:
1276:            self.remove_trailing_comma()
1277:            return True
1278:
1279:        # Otherwise, if the trailing one is the only one, we might mistakenly
1280:        # change a tuple into a different type by removing the comma.
1281:        depth = closing.bracket_depth + 1
1282:        commas = 0
1283:        opening = closing.opening_bracket
1284:        for _opening_index, leaf in enumerate(self.leaves):
1285:            if leaf is opening:
1286:                break
1287:
1288:        else:
1289:            return False
1290:
1291:        for leaf in self.leaves[_opening_index + 1 :]:
1292:            if leaf is closing:
1293:                break
1294:
1295:            bracket_depth = leaf.bracket_depth
1296:            if bracket_depth == depth and leaf.type == token.COMMA:
1297:                commas += 1
1298:                if leaf.parent and leaf.parent.type == syms.arglist:
1299:                    commas += 1
1300:                    break
1301:
1302:        if commas > 1:
1303:            self.remove_trailing_comma()
1304:            return True
1305:
1306:        return False
1307:

Calling tool: grepTool
Leaf\(token\.COMMA
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2510:            current_line.append(Leaf(token.COMMA, ","))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2485:            yield from append_to_line(comment_after)
2486:
2487:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2488:        if leaf.bracket_depth == lowest_depth:
2489:            if is_vararg(leaf, within={syms.typedargslist}):
2490:                trailing_comma_safe = (
2491:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features
2492:                )
2493:            elif is_vararg(leaf, within={syms.arglist, syms.argument}):
2494:                trailing_comma_safe = (
2495:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features
2496:                )
2497:
2498:        leaf_priority = bt.delimiters.get(id(leaf))
2499:        if leaf_priority == delimiter_priority:
2500:            yield current_line
2501:
2502:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2503:    if current_line:
2504:        if (
2505:            trailing_comma_safe
2506:            and delimiter_priority == COMMA_PRIORITY
2507:            and current_line.leaves[-1].type != token.COMMA
2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
2509:        ):
2510:            current_line.append(Leaf(token.COMMA, ","))
2511:        yield current_line
2512:
2513:
2514:@dont_increase_indentation
2515:def standalone_comment_split(
2516:    line: Line, features: Collection[Feature] = ()
2517:) -> Iterator[Line]:
2518:    """Split standalone comments from the rest of the line."""
2519:    if not line.contains_standalone_comments(0):
2520:        raise CannotSplit("Line does not have any standalone comments")
2521:
2522:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2523:
2524:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2525:        """Append `leaf` to current line or to new line if appending impossible."""
2526:        nonlocal current_line
2527:        try:
2528:            current_line.append_safe(leaf, preformatted=True)
2529:        except ValueError:
2530:            yield current_line
2531:
2532:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2533:            current_line.append(leaf)
2534:
2535:    for leaf in line.leaves:
2536:        yield from append_to_line(leaf)
2537:
2538:        for comment_after in line.comments_after(leaf):
2539:            yield from append_to_line(comment_after)
2540:
2541:    if current_line:
2542:        yield current_line
2543:
2544:

Calling tool: grepTool
\bdelimiter_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3023:    """Should `line` immediately be split with `delimiter_split()` after RHS?"""

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
3000:        else:
3001:            for leaf in c.leaves():
3002:                bt.mark(leaf)
3003:    try:
3004:        return bt.max_delimiter_priority()
3005:
3006:    except ValueError:
3007:        return 0
3008:
3009:
3010:def ensure_visible(leaf: Leaf) -> None:
3011:    """Make sure parentheses are visible.
3012:
3013:    They could be invisible as part of some statements (see
3014:    :func:`normalize_invible_parens` and :func:`visit_import_from`).
3015:    """
3016:    if leaf.type == token.LPAR:
3017:        leaf.value = "("
3018:    elif leaf.type == token.RPAR:
3019:        leaf.value = ")"
3020:
3021:
3022:def should_explode(line: Line, opening_bracket: Leaf) -> bool:
3023:    """Should `line` immediately be split with `delimiter_split()` after RHS?"""
3024:
3025:    if not (
3026:        opening_bracket.parent
3027:        and opening_bracket.parent.type in {syms.atom, syms.import_from}
3028:        and opening_bracket.value in "[{("
3029:    ):
3030:        return False
3031:
3032:    try:
3033:        last_leaf = line.leaves[-1]
3034:        exclude = {id(last_leaf)} if last_leaf.type == token.COMMA else set()
3035:        max_priority = line.bracket_tracker.max_delimiter_priority(exclude=exclude)
3036:    except (IndexError, ValueError):
3037:        return False
3038:
3039:    return max_priority == COMMA_PRIORITY
3040:
3041:
3042:def get_features_used(node: Node) -> Set[Feature]:
3043:    """Return a set of (relatively) new Python features used in this file.
3044:
3045:    Currently looking for:
3046:    - f-strings;
3047:    - underscores in numeric literals; and
3048:    - trailing commas after * or ** in function signatures and calls.
3049:    """
3050:    features: Set[Feature] = set()
3051:    for n in node.pre_order():
3052:        if n.type == token.STRING:
3053:            value_head = n.value[:2]  # type: ignore
3054:            if value_head in {'f"', 'F"', "f'", "F'", "rf", "fr", "RF", "FR"}:
3055:                features.add(Feature.F_STRINGS)
3056:
3057:        elif n.type == token.NUMBER:
3058:            if "_" in n.value:  # type: ignore
3059:                features.add(Feature.NUMERIC_UNDERSCORES)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1418:        while self.previous_defs and self.previous_defs[-1] >= depth:
1419:            self.previous_defs.pop()
1420:            if self.is_pyi:
1421:                before = 0 if depth else 1
1422:            else:
1423:                before = 1 if depth else 2
1424:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
1425:            return self._maybe_empty_lines_for_class_or_def(current_line, before)
1426:
1427:        if (
1428:            self.previous_line
1429:            and self.previous_line.is_import
1430:            and not current_line.is_import
1431:            and depth == self.previous_line.depth
1432:        ):
1433:            return (before or 1), 0
1434:
1435:        if (
1436:            self.previous_line
1437:            and self.previous_line.is_class

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2320:    bracket_split_succeeded_or_raise(head, body, tail)
2321:    if (
2322:        # the body shouldn't be exploded
2323:        not body.should_explode
2324:        # the opening bracket is an optional paren
2325:        and opening_bracket.type == token.LPAR
2326:        and not opening_bracket.value
2327:        # the closing bracket is an optional paren
2328:        and closing_bracket.type == token.RPAR
2329:        and not closing_bracket.value
2330:        # it's not an import (optional parens are the only thing we can split on
2331:        # in this case; attempting a split without them is a waste of time)
2332:        and not line.is_import
2333:        # there are no standalone comments in the body
2334:        and not body.contains_standalone_comments(0)
2335:        # and we can actually remove the parens
2336:        and can_omit_invisible_parens(body, line_length)
2337:    ):
2338:        omit = {id(closing_bracket), *omit}
2339:        try:
2340:            yield from right_hand_split(line, line_length, features=features, omit=omit)
2341:            return
2342:
2343:        except CannotSplit:
2344:            if not (
2345:                can_be_split(body)
2346:                or is_line_short_enough(body, line_length=line_length)
2347:            ):
2348:                raise CannotSplit(
2349:                    "Splitting failed, body is still too long and can't be split."

Calling tool: grepTool
trailing comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/Grammar.txt:151:# contains comma which clashes with trailing comma in arglist.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:81:                                  input files.  This will put trailing commas
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:233:that a trailing comma is always added.  Such formatting produces smaller
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:331:*Black* will add trailing commas to expressions that are split
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:335:Unnecessary trailing commas are removed if an expression fits in one
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:341:One exception to removing trailing commas is tuple expressions with
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:347:One exception to adding trailing commas is function signatures
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:348:containing `*`, `*args`, or `**kwargs`.  In this case a trailing comma
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:350:already 3.6+ only and use trailing commas in this situation.  If you
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:353:if you'd like a trailing comma in this situation and *Black* didn't
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1004:* trailing comma is now added to single imports that don't fit on a line (#250)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1172:* fixed an invalid trailing comma sometimes left in imports (#185)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1183:  unpacking. This fixed non-deterministic formatting if trailing commas
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1208:  fixes multiplication making expressions "unsafe" for trailing commas (#132)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1213:* *Black* now splits imports like "Mode 3 + trailing comma" of isort (#127)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1294:* don't remove single trailing commas from square bracket indexing
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1328:* remove a trailing comma if there is a single argument to a call
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1347:* only put trailing commas in function signatures and calls if it's
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:258:        "trailing commas in function signatures and calls also after *args and "
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1229:                # When trailing commas are inserted by Black for consistency, comments
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1231:                # rendering will still be correct).  So we ignore trailing commas.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1255:        """Remove trailing comma if there is one and it's safe."""
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1333:        """Remove the trailing comma and moves the comments attached to it."""
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2408:            # Ensure a trailing comma for imports, but be careful not to add one after
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2448:    If the appropriate Features are given, the split will add trailing commas
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3048:    - trailing commas after * or ** in function signatures and calls.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/expression.py:85:call(this_is_a_very_long_variable_which_will_force_a_delimiter_split, arg, another, kwarg='hey', **kwargs)  # note: no trailing comma pre-3.6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/expression.py:353:)  # note: no trailing comma pre-3.6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/README:6:- backport of BPO-33064 that fixes parsing files with trailing commas after
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/force_py36.py:2:# annotations, trailing comma after *rest) or this test becomes invalid.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/force_py36.py:6:# annotations, trailing comma after *rest) or this test becomes invalid.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/expression.diff:103:-call(this_is_a_very_long_variable_which_will_force_a_delimiter_split, arg, another, kwarg='hey', **kwargs)  # note: no trailing comma pre-3.6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/expression.diff:113:+)  # note: no trailing comma pre-3.6

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1218:            if leaf.type == STANDALONE_COMMENT:
1219:                if leaf.bracket_depth <= depth_limit:
1220:                    return True
1221:        return False
1222:
1223:    def contains_inner_type_comments(self) -> bool:
1224:        ignored_ids = set()
1225:        try:
1226:            last_leaf = self.leaves[-1]
1227:            ignored_ids.add(id(last_leaf))
1228:            if last_leaf.type == token.COMMA:
1229:                # When trailing commas are inserted by Black for consistency, comments
1230:                # after the previous last element are not moved (they don't have to,
1231:                # rendering will still be correct).  So we ignore trailing commas.
1232:                last_leaf = self.leaves[-2]
1233:                ignored_ids.add(id(last_leaf))
1234:        except IndexError:
1235:            return False
1236:
1237:        for leaf_id, comments in self.comments.items():
1238:            if leaf_id in ignored_ids:
1239:                continue
1240:
1241:            for comment in comments:
1242:                if is_type_comment(comment):
1243:                    return True
1244:
1245:        return False
1246:
1247:    def contains_multiline_strings(self) -> bool:
1248:        for leaf in self.leaves:
1249:            if is_multiline_string(leaf):
1250:                return True
1251:
1252:        return False
1253:
1254:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1255:        """Remove trailing comma if there is one and it's safe."""
1256:        if not (
1257:            self.leaves
1258:            and self.leaves[-1].type == token.COMMA
1259:            and closing.type in CLOSING_BRACKETS
1260:        ):
1261:            return False
1262:
1263:        if closing.type == token.RBRACE:
1264:            self.remove_trailing_comma()
1265:            return True
1266:
1267:        if closing.type == token.RSQB:
1268:            comma = self.leaves[-1]
1269:            if comma.parent and comma.parent.type == syms.listmaker:
1270:                self.remove_trailing_comma()
1271:                return True
1272:
1273:        # For parens let's check if it's safe to remove the comma.
1274:        # Imports are always safe.
1275:        if self.is_import:
1276:            self.remove_trailing_comma()
1277:            return True
1278:
1279:        # Otherwise, if the trailing one is the only one, we might mistakenly
1280:        # change a tuple into a different type by removing the comma.
1281:        depth = closing.bracket_depth + 1
1282:        commas = 0
1283:        opening = closing.opening_bracket
1284:        for _opening_index, leaf in enumerate(self.leaves):
1285:            if leaf is opening:
1286:                break
1287:
1288:        else:
1289:            return False
1290:
1291:        for leaf in self.leaves[_opening_index + 1 :]:
1292:            if leaf is closing:
1293:                break
1294:
1295:            bracket_depth = leaf.bracket_depth
1296:            if bracket_depth == depth and leaf.type == token.COMMA:
1297:                commas += 1
1298:                if leaf.parent and leaf.parent.type == syms.arglist:
1299:                    commas += 1
1300:                    break
1301:
1302:        if commas > 1:
1303:            self.remove_trailing_comma()
1304:            return True
1305:
1306:        return False
1307:
1308:    def append_comment(self, comment: Leaf) -> bool:
1309:        """Add an inline or standalone comment to the line."""
1310:        if (
1311:            comment.type == STANDALONE_COMMENT
1312:            and self.bracket_tracker.any_open_brackets()
1313:        ):
1314:            comment.prefix = ""
1315:            return False
1316:
1317:        if comment.type != token.COMMENT:
1318:            return False
1319:
1320:        if not self.leaves:
1321:            comment.type = STANDALONE_COMMENT
1322:            comment.prefix = ""
1323:            return False
1324:
1325:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1326:        return True
1327:
1328:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1329:        """Generate comments that should appear directly after `leaf`."""
1330:        return self.comments.get(id(leaf), [])
1331:
1332:    def remove_trailing_comma(self) -> None:
1333:        """Remove the trailing comma and moves the comments attached to it."""
1334:        trailing_comma = self.leaves.pop()
1335:        trailing_comma_comments = self.comments.pop(id(trailing_comma), [])
1336:        self.comments.setdefault(id(self.leaves[-1]), []).extend(
1337:            trailing_comma_comments
1338:        )
1339:
1340:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1341:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1342:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1343:        if open_lsqb is None:
1344:            return False
1345:
1346:        subscript_start = open_lsqb.next_sibling
1347:

Calling tool: grepTool
visit_import_from
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1666:        self.visit_import_from = partial(v, keywords=Ø, parens={"import"})
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3014:    :func:`normalize_invible_parens` and :func:`visit_import_from`).

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1600:            if self.is_pyi and is_stub_body(node):
1601:                yield from self.visit_default(node)
1602:            else:
1603:                yield from self.line(+1)
1604:                yield from self.visit_default(node)
1605:                yield from self.line(-1)
1606:
1607:        else:
1608:            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):
1609:                yield from self.line()
1610:            yield from self.visit_default(node)
1611:
1612:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:
1613:        """Visit `async def`, `async for`, `async with`."""
1614:        yield from self.line()
1615:
1616:        children = iter(node.children)
1617:        for child in children:
1618:            yield from self.visit(child)
1619:
1620:            if child.type == token.ASYNC:
1621:                break
1622:
1623:        internal_stmt = next(children)
1624:        for child in internal_stmt.children:
1625:            yield from self.visit(child)
1626:
1627:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1628:        """Visit decorators."""
1629:        for child in node.children:
1630:            yield from self.line()
1631:            yield from self.visit(child)
1632:
1633:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1634:        """Remove a semicolon and put the other statement on a separate line."""
1635:        yield from self.line()
1636:
1637:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1638:        """End of file. Process outstanding comments and end with a newline."""
1639:        yield from self.visit_default(leaf)
1640:        yield from self.line()
1641:
1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1643:        if not self.current_line.bracket_tracker.any_open_brackets():
1644:            yield from self.line()
1645:        yield from self.visit_default(leaf)
1646:
1647:    def __attrs_post_init__(self) -> None:
1648:        """You are in a twisty little maze of passages."""
1649:        v = self.visit_stmt
1650:        Ø: Set[str] = set()
1651:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1652:        self.visit_if_stmt = partial(
1653:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1654:        )
1655:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1656:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1657:        self.visit_try_stmt = partial(
1658:            v, keywords={"try", "except", "else", "finally"}, parens=Ø
1659:        )
1660:        self.visit_except_clause = partial(v, keywords={"except"}, parens=Ø)
1661:        self.visit_with_stmt = partial(v, keywords={"with"}, parens=Ø)
1662:        self.visit_funcdef = partial(v, keywords={"def"}, parens=Ø)
1663:        self.visit_classdef = partial(v, keywords={"class"}, parens=Ø)
1664:        self.visit_expr_stmt = partial(v, keywords=Ø, parens=ASSIGNMENTS)
1665:        self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})
1666:        self.visit_import_from = partial(v, keywords=Ø, parens={"import"})
1667:        self.visit_del_stmt = partial(v, keywords=Ø, parens={"del"})
1668:        self.visit_async_funcdef = self.visit_async_stmt
1669:        self.visit_decorated = self.visit_decorators
1670:
1671:
1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
1673:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1674:OPENING_BRACKETS = set(BRACKET.keys())
1675:CLOSING_BRACKETS = set(BRACKET.values())
1676:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1678:
1679:
1680:def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa: C901
1681:    """Return whitespace prefix if needed for the given `leaf`.
1682:
1683:    `complex_subscript` signals whether the given leaf is part of a subscription
1684:    which has non-trivial arguments, like arithmetic expressions or function calls.
1685:    """
1686:    NO = ""
1687:    SPACE = " "
1688:    DOUBLESPACE = "  "
1689:    t = leaf.type
1690:    p = leaf.parent
1691:    v = leaf.value
1692:    if t in ALWAYS_NO_SPACE:
1693:        return NO
1694:
1695:    if t == token.COMMENT:
1696:        return DOUBLESPACE
1697:
1698:    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"
1699:    if t == token.COLON and p.type not in {
1700:        syms.subscript,
1701:        syms.subscriptlist,
1702:        syms.sliceop,
1703:    }:
1704:        return NO
1705:
1706:    prev = leaf.prev_sibling
1707:    if not prev:
1708:        prevp = preceding_leaf(p)
1709:        if not prevp or prevp.type in OPENING_BRACKETS:
1710:            return NO
1711:
1712:        if t == token.COLON:
1713:            if prevp.type == token.COLON:
1714:                return NO
1715:
1716:            elif prevp.type != token.COMMA and not complex_subscript:
1717:                return NO
1718:
1719:            return SPACE

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2540:
2541:    if current_line:
2542:        yield current_line
2543:
2544:
2545:def is_import(leaf: Leaf) -> bool:
2546:    """Return True if the given leaf starts an import statement."""
2547:    p = leaf.parent
2548:    t = leaf.type
2549:    v = leaf.value
2550:    return bool(
2551:        t == token.NAME
2552:        and (
2553:            (v == "import" and p and p.type == syms.import_name)
2554:            or (v == "from" and p and p.type == syms.import_from)
2555:        )
2556:    )
2557:
2558:
2559:def is_type_comment(leaf: Leaf) -> bool:
2560:    """Return True if the given leaf is a special comment.
2561:    Only returns true for type comments for now."""
2562:    t = leaf.type
2563:    v = leaf.value
2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
2565:
2566:
2567:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2568:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2569:    else.
2570:
2571:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2572:    """
2573:    if not inside_brackets:
2574:        spl = leaf.prefix.split("#")
2575:        if "\\" not in spl[0]:
2576:            nl_count = spl[-1].count("\n")
2577:            if len(spl) > 1:
2578:                nl_count -= 1
2579:            leaf.prefix = "\n" * nl_count

Calling tool: grepTool
append\([^\)]*COMMA
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2510:            current_line.append(Leaf(token.COMMA, ","))

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Searched codebase for other trailing-comma insertion paths and import checks. Only import-specific insertion is in bracket_split_build_line (updated to skip standalone comments). The only other comma append is in delimiter_split, which explicitly avoids adding when the last leaf is a standalone comment. No other original.is_import or “Ensure a trailing comma” logic exists that would append after comments.


Todo item 8 of 11 is correct
description: 'Verify that no remaining code paths still append a trailing comma for imports by only checking the last leaf (i.e., search for other 'Ensure a trailing comma' or `original.is_import` logic that might conflict and still append after comments).'
Validating todo item 9 of 11
description: 'Check that the surrounding logic remains unchanged and correct: `normalize_prefix(leaves[0], inside_brackets=True)` still runs and the subsequent population of `result` (`result.append(leaf, preformatted=True)`) is unaffected by the change.'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize
2468:    trailing_comma_safe = True
2469:
2470:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2471:        """Append `leaf` to current line or to new line if appending impossible."""
2472:        nonlocal current_line

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified in black.py: normalize_prefix(leaves[0], inside_brackets=True) is still executed inside the is_body and leaves block (lines 2405-2408), and the subsequent result population loop (lines 2419-2421) remains outside the conditional and unchanged, ensuring behavior is unaffected.


Todo item 9 of 11 is correct
description: 'Check that the surrounding logic remains unchanged and correct: `normalize_prefix(leaves[0], inside_brackets=True)` still runs and the subsequent population of `result` (`result.append(leaf, preformatted=True)`) is unaffected by the change.'
Validating todo item 10 of 11
description: 'Open the `test_comments7` test and confirm it covers a `from ... import (...)` block with commented-out lines at the end and asserts that the formatted result does not contain a standalone comma before the closing parenthesis (i.e., avoids the invalid output shown in Issue #671).'
Calling tool: grepTool
test_comments7
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments7
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py:392:    def test_comments7(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py
360:    def test_comments3(self) -> None:
361:        source, expected = read_data("comments3")
362:        actual = fs(source)
363:        self.assertFormatEqual(expected, actual)
364:        black.assert_equivalent(source, actual)
365:        black.assert_stable(source, actual, black.FileMode())
366:
367:    @patch("black.dump_to_file", dump_to_stderr)
368:    def test_comments4(self) -> None:
369:        source, expected = read_data("comments4")
370:        actual = fs(source)
371:        self.assertFormatEqual(expected, actual)
372:        black.assert_equivalent(source, actual)
373:        black.assert_stable(source, actual, black.FileMode())
374:
375:    @patch("black.dump_to_file", dump_to_stderr)
376:    def test_comments5(self) -> None:
377:        source, expected = read_data("comments5")
378:        actual = fs(source)
379:        self.assertFormatEqual(expected, actual)
380:        black.assert_equivalent(source, actual)
381:        black.assert_stable(source, actual, black.FileMode())
382:
383:    @patch("black.dump_to_file", dump_to_stderr)
384:    def test_comments6(self) -> None:
385:        source, expected = read_data("comments6")
386:        actual = fs(source)
387:        self.assertFormatEqual(expected, actual)
388:        black.assert_equivalent(source, actual)
389:        black.assert_stable(source, actual, black.FileMode())
390:
391:    @patch("black.dump_to_file", dump_to_stderr)
392:    def test_comments7(self) -> None:
393:        source, expected = read_data("comments7")
394:        actual = fs(source)
395:        self.assertFormatEqual(expected, actual)
396:        black.assert_equivalent(source, actual)
397:        black.assert_stable(source, actual, black.FileMode())
398:
399:    @patch("black.dump_to_file", dump_to_stderr)
400:    def test_cantfit(self) -> None:
401:        source, expected = read_data("cantfit")
402:        actual = fs(source)
403:        self.assertFormatEqual(expected, actual)
404:        black.assert_equivalent(source, actual)
405:        black.assert_stable(source, actual, black.FileMode())
406:
407:    @patch("black.dump_to_file", dump_to_stderr)
408:    def test_import_spacing(self) -> None:
409:        source, expected = read_data("import_spacing")
410:        actual = fs(source)
411:        self.assertFormatEqual(expected, actual)
412:        black.assert_equivalent(source, actual)
413:        black.assert_stable(source, actual, black.FileMode())
414:
415:    @patch("black.dump_to_file", dump_to_stderr)
416:    def test_composition(self) -> None:
417:        source, expected = read_data("composition")
418:        actual = fs(source)
419:        self.assertFormatEqual(expected, actual)
420:        black.assert_equivalent(source, actual)
421:        black.assert_stable(source, actual, black.FileMode())
422:
423:    @patch("black.dump_to_file", dump_to_stderr)
424:    def test_empty_lines(self) -> None:
425:        source, expected = read_data("empty_lines")
426:        actual = fs(source)
427:        self.assertFormatEqual(expected, actual)
428:        black.assert_equivalent(source, actual)
429:        black.assert_stable(source, actual, black.FileMode())
430:
431:    @patch("black.dump_to_file", dump_to_stderr)
432:    def test_string_prefixes(self) -> None:
433:        source, expected = read_data("string_prefixes")
434:        actual = fs(source)
435:        self.assertFormatEqual(expected, actual)
436:        black.assert_equivalent(source, actual)
437:        black.assert_stable(source, actual, black.FileMode())
438:
439:    @patch("black.dump_to_file", dump_to_stderr)
440:    def test_numeric_literals(self) -> None:
441:        source, expected = read_data("numeric_literals")
442:        mode = black.FileMode(target_versions=black.PY36_VERSIONS)
443:        actual = fs(source, mode=mode)
444:        self.assertFormatEqual(expected, actual)
445:        black.assert_equivalent(source, actual)
446:        black.assert_stable(source, actual, mode)
447:
448:    @patch("black.dump_to_file", dump_to_stderr)
449:    def test_numeric_literals_ignoring_underscores(self) -> None:
450:        source, expected = read_data("numeric_literals_skip_underscores")
451:        mode = black.FileMode(target_versions=black.PY36_VERSIONS)
452:        actual = fs(source, mode=mode)
453:        self.assertFormatEqual(expected, actual)
454:        black.assert_equivalent(source, actual)
455:        black.assert_stable(source, actual, mode)
456:
457:    @patch("black.dump_to_file", dump_to_stderr)
458:    def test_numeric_literals_py2(self) -> None:
459:        source, expected = read_data("numeric_literals_py2")
460:        actual = fs(source)
461:        self.assertFormatEqual(expected, actual)
462:        black.assert_stable(source, actual, black.FileMode())
463:
464:    @patch("black.dump_to_file", dump_to_stderr)
465:    def test_python2(self) -> None:
466:        source, expected = read_data("python2")
467:        actual = fs(source)
468:        self.assertFormatEqual(expected, actual)
469:        # black.assert_equivalent(source, actual)
470:        black.assert_stable(source, actual, black.FileMode())
471:
472:    @patch("black.dump_to_file", dump_to_stderr)
473:    def test_python2_print_function(self) -> None:
474:        source, expected = read_data("python2_print_function")
475:        mode = black.FileMode(target_versions={TargetVersion.PY27})
476:        actual = fs(source, mode=mode)
477:        self.assertFormatEqual(expected, actual)
478:        black.assert_stable(source, actual, mode)
479:

Calling tool: globTool
**/*comments7*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py
1:from .config import (
2:    Any,
3:    Bool,
4:    ConfigType,
5:    ConfigTypeAttributes,
6:    Int,
7:    Path,
8:    #  String,
9:    #  resolve_to_config_type,
10:    #  DEFAULT_TYPE_ATTRIBUTES,
11:)
12:
13:
14:from .config import (
15:    Any,
16:    Bool,
17:    ConfigType,
18:    ConfigTypeAttributes,
19:    Int,
20:    no_comma_here_yet
21:    #  and some comments,
22:    #  resolve_to_config_type,
23:    #  DEFAULT_TYPE_ATTRIBUTES,
24:)
25:
26:# output
27:
28:from .config import (
29:    Any,
30:    Bool,
31:    ConfigType,
32:    ConfigTypeAttributes,
33:    Int,
34:    Path,
35:    #  String,
36:    #  resolve_to_config_type,
37:    #  DEFAULT_TYPE_ATTRIBUTES,
38:)
39:
40:
41:from .config import (
42:    Any,
43:    Bool,
44:    ConfigType,
45:    ConfigTypeAttributes,
46:    Int,
47:    no_comma_here_yet,
48:    #  and some comments,
49:    #  resolve_to_config_type,
50:    #  DEFAULT_TYPE_ATTRIBUTES,
51:)

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py:57:def read_data(name: str, data: bool = True) -> Tuple[str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:import logging
4:from concurrent.futures import ThreadPoolExecutor
5:from contextlib import contextmanager, redirect_stderr
6:from functools import partial, wraps
7:from io import BytesIO, TextIOWrapper
8:import os
9:from pathlib import Path
10:import re
11:import sys
12:from tempfile import TemporaryDirectory
13:from typing import (
14:    Any,
15:    BinaryIO,
16:    Callable,
17:    Coroutine,
18:    Generator,
19:    List,
20:    Tuple,
21:    Iterator,
22:    TypeVar,
23:)
24:import unittest
25:from unittest.mock import patch, MagicMock
26:
27:from click import unstyle
28:from click.testing import CliRunner
29:
30:import black
31:from black import Feature, TargetVersion
32:
33:try:
34:    import blackd
35:    from aiohttp.test_utils import TestClient, TestServer
36:except ImportError:
37:    has_blackd_deps = False
38:else:
39:    has_blackd_deps = True
40:
41:ff = partial(black.format_file_in_place, mode=black.FileMode(), fast=True)
42:fs = partial(black.format_str, mode=black.FileMode())
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:PY36_ARGS = [
47:    f"--target-version={version.name.lower()}" for version in black.PY36_VERSIONS
48:]
49:T = TypeVar("T")
50:R = TypeVar("R")
51:
52:
53:def dump_to_stderr(*output: str) -> str:
54:    return "\n" + "\n".join(output) + "\n"
55:
56:
57:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
58:    """read_data('test_name') -> 'input', 'output'"""
59:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
60:        name += ".py"
61:    _input: List[str] = []
62:    _output: List[str] = []
63:    base_dir = THIS_DIR / "data" if data else THIS_DIR
64:    with open(base_dir / name, "r", encoding="utf8") as test:
65:        lines = test.readlines()
66:    result = _input
67:    for line in lines:
68:        line = line.replace(EMPTY_LINE, "")
69:        if line.rstrip() == "# output":
70:            result = _output
71:            continue
72:
73:        result.append(line)
74:    if _input and not _output:
75:        # If there's no output marker, treat the entire file as already pre-formatted.
76:        _output = _input[:]
77:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
78:
79:
80:@contextmanager

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Located tests/test_black.py::test_comments7 which uses tests/data/comments7.py. That data file contains a from-import with trailing commented-out lines; the expected output shows adding a comma after the last actual name (if missing) but no standalone comma before the closing parenthesis. The test asserts actual equals this expected, thus covering and preventing the invalid output from Issue #671.


Todo item 10 of 11 is correct
description: 'Open the `test_comments7` test and confirm it covers a `from ... import (...)` block with commented-out lines at the end and asserts that the formatted result does not contain a standalone comma before the closing parenthesis (i.e., avoids the invalid output shown in Issue #671).'
Validating todo item 11 of 11
description: 'In `test_comments7`, verify that when the last real imported name lacks a trailing comma but is followed by comments, the expected formatted output contains a comma immediately after that name (before comments), not at the very end after comments.'
Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2385:
2386:        elif tail_len < 3:
2387:            raise CannotSplit(
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")

Calling tool: grepTool
test_comments7\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments7
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py:392:    def test_comments7(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py
380:        black.assert_equivalent(source, actual)
381:        black.assert_stable(source, actual, black.FileMode())
382:
383:    @patch("black.dump_to_file", dump_to_stderr)
384:    def test_comments6(self) -> None:
385:        source, expected = read_data("comments6")
386:        actual = fs(source)
387:        self.assertFormatEqual(expected, actual)
388:        black.assert_equivalent(source, actual)
389:        black.assert_stable(source, actual, black.FileMode())
390:
391:    @patch("black.dump_to_file", dump_to_stderr)
392:    def test_comments7(self) -> None:
393:        source, expected = read_data("comments7")
394:        actual = fs(source)
395:        self.assertFormatEqual(expected, actual)
396:        black.assert_equivalent(source, actual)
397:        black.assert_stable(source, actual, black.FileMode())
398:
399:    @patch("black.dump_to_file", dump_to_stderr)
400:    def test_cantfit(self) -> None:
401:        source, expected = read_data("cantfit")
402:        actual = fs(source)
403:        self.assertFormatEqual(expected, actual)
404:        black.assert_equivalent(source, actual)
405:        black.assert_stable(source, actual, black.FileMode())
406:
407:    @patch("black.dump_to_file", dump_to_stderr)
408:    def test_import_spacing(self) -> None:
409:        source, expected = read_data("import_spacing")
410:        actual = fs(source)
411:        self.assertFormatEqual(expected, actual)
412:        black.assert_equivalent(source, actual)
413:        black.assert_stable(source, actual, black.FileMode())
414:
415:    @patch("black.dump_to_file", dump_to_stderr)
416:    def test_composition(self) -> None:
417:        source, expected = read_data("composition")
418:        actual = fs(source)
419:        self.assertFormatEqual(expected, actual)
420:        black.assert_equivalent(source, actual)
421:        black.assert_stable(source, actual, black.FileMode())
422:
423:    @patch("black.dump_to_file", dump_to_stderr)
424:    def test_empty_lines(self) -> None:
425:        source, expected = read_data("empty_lines")
426:        actual = fs(source)
427:        self.assertFormatEqual(expected, actual)
428:        black.assert_equivalent(source, actual)
429:        black.assert_stable(source, actual, black.FileMode())
430:
431:    @patch("black.dump_to_file", dump_to_stderr)
432:    def test_string_prefixes(self) -> None:
433:        source, expected = read_data("string_prefixes")
434:        actual = fs(source)
435:        self.assertFormatEqual(expected, actual)
436:        black.assert_equivalent(source, actual)
437:        black.assert_stable(source, actual, black.FileMode())
438:
439:    @patch("black.dump_to_file", dump_to_stderr)

Calling tool: globTool
**/*comments7*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py
1:from .config import (
2:    Any,
3:    Bool,
4:    ConfigType,
5:    ConfigTypeAttributes,
6:    Int,
7:    Path,
8:    #  String,
9:    #  resolve_to_config_type,
10:    #  DEFAULT_TYPE_ATTRIBUTES,
11:)
12:
13:
14:from .config import (
15:    Any,
16:    Bool,
17:    ConfigType,
18:    ConfigTypeAttributes,
19:    Int,
20:    no_comma_here_yet
21:    #  and some comments,
22:    #  resolve_to_config_type,
23:    #  DEFAULT_TYPE_ATTRIBUTES,
24:)
25:
26:# output
27:
28:from .config import (
29:    Any,
30:    Bool,
31:    ConfigType,
32:    ConfigTypeAttributes,
33:    Int,
34:    Path,
35:    #  String,
36:    #  resolve_to_config_type,
37:    #  DEFAULT_TYPE_ATTRIBUTES,
38:)
39:
40:
41:from .config import (
42:    Any,
43:    Bool,
44:    ConfigType,
45:    ConfigTypeAttributes,
46:    Int,
47:    no_comma_here_yet,
48:    #  and some comments,
49:    #  resolve_to_config_type,
50:    #  DEFAULT_TYPE_ATTRIBUTES,
51:)

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py:57:def read_data(name: str, data: bool = True) -> Tuple[str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py
40:
41:ff = partial(black.format_file_in_place, mode=black.FileMode(), fast=True)
42:fs = partial(black.format_str, mode=black.FileMode())
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:PY36_ARGS = [
47:    f"--target-version={version.name.lower()}" for version in black.PY36_VERSIONS
48:]
49:T = TypeVar("T")
50:R = TypeVar("R")
51:
52:
53:def dump_to_stderr(*output: str) -> str:
54:    return "\n" + "\n".join(output) + "\n"
55:
56:
57:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
58:    """read_data('test_name') -> 'input', 'output'"""
59:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
60:        name += ".py"
61:    _input: List[str] = []
62:    _output: List[str] = []
63:    base_dir = THIS_DIR / "data" if data else THIS_DIR
64:    with open(base_dir / name, "r", encoding="utf8") as test:
65:        lines = test.readlines()
66:    result = _input
67:    for line in lines:
68:        line = line.replace(EMPTY_LINE, "")
69:        if line.rstrip() == "# output":
70:            result = _output
71:            continue
72:
73:        result.append(line)
74:    if _input and not _output:
75:        # If there's no output marker, treat the entire file as already pre-formatted.
76:        _output = _input[:]
77:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
78:
79:

Calling tool: grepTool
bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2269:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2270:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2271:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2317:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2318:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2319:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2245:    Note: this usually looks weird, only use this for function definitions.
2246:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2247:    :func:`right_hand_split` which also handles optional parentheses.
2248:    """
2249:    tail_leaves: List[Leaf] = []
2250:    body_leaves: List[Leaf] = []
2251:    head_leaves: List[Leaf] = []
2252:    current_leaves = head_leaves
2253:    matching_bracket = None
2254:    for leaf in line.leaves:
2255:        if (
2256:            current_leaves is body_leaves
2257:            and leaf.type in CLOSING_BRACKETS
2258:            and leaf.opening_bracket is matching_bracket
2259:        ):
2260:            current_leaves = tail_leaves if body_leaves else head_leaves
2261:        current_leaves.append(leaf)
2262:        if current_leaves is head_leaves:
2263:            if leaf.type in OPENING_BRACKETS:
2264:                matching_bracket = leaf
2265:                current_leaves = body_leaves
2266:    if not matching_bracket:
2267:        raise CannotSplit("No brackets found")
2268:
2269:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2270:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2271:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2272:    bracket_split_succeeded_or_raise(head, body, tail)
2273:    for result in (head, body, tail):
2274:        if result:
2275:            yield result
2276:
2277:
2278:def right_hand_split(
2279:    line: Line,
2280:    line_length: int,
2281:    features: Collection[Feature] = (),
2282:    omit: Collection[LeafID] = (),
2283:) -> Iterator[Line]:
2284:    """Split line into many lines, starting with the last matching bracket pair.
2285:
2286:    If the split was by optional parentheses, attempt splitting without them, too.
2287:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2288:    this split.
2289:
2290:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2291:    """
2292:    tail_leaves: List[Leaf] = []
2293:    body_leaves: List[Leaf] = []
2294:    head_leaves: List[Leaf] = []
2295:    current_leaves = tail_leaves
2296:    opening_bracket = None
2297:    closing_bracket = None
2298:    for leaf in reversed(line.leaves):
2299:        if current_leaves is body_leaves:
2300:            if leaf is opening_bracket:
2301:                current_leaves = head_leaves if body_leaves else tail_leaves
2302:        current_leaves.append(leaf)
2303:        if current_leaves is tail_leaves:
2304:            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:
2305:                opening_bracket = leaf.opening_bracket
2306:                closing_bracket = leaf
2307:                current_leaves = body_leaves
2308:    if not (opening_bracket and closing_bracket and head_leaves):
2309:        # If there is no opening or closing_bracket that means the split failed and
2310:        # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means
2311:        # the matching `opening_bracket` wasn't available on `line` anymore.
2312:        raise CannotSplit("No brackets found")
2313:
2314:    tail_leaves.reverse()
2315:    body_leaves.reverse()
2316:    head_leaves.reverse()
2317:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
2318:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
2319:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
2320:    bracket_split_succeeded_or_raise(head, body, tail)
2321:    if (
2322:        # the body shouldn't be exploded
2323:        not body.should_explode
2324:        # the opening bracket is an optional paren
2325:        and opening_bracket.type == token.LPAR
2326:        and not opening_bracket.value
2327:        # the closing bracket is an optional paren
2328:        and closing_bracket.type == token.RPAR
2329:        and not closing_bracket.value
2330:        # it's not an import (optional parens are the only thing we can split on
2331:        # in this case; attempting a split without them is a waste of time)
2332:        and not line.is_import
2333:        # there are no standalone comments in the body
2334:        and not body.contains_standalone_comments(0)

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:852:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1218:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1311:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1321:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2136:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2412:                    if leaves[i].type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2784:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2814:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3114:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
820:        else:
821:            _type = token.tok_name.get(node.type, str(node.type))
822:            out(f"{indent}{_type}", fg="blue", nl=False)
823:            if node.prefix:
824:                # We don't have to handle prefixes for `Node` objects since
825:                # that delegates to the first child anyway.
826:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
827:            out(f" {node.value!r}", fg="blue", bold=False)
828:
829:    @classmethod
830:    def show(cls, code: Union[str, Leaf, Node]) -> None:
831:        """Pretty-print the lib2to3 AST of a given string of `code`.
832:
833:        Convenience method for debugging.
834:        """
835:        v: DebugVisitor[None] = DebugVisitor()
836:        if isinstance(code, str):
837:            code = lib2to3_parse(code)
838:        list(v.visit(code))
839:
840:
841:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
842:STATEMENT = {
843:    syms.if_stmt,
844:    syms.while_stmt,
845:    syms.for_stmt,
846:    syms.try_stmt,
847:    syms.except_clause,
848:    syms.with_stmt,
849:    syms.funcdef,
850:    syms.classdef,
851:}
852:STANDALONE_COMMENT = 153
853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
854:LOGIC_OPERATORS = {"and", "or"}
855:COMPARATORS = {
856:    token.LESS,
857:    token.GREATER,
858:    token.EQEQUAL,
859:    token.NOTEQUAL,
860:    token.LESSEQUAL,
861:    token.GREATEREQUAL,
862:}
863:MATH_OPERATORS = {
864:    token.VBAR,
865:    token.CIRCUMFLEX,
866:    token.AMPER,
867:    token.LEFTSHIFT,
868:    token.RIGHTSHIFT,
869:    token.PLUS,
870:    token.MINUS,
871:    token.STAR,
872:    token.SLASH,
873:    token.DOUBLESLASH,
874:    token.PERCENT,
875:    token.AT,
876:    token.TILDE,
877:    token.DOUBLESTAR,
878:}
879:STARS = {token.STAR, token.DOUBLESTAR}
880:VARARGS_PARENTS = {
881:    syms.arglist,
882:    syms.argument,  # double star in arglist
883:    syms.trailer,  # single argument to call
884:    syms.typedargslist,
885:    syms.varargslist,  # lambdas
886:}
887:UNPACKING_PARENTS = {
888:    syms.atom,  # single element of a list or set literal
889:    syms.dictsetmaker,
890:    syms.listmaker,
891:    syms.testlist_gexp,
892:    syms.testlist_star_expr,
893:}
894:TEST_DESCENDANTS = {
895:    syms.test,
896:    syms.lambdef,
897:    syms.or_test,
898:    syms.and_test,
899:    syms.not_test,
900:    syms.comparison,
901:    syms.star_expr,
902:    syms.expr,
903:    syms.xor_expr,
904:    syms.and_expr,
905:    syms.shift_expr,
906:    syms.arith_expr,
907:    syms.trailer,
908:    syms.term,
909:    syms.power,
910:}
911:ASSIGNMENTS = {
912:    "=",
913:    "+=",
914:    "-=",
915:    "*=",
916:    "@=",
917:    "/=",
918:    "%=",
919:    "&=",
920:    "|=",
921:    "^=",
922:    "<<=",
923:    ">>=",
924:    "**=",
925:    "//=",
926:}
927:COMPREHENSION_PRIORITY = 20
928:COMMA_PRIORITY = 18
929:TERNARY_PRIORITY = 16
930:LOGIC_PRIORITY = 14
931:STRING_PRIORITY = 12
932:COMPARATOR_PRIORITY = 10
933:MATH_PRIORITIES = {
934:    token.VBAR: 9,
935:    token.CIRCUMFLEX: 8,
936:    token.AMPER: 7,
937:    token.LEFTSHIFT: 6,
938:    token.RIGHTSHIFT: 6,
939:    token.PLUS: 5,
940:    token.MINUS: 5,
941:    token.STAR: 4,
942:    token.SLASH: 4,
943:    token.DOUBLESLASH: 4,
944:    token.PERCENT: 4,
945:    token.AT: 4,
946:    token.TILDE: 3,
947:    token.DOUBLESTAR: 2,
948:}
949:DOT_PRIORITY = 1
950:
951:
952:@dataclass
953:class BracketTracker:
954:    """Keeps track of brackets on a line."""
955:
956:    depth: int = 0
957:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
958:    delimiters: Dict[LeafID, Priority] = Factory(dict)
959:    previous: Optional[Leaf] = None
960:    _for_loop_depths: List[int] = Factory(list)
961:    _lambda_argument_depths: List[int] = Factory(list)
962:
963:    def mark(self, leaf: Leaf) -> None:
964:        """Mark `leaf` with bracket-related metadata. Keep track of delimiters.
965:
966:        All leaves receive an int `bracket_depth` field that stores how deep
967:        within brackets a given leaf is. 0 means there are no enclosing brackets
968:        that started on this line.
969:
970:        If a leaf is itself a closing bracket, it receives an `opening_bracket`
971:        field that it forms a pair with. This is a one-directional link to
972:        avoid reference cycles.
973:
974:        If a leaf is a delimiter (a token on which Black can split the line if
975:        needed) and it's on depth 0, its `id()` is stored in the tracker's
976:        `delimiters` field.
977:        """
978:        if leaf.type == token.COMMENT:
979:            return
980:
981:        self.maybe_decrement_after_for_loop_variable(leaf)
982:        self.maybe_decrement_after_lambda_arguments(leaf)
983:        if leaf.type in CLOSING_BRACKETS:
984:            self.depth -= 1
985:            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))
986:            leaf.opening_bracket = opening_bracket
987:        leaf.bracket_depth = self.depth
988:        if self.depth == 0:
989:            delim = is_split_before_delimiter(leaf, self.previous)
990:            if delim and self.previous is not None:
991:                self.delimiters[id(self.previous)] = delim
992:            else:
993:                delim = is_split_after_delimiter(leaf, self.previous)
994:                if delim:
995:                    self.delimiters[id(leaf)] = delim
996:        if leaf.type in OPENING_BRACKETS:
997:            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf
998:            self.depth += 1
999:        self.previous = leaf
1000:        self.maybe_increment_lambda_arguments(leaf)
1001:        self.maybe_increment_for_loop_variable(leaf)
1002:
1003:    def any_open_brackets(self) -> bool:
1004:        """Return True if there is an yet unmatched open bracket on the line."""
1005:        return bool(self.bracket_match)
1006:
1007:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
1008:        """Return the highest priority of a delimiter found on the line.
1009:
1010:        Values are consistent with what `is_split_*_delimiter()` return.
1011:        Raises ValueError on no delimiters.
1012:        """
1013:        return max(v for k, v in self.delimiters.items() if k not in exclude)
1014:
1015:    def delimiter_count_with_priority(self, priority: int = 0) -> int:
1016:        """Return the number of delimiters with the given `priority`.
1017:
1018:        If no `priority` is passed, defaults to max priority on the line.
1019:        """
1020:        if not self.delimiters:
1021:            return 0
1022:
1023:        priority = priority or self.max_delimiter_priority()
1024:        return sum(1 for p in self.delimiters.values() if p == priority)
1025:
1026:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
1027:        """In a for loop, or comprehension, the variables are often unpacks.
1028:
1029:        To avoid splitting on the comma in this situation, increase the depth of
1030:        tokens between `for` and `in`.
1031:        """
1032:        if leaf.type == token.NAME and leaf.value == "for":
1033:            self.depth += 1
1034:            self._for_loop_depths.append(self.depth)
1035:            return True
1036:
1037:        return False
1038:
1039:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
1040:        """See `maybe_increment_for_loop_variable` above for explanation."""
1041:        if (
1042:            self._for_loop_depths
1043:            and self._for_loop_depths[-1] == self.depth
1044:            and leaf.type == token.NAME
1045:            and leaf.value == "in"
1046:        ):
1047:            self.depth -= 1
1048:            self._for_loop_depths.pop()
1049:            return True
1050:
1051:        return False
1052:
1053:    def maybe_increment_lambda_arguments(self, leaf: Leaf) -> bool:
1054:        """In a lambda expression, there might be more than one argument.
1055:
1056:        To avoid splitting on the comma in this situation, increase the depth of
1057:        tokens between `lambda` and `:`.
1058:        """
1059:        if leaf.type == token.NAME and leaf.value == "lambda":
1060:            self.depth += 1
1061:            self._lambda_argument_depths.append(self.depth)
1062:            return True
1063:
1064:        return False
1065:
1066:    def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:
1067:        """See `maybe_increment_lambda_arguments` above for explanation."""
1068:        if (
1069:            self._lambda_argument_depths
1070:            and self._lambda_argument_depths[-1] == self.depth
1071:            and leaf.type == token.COLON
1072:        ):
1073:            self.depth -= 1
1074:            self._lambda_argument_depths.pop()
1075:            return True
1076:
1077:        return False
1078:
1079:    def get_open_lsqb(self) -> Optional[Leaf]:
1080:        """Return the most recent opening square bracket (if any)."""
1081:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1082:
1083:
1084:@dataclass
1085:class Line:
1086:    """Holds leaves and comments. Can be printed with `str(line)`."""
1087:
1088:    depth: int = 0
1089:    leaves: List[Leaf] = Factory(list)
1090:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)  # keys ordered like `leaves`
1091:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1092:    inside_brackets: bool = False
1093:    should_explode: bool = False
1094:
1095:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1096:        """Add a new `leaf` to the end of the line.
1097:
1098:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1099:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1100:        Trailing commas are maybe removed, unpacked for loop variables are
1101:        demoted from being delimiters.
1102:
1103:        Inline comments are put aside.
1104:        """
1105:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1106:        if not has_value:
1107:            return
1108:
1109:        if token.COLON == leaf.type and self.is_class_paren_empty:
1110:            del self.leaves[-2:]
1111:        if self.leaves and not preformatted:
1112:            # Note: at this point leaf.prefix should be empty except for
1113:            # imports, for which we only preserve newlines.
1114:            leaf.prefix += whitespace(
1115:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1116:            )
1117:        if self.inside_brackets or not preformatted:
1118:            self.bracket_tracker.mark(leaf)
1119:            self.maybe_remove_trailing_comma(leaf)
1120:        if not self.append_comment(leaf):
1121:            self.leaves.append(leaf)
1122:
1123:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1124:        """Like :func:`append()` but disallow invalid standalone comment structure.
1125:
1126:        Raises ValueError when any `leaf` is appended after a standalone comment
1127:        or when a standalone comment is not the first leaf on the line.
1128:        """
1129:        if self.bracket_tracker.depth == 0:
1130:            if self.is_comment:
1131:                raise ValueError("cannot append to standalone comments")
1132:
1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1134:                raise ValueError(
1135:                    "cannot append standalone comments to a populated line"
1136:                )
1137:
1138:        self.append(leaf, preformatted=preformatted)
1139:
1140:    @property
1141:    def is_comment(self) -> bool:
1142:        """Is this line a standalone comment?"""
1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1144:
1145:    @property
1146:    def is_decorator(self) -> bool:
1147:        """Is this line a decorator?"""
1148:        return bool(self) and self.leaves[0].type == token.AT
1149:
1150:    @property
1151:    def is_import(self) -> bool:
1152:        """Is this an import line?"""
1153:        return bool(self) and is_import(self.leaves[0])
1154:
1155:    @property
1156:    def is_class(self) -> bool:
1157:        """Is this line a class definition?"""
1158:        return (
1159:            bool(self)
1160:            and self.leaves[0].type == token.NAME
1161:            and self.leaves[0].value == "class"
1162:        )
1163:
1164:    @property
1165:    def is_stub_class(self) -> bool:
1166:        """Is this line a class definition with a body consisting only of "..."?"""
1167:        return self.is_class and self.leaves[-3:] == [
1168:            Leaf(token.DOT, ".") for _ in range(3)
1169:        ]
1170:
1171:    @property
1172:    def is_def(self) -> bool:
1173:        """Is this a function definition? (Also returns True for async defs.)"""
1174:        try:
1175:            first_leaf = self.leaves[0]
1176:        except IndexError:
1177:            return False
1178:
1179:        try:
1180:            second_leaf: Optional[Leaf] = self.leaves[1]
1181:        except IndexError:
1182:            second_leaf = None
1183:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1184:            first_leaf.type == token.ASYNC
1185:            and second_leaf is not None
1186:            and second_leaf.type == token.NAME
1187:            and second_leaf.value == "def"
1188:        )
1189:
1190:    @property
1191:    def is_class_paren_empty(self) -> bool:
1192:        """Is this a class with no base classes but using parentheses?
1193:
1194:        Those are unnecessary and should be removed.
1195:        """
1196:        return (
1197:            bool(self)
1198:            and len(self.leaves) == 4
1199:            and self.is_class
1200:            and self.leaves[2].type == token.LPAR
1201:            and self.leaves[2].value == "("
1202:            and self.leaves[3].type == token.RPAR
1203:            and self.leaves[3].value == ")"
1204:        )
1205:
1206:    @property
1207:    def is_triple_quoted_string(self) -> bool:
1208:        """Is the line a triple quoted string?"""
1209:        return (
1210:            bool(self)
1211:            and self.leaves[0].type == token.STRING
1212:            and self.leaves[0].value.startswith(('"""', "'''"))
1213:        )
1214:
1215:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1216:        """If so, needs to be split before emitting."""
1217:        for leaf in self.leaves:
1218:            if leaf.type == STANDALONE_COMMENT:
1219:                if leaf.bracket_depth <= depth_limit:
1220:                    return True
1221:        return False
1222:
1223:    def contains_inner_type_comments(self) -> bool:
1224:        ignored_ids = set()
1225:        try:
1226:            last_leaf = self.leaves[-1]
1227:            ignored_ids.add(id(last_leaf))
1228:            if last_leaf.type == token.COMMA:
1229:                # When trailing commas are inserted by Black for consistency, comments
1230:                # after the previous last element are not moved (they don't have to,
1231:                # rendering will still be correct).  So we ignore trailing commas.
1232:                last_leaf = self.leaves[-2]
1233:                ignored_ids.add(id(last_leaf))
1234:        except IndexError:
1235:            return False
1236:
1237:        for leaf_id, comments in self.comments.items():
1238:            if leaf_id in ignored_ids:
1239:                continue
1240:
1241:            for comment in comments:
1242:                if is_type_comment(comment):
1243:                    return True
1244:
1245:        return False
1246:
1247:    def contains_multiline_strings(self) -> bool:
1248:        for leaf in self.leaves:
1249:            if is_multiline_string(leaf):
1250:                return True
1251:
1252:        return False
1253:
1254:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1255:        """Remove trailing comma if there is one and it's safe."""
1256:        if not (
1257:            self.leaves
1258:            and self.leaves[-1].type == token.COMMA
1259:            and closing.type in CLOSING_BRACKETS
1260:        ):
1261:            return False
1262:
1263:        if closing.type == token.RBRACE:
1264:            self.remove_trailing_comma()
1265:            return True
1266:
1267:        if closing.type == token.RSQB:
1268:            comma = self.leaves[-1]
1269:            if comma.parent and comma.parent.type == syms.listmaker:
1270:                self.remove_trailing_comma()
1271:                return True
1272:
1273:        # For parens let's check if it's safe to remove the comma.
1274:        # Imports are always safe.
1275:        if self.is_import:
1276:            self.remove_trailing_comma()
1277:            return True
1278:
1279:        # Otherwise, if the trailing one is the only one, we might mistakenly

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2000:    ):
2001:        return MATH_PRIORITIES[leaf.type]
2002:
2003:    if leaf.type in COMPARATORS:
2004:        return COMPARATOR_PRIORITY
2005:
2006:    if (
2007:        leaf.type == token.STRING
2008:        and previous is not None
2009:        and previous.type == token.STRING
2010:    ):
2011:        return STRING_PRIORITY
2012:
2013:    if leaf.type not in {token.NAME, token.ASYNC}:
2014:        return 0
2015:
2016:    if (
2017:        leaf.value == "for"
2018:        and leaf.parent
2019:        and leaf.parent.type in {syms.comp_for, syms.old_comp_for}
2020:        or leaf.type == token.ASYNC
2021:    ):
2022:        if (
2023:            not isinstance(leaf.prev_sibling, Leaf)
2024:            or leaf.prev_sibling.value != "async"
2025:        ):
2026:            return COMPREHENSION_PRIORITY
2027:
2028:    if (
2029:        leaf.value == "if"
2030:        and leaf.parent
2031:        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
2032:    ):
2033:        return COMPREHENSION_PRIORITY
2034:
2035:    if leaf.value in {"if", "else"} and leaf.parent and leaf.parent.type == syms.test:
2036:        return TERNARY_PRIORITY
2037:
2038:    if leaf.value == "is":
2039:        return COMPARATOR_PRIORITY
2040:
2041:    if (
2042:        leaf.value == "in"
2043:        and leaf.parent
2044:        and leaf.parent.type in {syms.comp_op, syms.comparison}
2045:        and not (
2046:            previous is not None
2047:            and previous.type == token.NAME
2048:            and previous.value == "not"
2049:        )
2050:    ):
2051:        return COMPARATOR_PRIORITY
2052:
2053:    if (
2054:        leaf.value == "not"
2055:        and leaf.parent
2056:        and leaf.parent.type == syms.comp_op
2057:        and not (
2058:            previous is not None
2059:            and previous.type == token.NAME
2060:            and previous.value == "is"
2061:        )
2062:    ):
2063:        return COMPARATOR_PRIORITY
2064:
2065:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
2066:        return LOGIC_PRIORITY
2067:
2068:    return 0
2069:
2070:
2071:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2072:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2073:
2074:
2075:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2076:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2077:
2078:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2079:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2080:    move because it does away with modifying the grammar to include all the
2081:    possible places in which comments can be placed.
2082:
2083:    The sad consequence for us though is that comments don't "belong" anywhere.
2084:    This is why this function generates simple parentless Leaf objects for
2085:    comments.  We simply don't know what the correct parent should be.
2086:
2087:    No matter though, we can live without this.  We really only need to
2088:    differentiate between inline and standalone comments.  The latter don't
2089:    share the line with any code.
2090:
2091:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
2093:    """
2094:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2095:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2096:
2097:
2098:@dataclass
2099:class ProtoComment:
2100:    """Describes a piece of syntax that is a comment.
2101:
2102:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2103:
2104:    * it can be cached (`Leaf` objects should not be reused more than once as
2105:      they store their lineno, column, prefix, and parent information);
2106:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2107:      simplifies handling of special marker comments like ``# fmt: off/on``.
2108:    """
2109:
2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
2111:    value: str  # content of the comment
2112:    newlines: int  # how many newlines before the comment
2113:    consumed: int  # how many characters of the original leaf's prefix did we consume
2114:
2115:
2116:@lru_cache(maxsize=4096)
2117:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2118:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2119:    result: List[ProtoComment] = []
2120:    if not prefix or "#" not in prefix:
2121:        return result
2122:
2123:    consumed = 0
2124:    nlines = 0
2125:    for index, line in enumerate(prefix.split("\n")):
2126:        consumed += len(line) + 1  # adding the length of the split '\n'
2127:        line = line.lstrip()
2128:        if not line:
2129:            nlines += 1
2130:        if not line.startswith("#"):
2131:            continue
2132:
2133:        if index == 0 and not is_endmarker:
2134:            comment_type = token.COMMENT  # simple trailing comment
2135:        else:
2136:            comment_type = STANDALONE_COMMENT
2137:        comment = make_comment(line)
2138:        result.append(
2139:            ProtoComment(
2140:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2141:            )
2142:        )
2143:        nlines = 0
2144:    return result
2145:
2146:
2147:def make_comment(content: str) -> str:
2148:    """Return a consistently formatted comment from the given `content` string.
2149:
2150:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2151:    space between the hash sign and the content.
2152:
2153:    If `content` didn't start with a hash sign, one is provided.
2154:    """
2155:    content = content.rstrip()
2156:    if not content:
2157:        return "#"
2158:
2159:    if content[0] == "#":
2160:        content = content[1:]
2161:    if content and content[0] not in " !:#'%":
2162:        content = " " + content
2163:    return "#" + content
2164:
2165:
2166:def split_line(
2167:    line: Line,
2168:    line_length: int,
2169:    inner: bool = False,
2170:    features: Collection[Feature] = (),
2171:) -> Iterator[Line]:
2172:    """Split a `line` into potentially many lines.
2173:
2174:    They should fit in the allotted `line_length` but might not be able to.
2175:    `inner` signifies that there were a pair of brackets somewhere around the
2176:    current `line`, possibly transitively. This means we can fallback to splitting
2177:    by delimiters if the LHS/RHS don't yield any results.
2178:
2179:    `features` are syntactical features that may be used in the output.
2180:    """
2181:    if line.is_comment:
2182:        yield line
2183:        return
2184:
2185:    line_str = str(line).strip("\n")
2186:
2187:    if (
2188:        not line.contains_inner_type_comments()
2189:        and not line.should_explode
2190:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2191:    ):
2192:        yield line
2193:        return
2194:
2195:    split_funcs: List[SplitFunc]
2196:    if line.is_def:
2197:        split_funcs = [left_hand_split]
2198:    else:
2199:
2200:        def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:
2201:            for omit in generate_trailers_to_omit(line, line_length):
2202:                lines = list(right_hand_split(line, line_length, features, omit=omit))
2203:                if is_line_short_enough(lines[0], line_length=line_length):
2204:                    yield from lines
2205:                    return
2206:
2207:            # All splits failed, best effort split with no omits.
2208:            # This mostly happens to multiline strings that are by definition
2209:            # reported as not fitting a single line.
2210:            yield from right_hand_split(line, line_length, features=features)
2211:
2212:        if line.inside_brackets:
2213:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2214:        else:
2215:            split_funcs = [rhs]
2216:    for split_func in split_funcs:
2217:        # We are accumulating lines in `result` because we might want to abort
2218:        # mission and return the original line in the end, or attempt a different
2219:        # split altogether.

Calling tool: grepTool
def append_comment\(|def comments_after\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1308:    def append_comment(self, comment: Leaf) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1328:    def comments_after(self, leaf: Leaf) -> List[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1296:            if bracket_depth == depth and leaf.type == token.COMMA:
1297:                commas += 1
1298:                if leaf.parent and leaf.parent.type == syms.arglist:
1299:                    commas += 1
1300:                    break
1301:
1302:        if commas > 1:
1303:            self.remove_trailing_comma()
1304:            return True
1305:
1306:        return False
1307:
1308:    def append_comment(self, comment: Leaf) -> bool:
1309:        """Add an inline or standalone comment to the line."""
1310:        if (
1311:            comment.type == STANDALONE_COMMENT
1312:            and self.bracket_tracker.any_open_brackets()
1313:        ):
1314:            comment.prefix = ""
1315:            return False
1316:
1317:        if comment.type != token.COMMENT:
1318:            return False
1319:
1320:        if not self.leaves:
1321:            comment.type = STANDALONE_COMMENT
1322:            comment.prefix = ""
1323:            return False
1324:
1325:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1326:        return True
1327:
1328:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1329:        """Generate comments that should appear directly after `leaf`."""
1330:        return self.comments.get(id(leaf), [])
1331:
1332:    def remove_trailing_comma(self) -> None:
1333:        """Remove the trailing comma and moves the comments attached to it."""
1334:        trailing_comma = self.leaves.pop()
1335:        trailing_comma_comments = self.comments.pop(id(trailing_comma), [])
1336:        self.comments.setdefault(id(self.leaves[-1]), []).extend(
1337:            trailing_comma_comments
1338:        )
1339:
1340:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1341:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1342:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1343:        if open_lsqb is None:
1344:            return False
1345:
1346:        subscript_start = open_lsqb.next_sibling
1347:
1348:        if isinstance(subscript_start, Node):
1349:            if subscript_start.type == syms.listmaker:
1350:                return False
1351:
1352:            if subscript_start.type == syms.subscriptlist:
1353:                subscript_start = child_towards(subscript_start, leaf)
1354:        return subscript_start is not None and any(
1355:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()

Calling tool: grepTool
def is_import\(
Matched content:
1151:    def is_import(self) -> bool:
2545:def is_import(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2536:        yield from append_to_line(leaf)
2537:
2538:        for comment_after in line.comments_after(leaf):
2539:            yield from append_to_line(comment_after)
2540:
2541:    if current_line:
2542:        yield current_line
2543:
2544:
2545:def is_import(leaf: Leaf) -> bool:
2546:    """Return True if the given leaf starts an import statement."""
2547:    p = leaf.parent
2548:    t = leaf.type
2549:    v = leaf.value
2550:    return bool(
2551:        t == token.NAME
2552:        and (
2553:            (v == "import" and p and p.type == syms.import_name)
2554:            or (v == "from" and p and p.type == syms.import_from)
2555:        )
2556:    )
2557:
2558:
2559:def is_type_comment(leaf: Leaf) -> bool:
2560:    """Return True if the given leaf is a special comment.
2561:    Only returns true for type comments for now."""
2562:    t = leaf.type
2563:    v = leaf.value
2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
2565:
2566:
2567:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2568:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2569:    else.
2570:
2571:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2572:    """
2573:    if not inside_brackets:
2574:        spl = leaf.prefix.split("#")
2575:        if "\\" not in spl[0]:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The updated logic in black.py’s bracket_split_build_line now scans backward over body_leaves, skips STANDALONE_COMMENT leaves, and inserts a comma after the last non-comment leaf when original.is_import is true. This ensures the comma is placed after the last imported name and before any following comments. The test data for test_comments7 expects exactly this output (no_comma_here_yet, followed by comments), matching the new implementation.


Todo item 11 of 11 is correct
description: 'In `test_comments7`, verify that when the last real imported name lacks a trailing comma but is followed by comments, the expected formatted output contains a comma immediately after that name (before comments), not at the very end after comments.'
Validating todo item 1 of 11
description: 'In `black.py`, locate `bracket_split_build_line` and verify the trailing-comma logic is only applied when `original.is_import` and `leaves` is non-empty, preserving existing behavior for non-import cases.'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize
2468:    trailing_comma_safe = True
2469:
2470:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2471:        """Append `leaf` to current line or to new line if appending impossible."""
2472:        nonlocal current_line

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py’s bracket_split_build_line (lines 2405-2418), the trailing comma insertion is gated by `if leaves:` and further by `if original.is_import:`. No trailing comma logic is applied for non-import cases, preserving prior behavior.

Todo item 1 of 11 is correct
description: 'In `black.py`, locate `bracket_split_build_line` and verify the trailing-comma logic is only applied when `original.is_import` and `leaves` is non-empty, preserving existing behavior for non-import cases.'

Validating todo item 2 of 11
description: 'Confirm `STANDALONE_COMMENT` is defined/imported in `black.py` and accessible within `bracket_split_build_line` (no NameError risk). Identify its definition to ensure it represents standalone comment leaves used in this code path.'

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:852:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1218:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1311:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1321:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2136:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2412:                    if leaves[i].type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2784:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2814:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3114:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
840:
841:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
842:STATEMENT = {
843:    syms.if_stmt,
844:    syms.while_stmt,
845:    syms.for_stmt,
846:    syms.try_stmt,
847:    syms.except_clause,
848:    syms.with_stmt,
849:    syms.funcdef,
850:    syms.classdef,
851:}
852:STANDALONE_COMMENT = 153
853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
854:LOGIC_OPERATORS = {"and", "or"}
855:COMPARATORS = {
856:    token.LESS,
857:    token.GREATER,
858:    token.EQEQUAL,
859:    token.NOTEQUAL,
860:    token.LESSEQUAL,
861:    token.GREATEREQUAL,
862:}
863:MATH_OPERATORS = {
864:    token.VBAR,
865:    token.CIRCUMFLEX,
866:    token.AMPER,
867:    token.LEFTSHIFT,
868:    token.RIGHTSHIFT,
869:    token.PLUS,
870:    token.MINUS,
871:    token.STAR,
872:    token.SLASH,
873:    token.DOUBLESLASH,
874:    token.PERCENT,
875:    token.AT,
876:    token.TILDE,
877:    token.DOUBLESTAR,
878:}
879:STARS = {token.STAR, token.DOUBLESTAR}

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2086:
2087:    No matter though, we can live without this.  We really only need to
2088:    differentiate between inline and standalone comments.  The latter don't
2089:    share the line with any code.
2090:
2091:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
2093:    """
2094:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2095:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2096:
2097:
2098:@dataclass
2099:class ProtoComment:
2100:    """Describes a piece of syntax that is a comment.
2101:
2102:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2103:
2104:    * it can be cached (`Leaf` objects should not be reused more than once as
2105:      they store their lineno, column, prefix, and parent information);
2106:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2107:      simplifies handling of special marker comments like ``# fmt: off/on``.
2108:    """
2109:
2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
2111:    value: str  # content of the comment
2112:    newlines: int  # how many newlines before the comment
2113:    consumed: int  # how many characters of the original leaf's prefix did we consume
2114:
2115:
2116:@lru_cache(maxsize=4096)
2117:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2118:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2119:    result: List[ProtoComment] = []
2120:    if not prefix or "#" not in prefix:
2121:        return result
2122:
2123:    consumed = 0
2124:    nlines = 0
2125:    for index, line in enumerate(prefix.split("\n")):
2126:        consumed += len(line) + 1  # adding the length of the split '\n'
2127:        line = line.lstrip()
2128:        if not line:
2129:            nlines += 1
2130:        if not line.startswith("#"):
2131:            continue
2132:
2133:        if index == 0 and not is_endmarker:
2134:            comment_type = token.COMMENT  # simple trailing comment
2135:        else:
2136:            comment_type = STANDALONE_COMMENT
2137:        comment = make_comment(line)
2138:        result.append(
2139:            ProtoComment(
2140:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2141:            )
2142:        )
2143:        nlines = 0
2144:    return result
2145:
2146:
2147:def make_comment(content: str) -> str:
2148:    """Return a consistently formatted comment from the given `content` string.
2149:
2150:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2151:    space between the hash sign and the content.
2152:
2153:    If `content` didn't start with a hash sign, one is provided.
2154:    """
2155:    content = content.rstrip()
2156:    if not content:
2157:        return "#"
2158:
2159:    if content[0] == "#":
2160:        content = content[1:]
2161:    if content and content[0] not in " !:#'%":
2162:        content = " " + content
2163:    return "#" + content
2164:
2165:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: STANDALONE_COMMENT is defined at black.py:852 and registered in token.tok_name; it’s used throughout to mark standalone comment leaves (e.g., set in list_comments at lines 2133-2137). bracket_split_build_line (around 2393-2418) references it in-scope, so there’s no NameError risk.

Todo item 2 of 11 is correct
description: 'Confirm `STANDALONE_COMMENT` is defined/imported in `black.py` and accessible within `bracket_split_build_line` (no NameError risk). Identify its definition to ensure it represents standalone comment leaves used in this code path.'

Validating todo item 3 of 11
description: 'Verify the new loop iterates backward over `leaves` and correctly skips all trailing `STANDALONE_COMMENT` leaves before making a decision about inserting a comma.'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize
2468:    trailing_comma_safe = True
2469:
2470:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2471:        """Append `leaf` to current line or to new line if appending impossible."""
2472:        nonlocal current_line
2473:        try:
2474:            current_line.append_safe(leaf, preformatted=True)
2475:        except ValueError:
2476:            yield current_line
2477:
2478:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2479:            current_line.append(leaf)
2480:
2481:    for leaf in line.leaves:
2482:        yield from append_to_line(leaf)
2483:
2484:        for comment_after in line.comments_after(leaf):
2485:            yield from append_to_line(comment_after)
2486:
2487:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2488:        if leaf.bracket_depth == lowest_depth:
2489:            if is_vararg(leaf, within={syms.typedargslist}):
2490:                trailing_comma_safe = (
2491:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features
2492:                )
2493:            elif is_vararg(leaf, within={syms.arglist, syms.argument}):
2494:                trailing_comma_safe = (
2495:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features
2496:                )
2497:
2498:        leaf_priority = bt.delimiters.get(id(leaf))
2499:        if leaf_priority == delimiter_priority:
2500:            yield current_line
2501:
2502:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2503:    if current_line:
2504:        if (
2505:            trailing_comma_safe
2506:            and delimiter_priority == COMMA_PRIORITY
2507:            and current_line.leaves[-1].type != token.COMMA

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py:2393+, the loop iterates from the end toward the start (range(len(leaves)-1, -1, -1)) and continues past any STANDALONE_COMMENT leaves. It then checks the first non-comment: if it’s a COMMA it breaks, otherwise inserts a comma at i+1. This correctly skips trailing comments before deciding on insertion.

Todo item 3 of 11 is correct
description: 'Verify the new loop iterates backward over `leaves` and correctly skips all trailing `STANDALONE_COMMENT` leaves before making a decision about inserting a comma.'

Validating todo item 4 of 11
description: 'Check that the condition `elif leaves[i].type == token.COMMA: break` prevents inserting an additional comma when a trailing comma already exists before trailing comments (i.e., handles the regression case from Issue #671).'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize

Calling tool: grepTool
test_comments7\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments7
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py:392:    def test_comments7(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py
380:        black.assert_equivalent(source, actual)
381:        black.assert_stable(source, actual, black.FileMode())
382:
383:    @patch("black.dump_to_file", dump_to_stderr)
384:    def test_comments6(self) -> None:
385:        source, expected = read_data("comments6")
386:        actual = fs(source)
387:        self.assertFormatEqual(expected, actual)
388:        black.assert_equivalent(source, actual)
389:        black.assert_stable(source, actual, black.FileMode())
390:
391:    @patch("black.dump_to_file", dump_to_stderr)
392:    def test_comments7(self) -> None:
393:        source, expected = read_data("comments7")
394:        actual = fs(source)
395:        self.assertFormatEqual(expected, actual)
396:        black.assert_equivalent(source, actual)
397:        black.assert_stable(source, actual, black.FileMode())
398:
399:    @patch("black.dump_to_file", dump_to_stderr)
400:    def test_cantfit(self) -> None:
401:        source, expected = read_data("cantfit")
402:        actual = fs(source)
403:        self.assertFormatEqual(expected, actual)
404:        black.assert_equivalent(source, actual)
405:        black.assert_stable(source, actual, black.FileMode())
406:
407:    @patch("black.dump_to_file", dump_to_stderr)
408:    def test_import_spacing(self) -> None:
409:        source, expected = read_data("import_spacing")
410:        actual = fs(source)
411:        self.assertFormatEqual(expected, actual)
412:        black.assert_equivalent(source, actual)
413:        black.assert_stable(source, actual, black.FileMode())
414:
415:    @patch("black.dump_to_file", dump_to_stderr)
416:    def test_composition(self) -> None:
417:        source, expected = read_data("composition")
418:        actual = fs(source)
419:        self.assertFormatEqual(expected, actual)

Calling tool: globTool
**/*comments7*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py
1:from .config import (
2:    Any,
3:    Bool,
4:    ConfigType,
5:    ConfigTypeAttributes,
6:    Int,
7:    Path,
8:    #  String,
9:    #  resolve_to_config_type,
10:    #  DEFAULT_TYPE_ATTRIBUTES,
11:)
12:
13:
14:from .config import (
15:    Any,
16:    Bool,
17:    ConfigType,
18:    ConfigTypeAttributes,
19:    Int,
20:    no_comma_here_yet
21:    #  and some comments,
22:    #  resolve_to_config_type,
23:    #  DEFAULT_TYPE_ATTRIBUTES,
24:)
25:
26:# output
27:
28:from .config import (
29:    Any,
30:    Bool,
31:    ConfigType,
32:    ConfigTypeAttributes,
33:    Int,
34:    Path,
35:    #  String,
36:    #  resolve_to_config_type,
37:    #  DEFAULT_TYPE_ATTRIBUTES,
38:)
39:
40:
41:from .config import (
42:    Any,
43:    Bool,
44:    ConfigType,
45:    ConfigTypeAttributes,
46:    Int,
47:    no_comma_here_yet,
48:    #  and some comments,
49:    #  resolve_to_config_type,
50:    #  DEFAULT_TYPE_ATTRIBUTES,
51:)

Calling tool: grepTool
STANDALONE_COMMENT\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:852:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1218:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1311:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1321:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2136:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2412:                    if leaves[i].type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2784:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2814:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3114:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
840:
841:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
842:STATEMENT = {
843:    syms.if_stmt,
844:    syms.while_stmt,
845:    syms.for_stmt,
846:    syms.try_stmt,
847:    syms.except_clause,
848:    syms.with_stmt,
849:    syms.funcdef,
850:    syms.classdef,
851:}
852:STANDALONE_COMMENT = 153
853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
854:LOGIC_OPERATORS = {"and", "or"}
855:COMPARATORS = {
856:    token.LESS,
857:    token.GREATER,
858:    token.EQEQUAL,
859:    token.NOTEQUAL,
860:    token.LESSEQUAL,
861:    token.GREATEREQUAL,
862:}
863:MATH_OPERATORS = {
864:    token.VBAR,
865:    token.CIRCUMFLEX,
866:    token.AMPER,
867:    token.LEFTSHIFT,
868:    token.RIGHTSHIFT,
869:    token.PLUS,

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In `black.py` lines 2411-2418, the loop skips trailing `STANDALONE_COMMENT` leaves and checks `elif leaves[i].type == token.COMMA: break`, which stops insertion when a trailing comma already exists before comments. This matches the requirement and is validated by the `tests/data/comments7.py` case where the first import remains unchanged.

Todo item 4 of 11 is correct
description: 'Check that the condition `elif leaves[i].type == token.COMMA: break` prevents inserting an additional comma when a trailing comma already exists before trailing comments (i.e., handles the regression case from Issue #671).'

Validating todo item 5 of 11
description: 'Verify that when the last non-comment leaf is not a comma, `leaves.insert(i + 1, Leaf(token.COMMA, ","))` inserts the comma immediately after that leaf (and not after any comments), matching the PR intent.'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:852:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1218:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1311:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1321:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2136:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2412:                    if leaves[i].type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2784:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2814:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3114:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py:2393-2426, the loop scans leaves backward, skips STANDALONE_COMMENTs, and if the first non-comment is not a COMMA, it inserts a COMMA at i+1. This places the comma immediately after the last non-comment leaf and before any trailing comments, matching the PR intent.

Todo item 5 of 11 is correct
description: 'Verify that when the last non-comment leaf is not a comma, `leaves.insert(i + 1, Leaf(token.COMMA, ","))` inserts the comma immediately after that leaf (and not after any comments), matching the PR intent.'

Validating todo item 6 of 11
description: 'Confirm that if all trailing leaves are comments (or all leaves are comments), the loop exits without inserting a comma (i.e., no dangling comma is added at the end of the block).'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: In black.py lines 2405-2418, the loop iterates backward over leaves, skipping STANDALONE_COMMENTs. If all leaves are comments, no non-comment is encountered, so no insertion occurs and no dangling comma is added.

Todo item 6 of 11 is correct
description: 'Confirm that if all trailing leaves are comments (or all leaves are comments), the loop exits without inserting a comma (i.e., no dangling comma is added at the end of the block).'

Validating todo item 7 of 11
description: 'Ensure that use of `Leaf(token.COMMA, ",")` is consistent with similar code elsewhere in the file (e.g., previously appended commas) and that `Leaf` and `token` are in scope for this function.'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize

Calling tool: grepTool
Leaf\(token\.COMMA, ","\)
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2510:            current_line.append(Leaf(token.COMMA, ","))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2488:        if leaf.bracket_depth == lowest_depth:
2489:            if is_vararg(leaf, within={syms.typedargslist}):
2490:                trailing_comma_safe = (
2491:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features
2492:                )
2493:            elif is_vararg(leaf, within={syms.arglist, syms.argument}):
2494:                trailing_comma_safe = (
2495:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features
2496:                )
2497:
2498:        leaf_priority = bt.delimiters.get(id(leaf))
2499:        if leaf_priority == delimiter_priority:
2500:            yield current_line
2501:
2502:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2503:    if current_line:
2504:        if (
2505:            trailing_comma_safe
2506:            and delimiter_priority == COMMA_PRIORITY
2507:            and current_line.leaves[-1].type != token.COMMA
2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
2509:        ):
2510:            current_line.append(Leaf(token.COMMA, ","))
2511:        yield current_line
2512:
2513:
2514:@dont_increase_indentation
2515:def standalone_comment_split(
2516:    line: Line, features: Collection[Feature] = ()
2517:) -> Iterator[Line]:
2518:    """Split standalone comments from the rest of the line."""
2519:    if not line.contains_standalone_comments(0):
2520:        raise CannotSplit("Line does not have any standalone comments")
2521:
2522:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2523:
2524:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2525:        """Append `leaf` to current line or to new line if appending impossible."""
2526:        nonlocal current_line
2527:        try:
2528:            current_line.append_safe(leaf, preformatted=True)
2529:        except ValueError:
2530:            yield current_line
2531:
2532:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2533:            current_line.append(leaf)
2534:
2535:    for leaf in line.leaves:
2536:        yield from append_to_line(leaf)
2537:

Calling tool: grepTool
import token
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/pytree.py:26:        # from .pgen2 import token // token.__dict__.items():
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/pgen2/tokenize.py:36:from . import token
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/pgen2/parse.py:14:from . import token
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/pygram.py:10:from .pgen2 import token
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/pgen2/grammar.py:21:from . import token
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:18:import tokenize

Calling tool: grepTool
token\)
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
from .* import token
No files found. Call grepTool again with a more generic pattern.

Calling tool: grepTool
token\.
Showing first 50 results from grep. Consider using a more specific pattern or path.
793:            name = token.tok_name[node.type]
821:            _type = token.tok_name.get(node.type, str(node.type))
841:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
856:    token.LESS,
857:    token.GREATER,
858:    token.EQEQUAL,
859:    token.NOTEQUAL,
860:    token.LESSEQUAL,
861:    token.GREATEREQUAL,
864:    token.VBAR,
865:    token.CIRCUMFLEX,
866:    token.AMPER,
867:    token.LEFTSHIFT,
868:    token.RIGHTSHIFT,
869:    token.PLUS,
870:    token.MINUS,
871:    token.STAR,
872:    token.SLASH,
873:    token.DOUBLESLASH,
874:    token.PERCENT,
875:    token.AT,
876:    token.TILDE,
877:    token.DOUBLESTAR,
879:STARS = {token.STAR, token.DOUBLESTAR}
934:    token.VBAR: 9,
935:    token.CIRCUMFLEX: 8,
936:    token.AMPER: 7,
937:    token.LEFTSHIFT: 6,
938:    token.RIGHTSHIFT: 6,
939:    token.PLUS: 5,
940:    token.MINUS: 5,
941:    token.STAR: 4,
942:    token.SLASH: 4,
943:    token.DOUBLESLASH: 4,
944:    token.PERCENT: 4,
945:    token.AT: 4,
946:    token.TILDE: 3,
947:    token.DOUBLESTAR: 2,
978:        if leaf.type == token.COMMENT:
1032:        if leaf.type == token.NAME and leaf.value == "for":
1044:            and leaf.type == token.NAME
1059:        if leaf.type == token.NAME and leaf.value == "lambda":
1071:            and leaf.type == token.COLON
1081:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1109:        if token.COLON == leaf.type and self.is_class_paren_empty:
1148:        return bool(self) and self.leaves[0].type == token.AT
1160:            and self.leaves[0].type == token.NAME
1168:            Leaf(token.DOT, ".") for _ in range(3)
1183:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1:import asyncio
2:from asyncio.base_events import BaseEventLoop
3:from concurrent.futures import Executor, ProcessPoolExecutor
4:from datetime import datetime
5:from enum import Enum
6:from functools import lru_cache, partial, wraps
7:import io
8:import itertools
9:import logging
10:from multiprocessing import Manager, freeze_support
11:import os
12:from pathlib import Path
13:import pickle
14:import re
15:import signal
16:import sys
17:import tempfile
18:import tokenize
19:from typing import (
20:    Any,
21:    Callable,
22:    Collection,
23:    Dict,
24:    Generator,
25:    Generic,
26:    Iterable,
27:    Iterator,
28:    List,
29:    Optional,
30:    Pattern,
31:    Sequence,
32:    Set,
33:    Tuple,
34:    TypeVar,
35:    Union,
36:    cast,
37:)
38:
39:from appdirs import user_cache_dir
40:from attr import dataclass, evolve, Factory
41:import click
42:import toml
43:
44:# lib2to3 fork
45:from blib2to3.pytree import Node, Leaf, type_repr
46:from blib2to3 import pygram, pytree
47:from blib2to3.pgen2 import driver, token
48:from blib2to3.pgen2.grammar import Grammar
49:from blib2to3.pgen2.parse import ParseError
50:
51:
52:__version__ = "19.3b0"
53:DEFAULT_LINE_LENGTH = 88
54:DEFAULT_EXCLUDES = (
55:    r"/(\.eggs|\.git|\.hg|\.mypy_cache|\.nox|\.tox|\.venv|_build|buck-out|build|dist)/"
56:)
57:DEFAULT_INCLUDES = r"\.pyi?$"
58:CACHE_DIR = Path(user_cache_dir("black", version=__version__))
59:
60:
61:# types
62:FileContent = str
63:Encoding = str
64:NewLine = str
65:Depth = int
66:NodeType = int
67:LeafID = int
68:Priority = int
69:Index = int
70:LN = Union[Leaf, Node]
71:SplitFunc = Callable[["Line", Collection["Feature"]], Iterator["Line"]]
72:Timestamp = float
73:FileSize = int
74:CacheInfo = Tuple[Timestamp, FileSize]
75:Cache = Dict[Path, CacheInfo]
76:out = partial(click.secho, bold=True, err=True)
77:err = partial(click.secho, fg="red", err=True)
78:
79:pygram.initialize(CACHE_DIR)
80:syms = pygram.python_symbols
81:
82:
83:class NothingChanged(UserWarning):
84:    """Raised when reformatted code is the same as source."""
85:
86:
87:class CannotSplit(Exception):
88:    """A readable split that fits the allotted line length is impossible."""
89:
90:
91:class InvalidInput(ValueError):
92:    """Raised when input source code fails all parse attempts."""
93:
94:
95:class WriteBack(Enum):
96:    NO = 0
97:    YES = 1
98:    DIFF = 2
99:    CHECK = 3
100:
101:    @classmethod
102:    def from_configuration(cls, *, check: bool, diff: bool) -> "WriteBack":
103:        if check and not diff:
104:            return cls.CHECK
105:
106:        return cls.DIFF if diff else cls.YES
107:
108:
109:class Changed(Enum):
110:    NO = 0
111:    CACHED = 1
112:    YES = 2
113:
114:
115:class TargetVersion(Enum):
116:    PY27 = 2
117:    PY33 = 3
118:    PY34 = 4
119:    PY35 = 5
120:    PY36 = 6

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
852:STANDALONE_COMMENT = 153
853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1218:            if leaf.type == STANDALONE_COMMENT:
1311:            comment.type == STANDALONE_COMMENT
1321:            comment.type = STANDALONE_COMMENT
1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
2136:            comment_type = STANDALONE_COMMENT
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
2784:                if comment.type != STANDALONE_COMMENT:
2814:                        STANDALONE_COMMENT,
3114:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: grepTool
Leaf\(token\.COMMA
Matched content:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2510:            current_line.append(Leaf(token.COMMA, ","))

Calling tool: grepTool
\btoken\b\s*=
No files found. Call grepTool again with a more generic pattern.

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The function uses Leaf(token.COMMA, ",") just like elsewhere in the file (e.g., at line ~2510 in delimiter_split). Both Leaf and token are imported at module scope (from blib2to3.pytree and blib2to3.pgen2 respectively), so they are in scope for bracket_split_build_line.

Todo item 7 of 11 is correct
description: 'Ensure that use of `Leaf(token.COMMA, ",")` is consistent with similar code elsewhere in the file (e.g., previously appended commas) and that `Leaf` and `token` are in scope for this function.'

Validating todo item 8 of 11
description: 'Verify that no remaining code paths still append a trailing comma for imports by only checking the last leaf (i.e., search for other 'Ensure a trailing comma' or `original.is_import` logic that might conflict and still append after comments).'

Calling tool: grepTool
Ensure a trailing comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2408:            # Ensure a trailing comma for imports, but be careful not to add one after

Calling tool: grepTool
original\.is_import
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2410:            if original.is_import:

Calling tool: grepTool
\bis_import\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/docs/reference/reference_functions.rst:21:.. autofunction:: black.is_import
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1151:    def is_import(self) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1153:        return bool(self) and is_import(self.leaves[0])
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1275:        if self.is_import:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1429:            and self.previous_line.is_import
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1430:            and not current_line.is_import
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2332:        and not line.is_import
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2410:            if original.is_import:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2545:def is_import(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2375:    following the closing bracket is put on a separate line.
2376:
2377:    Those are called `head`, `body`, and `tail`, respectively. If the split
2378:    produced the same line (all content in `head`) or ended up with an empty `body`
2379:    and the `tail` is just the closing bracket, then it's considered failed.
2380:    """
2381:    tail_len = len(str(tail).strip())
2382:    if not body:
2383:        if tail_len == 0:
2384:            raise CannotSplit("Splitting brackets produced the same line")
2385:
2386:        elif tail_len < 3:
2387:            raise CannotSplit(
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize
2468:    trailing_comma_safe = True
2469:
2470:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2471:        """Append `leaf` to current line or to new line if appending impossible."""
2472:        nonlocal current_line
2473:        try:
2474:            current_line.append_safe(leaf, preformatted=True)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1140:    @property
1141:    def is_comment(self) -> bool:
1142:        """Is this line a standalone comment?"""
1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1144:
1145:    @property
1146:    def is_decorator(self) -> bool:
1147:        """Is this line a decorator?"""
1148:        return bool(self) and self.leaves[0].type == token.AT
1149:
1150:    @property
1151:    def is_import(self) -> bool:
1152:        """Is this an import line?"""
1153:        return bool(self) and is_import(self.leaves[0])
1154:
1155:    @property
1156:    def is_class(self) -> bool:
1157:        """Is this line a class definition?"""
1158:        return (
1159:            bool(self)
1160:            and self.leaves[0].type == token.NAME
1161:            and self.leaves[0].value == "class"
1162:        )
1163:
1164:    @property
1165:    def is_stub_class(self) -> bool:
1166:        """Is this line a class definition with a body consisting only of "..."?"""
1167:        return self.is_class and self.leaves[-3:] == [
1168:            Leaf(token.DOT, ".") for _ in range(3)
1169:        ]
1170:
1171:    @property
1172:    def is_def(self) -> bool:
1173:        """Is this a function definition? (Also returns True for async defs.)"""
1174:        try:
1175:            first_leaf = self.leaves[0]
1176:        except IndexError:
1177:            return False
1178:
1179:        try:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1268:            comma = self.leaves[-1]
1269:            if comma.parent and comma.parent.type == syms.listmaker:
1270:                self.remove_trailing_comma()
1271:                return True
1272:
1273:        # For parens let's check if it's safe to remove the comma.
1274:        # Imports are always safe.
1275:        if self.is_import:
1276:            self.remove_trailing_comma()
1277:            return True
1278:
1279:        # Otherwise, if the trailing one is the only one, we might mistakenly
1280:        # change a tuple into a different type by removing the comma.
1281:        depth = closing.bracket_depth + 1
1282:        commas = 0
1283:        opening = closing.opening_bracket
1284:        for _opening_index, leaf in enumerate(self.leaves):
1285:            if leaf is opening:
1286:                break
1287:
1288:        else:
1289:            return False
1290:
1291:        for leaf in self.leaves[_opening_index + 1 :]:
1292:            if leaf is closing:
1293:                break
1294:
1295:            bracket_depth = leaf.bracket_depth
1296:            if bracket_depth == depth and leaf.type == token.COMMA:
1297:                commas += 1
1298:                if leaf.parent and leaf.parent.type == syms.arglist:
1299:                    commas += 1
1300:                    break
1301:
1302:        if commas > 1:
1303:            self.remove_trailing_comma()
1304:            return True
1305:
1306:        return False
1307:

Calling tool: grepTool
Leaf\(token\.COMMA
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2510:            current_line.append(Leaf(token.COMMA, ","))

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2485:            yield from append_to_line(comment_after)
2486:
2487:        lowest_depth = min(lowest_depth, leaf.bracket_depth)
2488:        if leaf.bracket_depth == lowest_depth:
2489:            if is_vararg(leaf, within={syms.typedargslist}):
2490:                trailing_comma_safe = (
2491:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_DEF in features
2492:                )
2493:            elif is_vararg(leaf, within={syms.arglist, syms.argument}):
2494:                trailing_comma_safe = (
2495:                    trailing_comma_safe and Feature.TRAILING_COMMA_IN_CALL in features
2496:                )
2497:
2498:        leaf_priority = bt.delimiters.get(id(leaf))
2499:        if leaf_priority == delimiter_priority:
2500:            yield current_line
2501:
2502:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2503:    if current_line:
2504:        if (
2505:            trailing_comma_safe
2506:            and delimiter_priority == COMMA_PRIORITY
2507:            and current_line.leaves[-1].type != token.COMMA
2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
2509:        ):
2510:            current_line.append(Leaf(token.COMMA, ","))
2511:        yield current_line
2512:
2513:
2514:@dont_increase_indentation
2515:def standalone_comment_split(
2516:    line: Line, features: Collection[Feature] = ()
2517:) -> Iterator[Line]:
2518:    """Split standalone comments from the rest of the line."""
2519:    if not line.contains_standalone_comments(0):
2520:        raise CannotSplit("Line does not have any standalone comments")
2521:
2522:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2523:
2524:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2525:        """Append `leaf` to current line or to new line if appending impossible."""
2526:        nonlocal current_line
2527:        try:
2528:            current_line.append_safe(leaf, preformatted=True)
2529:        except ValueError:
2530:            yield current_line
2531:
2532:            current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2533:            current_line.append(leaf)
2534:
2535:    for leaf in line.leaves:
2536:        yield from append_to_line(leaf)
2537:
2538:        for comment_after in line.comments_after(leaf):
2539:            yield from append_to_line(comment_after)
2540:
2541:    if current_line:
2542:        yield current_line
2543:
2544:

Calling tool: grepTool
\bdelimiter_split\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3023:    """Should `line` immediately be split with `delimiter_split()` after RHS?"""

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
3000:        else:
3001:            for leaf in c.leaves():
3002:                bt.mark(leaf)
3003:    try:
3004:        return bt.max_delimiter_priority()
3005:
3006:    except ValueError:
3007:        return 0
3008:
3009:
3010:def ensure_visible(leaf: Leaf) -> None:
3011:    """Make sure parentheses are visible.
3012:
3013:    They could be invisible as part of some statements (see
3014:    :func:`normalize_invible_parens` and :func:`visit_import_from`).
3015:    """
3016:    if leaf.type == token.LPAR:
3017:        leaf.value = "("
3018:    elif leaf.type == token.RPAR:
3019:        leaf.value = ")"
3020:
3021:
3022:def should_explode(line: Line, opening_bracket: Leaf) -> bool:
3023:    """Should `line` immediately be split with `delimiter_split()` after RHS?"""
3024:
3025:    if not (
3026:        opening_bracket.parent
3027:        and opening_bracket.parent.type in {syms.atom, syms.import_from}
3028:        and opening_bracket.value in "[{("
3029:    ):
3030:        return False
3031:
3032:    try:
3033:        last_leaf = line.leaves[-1]
3034:        exclude = {id(last_leaf)} if last_leaf.type == token.COMMA else set()
3035:        max_priority = line.bracket_tracker.max_delimiter_priority(exclude=exclude)
3036:    except (IndexError, ValueError):
3037:        return False
3038:
3039:    return max_priority == COMMA_PRIORITY
3040:
3041:
3042:def get_features_used(node: Node) -> Set[Feature]:
3043:    """Return a set of (relatively) new Python features used in this file.
3044:
3045:    Currently looking for:
3046:    - f-strings;
3047:    - underscores in numeric literals; and
3048:    - trailing commas after * or ** in function signatures and calls.
3049:    """
3050:    features: Set[Feature] = set()
3051:    for n in node.pre_order():
3052:        if n.type == token.STRING:
3053:            value_head = n.value[:2]  # type: ignore
3054:            if value_head in {'f"', 'F"', "f'", "F'", "rf", "fr", "RF", "FR"}:
3055:                features.add(Feature.F_STRINGS)
3056:
3057:        elif n.type == token.NUMBER:
3058:            if "_" in n.value:  # type: ignore
3059:                features.add(Feature.NUMERIC_UNDERSCORES)

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1418:        while self.previous_defs and self.previous_defs[-1] >= depth:
1419:            self.previous_defs.pop()
1420:            if self.is_pyi:
1421:                before = 0 if depth else 1
1422:            else:
1423:                before = 1 if depth else 2
1424:        if current_line.is_decorator or current_line.is_def or current_line.is_class:
1425:            return self._maybe_empty_lines_for_class_or_def(current_line, before)
1426:
1427:        if (
1428:            self.previous_line
1429:            and self.previous_line.is_import
1430:            and not current_line.is_import
1431:            and depth == self.previous_line.depth
1432:        ):
1433:            return (before or 1), 0
1434:
1435:        if (
1436:            self.previous_line
1437:            and self.previous_line.is_class

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2320:    bracket_split_succeeded_or_raise(head, body, tail)
2321:    if (
2322:        # the body shouldn't be exploded
2323:        not body.should_explode
2324:        # the opening bracket is an optional paren
2325:        and opening_bracket.type == token.LPAR
2326:        and not opening_bracket.value
2327:        # the closing bracket is an optional paren
2328:        and closing_bracket.type == token.RPAR
2329:        and not closing_bracket.value
2330:        # it's not an import (optional parens are the only thing we can split on
2331:        # in this case; attempting a split without them is a waste of time)
2332:        and not line.is_import
2333:        # there are no standalone comments in the body
2334:        and not body.contains_standalone_comments(0)
2335:        # and we can actually remove the parens
2336:        and can_omit_invisible_parens(body, line_length)
2337:    ):
2338:        omit = {id(closing_bracket), *omit}
2339:        try:
2340:            yield from right_hand_split(line, line_length, features=features, omit=omit)
2341:            return
2342:
2343:        except CannotSplit:
2344:            if not (
2345:                can_be_split(body)
2346:                or is_line_short_enough(body, line_length=line_length)
2347:            ):
2348:                raise CannotSplit(
2349:                    "Splitting failed, body is still too long and can't be split."

Calling tool: grepTool
trailing comma
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/Grammar.txt:151:# contains comma which clashes with trailing comma in arglist.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:81:                                  input files.  This will put trailing commas
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:233:that a trailing comma is always added.  Such formatting produces smaller
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:331:*Black* will add trailing commas to expressions that are split
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:335:Unnecessary trailing commas are removed if an expression fits in one
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:341:One exception to removing trailing commas is tuple expressions with
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:347:One exception to adding trailing commas is function signatures
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:348:containing `*`, `*args`, or `**kwargs`.  In this case a trailing comma
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:350:already 3.6+ only and use trailing commas in this situation.  If you
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:353:if you'd like a trailing comma in this situation and *Black* didn't
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1004:* trailing comma is now added to single imports that don't fit on a line (#250)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1172:* fixed an invalid trailing comma sometimes left in imports (#185)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1183:  unpacking. This fixed non-deterministic formatting if trailing commas
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1208:  fixes multiplication making expressions "unsafe" for trailing commas (#132)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1213:* *Black* now splits imports like "Mode 3 + trailing comma" of isort (#127)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1294:* don't remove single trailing commas from square bracket indexing
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1328:* remove a trailing comma if there is a single argument to a call
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/README.md:1347:* only put trailing commas in function signatures and calls if it's
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:258:        "trailing commas in function signatures and calls also after *args and "
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1229:                # When trailing commas are inserted by Black for consistency, comments
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1231:                # rendering will still be correct).  So we ignore trailing commas.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1255:        """Remove trailing comma if there is one and it's safe."""
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1333:        """Remove the trailing comma and moves the comments attached to it."""
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2408:            # Ensure a trailing comma for imports, but be careful not to add one after
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2448:    If the appropriate Features are given, the split will add trailing commas
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3048:    - trailing commas after * or ** in function signatures and calls.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/expression.py:85:call(this_is_a_very_long_variable_which_will_force_a_delimiter_split, arg, another, kwarg='hey', **kwargs)  # note: no trailing comma pre-3.6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/expression.py:353:)  # note: no trailing comma pre-3.6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/blib2to3/README:6:- backport of BPO-33064 that fixes parsing files with trailing commas after
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/force_py36.py:2:# annotations, trailing comma after *rest) or this test becomes invalid.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/force_py36.py:6:# annotations, trailing comma after *rest) or this test becomes invalid.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/expression.diff:103:-call(this_is_a_very_long_variable_which_will_force_a_delimiter_split, arg, another, kwarg='hey', **kwargs)  # note: no trailing comma pre-3.6
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/expression.diff:113:+)  # note: no trailing comma pre-3.6

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1218:            if leaf.type == STANDALONE_COMMENT:
1219:                if leaf.bracket_depth <= depth_limit:
1220:                    return True
1221:        return False
1222:
1223:    def contains_inner_type_comments(self) -> bool:
1224:        ignored_ids = set()
1225:        try:
1226:            last_leaf = self.leaves[-1]
1227:            ignored_ids.add(id(last_leaf))
1228:            if last_leaf.type == token.COMMA:
1229:                # When trailing commas are inserted by Black for consistency, comments
1230:                # after the previous last element are not moved (they don't have to,
1231:                # rendering will still be correct).  So we ignore trailing commas.
1232:                last_leaf = self.leaves[-2]
1233:                ignored_ids.add(id(last_leaf))
1234:        except IndexError:
1235:            return False
1236:
1237:        for leaf_id, comments in self.comments.items():
1238:            if leaf_id in ignored_ids:
1239:                continue
1240:
1241:            for comment in comments:
1242:                if is_type_comment(comment):
1243:                    return True
1244:
1245:        return False
1246:
1247:    def contains_multiline_strings(self) -> bool:
1248:        for leaf in self.leaves:
1249:            if is_multiline_string(leaf):
1250:                return True
1251:
1252:        return False
1253:
1254:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1255:        """Remove trailing comma if there is one and it's safe."""
1256:        if not (
1257:            self.leaves
1258:            and self.leaves[-1].type == token.COMMA
1259:            and closing.type in CLOSING_BRACKETS
1260:        ):
1261:            return False
1262:
1263:        if closing.type == token.RBRACE:
1264:            self.remove_trailing_comma()
1265:            return True
1266:
1267:        if closing.type == token.RSQB:
1268:            comma = self.leaves[-1]
1269:            if comma.parent and comma.parent.type == syms.listmaker:
1270:                self.remove_trailing_comma()
1271:                return True
1272:
1273:        # For parens let's check if it's safe to remove the comma.
1274:        # Imports are always safe.
1275:        if self.is_import:
1276:            self.remove_trailing_comma()
1277:            return True
1278:
1279:        # Otherwise, if the trailing one is the only one, we might mistakenly
1280:        # change a tuple into a different type by removing the comma.
1281:        depth = closing.bracket_depth + 1
1282:        commas = 0
1283:        opening = closing.opening_bracket
1284:        for _opening_index, leaf in enumerate(self.leaves):
1285:            if leaf is opening:
1286:                break
1287:
1288:        else:
1289:            return False
1290:
1291:        for leaf in self.leaves[_opening_index + 1 :]:
1292:            if leaf is closing:
1293:                break
1294:
1295:            bracket_depth = leaf.bracket_depth
1296:            if bracket_depth == depth and leaf.type == token.COMMA:
1297:                commas += 1
1298:                if leaf.parent and leaf.parent.type == syms.arglist:
1299:                    commas += 1
1300:                    break
1301:
1302:        if commas > 1:
1303:            self.remove_trailing_comma()
1304:            return True
1305:
1306:        return False
1307:
1308:    def append_comment(self, comment: Leaf) -> bool:
1309:        """Add an inline or standalone comment to the line."""
1310:        if (
1311:            comment.type == STANDALONE_COMMENT
1312:            and self.bracket_tracker.any_open_brackets()
1313:        ):
1314:            comment.prefix = ""
1315:            return False
1316:
1317:        if comment.type != token.COMMENT:
1318:            return False
1319:
1320:        if not self.leaves:
1321:            comment.type = STANDALONE_COMMENT
1322:            comment.prefix = ""
1323:            return False
1324:
1325:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1326:        return True
1327:
1328:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1329:        """Generate comments that should appear directly after `leaf`."""
1330:        return self.comments.get(id(leaf), [])
1331:
1332:    def remove_trailing_comma(self) -> None:
1333:        """Remove the trailing comma and moves the comments attached to it."""
1334:        trailing_comma = self.leaves.pop()
1335:        trailing_comma_comments = self.comments.pop(id(trailing_comma), [])
1336:        self.comments.setdefault(id(self.leaves[-1]), []).extend(
1337:            trailing_comma_comments
1338:        )
1339:
1340:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1341:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1342:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1343:        if open_lsqb is None:
1344:            return False
1345:
1346:        subscript_start = open_lsqb.next_sibling
1347:

Calling tool: grepTool
visit_import_from
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1666:        self.visit_import_from = partial(v, keywords=Ø, parens={"import"})
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3014:    :func:`normalize_invible_parens` and :func:`visit_import_from`).

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1600:            if self.is_pyi and is_stub_body(node):
1601:                yield from self.visit_default(node)
1602:            else:
1603:                yield from self.line(+1)
1604:                yield from self.visit_default(node)
1605:                yield from self.line(-1)
1606:
1607:        else:
1608:            if not self.is_pyi or not node.parent or not is_stub_suite(node.parent):
1609:                yield from self.line()
1610:            yield from self.visit_default(node)
1611:
1612:    def visit_async_stmt(self, node: Node) -> Iterator[Line]:
1613:        """Visit `async def`, `async for`, `async with`."""
1614:        yield from self.line()
1615:
1616:        children = iter(node.children)
1617:        for child in children:
1618:            yield from self.visit(child)
1619:
1620:            if child.type == token.ASYNC:
1621:                break
1622:
1623:        internal_stmt = next(children)
1624:        for child in internal_stmt.children:
1625:            yield from self.visit(child)
1626:
1627:    def visit_decorators(self, node: Node) -> Iterator[Line]:
1628:        """Visit decorators."""
1629:        for child in node.children:
1630:            yield from self.line()
1631:            yield from self.visit(child)
1632:
1633:    def visit_SEMI(self, leaf: Leaf) -> Iterator[Line]:
1634:        """Remove a semicolon and put the other statement on a separate line."""
1635:        yield from self.line()
1636:
1637:    def visit_ENDMARKER(self, leaf: Leaf) -> Iterator[Line]:
1638:        """End of file. Process outstanding comments and end with a newline."""
1639:        yield from self.visit_default(leaf)
1640:        yield from self.line()
1641:
1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
1643:        if not self.current_line.bracket_tracker.any_open_brackets():
1644:            yield from self.line()
1645:        yield from self.visit_default(leaf)
1646:
1647:    def __attrs_post_init__(self) -> None:
1648:        """You are in a twisty little maze of passages."""
1649:        v = self.visit_stmt
1650:        Ø: Set[str] = set()
1651:        self.visit_assert_stmt = partial(v, keywords={"assert"}, parens={"assert", ","})
1652:        self.visit_if_stmt = partial(
1653:            v, keywords={"if", "else", "elif"}, parens={"if", "elif"}
1654:        )
1655:        self.visit_while_stmt = partial(v, keywords={"while", "else"}, parens={"while"})
1656:        self.visit_for_stmt = partial(v, keywords={"for", "else"}, parens={"for", "in"})
1657:        self.visit_try_stmt = partial(
1658:            v, keywords={"try", "except", "else", "finally"}, parens=Ø
1659:        )
1660:        self.visit_except_clause = partial(v, keywords={"except"}, parens=Ø)
1661:        self.visit_with_stmt = partial(v, keywords={"with"}, parens=Ø)
1662:        self.visit_funcdef = partial(v, keywords={"def"}, parens=Ø)
1663:        self.visit_classdef = partial(v, keywords={"class"}, parens=Ø)
1664:        self.visit_expr_stmt = partial(v, keywords=Ø, parens=ASSIGNMENTS)
1665:        self.visit_return_stmt = partial(v, keywords={"return"}, parens={"return"})
1666:        self.visit_import_from = partial(v, keywords=Ø, parens={"import"})
1667:        self.visit_del_stmt = partial(v, keywords=Ø, parens={"del"})
1668:        self.visit_async_funcdef = self.visit_async_stmt
1669:        self.visit_decorated = self.visit_decorators
1670:
1671:
1672:IMPLICIT_TUPLE = {syms.testlist, syms.testlist_star_expr, syms.exprlist}
1673:BRACKET = {token.LPAR: token.RPAR, token.LSQB: token.RSQB, token.LBRACE: token.RBRACE}
1674:OPENING_BRACKETS = set(BRACKET.keys())
1675:CLOSING_BRACKETS = set(BRACKET.values())
1676:BRACKETS = OPENING_BRACKETS | CLOSING_BRACKETS
1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
1678:
1679:
1680:def whitespace(leaf: Leaf, *, complex_subscript: bool) -> str:  # noqa: C901
1681:    """Return whitespace prefix if needed for the given `leaf`.
1682:
1683:    `complex_subscript` signals whether the given leaf is part of a subscription
1684:    which has non-trivial arguments, like arithmetic expressions or function calls.
1685:    """
1686:    NO = ""
1687:    SPACE = " "
1688:    DOUBLESPACE = "  "
1689:    t = leaf.type
1690:    p = leaf.parent
1691:    v = leaf.value
1692:    if t in ALWAYS_NO_SPACE:
1693:        return NO
1694:
1695:    if t == token.COMMENT:
1696:        return DOUBLESPACE
1697:
1698:    assert p is not None, f"INTERNAL ERROR: hand-made leaf without parent: {leaf!r}"
1699:    if t == token.COLON and p.type not in {
1700:        syms.subscript,
1701:        syms.subscriptlist,
1702:        syms.sliceop,
1703:    }:
1704:        return NO
1705:
1706:    prev = leaf.prev_sibling
1707:    if not prev:
1708:        prevp = preceding_leaf(p)
1709:        if not prevp or prevp.type in OPENING_BRACKETS:
1710:            return NO
1711:
1712:        if t == token.COLON:
1713:            if prevp.type == token.COLON:
1714:                return NO
1715:
1716:            elif prevp.type != token.COMMA and not complex_subscript:
1717:                return NO
1718:
1719:            return SPACE

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2540:
2541:    if current_line:
2542:        yield current_line
2543:
2544:
2545:def is_import(leaf: Leaf) -> bool:
2546:    """Return True if the given leaf starts an import statement."""
2547:    p = leaf.parent
2548:    t = leaf.type
2549:    v = leaf.value
2550:    return bool(
2551:        t == token.NAME
2552:        and (
2553:            (v == "import" and p and p.type == syms.import_name)
2554:            or (v == "from" and p and p.type == syms.import_from)
2555:        )
2556:    )
2557:
2558:
2559:def is_type_comment(leaf: Leaf) -> bool:
2560:    """Return True if the given leaf is a special comment.
2561:    Only returns true for type comments for now."""
2562:    t = leaf.type
2563:    v = leaf.value
2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
2565:
2566:
2567:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2568:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2569:    else.
2570:
2571:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2572:    """
2573:    if not inside_brackets:
2574:        spl = leaf.prefix.split("#")
2575:        if "\\" not in spl[0]:
2576:            nl_count = spl[-1].count("\n")
2577:            if len(spl) > 1:
2578:                nl_count -= 1
2579:            leaf.prefix = "\n" * nl_count

Calling tool: grepTool
append\([^\)]*COMMA
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2510:            current_line.append(Leaf(token.COMMA, ","))

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Searched codebase for other trailing-comma insertion paths and import checks. Only import-specific insertion is in bracket_split_build_line (updated to skip standalone comments). The only other comma append is in delimiter_split, which explicitly avoids adding when the last leaf is a standalone comment. No other original.is_import or “Ensure a trailing comma” logic exists that would append after comments.

Todo item 8 of 11 is correct
description: 'Verify that no remaining code paths still append a trailing comma for imports by only checking the last leaf (i.e., search for other 'Ensure a trailing comma' or `original.is_import` logic that might conflict and still append after comments).'

Validating todo item 9 of 11
description: 'Check that the surrounding logic remains unchanged and correct: `normalize_prefix(leaves[0], inside_brackets=True)` still runs and the subsequent population of `result` (`result.append(leaf, preformatted=True)`) is unaffected by the change.'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")
2465:
2466:    current_line = Line(depth=line.depth, inside_brackets=line.inside_brackets)
2467:    lowest_depth = sys.maxsize
2468:    trailing_comma_safe = True
2469:
2470:    def append_to_line(leaf: Leaf) -> Iterator[Line]:
2471:        """Append `leaf` to current line or to new line if appending impossible."""
2472:        nonlocal current_line

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Verified in black.py: normalize_prefix(leaves[0], inside_brackets=True) is still executed inside the is_body and leaves block (lines 2405-2408), and the subsequent result population loop (lines 2419-2421) remains outside the conditional and unchanged, ensuring behavior is unaffected.

Todo item 9 of 11 is correct
description: 'Check that the surrounding logic remains unchanged and correct: `normalize_prefix(leaves[0], inside_brackets=True)` still runs and the subsequent population of `result` (`result.append(leaf, preformatted=True)`) is unaffected by the change.'

Validating todo item 10 of 11
description: 'Open the `test_comments7` test and confirm it covers a `from ... import (...)` block with commented-out lines at the end and asserts that the formatted result does not contain a standalone comma before the closing parenthesis (i.e., avoids the invalid output shown in Issue #671).'

Calling tool: grepTool
test_comments7
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments7
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py:392:    def test_comments7(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py
360:    def test_comments3(self) -> None:
361:        source, expected = read_data("comments3")
362:        actual = fs(source)
363:        self.assertFormatEqual(expected, actual)
364:        black.assert_equivalent(source, actual)
365:        black.assert_stable(source, actual, black.FileMode())
366:
367:    @patch("black.dump_to_file", dump_to_stderr)
368:    def test_comments4(self) -> None:
369:        source, expected = read_data("comments4")
370:        actual = fs(source)
371:        self.assertFormatEqual(expected, actual)
372:        black.assert_equivalent(source, actual)
373:        black.assert_stable(source, actual, black.FileMode())
374:
375:    @patch("black.dump_to_file", dump_to_stderr)
376:    def test_comments5(self) -> None:
377:        source, expected = read_data("comments5")
378:        actual = fs(source)
379:        self.assertFormatEqual(expected, actual)
380:        black.assert_equivalent(source, actual)
381:        black.assert_stable(source, actual, black.FileMode())
382:
383:    @patch("black.dump_to_file", dump_to_stderr)
384:    def test_comments6(self) -> None:
385:        source, expected = read_data("comments6")
386:        actual = fs(source)
387:        self.assertFormatEqual(expected, actual)
388:        black.assert_equivalent(source, actual)
389:        black.assert_stable(source, actual, black.FileMode())
390:
391:    @patch("black.dump_to_file", dump_to_stderr)
392:    def test_comments7(self) -> None:
393:        source, expected = read_data("comments7")
394:        actual = fs(source)
395:        self.assertFormatEqual(expected, actual)
396:        black.assert_equivalent(source, actual)
397:        black.assert_stable(source, actual, black.FileMode())
398:
399:    @patch("black.dump_to_file", dump_to_stderr)
400:    def test_cantfit(self) -> None:
401:        source, expected = read_data("cantfit")
402:        actual = fs(source)
403:        self.assertFormatEqual(expected, actual)
404:        black.assert_equivalent(source, actual)
405:        black.assert_stable(source, actual, black.FileMode())
406:
407:    @patch("black.dump_to_file", dump_to_stderr)
408:    def test_import_spacing(self) -> None:
409:        source, expected = read_data("import_spacing")
410:        actual = fs(source)
411:        self.assertFormatEqual(expected, actual)
412:        black.assert_equivalent(source, actual)
413:        black.assert_stable(source, actual, black.FileMode())
414:
415:    @patch("black.dump_to_file", dump_to_stderr)
416:    def test_composition(self) -> None:
417:        source, expected = read_data("composition")
418:        actual = fs(source)
419:        self.assertFormatEqual(expected, actual)
420:        black.assert_equivalent(source, actual)
421:        black.assert_stable(source, actual, black.FileMode())
422:
423:    @patch("black.dump_to_file", dump_to_stderr)
424:    def test_empty_lines(self) -> None:
425:        source, expected = read_data("empty_lines")
426:        actual = fs(source)
427:        self.assertFormatEqual(expected, actual)
428:        black.assert_equivalent(source, actual)
429:        black.assert_stable(source, actual, black.FileMode())
430:
431:    @patch("black.dump_to_file", dump_to_stderr)
432:    def test_string_prefixes(self) -> None:
433:        source, expected = read_data("string_prefixes")
434:        actual = fs(source)
435:        self.assertFormatEqual(expected, actual)
436:        black.assert_equivalent(source, actual)
437:        black.assert_stable(source, actual, black.FileMode())
438:
439:    @patch("black.dump_to_file", dump_to_stderr)
440:    def test_numeric_literals(self) -> None:
441:        source, expected = read_data("numeric_literals")
442:        mode = black.FileMode(target_versions=black.PY36_VERSIONS)
443:        actual = fs(source, mode=mode)
444:        self.assertFormatEqual(expected, actual)
445:        black.assert_equivalent(source, actual)
446:        black.assert_stable(source, actual, mode)
447:
448:    @patch("black.dump_to_file", dump_to_stderr)
449:    def test_numeric_literals_ignoring_underscores(self) -> None:
450:        source, expected = read_data("numeric_literals_skip_underscores")
451:        mode = black.FileMode(target_versions=black.PY36_VERSIONS)
452:        actual = fs(source, mode=mode)
453:        self.assertFormatEqual(expected, actual)
454:        black.assert_equivalent(source, actual)
455:        black.assert_stable(source, actual, mode)
456:
457:    @patch("black.dump_to_file", dump_to_stderr)
458:    def test_numeric_literals_py2(self) -> None:
459:        source, expected = read_data("numeric_literals_py2")
460:        actual = fs(source)
461:        self.assertFormatEqual(expected, actual)
462:        black.assert_stable(source, actual, black.FileMode())
463:
464:    @patch("black.dump_to_file", dump_to_stderr)
465:    def test_python2(self) -> None:
466:        source, expected = read_data("python2")
467:        actual = fs(source)
468:        self.assertFormatEqual(expected, actual)
469:        # black.assert_equivalent(source, actual)
470:        black.assert_stable(source, actual, black.FileMode())
471:
472:    @patch("black.dump_to_file", dump_to_stderr)
473:    def test_python2_print_function(self) -> None:
474:        source, expected = read_data("python2_print_function")
475:        mode = black.FileMode(target_versions={TargetVersion.PY27})
476:        actual = fs(source, mode=mode)
477:        self.assertFormatEqual(expected, actual)
478:        black.assert_stable(source, actual, mode)
479:

Calling tool: globTool
**/*comments7*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py
1:from .config import (
2:    Any,
3:    Bool,
4:    ConfigType,
5:    ConfigTypeAttributes,
6:    Int,
7:    Path,
8:    #  String,
9:    #  resolve_to_config_type,
10:    #  DEFAULT_TYPE_ATTRIBUTES,
11:)
12:
13:
14:from .config import (
15:    Any,
16:    Bool,
17:    ConfigType,
18:    ConfigTypeAttributes,
19:    Int,
20:    no_comma_here_yet
21:    #  and some comments,
22:    #  resolve_to_config_type,
23:    #  DEFAULT_TYPE_ATTRIBUTES,
24:)
25:
26:# output
27:
28:from .config import (
29:    Any,
30:    Bool,
31:    ConfigType,
32:    ConfigTypeAttributes,
33:    Int,
34:    Path,
35:    #  String,
36:    #  resolve_to_config_type,
37:    #  DEFAULT_TYPE_ATTRIBUTES,
38:)
39:
40:
41:from .config import (
42:    Any,
43:    Bool,
44:    ConfigType,
45:    ConfigTypeAttributes,
46:    Int,
47:    no_comma_here_yet,
48:    #  and some comments,
49:    #  resolve_to_config_type,
50:    #  DEFAULT_TYPE_ATTRIBUTES,
51:)

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py:57:def read_data(name: str, data: bool = True) -> Tuple[str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py
1:#!/usr/bin/env python3
2:import asyncio
3:import logging
4:from concurrent.futures import ThreadPoolExecutor
5:from contextlib import contextmanager, redirect_stderr
6:from functools import partial, wraps
7:from io import BytesIO, TextIOWrapper
8:import os
9:from pathlib import Path
10:import re
11:import sys
12:from tempfile import TemporaryDirectory
13:from typing import (
14:    Any,
15:    BinaryIO,
16:    Callable,
17:    Coroutine,
18:    Generator,
19:    List,
20:    Tuple,
21:    Iterator,
22:    TypeVar,
23:)
24:import unittest
25:from unittest.mock import patch, MagicMock
26:
27:from click import unstyle
28:from click.testing import CliRunner
29:
30:import black
31:from black import Feature, TargetVersion
32:
33:try:
34:    import blackd
35:    from aiohttp.test_utils import TestClient, TestServer
36:except ImportError:
37:    has_blackd_deps = False
38:else:
39:    has_blackd_deps = True
40:
41:ff = partial(black.format_file_in_place, mode=black.FileMode(), fast=True)
42:fs = partial(black.format_str, mode=black.FileMode())
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:PY36_ARGS = [
47:    f"--target-version={version.name.lower()}" for version in black.PY36_VERSIONS
48:]
49:T = TypeVar("T")
50:R = TypeVar("R")
51:
52:
53:def dump_to_stderr(*output: str) -> str:
54:    return "\n" + "\n".join(output) + "\n"
55:
56:
57:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
58:    """read_data('test_name') -> 'input', 'output'"""
59:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
60:        name += ".py"
61:    _input: List[str] = []
62:    _output: List[str] = []
63:    base_dir = THIS_DIR / "data" if data else THIS_DIR
64:    with open(base_dir / name, "r", encoding="utf8") as test:
65:        lines = test.readlines()
66:    result = _input
67:    for line in lines:
68:        line = line.replace(EMPTY_LINE, "")
69:        if line.rstrip() == "# output":
70:            result = _output
71:            continue
72:
73:        result.append(line)
74:    if _input and not _output:
75:        # If there's no output marker, treat the entire file as already pre-formatted.
76:        _output = _input[:]
77:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
78:
79:
80:@contextmanager

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: Located tests/test_black.py::test_comments7 which uses tests/data/comments7.py. That data file contains a from-import with trailing commented-out lines; the expected output shows adding a comma after the last actual name (if missing) but no standalone comma before the closing parenthesis. The test asserts actual equals this expected, thus covering and preventing the invalid output from Issue #671.

Todo item 10 of 11 is correct
description: 'Open the `test_comments7` test and confirm it covers a `from ... import (...)` block with commented-out lines at the end and asserts that the formatted result does not contain a standalone comma before the closing parenthesis (i.e., avoids the invalid output shown in Issue #671).'

Validating todo item 11 of 11
description: 'In `test_comments7`, verify that when the last real imported name lacks a trailing comma but is followed by comments, the expected formatted output contains a comma immediately after that name (before comments), not at the very end after comments.'

Calling tool: grepTool
def bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2385:
2386:        elif tail_len < 3:
2387:            raise CannotSplit(
2388:                f"Splitting brackets on an empty body to save "
2389:                f"{tail_len} characters is not worth it"
2390:            )
2391:
2392:
2393:def bracket_split_build_line(
2394:    leaves: List[Leaf], original: Line, opening_bracket: Leaf, *, is_body: bool = False
2395:) -> Line:
2396:    """Return a new line with given `leaves` and respective comments from `original`.
2397:
2398:    If `is_body` is True, the result line is one-indented inside brackets and as such
2399:    has its first leaf's prefix normalized and a trailing comma added when expected.
2400:    """
2401:    result = Line(depth=original.depth)
2402:    if is_body:
2403:        result.inside_brackets = True
2404:        result.depth += 1
2405:        if leaves:
2406:            # Since body is a new indent level, remove spurious leading whitespace.
2407:            normalize_prefix(leaves[0], inside_brackets=True)
2408:            # Ensure a trailing comma for imports, but be careful not to add one after
2409:            # any comments.
2410:            if original.is_import:
2411:                for i in range(len(leaves) - 1, -1, -1):
2412:                    if leaves[i].type == STANDALONE_COMMENT:
2413:                        continue
2414:                    elif leaves[i].type == token.COMMA:
2415:                        break
2416:                    else:
2417:                        leaves.insert(i + 1, Leaf(token.COMMA, ","))
2418:                        break
2419:    # Populate the line
2420:    for leaf in leaves:
2421:        result.append(leaf, preformatted=True)
2422:        for comment_after in original.comments_after(leaf):
2423:            result.append(comment_after, preformatted=True)
2424:    if is_body:
2425:        result.should_explode = should_explode(result, opening_bracket)
2426:    return result
2427:
2428:
2429:def dont_increase_indentation(split_func: SplitFunc) -> SplitFunc:
2430:    """Normalize prefix of the first leaf in every line returned by `split_func`.
2431:
2432:    This is a decorator over relevant split functions.
2433:    """
2434:
2435:    @wraps(split_func)
2436:    def split_wrapper(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2437:        for l in split_func(line, features):
2438:            normalize_prefix(l.leaves[0], inside_brackets=True)
2439:            yield l
2440:
2441:    return split_wrapper
2442:
2443:
2444:@dont_increase_indentation
2445:def delimiter_split(line: Line, features: Collection[Feature] = ()) -> Iterator[Line]:
2446:    """Split according to delimiters of the highest priority.
2447:
2448:    If the appropriate Features are given, the split will add trailing commas
2449:    also in function signatures and calls that contain `*` and `**`.
2450:    """
2451:    try:
2452:        last_leaf = line.leaves[-1]
2453:    except IndexError:
2454:        raise CannotSplit("Line empty")
2455:
2456:    bt = line.bracket_tracker
2457:    try:
2458:        delimiter_priority = bt.max_delimiter_priority(exclude={id(last_leaf)})
2459:    except ValueError:
2460:        raise CannotSplit("No delimiters found")
2461:
2462:    if delimiter_priority == DOT_PRIORITY:
2463:        if bt.delimiter_count_with_priority(delimiter_priority) == 1:
2464:            raise CannotSplit("Splitting a single attribute from its owner looks wrong")

Calling tool: grepTool
test_comments7\b
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/bugsinpy_run_test.sh:1:python -m unittest -q tests.test_black.BlackTestCase.test_comments7
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py:392:    def test_comments7(self) -> None:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py
380:        black.assert_equivalent(source, actual)
381:        black.assert_stable(source, actual, black.FileMode())
382:
383:    @patch("black.dump_to_file", dump_to_stderr)
384:    def test_comments6(self) -> None:
385:        source, expected = read_data("comments6")
386:        actual = fs(source)
387:        self.assertFormatEqual(expected, actual)
388:        black.assert_equivalent(source, actual)
389:        black.assert_stable(source, actual, black.FileMode())
390:
391:    @patch("black.dump_to_file", dump_to_stderr)
392:    def test_comments7(self) -> None:
393:        source, expected = read_data("comments7")
394:        actual = fs(source)
395:        self.assertFormatEqual(expected, actual)
396:        black.assert_equivalent(source, actual)
397:        black.assert_stable(source, actual, black.FileMode())
398:
399:    @patch("black.dump_to_file", dump_to_stderr)
400:    def test_cantfit(self) -> None:
401:        source, expected = read_data("cantfit")
402:        actual = fs(source)
403:        self.assertFormatEqual(expected, actual)
404:        black.assert_equivalent(source, actual)
405:        black.assert_stable(source, actual, black.FileMode())
406:
407:    @patch("black.dump_to_file", dump_to_stderr)
408:    def test_import_spacing(self) -> None:
409:        source, expected = read_data("import_spacing")
410:        actual = fs(source)
411:        self.assertFormatEqual(expected, actual)
412:        black.assert_equivalent(source, actual)
413:        black.assert_stable(source, actual, black.FileMode())
414:
415:    @patch("black.dump_to_file", dump_to_stderr)
416:    def test_composition(self) -> None:
417:        source, expected = read_data("composition")
418:        actual = fs(source)
419:        self.assertFormatEqual(expected, actual)
420:        black.assert_equivalent(source, actual)
421:        black.assert_stable(source, actual, black.FileMode())
422:
423:    @patch("black.dump_to_file", dump_to_stderr)
424:    def test_empty_lines(self) -> None:
425:        source, expected = read_data("empty_lines")
426:        actual = fs(source)
427:        self.assertFormatEqual(expected, actual)
428:        black.assert_equivalent(source, actual)
429:        black.assert_stable(source, actual, black.FileMode())
430:
431:    @patch("black.dump_to_file", dump_to_stderr)
432:    def test_string_prefixes(self) -> None:
433:        source, expected = read_data("string_prefixes")
434:        actual = fs(source)
435:        self.assertFormatEqual(expected, actual)
436:        black.assert_equivalent(source, actual)
437:        black.assert_stable(source, actual, black.FileMode())
438:
439:    @patch("black.dump_to_file", dump_to_stderr)

Calling tool: globTool
**/*comments7*
Matched files:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/data/comments7.py
1:from .config import (
2:    Any,
3:    Bool,
4:    ConfigType,
5:    ConfigTypeAttributes,
6:    Int,
7:    Path,
8:    #  String,
9:    #  resolve_to_config_type,
10:    #  DEFAULT_TYPE_ATTRIBUTES,
11:)
12:
13:
14:from .config import (
15:    Any,
16:    Bool,
17:    ConfigType,
18:    ConfigTypeAttributes,
19:    Int,
20:    no_comma_here_yet
21:    #  and some comments,
22:    #  resolve_to_config_type,
23:    #  DEFAULT_TYPE_ATTRIBUTES,
24:)
25:
26:# output
27:
28:from .config import (
29:    Any,
30:    Bool,
31:    ConfigType,
32:    ConfigTypeAttributes,
33:    Int,
34:    Path,
35:    #  String,
36:    #  resolve_to_config_type,
37:    #  DEFAULT_TYPE_ATTRIBUTES,
38:)
39:
40:
41:from .config import (
42:    Any,
43:    Bool,
44:    ConfigType,
45:    ConfigTypeAttributes,
46:    Int,
47:    no_comma_here_yet,
48:    #  and some comments,
49:    #  resolve_to_config_type,
50:    #  DEFAULT_TYPE_ATTRIBUTES,
51:)

Calling tool: grepTool
def read_data\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py:57:def read_data(name: str, data: bool = True) -> Tuple[str, str]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/tests/test_black.py
40:
41:ff = partial(black.format_file_in_place, mode=black.FileMode(), fast=True)
42:fs = partial(black.format_str, mode=black.FileMode())
43:THIS_FILE = Path(__file__)
44:THIS_DIR = THIS_FILE.parent
45:EMPTY_LINE = "# EMPTY LINE WITH WHITESPACE" + " (this comment will be removed)"
46:PY36_ARGS = [
47:    f"--target-version={version.name.lower()}" for version in black.PY36_VERSIONS
48:]
49:T = TypeVar("T")
50:R = TypeVar("R")
51:
52:
53:def dump_to_stderr(*output: str) -> str:
54:    return "\n" + "\n".join(output) + "\n"
55:
56:
57:def read_data(name: str, data: bool = True) -> Tuple[str, str]:
58:    """read_data('test_name') -> 'input', 'output'"""
59:    if not name.endswith((".py", ".pyi", ".out", ".diff")):
60:        name += ".py"
61:    _input: List[str] = []
62:    _output: List[str] = []
63:    base_dir = THIS_DIR / "data" if data else THIS_DIR
64:    with open(base_dir / name, "r", encoding="utf8") as test:
65:        lines = test.readlines()
66:    result = _input
67:    for line in lines:
68:        line = line.replace(EMPTY_LINE, "")
69:        if line.rstrip() == "# output":
70:            result = _output
71:            continue
72:
73:        result.append(line)
74:    if _input and not _output:
75:        # If there's no output marker, treat the entire file as already pre-formatted.
76:        _output = _input[:]
77:    return "".join(_input).strip() + "\n", "".join(_output).strip() + "\n"
78:
79:

Calling tool: grepTool
bracket_split_build_line\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2269:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2270:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2271:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2317:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2318:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2319:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2393:def bracket_split_build_line(

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2245:    Note: this usually looks weird, only use this for function definitions.
2246:    Prefer RHS otherwise.  This is why this function is not symmetrical with
2247:    :func:`right_hand_split` which also handles optional parentheses.
2248:    """
2249:    tail_leaves: List[Leaf] = []
2250:    body_leaves: List[Leaf] = []
2251:    head_leaves: List[Leaf] = []
2252:    current_leaves = head_leaves
2253:    matching_bracket = None
2254:    for leaf in line.leaves:
2255:        if (
2256:            current_leaves is body_leaves
2257:            and leaf.type in CLOSING_BRACKETS
2258:            and leaf.opening_bracket is matching_bracket
2259:        ):
2260:            current_leaves = tail_leaves if body_leaves else head_leaves
2261:        current_leaves.append(leaf)
2262:        if current_leaves is head_leaves:
2263:            if leaf.type in OPENING_BRACKETS:
2264:                matching_bracket = leaf
2265:                current_leaves = body_leaves
2266:    if not matching_bracket:
2267:        raise CannotSplit("No brackets found")
2268:
2269:    head = bracket_split_build_line(head_leaves, line, matching_bracket)
2270:    body = bracket_split_build_line(body_leaves, line, matching_bracket, is_body=True)
2271:    tail = bracket_split_build_line(tail_leaves, line, matching_bracket)
2272:    bracket_split_succeeded_or_raise(head, body, tail)
2273:    for result in (head, body, tail):
2274:        if result:
2275:            yield result
2276:
2277:
2278:def right_hand_split(
2279:    line: Line,
2280:    line_length: int,
2281:    features: Collection[Feature] = (),
2282:    omit: Collection[LeafID] = (),
2283:) -> Iterator[Line]:
2284:    """Split line into many lines, starting with the last matching bracket pair.
2285:
2286:    If the split was by optional parentheses, attempt splitting without them, too.
2287:    `omit` is a collection of closing bracket IDs that shouldn't be considered for
2288:    this split.
2289:
2290:    Note: running this function modifies `bracket_depth` on the leaves of `line`.
2291:    """
2292:    tail_leaves: List[Leaf] = []
2293:    body_leaves: List[Leaf] = []
2294:    head_leaves: List[Leaf] = []
2295:    current_leaves = tail_leaves
2296:    opening_bracket = None
2297:    closing_bracket = None
2298:    for leaf in reversed(line.leaves):
2299:        if current_leaves is body_leaves:
2300:            if leaf is opening_bracket:
2301:                current_leaves = head_leaves if body_leaves else tail_leaves
2302:        current_leaves.append(leaf)
2303:        if current_leaves is tail_leaves:
2304:            if leaf.type in CLOSING_BRACKETS and id(leaf) not in omit:
2305:                opening_bracket = leaf.opening_bracket
2306:                closing_bracket = leaf
2307:                current_leaves = body_leaves
2308:    if not (opening_bracket and closing_bracket and head_leaves):
2309:        # If there is no opening or closing_bracket that means the split failed and
2310:        # all content is in the tail.  Otherwise, if `head_leaves` are empty, it means
2311:        # the matching `opening_bracket` wasn't available on `line` anymore.
2312:        raise CannotSplit("No brackets found")
2313:
2314:    tail_leaves.reverse()
2315:    body_leaves.reverse()
2316:    head_leaves.reverse()
2317:    head = bracket_split_build_line(head_leaves, line, opening_bracket)
2318:    body = bracket_split_build_line(body_leaves, line, opening_bracket, is_body=True)
2319:    tail = bracket_split_build_line(tail_leaves, line, opening_bracket)
2320:    bracket_split_succeeded_or_raise(head, body, tail)
2321:    if (
2322:        # the body shouldn't be exploded
2323:        not body.should_explode
2324:        # the opening bracket is an optional paren
2325:        and opening_bracket.type == token.LPAR
2326:        and not opening_bracket.value
2327:        # the closing bracket is an optional paren
2328:        and closing_bracket.type == token.RPAR
2329:        and not closing_bracket.value
2330:        # it's not an import (optional parens are the only thing we can split on
2331:        # in this case; attempting a split without them is a waste of time)
2332:        and not line.is_import
2333:        # there are no standalone comments in the body
2334:        and not body.contains_standalone_comments(0)

Calling tool: grepTool
STANDALONE_COMMENT
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:852:STANDALONE_COMMENT = 153
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1218:            if leaf.type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1311:            comment.type == STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1321:            comment.type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1642:    def visit_STANDALONE_COMMENT(self, leaf: Leaf) -> Iterator[Line]:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1677:ALWAYS_NO_SPACE = CLOSING_BRACKETS | {token.COMMA, STANDALONE_COMMENT}
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2136:            comment_type = STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2412:                    if leaves[i].type == STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2508:            and current_line.leaves[-1].type != STANDALONE_COMMENT
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2784:                if comment.type != STANDALONE_COMMENT:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:2814:                        STANDALONE_COMMENT,
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:3114:        if leaf.type == STANDALONE_COMMENT or has_inline_comment:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
820:        else:
821:            _type = token.tok_name.get(node.type, str(node.type))
822:            out(f"{indent}{_type}", fg="blue", nl=False)
823:            if node.prefix:
824:                # We don't have to handle prefixes for `Node` objects since
825:                # that delegates to the first child anyway.
826:                out(f" {node.prefix!r}", fg="green", bold=False, nl=False)
827:            out(f" {node.value!r}", fg="blue", bold=False)
828:
829:    @classmethod
830:    def show(cls, code: Union[str, Leaf, Node]) -> None:
831:        """Pretty-print the lib2to3 AST of a given string of `code`.
832:
833:        Convenience method for debugging.
834:        """
835:        v: DebugVisitor[None] = DebugVisitor()
836:        if isinstance(code, str):
837:            code = lib2to3_parse(code)
838:        list(v.visit(code))
839:
840:
841:WHITESPACE = {token.DEDENT, token.INDENT, token.NEWLINE}
842:STATEMENT = {
843:    syms.if_stmt,
844:    syms.while_stmt,
845:    syms.for_stmt,
846:    syms.try_stmt,
847:    syms.except_clause,
848:    syms.with_stmt,
849:    syms.funcdef,
850:    syms.classdef,
851:}
852:STANDALONE_COMMENT = 153
853:token.tok_name[STANDALONE_COMMENT] = "STANDALONE_COMMENT"
854:LOGIC_OPERATORS = {"and", "or"}
855:COMPARATORS = {
856:    token.LESS,
857:    token.GREATER,
858:    token.EQEQUAL,
859:    token.NOTEQUAL,
860:    token.LESSEQUAL,
861:    token.GREATEREQUAL,
862:}
863:MATH_OPERATORS = {
864:    token.VBAR,
865:    token.CIRCUMFLEX,
866:    token.AMPER,
867:    token.LEFTSHIFT,
868:    token.RIGHTSHIFT,
869:    token.PLUS,
870:    token.MINUS,
871:    token.STAR,
872:    token.SLASH,
873:    token.DOUBLESLASH,
874:    token.PERCENT,
875:    token.AT,
876:    token.TILDE,
877:    token.DOUBLESTAR,
878:}
879:STARS = {token.STAR, token.DOUBLESTAR}
880:VARARGS_PARENTS = {
881:    syms.arglist,
882:    syms.argument,  # double star in arglist
883:    syms.trailer,  # single argument to call
884:    syms.typedargslist,
885:    syms.varargslist,  # lambdas
886:}
887:UNPACKING_PARENTS = {
888:    syms.atom,  # single element of a list or set literal
889:    syms.dictsetmaker,
890:    syms.listmaker,
891:    syms.testlist_gexp,
892:    syms.testlist_star_expr,
893:}
894:TEST_DESCENDANTS = {
895:    syms.test,
896:    syms.lambdef,
897:    syms.or_test,
898:    syms.and_test,
899:    syms.not_test,
900:    syms.comparison,
901:    syms.star_expr,
902:    syms.expr,
903:    syms.xor_expr,
904:    syms.and_expr,
905:    syms.shift_expr,
906:    syms.arith_expr,
907:    syms.trailer,
908:    syms.term,
909:    syms.power,
910:}
911:ASSIGNMENTS = {
912:    "=",
913:    "+=",
914:    "-=",
915:    "*=",
916:    "@=",
917:    "/=",
918:    "%=",
919:    "&=",
920:    "|=",
921:    "^=",
922:    "<<=",
923:    ">>=",
924:    "**=",
925:    "//=",
926:}
927:COMPREHENSION_PRIORITY = 20
928:COMMA_PRIORITY = 18
929:TERNARY_PRIORITY = 16
930:LOGIC_PRIORITY = 14
931:STRING_PRIORITY = 12
932:COMPARATOR_PRIORITY = 10
933:MATH_PRIORITIES = {
934:    token.VBAR: 9,
935:    token.CIRCUMFLEX: 8,
936:    token.AMPER: 7,
937:    token.LEFTSHIFT: 6,
938:    token.RIGHTSHIFT: 6,
939:    token.PLUS: 5,
940:    token.MINUS: 5,
941:    token.STAR: 4,
942:    token.SLASH: 4,
943:    token.DOUBLESLASH: 4,
944:    token.PERCENT: 4,
945:    token.AT: 4,
946:    token.TILDE: 3,
947:    token.DOUBLESTAR: 2,
948:}
949:DOT_PRIORITY = 1
950:
951:
952:@dataclass
953:class BracketTracker:
954:    """Keeps track of brackets on a line."""
955:
956:    depth: int = 0
957:    bracket_match: Dict[Tuple[Depth, NodeType], Leaf] = Factory(dict)
958:    delimiters: Dict[LeafID, Priority] = Factory(dict)
959:    previous: Optional[Leaf] = None
960:    _for_loop_depths: List[int] = Factory(list)
961:    _lambda_argument_depths: List[int] = Factory(list)
962:
963:    def mark(self, leaf: Leaf) -> None:
964:        """Mark `leaf` with bracket-related metadata. Keep track of delimiters.
965:
966:        All leaves receive an int `bracket_depth` field that stores how deep
967:        within brackets a given leaf is. 0 means there are no enclosing brackets
968:        that started on this line.
969:
970:        If a leaf is itself a closing bracket, it receives an `opening_bracket`
971:        field that it forms a pair with. This is a one-directional link to
972:        avoid reference cycles.
973:
974:        If a leaf is a delimiter (a token on which Black can split the line if
975:        needed) and it's on depth 0, its `id()` is stored in the tracker's
976:        `delimiters` field.
977:        """
978:        if leaf.type == token.COMMENT:
979:            return
980:
981:        self.maybe_decrement_after_for_loop_variable(leaf)
982:        self.maybe_decrement_after_lambda_arguments(leaf)
983:        if leaf.type in CLOSING_BRACKETS:
984:            self.depth -= 1
985:            opening_bracket = self.bracket_match.pop((self.depth, leaf.type))
986:            leaf.opening_bracket = opening_bracket
987:        leaf.bracket_depth = self.depth
988:        if self.depth == 0:
989:            delim = is_split_before_delimiter(leaf, self.previous)
990:            if delim and self.previous is not None:
991:                self.delimiters[id(self.previous)] = delim
992:            else:
993:                delim = is_split_after_delimiter(leaf, self.previous)
994:                if delim:
995:                    self.delimiters[id(leaf)] = delim
996:        if leaf.type in OPENING_BRACKETS:
997:            self.bracket_match[self.depth, BRACKET[leaf.type]] = leaf
998:            self.depth += 1
999:        self.previous = leaf
1000:        self.maybe_increment_lambda_arguments(leaf)
1001:        self.maybe_increment_for_loop_variable(leaf)
1002:
1003:    def any_open_brackets(self) -> bool:
1004:        """Return True if there is an yet unmatched open bracket on the line."""
1005:        return bool(self.bracket_match)
1006:
1007:    def max_delimiter_priority(self, exclude: Iterable[LeafID] = ()) -> int:
1008:        """Return the highest priority of a delimiter found on the line.
1009:
1010:        Values are consistent with what `is_split_*_delimiter()` return.
1011:        Raises ValueError on no delimiters.
1012:        """
1013:        return max(v for k, v in self.delimiters.items() if k not in exclude)
1014:
1015:    def delimiter_count_with_priority(self, priority: int = 0) -> int:
1016:        """Return the number of delimiters with the given `priority`.
1017:
1018:        If no `priority` is passed, defaults to max priority on the line.
1019:        """
1020:        if not self.delimiters:
1021:            return 0
1022:
1023:        priority = priority or self.max_delimiter_priority()
1024:        return sum(1 for p in self.delimiters.values() if p == priority)
1025:
1026:    def maybe_increment_for_loop_variable(self, leaf: Leaf) -> bool:
1027:        """In a for loop, or comprehension, the variables are often unpacks.
1028:
1029:        To avoid splitting on the comma in this situation, increase the depth of
1030:        tokens between `for` and `in`.
1031:        """
1032:        if leaf.type == token.NAME and leaf.value == "for":
1033:            self.depth += 1
1034:            self._for_loop_depths.append(self.depth)
1035:            return True
1036:
1037:        return False
1038:
1039:    def maybe_decrement_after_for_loop_variable(self, leaf: Leaf) -> bool:
1040:        """See `maybe_increment_for_loop_variable` above for explanation."""
1041:        if (
1042:            self._for_loop_depths
1043:            and self._for_loop_depths[-1] == self.depth
1044:            and leaf.type == token.NAME
1045:            and leaf.value == "in"
1046:        ):
1047:            self.depth -= 1
1048:            self._for_loop_depths.pop()
1049:            return True
1050:
1051:        return False
1052:
1053:    def maybe_increment_lambda_arguments(self, leaf: Leaf) -> bool:
1054:        """In a lambda expression, there might be more than one argument.
1055:
1056:        To avoid splitting on the comma in this situation, increase the depth of
1057:        tokens between `lambda` and `:`.
1058:        """
1059:        if leaf.type == token.NAME and leaf.value == "lambda":
1060:            self.depth += 1
1061:            self._lambda_argument_depths.append(self.depth)
1062:            return True
1063:
1064:        return False
1065:
1066:    def maybe_decrement_after_lambda_arguments(self, leaf: Leaf) -> bool:
1067:        """See `maybe_increment_lambda_arguments` above for explanation."""
1068:        if (
1069:            self._lambda_argument_depths
1070:            and self._lambda_argument_depths[-1] == self.depth
1071:            and leaf.type == token.COLON
1072:        ):
1073:            self.depth -= 1
1074:            self._lambda_argument_depths.pop()
1075:            return True
1076:
1077:        return False
1078:
1079:    def get_open_lsqb(self) -> Optional[Leaf]:
1080:        """Return the most recent opening square bracket (if any)."""
1081:        return self.bracket_match.get((self.depth - 1, token.RSQB))
1082:
1083:
1084:@dataclass
1085:class Line:
1086:    """Holds leaves and comments. Can be printed with `str(line)`."""
1087:
1088:    depth: int = 0
1089:    leaves: List[Leaf] = Factory(list)
1090:    comments: Dict[LeafID, List[Leaf]] = Factory(dict)  # keys ordered like `leaves`
1091:    bracket_tracker: BracketTracker = Factory(BracketTracker)
1092:    inside_brackets: bool = False
1093:    should_explode: bool = False
1094:
1095:    def append(self, leaf: Leaf, preformatted: bool = False) -> None:
1096:        """Add a new `leaf` to the end of the line.
1097:
1098:        Unless `preformatted` is True, the `leaf` will receive a new consistent
1099:        whitespace prefix and metadata applied by :class:`BracketTracker`.
1100:        Trailing commas are maybe removed, unpacked for loop variables are
1101:        demoted from being delimiters.
1102:
1103:        Inline comments are put aside.
1104:        """
1105:        has_value = leaf.type in BRACKETS or bool(leaf.value.strip())
1106:        if not has_value:
1107:            return
1108:
1109:        if token.COLON == leaf.type and self.is_class_paren_empty:
1110:            del self.leaves[-2:]
1111:        if self.leaves and not preformatted:
1112:            # Note: at this point leaf.prefix should be empty except for
1113:            # imports, for which we only preserve newlines.
1114:            leaf.prefix += whitespace(
1115:                leaf, complex_subscript=self.is_complex_subscript(leaf)
1116:            )
1117:        if self.inside_brackets or not preformatted:
1118:            self.bracket_tracker.mark(leaf)
1119:            self.maybe_remove_trailing_comma(leaf)
1120:        if not self.append_comment(leaf):
1121:            self.leaves.append(leaf)
1122:
1123:    def append_safe(self, leaf: Leaf, preformatted: bool = False) -> None:
1124:        """Like :func:`append()` but disallow invalid standalone comment structure.
1125:
1126:        Raises ValueError when any `leaf` is appended after a standalone comment
1127:        or when a standalone comment is not the first leaf on the line.
1128:        """
1129:        if self.bracket_tracker.depth == 0:
1130:            if self.is_comment:
1131:                raise ValueError("cannot append to standalone comments")
1132:
1133:            if self.leaves and leaf.type == STANDALONE_COMMENT:
1134:                raise ValueError(
1135:                    "cannot append standalone comments to a populated line"
1136:                )
1137:
1138:        self.append(leaf, preformatted=preformatted)
1139:
1140:    @property
1141:    def is_comment(self) -> bool:
1142:        """Is this line a standalone comment?"""
1143:        return len(self.leaves) == 1 and self.leaves[0].type == STANDALONE_COMMENT
1144:
1145:    @property
1146:    def is_decorator(self) -> bool:
1147:        """Is this line a decorator?"""
1148:        return bool(self) and self.leaves[0].type == token.AT
1149:
1150:    @property
1151:    def is_import(self) -> bool:
1152:        """Is this an import line?"""
1153:        return bool(self) and is_import(self.leaves[0])
1154:
1155:    @property
1156:    def is_class(self) -> bool:
1157:        """Is this line a class definition?"""
1158:        return (
1159:            bool(self)
1160:            and self.leaves[0].type == token.NAME
1161:            and self.leaves[0].value == "class"
1162:        )
1163:
1164:    @property
1165:    def is_stub_class(self) -> bool:
1166:        """Is this line a class definition with a body consisting only of "..."?"""
1167:        return self.is_class and self.leaves[-3:] == [
1168:            Leaf(token.DOT, ".") for _ in range(3)
1169:        ]
1170:
1171:    @property
1172:    def is_def(self) -> bool:
1173:        """Is this a function definition? (Also returns True for async defs.)"""
1174:        try:
1175:            first_leaf = self.leaves[0]
1176:        except IndexError:
1177:            return False
1178:
1179:        try:
1180:            second_leaf: Optional[Leaf] = self.leaves[1]
1181:        except IndexError:
1182:            second_leaf = None
1183:        return (first_leaf.type == token.NAME and first_leaf.value == "def") or (
1184:            first_leaf.type == token.ASYNC
1185:            and second_leaf is not None
1186:            and second_leaf.type == token.NAME
1187:            and second_leaf.value == "def"
1188:        )
1189:
1190:    @property
1191:    def is_class_paren_empty(self) -> bool:
1192:        """Is this a class with no base classes but using parentheses?
1193:
1194:        Those are unnecessary and should be removed.
1195:        """
1196:        return (
1197:            bool(self)
1198:            and len(self.leaves) == 4
1199:            and self.is_class
1200:            and self.leaves[2].type == token.LPAR
1201:            and self.leaves[2].value == "("
1202:            and self.leaves[3].type == token.RPAR
1203:            and self.leaves[3].value == ")"
1204:        )
1205:
1206:    @property
1207:    def is_triple_quoted_string(self) -> bool:
1208:        """Is the line a triple quoted string?"""
1209:        return (
1210:            bool(self)
1211:            and self.leaves[0].type == token.STRING
1212:            and self.leaves[0].value.startswith(('"""', "'''"))
1213:        )
1214:
1215:    def contains_standalone_comments(self, depth_limit: int = sys.maxsize) -> bool:
1216:        """If so, needs to be split before emitting."""
1217:        for leaf in self.leaves:
1218:            if leaf.type == STANDALONE_COMMENT:
1219:                if leaf.bracket_depth <= depth_limit:
1220:                    return True
1221:        return False
1222:
1223:    def contains_inner_type_comments(self) -> bool:
1224:        ignored_ids = set()
1225:        try:
1226:            last_leaf = self.leaves[-1]
1227:            ignored_ids.add(id(last_leaf))
1228:            if last_leaf.type == token.COMMA:
1229:                # When trailing commas are inserted by Black for consistency, comments
1230:                # after the previous last element are not moved (they don't have to,
1231:                # rendering will still be correct).  So we ignore trailing commas.
1232:                last_leaf = self.leaves[-2]
1233:                ignored_ids.add(id(last_leaf))
1234:        except IndexError:
1235:            return False
1236:
1237:        for leaf_id, comments in self.comments.items():
1238:            if leaf_id in ignored_ids:
1239:                continue
1240:
1241:            for comment in comments:
1242:                if is_type_comment(comment):
1243:                    return True
1244:
1245:        return False
1246:
1247:    def contains_multiline_strings(self) -> bool:
1248:        for leaf in self.leaves:
1249:            if is_multiline_string(leaf):
1250:                return True
1251:
1252:        return False
1253:
1254:    def maybe_remove_trailing_comma(self, closing: Leaf) -> bool:
1255:        """Remove trailing comma if there is one and it's safe."""
1256:        if not (
1257:            self.leaves
1258:            and self.leaves[-1].type == token.COMMA
1259:            and closing.type in CLOSING_BRACKETS
1260:        ):
1261:            return False
1262:
1263:        if closing.type == token.RBRACE:
1264:            self.remove_trailing_comma()
1265:            return True
1266:
1267:        if closing.type == token.RSQB:
1268:            comma = self.leaves[-1]
1269:            if comma.parent and comma.parent.type == syms.listmaker:
1270:                self.remove_trailing_comma()
1271:                return True
1272:
1273:        # For parens let's check if it's safe to remove the comma.
1274:        # Imports are always safe.
1275:        if self.is_import:
1276:            self.remove_trailing_comma()
1277:            return True
1278:
1279:        # Otherwise, if the trailing one is the only one, we might mistakenly

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2000:    ):
2001:        return MATH_PRIORITIES[leaf.type]
2002:
2003:    if leaf.type in COMPARATORS:
2004:        return COMPARATOR_PRIORITY
2005:
2006:    if (
2007:        leaf.type == token.STRING
2008:        and previous is not None
2009:        and previous.type == token.STRING
2010:    ):
2011:        return STRING_PRIORITY
2012:
2013:    if leaf.type not in {token.NAME, token.ASYNC}:
2014:        return 0
2015:
2016:    if (
2017:        leaf.value == "for"
2018:        and leaf.parent
2019:        and leaf.parent.type in {syms.comp_for, syms.old_comp_for}
2020:        or leaf.type == token.ASYNC
2021:    ):
2022:        if (
2023:            not isinstance(leaf.prev_sibling, Leaf)
2024:            or leaf.prev_sibling.value != "async"
2025:        ):
2026:            return COMPREHENSION_PRIORITY
2027:
2028:    if (
2029:        leaf.value == "if"
2030:        and leaf.parent
2031:        and leaf.parent.type in {syms.comp_if, syms.old_comp_if}
2032:    ):
2033:        return COMPREHENSION_PRIORITY
2034:
2035:    if leaf.value in {"if", "else"} and leaf.parent and leaf.parent.type == syms.test:
2036:        return TERNARY_PRIORITY
2037:
2038:    if leaf.value == "is":
2039:        return COMPARATOR_PRIORITY
2040:
2041:    if (
2042:        leaf.value == "in"
2043:        and leaf.parent
2044:        and leaf.parent.type in {syms.comp_op, syms.comparison}
2045:        and not (
2046:            previous is not None
2047:            and previous.type == token.NAME
2048:            and previous.value == "not"
2049:        )
2050:    ):
2051:        return COMPARATOR_PRIORITY
2052:
2053:    if (
2054:        leaf.value == "not"
2055:        and leaf.parent
2056:        and leaf.parent.type == syms.comp_op
2057:        and not (
2058:            previous is not None
2059:            and previous.type == token.NAME
2060:            and previous.value == "is"
2061:        )
2062:    ):
2063:        return COMPARATOR_PRIORITY
2064:
2065:    if leaf.value in LOGIC_OPERATORS and leaf.parent:
2066:        return LOGIC_PRIORITY
2067:
2068:    return 0
2069:
2070:
2071:FMT_OFF = {"# fmt: off", "# fmt:off", "# yapf: disable"}
2072:FMT_ON = {"# fmt: on", "# fmt:on", "# yapf: enable"}
2073:
2074:
2075:def generate_comments(leaf: LN) -> Iterator[Leaf]:
2076:    """Clean the prefix of the `leaf` and generate comments from it, if any.
2077:
2078:    Comments in lib2to3 are shoved into the whitespace prefix.  This happens
2079:    in `pgen2/driver.py:Driver.parse_tokens()`.  This was a brilliant implementation
2080:    move because it does away with modifying the grammar to include all the
2081:    possible places in which comments can be placed.
2082:
2083:    The sad consequence for us though is that comments don't "belong" anywhere.
2084:    This is why this function generates simple parentless Leaf objects for
2085:    comments.  We simply don't know what the correct parent should be.
2086:
2087:    No matter though, we can live without this.  We really only need to
2088:    differentiate between inline and standalone comments.  The latter don't
2089:    share the line with any code.
2090:
2091:    Inline comments are emitted as regular token.COMMENT leaves.  Standalone
2092:    are emitted with a fake STANDALONE_COMMENT token identifier.
2093:    """
2094:    for pc in list_comments(leaf.prefix, is_endmarker=leaf.type == token.ENDMARKER):
2095:        yield Leaf(pc.type, pc.value, prefix="\n" * pc.newlines)
2096:
2097:
2098:@dataclass
2099:class ProtoComment:
2100:    """Describes a piece of syntax that is a comment.
2101:
2102:    It's not a :class:`blib2to3.pytree.Leaf` so that:
2103:
2104:    * it can be cached (`Leaf` objects should not be reused more than once as
2105:      they store their lineno, column, prefix, and parent information);
2106:    * `newlines` and `consumed` fields are kept separate from the `value`. This
2107:      simplifies handling of special marker comments like ``# fmt: off/on``.
2108:    """
2109:
2110:    type: int  # token.COMMENT or STANDALONE_COMMENT
2111:    value: str  # content of the comment
2112:    newlines: int  # how many newlines before the comment
2113:    consumed: int  # how many characters of the original leaf's prefix did we consume
2114:
2115:
2116:@lru_cache(maxsize=4096)
2117:def list_comments(prefix: str, *, is_endmarker: bool) -> List[ProtoComment]:
2118:    """Return a list of :class:`ProtoComment` objects parsed from the given `prefix`."""
2119:    result: List[ProtoComment] = []
2120:    if not prefix or "#" not in prefix:
2121:        return result
2122:
2123:    consumed = 0
2124:    nlines = 0
2125:    for index, line in enumerate(prefix.split("\n")):
2126:        consumed += len(line) + 1  # adding the length of the split '\n'
2127:        line = line.lstrip()
2128:        if not line:
2129:            nlines += 1
2130:        if not line.startswith("#"):
2131:            continue
2132:
2133:        if index == 0 and not is_endmarker:
2134:            comment_type = token.COMMENT  # simple trailing comment
2135:        else:
2136:            comment_type = STANDALONE_COMMENT
2137:        comment = make_comment(line)
2138:        result.append(
2139:            ProtoComment(
2140:                type=comment_type, value=comment, newlines=nlines, consumed=consumed
2141:            )
2142:        )
2143:        nlines = 0
2144:    return result
2145:
2146:
2147:def make_comment(content: str) -> str:
2148:    """Return a consistently formatted comment from the given `content` string.
2149:
2150:    All comments (except for "##", "#!", "#:", '#'", "#%%") should have a single
2151:    space between the hash sign and the content.
2152:
2153:    If `content` didn't start with a hash sign, one is provided.
2154:    """
2155:    content = content.rstrip()
2156:    if not content:
2157:        return "#"
2158:
2159:    if content[0] == "#":
2160:        content = content[1:]
2161:    if content and content[0] not in " !:#'%":
2162:        content = " " + content
2163:    return "#" + content
2164:
2165:
2166:def split_line(
2167:    line: Line,
2168:    line_length: int,
2169:    inner: bool = False,
2170:    features: Collection[Feature] = (),
2171:) -> Iterator[Line]:
2172:    """Split a `line` into potentially many lines.
2173:
2174:    They should fit in the allotted `line_length` but might not be able to.
2175:    `inner` signifies that there were a pair of brackets somewhere around the
2176:    current `line`, possibly transitively. This means we can fallback to splitting
2177:    by delimiters if the LHS/RHS don't yield any results.
2178:
2179:    `features` are syntactical features that may be used in the output.
2180:    """
2181:    if line.is_comment:
2182:        yield line
2183:        return
2184:
2185:    line_str = str(line).strip("\n")
2186:
2187:    if (
2188:        not line.contains_inner_type_comments()
2189:        and not line.should_explode
2190:        and is_line_short_enough(line, line_length=line_length, line_str=line_str)
2191:    ):
2192:        yield line
2193:        return
2194:
2195:    split_funcs: List[SplitFunc]
2196:    if line.is_def:
2197:        split_funcs = [left_hand_split]
2198:    else:
2199:
2200:        def rhs(line: Line, features: Collection[Feature]) -> Iterator[Line]:
2201:            for omit in generate_trailers_to_omit(line, line_length):
2202:                lines = list(right_hand_split(line, line_length, features, omit=omit))
2203:                if is_line_short_enough(lines[0], line_length=line_length):
2204:                    yield from lines
2205:                    return
2206:
2207:            # All splits failed, best effort split with no omits.
2208:            # This mostly happens to multiline strings that are by definition
2209:            # reported as not fitting a single line.
2210:            yield from right_hand_split(line, line_length, features=features)
2211:
2212:        if line.inside_brackets:
2213:            split_funcs = [delimiter_split, standalone_comment_split, rhs]
2214:        else:
2215:            split_funcs = [rhs]
2216:    for split_func in split_funcs:
2217:        # We are accumulating lines in `result` because we might want to abort
2218:        # mission and return the original line in the end, or attempt a different
2219:        # split altogether.

Calling tool: grepTool
def append_comment\(|def comments_after\(
Matched content:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1308:    def append_comment(self, comment: Leaf) -> bool:
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py:1328:    def comments_after(self, leaf: Leaf) -> List[Leaf]:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
1296:            if bracket_depth == depth and leaf.type == token.COMMA:
1297:                commas += 1
1298:                if leaf.parent and leaf.parent.type == syms.arglist:
1299:                    commas += 1
1300:                    break
1301:
1302:        if commas > 1:
1303:            self.remove_trailing_comma()
1304:            return True
1305:
1306:        return False
1307:
1308:    def append_comment(self, comment: Leaf) -> bool:
1309:        """Add an inline or standalone comment to the line."""
1310:        if (
1311:            comment.type == STANDALONE_COMMENT
1312:            and self.bracket_tracker.any_open_brackets()
1313:        ):
1314:            comment.prefix = ""
1315:            return False
1316:
1317:        if comment.type != token.COMMENT:
1318:            return False
1319:
1320:        if not self.leaves:
1321:            comment.type = STANDALONE_COMMENT
1322:            comment.prefix = ""
1323:            return False
1324:
1325:        self.comments.setdefault(id(self.leaves[-1]), []).append(comment)
1326:        return True
1327:
1328:    def comments_after(self, leaf: Leaf) -> List[Leaf]:
1329:        """Generate comments that should appear directly after `leaf`."""
1330:        return self.comments.get(id(leaf), [])
1331:
1332:    def remove_trailing_comma(self) -> None:
1333:        """Remove the trailing comma and moves the comments attached to it."""
1334:        trailing_comma = self.leaves.pop()
1335:        trailing_comma_comments = self.comments.pop(id(trailing_comma), [])
1336:        self.comments.setdefault(id(self.leaves[-1]), []).extend(
1337:            trailing_comma_comments
1338:        )
1339:
1340:    def is_complex_subscript(self, leaf: Leaf) -> bool:
1341:        """Return True iff `leaf` is part of a slice with non-trivial exprs."""
1342:        open_lsqb = self.bracket_tracker.get_open_lsqb()
1343:        if open_lsqb is None:
1344:            return False
1345:
1346:        subscript_start = open_lsqb.next_sibling
1347:
1348:        if isinstance(subscript_start, Node):
1349:            if subscript_start.type == syms.listmaker:
1350:                return False
1351:
1352:            if subscript_start.type == syms.subscriptlist:
1353:                subscript_start = child_towards(subscript_start, leaf)
1354:        return subscript_start is not None and any(
1355:            n.type in TEST_DESCENDANTS for n in subscript_start.pre_order()

Calling tool: grepTool
def is_import\(
Matched content:
1151:    def is_import(self) -> bool:
2545:def is_import(leaf: Leaf) -> bool:

Calling tool: readTool
/Users/marcus/repos/BugsInPy/framework/bin/temp/black-8/good/black/black.py
2536:        yield from append_to_line(leaf)
2537:
2538:        for comment_after in line.comments_after(leaf):
2539:            yield from append_to_line(comment_after)
2540:
2541:    if current_line:
2542:        yield current_line
2543:
2544:
2545:def is_import(leaf: Leaf) -> bool:
2546:    """Return True if the given leaf starts an import statement."""
2547:    p = leaf.parent
2548:    t = leaf.type
2549:    v = leaf.value
2550:    return bool(
2551:        t == token.NAME
2552:        and (
2553:            (v == "import" and p and p.type == syms.import_name)
2554:            or (v == "from" and p and p.type == syms.import_from)
2555:        )
2556:    )
2557:
2558:
2559:def is_type_comment(leaf: Leaf) -> bool:
2560:    """Return True if the given leaf is a special comment.
2561:    Only returns true for type comments for now."""
2562:    t = leaf.type
2563:    v = leaf.value
2564:    return t in {token.COMMENT, t == STANDALONE_COMMENT} and v.startswith("# type:")
2565:
2566:
2567:def normalize_prefix(leaf: Leaf, *, inside_brackets: bool) -> None:
2568:    """Leave existing extra newlines if not `inside_brackets`. Remove everything
2569:    else.
2570:
2571:    Note: don't use backslashes for formatting or you'll lose your voting rights.
2572:    """
2573:    if not inside_brackets:
2574:        spl = leaf.prefix.split("#")
2575:        if "\\" not in spl[0]:

Calling tool: updateTodo
Todo Item Completed
Todo item was marked as CORRECT
Reason: The updated logic in black.py’s bracket_split_build_line now scans backward over body_leaves, skips STANDALONE_COMMENT leaves, and inserts a comma after the last non-comment leaf when original.is_import is true. This ensures the comma is placed after the last imported name and before any following comments. The test data for test_comments7 expects exactly this output (no_comma_here_yet, followed by comments), matching the new implementation.

Todo item 11 of 11 is correct
description: 'In `test_comments7`, verify that when the last real imported name lacks a trailing comma but is followed by comments, the expected formatted output contains a comma immediately after that name (before comments), not at the very end after comments.'


=== PHASE 2 COMPLETE ===

